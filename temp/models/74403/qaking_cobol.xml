<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="qaking_cobol" updated="">
  <description>EdcastModel</description>
  <rule name="OPT.COBOL.SEC.CheckCryptoReturnCode" message="CheckCryptoReturnCode: Validate return code for cryptographic operations" class="com.optimyth.qaking.security.rules.cobol.CheckCryptoReturnCode" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity,crypto]]></tags>
    <description><![CDATA[Return value from a cryptographic API call is not checked, which can prevent it from detecting unexpected states and conditions.
As potential errors go unchecked, the results from cryptographic operation should not be trusted, and subsequent operations
may fail.

The rule supports the following Cryptographic APIs:
- IBM ICSF (Integrated Cyrptographic Service Facility) for z/OS.
- iSeries Cryptographic Services API.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid wrong results in cryptographic operations due to uncontrolled errors.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* Generate a symmetric key (ICSF)
* VIOLATION, RETURN-CODE-S not checked
  CALL 'CSNBKGN'
  USING RETURN-CODE-S REASON-CODE-S
        EXIT-DATA-LENGTH-S EXIT-DATA-S
        KEY-FORM-S KEY-LENGTH-S
        DATA-KEY-TYPE-S NULL-KEY-TYPE-S
        KEK-KEY-ID-1-S KEK-KEY-ID-2-S
        DATA-KEY-ID-S NULL-KEY-ID-S.

* Generate a symmetric key (iSeries crypto API)
* VIOLATION, error code not checked
  CALL 'QC3GENSK'
  USING KEY-TYPE KEY-SIZE KEY-FMT KEY-FORM KEY-ENCRKEY KEY-ENCKEYALGO CSP CSPDEV
        KEYSTR KEYSTRLENI KEYSTRLENOUT
        QUS-EC.]]></example>
    <repair><![CDATA[* Generate a symmetric key (ICSF)
  CALL 'CSNBKGN'
  USING RETURN-CODE-S REASON-CODE-S
        EXIT-DATA-LENGTH-S EXIT-DATA-S
        KEY-FORM-S KEY-LENGTH-S
        DATA-KEY-TYPE-S NULL-KEY-TYPE-S
        KEK-KEY-ID-1-S KEK-KEY-ID-2-S
        DATA-KEY-ID-S NULL-KEY-ID-S.
* FIXED, RETURN-CODE-S checked
  IF RETURN-CODE-S NOT = 0 OR REASON-CODE-S NOT = 0 THEN
    DISPLAY '*** KEY-GENERATE ***'
    DISPLAY '*** RETURN-CODE = ' RETURN-CODE-S
    DISPLAY '*** REASON-CODE = ' REASON-CODE-S
  ELSE
    ... use generated key for other crypto operations ...
  END-IF.
* Generate a symmetric key (iSeries crypto API)
  CALL 'QC3GENSK'
  USING KEY-TYPE KEY-SIZE KEY-FMT KEY-FORM KEY-ENCRKEY KEY-ENCKEYALGO CSP CSPDEV
        KEYSTR KEYSTRLENI KEYSTRLENOUT
        QUS-EC.
* FIXED, error code checked
  IF BYTES-AVAILABLE OF QUS-EC > 0
    DISPLAY EXCEPTION-ID OF QUS-EC
  ELSE
    ... use generated key for other crypto operations ...
  END-IF.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/252.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:252,OWASP:2004:A7,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.Cobol_AccessControlDatabase" message="Cobol_AccessControlDatabase: Authorization Bypass Through User-Controlled SQL Primary Key" class="com.optimyth.qaking.security.rules.cobol.AccessControlDatabaseRule" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Without proper access control, executing a SQL statement that contains a user-controlled primary key can allow an attacker to view unauthorized records.

Database access control errors occur when: 1. Data enters a program from an untrusted source.
2. The data is used to specify the value of a primary key in a SQL query, without been processed in a proper neutralization routine.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid information leakage to unintended recipients]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[ ACCEPT PARAM-ID.
* ... user input is passed without check to SQL query
* ... so end user has full control on the rows to process
 EXEC SQL
   DECLARE C1 CURSOR FOR
     SELECT NAME, SURNAME, CODE, AMOUNT
     FROM POLICIES
     WHERE POLICYID = :PARAM-ID
 END-EXEC.]]></example>
    <repair><![CDATA[Same as above, but user input is processed by explicit authorization logic
that checks whether user input is valid for query parameters.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/566.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:566,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties>
      <property name="neutralizationRoutines" descname="comma-separated list of routines/procedures that could be used to validate user inputs before usage in SQL statements" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.Cobol_AccessControlDLI" message="Cobol_AccessControlDLI: Check user input used in DL/I (IMS) queries" class="com.optimyth.qaking.security.rules.cobol.AccessControlDLIRule" technology="COBOL" active="true">
    <tags><![CDATA[ASVS-v4.0.2:4.1.2,ASVS-v4.0.2:4.2.1,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Without proper access control, executing an EXEC DLI command that contains a user-controlled primary key can allow an attacker to view unauthorized DL/I records.

DL/I access control errors occur when: 1. Data enters a program from an untrusted source.
2. The data is used to specify an argument for an IMS query, without been processed in a proper neutralization routine.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid information leakage (and injection attacks) on DL/I resources]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* User controls VAR (via ACCEPT or RECEIVE MAP...)
  ACCEPT VAR.
* Without proper validation, VAR is used as the key to fetch a unique DL/I record in segment
  EXEC DLI
    GU
    SEGMENT(INVOICES)
    WHERE (INVOICEID = VAR)
  END-EXEC.]]></example>
    <repair><![CDATA[* Same as above, but user input is processed by a neutralization routine
* that checks whether user input is valid for parameters in DL/I code.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/639.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:639,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties>
      <property name="neutralizationRoutines" descname="comma-separated list of routines/procedures that could be used to validate user inputs" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.Cobol_AccessControlMQ" message="Cobol_AccessControlMQ: Do not allow user input to control fields of MQSeries descriptor" class="com.optimyth.qaking.security.rules.cobol.AccessControlMQRule" technology="COBOL" active="true">
    <tags><![CDATA[ASVS-v4.0.2:4.1.2,ASVS-v4.0.2:4.2.1,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Allowing user input to control the fields of the MQSeries object descriptor could enable an attacker to access or modify
otherwise protected MQSeries resources.

In general, do not allow user-provided or otherwise untrusted data to control sensitive values.
Sensitive arguments like credentials or queue names should not be controlled by user inputs.
Even message contents should not contain user inputs if not properly validated by explicit calls to registered neutralization routines.

The rule checks the following MQSeries commands, using batch, CICS or IMS interfaces: MQCONN/MQCONNX, MQOPEN, MQGET, MQPUT/MQPUT1, and MQCLOSE.
Any user-controlled input not controlled by one of the routines/procedures specified in the "neutralizationRoutines" property,
that could reach the MQ command will result in a potential security vulnerability reported.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid information leakage (and injection attacks) on DL/I resources]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[ 01 MQOD.
** Alternate user identifier
   03 MQOD-ALTERNATEUSERID     PIC X(12).
** Alternate security identifier
   03 MQOD-ALTERNATESECURITYID PIC X(40).
...
** User-controlled inputs
 ACCEPT MQOD-ALTERNATEUSERID.
 ACCEPT MQOD-ALTERNATESECURITYID.
** MQSeries operation with non-validated user-controlled MQOD record
 CALL 'MQOPEN' USING HCONN, MQOD, OPTS, HOBJ, COMPOCODE REASON.]]></example>
    <repair><![CDATA[* Same as above, but user input is processed by a neutralization routine that
* checks whether user input that could reach MQ command parameter is validated]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/639.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:639,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties>
      <property name="neutralizationRoutines" descname="comma-separated list of routines/procedures that validate user inputs used in MQSeries calls" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.Cobol_HardcodedPassword" message="Cobol_HardcodedPassword: Hardcoded passwords can compromise system security in a way that cannot be easily remedied" class="com.optimyth.qaking.security.rules.cobol.PasswordHardcodedRule" technology="COBOL" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.4,ASVS-v4.0.2:3.5.2,ASVS-v4.0.2:6.4.1,CWEScope:Access-Control,infoleak]]></tags>
    <description><![CDATA[It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers
to view the password, it also makes fixing the problem extremely difficult.

Once the code is in production, the password cannot be changed without patching the software.
If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.

The check looks for certain sites where a password could be specified in Cobol code (database connection, column-level database encryption, or
CICS commands expecting authentication credentials, among others).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Better credentials management]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      MOVE "scott" TO UID.
      MOVE "tiger" TO PWD.
      ...
      EXEC SQL
        CONNECT TO :DB USER :UID USING :PWD
      END-EXEC.]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/259.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:259,CWETOP25:2021:16,OWASP:2021:A7,PCI-DSS:6.5.10]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.Cobol_PasswordInComment" message="Cobol_PasswordInComment: Avoid placing passwords and other sensitive info in code comments" class="com.optimyth.qaking.security.rules.cobol.PasswordInCommentRule" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,infoleak]]></tags>
    <description><![CDATA[Passwords in code comments may provide unintended access to sensitive credentials to staff with access to the source code.
This rule simply looks for specific keywords in code comments, that could be customized in the 'pattern' property.]]></description>
    <priority>5</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Better credentials management]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[	*Username: scott, password: tiger.
		MOVE \"tiger\" TO PWD.
	*Contrasenha=tiger, for database.
		EXEC SQL
		CONNECT TO :DB USER :UID USING :PWD
		END-EXEC.
	*Normal, innocent comment.]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/615.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:615,OWASP:2021:A7,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="pattern" descname="pattern" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.Cobol_PasswordWithWeakCrypto" message="Cobol_PasswordWithWeakCrypto: Weak Cryptography for Passwords" class="com.optimyth.qaking.security.rules.cobol.PasswordWithWeakCryptoRule" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Access-Control,crypto]]></tags>
    <description><![CDATA[Obscuring a password or other sensitive information with a trivial encoding does not protect the password.
Password management issues occur when a password is stored in plaintext (e.g. in configuration file).

A programmer may attempt to fix the password management problem by 'obscuring' the password with an encoding function,
such as base 64 encoding, but such effort does not adequately protect the password.

The rule detects different constructs requiring credentials for authentication, checks if the credential is fetched
from a system resource (e.g. a configuration file), and if the credential is properly processed by an
approved decryption procedure/routine (registered in the 'passwordDecryptionRoutines' property).

Statements where passwords are used in Cobol code are:
- Database connections (SQL CONNECT operations in EXEC SQL statement).
- CICS commands (SIGNON, VERIFY PASSWORD, CHANGE PASSWORD, WEB SEND, WEB CONVERSE).

Statements where passwords are fetched from external files are:
- Cobol READ statement.
- CICS READ command.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Better credentials management]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[ IDENTIFICATION DIVISION.
 PROGRAM-ID. PROG0001.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
* Credentials record
 01 REC
 03 UID PIC X(8).
 03 PWD PIC X(8).
 PROCEDURE DIVISION.
* credentials stored in a system file
 EXEC CICS
   READ FILE('CFG') INTO(REC) RIDFLD(ACCTNO)
 END-EXEC
* too weak protection for database credentials
 PERFORM BASE64-DECODE.
* VIOLATION, connection with weakly protected credentials
 EXEC SQL
   CONNECT TO :DB USER :UID USING :PWD
 END-EXEC.]]></example>
    <repair><![CDATA[* Same as above, but use a proper decryption routine registered.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/261.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:261,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="passwordDecryptionRoutines" descname="comma-separated list of routines/procedures that could be used to recover properly encrypted credentials" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.Cobol_ProcessControl" message="Cobol_ProcessControl: Avoid calling subprogram where its name could be controlled by user input" class="com.optimyth.qaking.security.rules.cobol.ProcessControlRule" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Transferring program control to an untrusted application program or in an untrusted environment can cause an application to execute malicious commands on behalf of an attacker.

Process control vulnerabilities take two forms: - An attacker can change the name of the program being invoked: the attacker explicitly controls what the name of the application program is.
- An attacker can change the environment in which the program is invoked: the attacker implicitly controls a communication area made available to the invoked program.

In this case we are primarily concerned with the first scenario, the possibility that an attacker may be able to control the name of the program that is invoked. Process control vulnerabilities of this type occur when: 1. Data enters the application from an untrusted source.
2. The data is used as or as part of a string representing a program that is invoked (and no proper validation of user input is done).
3. By executing code from the invoked program, the application gives the attacker a privilege or capability that the attacker would not otherwise have.

If an attacker can control the subprogram executed, then he/she can fool the application into running malicious code and take control of the system: it could allow an attacker to transfer control to a program of choice and potentially execute arbitrary code with the elevated privilege of the application.

The rule detects if called subprogram name could come from (or contain) user input, without validation.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  * User controls the program name (via ACCEPT, RECEIVE MAP...)
    ACCEPT PROGNAME.
    ...
  * Execution of a program where program name could be controlled by user
    EXEC CICS
      LINK PROGRAM(PROGNAME) COMMAREA(CAREA)
    END-EXEC.]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/114.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:114,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.Cobol_ResourceInjection" message="Cobol_ResourceInjection: Improper Control of Resource Identifiers ('Resource Injection')" class="com.optimyth.qaking.security.rules.cobol.ResourceInjectionRule" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Look for access to system resources where the accessed resource could be controlled by user input.

A resource injection issue occurs when the following two conditions are met:
1. An attacker can control the identifier used to access a system resource.
   For example, an attacker might be able to specify the name for a CICS queue name, a datafile, etc.
2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.

The rule checks if the name of a system resource (e.g. a CICS queue) is specified in a variable that depends on user-controlled input
(e.g. via statements like ACCEPT or RECEIVE MAP), and no neutralization routine checks the user input properly
(neutralization routines could be specified in the 'neutralizationRoutines' rule parameter).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid illegal access to resources. Resource access control is easier to maintain.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* Input from terminal
  ACCEPT QNAME.
* Violation: A sensitive resource (e.g. CICS queue) could be specified by an attacker
  EXEC CICS
    READQ TD QUEUE(QNAME)
    INTO(DATA) LENGTH(LDATA)
  END-EXEC.]]></example>
    <repair><![CDATA[* Same as above, but QNAME is taken from a fixed set of allowed queue names
* (the queue name chosen may depend on user input, but should be chosen from a fixed set).
* Alternatively, insert a neutralization routine between input and access to resource:
  PERFORM CHECK-QUEUE.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/99.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:99,OWASP:2021:A3,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties>
      <property name="neutralizationRoutines" descname="comma-separated list of routines/procedures that could be used to check/neutralize user input" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.CrossSiteScripting" message="CrossSiteScripting: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')" class="com.optimyth.qaking.security.rules.cobol.CrossSiteScriptingRule" technology="COBOL" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[A Cross-site scripting flaw occurs when the following two conditions are met:
1. An attacker can control a data item used when composing HTML content.
2. Program uses user-controlled data items, not neutralized, in the HTML contents generated.

The rule checks if user-controlled input (e.g. via statements like ACCEPT or RECEIVE MAP) reaches a point where HTML content is generated,
and no neutralization routine checks the user input properly (neutralization routines could be specified in the 'neutralizationRoutines' rule parameter).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid attacks to end user's browser mediated by cobol program.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* Input from terminal
  ACCEPT HTTP-MSG.
* Output generated using CICS WEB SEND
  EXEC CICS
    WEB SEND
    DOCTOKEN(HTTP-MSG) DOCSTATUS(DOCDELETE)
  END-EXEC.]]></example>
    <repair><![CDATA[* Input from terminal
  ACCEPT HTTP-MSG.
* Input neutralized in a subroutine
* NEUTRALIZE should be registered in neutralizationRoutines property
  CALL NEUTRALIZE USING HTTP-MSG.
* Output generated using CICS WEB SEND
  EXEC CICS
    WEB SEND
    DOCTOKEN(HTTP-MSG) DOCSTATUS(DOCDELETE)
  END-EXEC.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.7]]></security>
    </normatives>
    <properties>
      <property name="neutralizationRoutines" descname="comma-separated list of routines/procedures that could be used to check/neutralize user input" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.DynamicStorageLeakRule" message="DynamicStorageLeakRule: Potential dynamic storage area leak" class="com.optimyth.qaking.security.rules.cobol.DynamicStorageLeakRule" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Availability,memoryLeak]]></tags>
    <description><![CDATA[Memory may be allocated / released dynamically in COBOL. This feature is not widely used in COBOL as much as in other languages
like C/C++. However, dynamically allocated memory should be released properly, or memory leaks may compromise the software availability.

COBOL offers different ways for dynamic memory reservation: ALLOCATE statement (COBOL 2002), system routines like
CEEGTST or CBL_ALLOC_MEM, or CICS commands like GETMAIN/GETMAIN64. Corresponding facilities (FREE statement,
routines like CEEFRST or CBL_FREE_MEM, or FREEMAIN/FREEMAIN64 CICS commands) should be used for releasing previously
allocated memory blocks.

For example, executing CICS GETMAIN/GETMAIN64 commands without associated FREEMAIN/FREEMAIN64 in long running jobs can
exhaust available resources, system memory in particular.

Although storage areas reserved by GETMAIN are automatically released by CICS at task end, particularly
without SHARED option, the rule demands that a explicit release (FREEMAIN/FREEMAIN64) on the reserved storage area
follows every GETMAIN/GETMAIN64, in same COBOL program.

This rule reports memory allocations not matched by an explicit deallocation, which may result in a memory leak.
Please note that some (but NOT all) dynamic memory handling facilities take care of deallocating any allocated memory blocks
at the end of the program execution, but for long-running programs it is recommended an explicit deallocation
when the memory block is not used anymore.]]></description>
    <priority>1</priority>
    <effort>1</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid main storage area leaks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[ IDENTIFICATION DIVISION.
 PROGRAM-ID. TESTPROG.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
   77  AREA-POINTER    USAGE IS POINTER.
 LINKAGE SECTION.
   01  WORKAREA        PIC X(100).
 PROCEDURE DIVISION.
  ...
* VIOLATION, no FREEMAIN for the reserved main storage area workarea
  EXEC CICS GETMAIN SET(AREA-POINTER) LENGTH(100) END-EXEC.
  SET ADDRESS OF WORKAREA TO AREA-POINTER.
  ...
END PROGRAM.]]></example>
    <repair><![CDATA[ IDENTIFICATION DIVISION.
 PROGRAM-ID. TESTPROG.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
   77  AREA-POINTER    USAGE IS POINTER.
 LINKAGE SECTION.
   01  WORKAREA        PIC X(100).
 PROCEDURE DIVISION.
  ...
* FIXED, there is FREEMAIN call
  EXEC CICS GETMAIN SET(AREA-POINTER) LENGTH(100) END-EXEC.
  SET ADDRESS OF WORKAREA TO AREA-POINTER.
  ...
  EXEC CICS FREEMAIN DATA(WORKAREA) END-EXEC.
* alternatively free using datapointer:
* EXEC CICS FREEMAIN DATAPOINTER(AREA-POINTER) END-EXEC.
END PROGRAM.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/401.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:401,CWETOP25:2021:32,PCI-DSS:6.5.2]]></security>
    </normatives>
    <properties>
      <property name="strictCheck" descname="If true, performs strict check to ensure that allocated memory is released in all potential execution paths (could lead to analysis timeouts with complex code). If false, a quicker, less strict check is performed." value="true"/>
      <property name="maxAllowedComplexity" value="40"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.HTTPHeaderManipulation" message="HTTPHeaderManipulation: Unvalidated data in HTTP response header" class="com.optimyth.qaking.security.rules.cobol.HTTPHeaderManipulationRule" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Integrity]]></tags>
    <description><![CDATA[When program inserts non-validated external input in an HTTP response header,
certain attacks (cache poisoning, cross-site scripting, cross-user defacement, page hijacking), particularly
when attacker inserts CR/LF (carriage return / line feed) characters to modify the structure of the HTTP message.

The header manipulation vulnerability (CWE 113, also known as CRLF injection) occurs when:
1. Data enters cobol program through an untrusted source, like an HTTP request.
2. Such data is included in an HTTP response header, without proper neutralization.

This allows a potential attacker to fully modify the HTTP response, typically including CR/LF characters
so a chosen value could generate one or more altered HTTP responses, resulting in many kinds of attacks,
like cache poisoning, URL redirection / page hijacking, web defacement, cross-site scripting, etc.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid web attacks allowed from open header manipulaton vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  IDENTIFICATION DIVISION.
  PROGRAM-ID. PROGNAME.

  DATA DIVISION.
  WORKING-STORAGE SECTION.

  01 WEB-REQUEST.
     05 W-AUTHOR PIC X(16).
     05 W-AUTHOR-LEN PIC 9(4).
     ...
  PROCEDURE DIVISION.
  INIT SECTION.

* External input (HTTP request reading input parameter)
  EXEC CICS
    WEB READ
    FORMFIELD(FIELD-NAME)
    VALUE(W-AUTHOR) VALUELENGTH(W-AUTHOR-LEN)
    ...
  END-EXEC.

  ... more statements ...

  EXEC CICS
    WEB WRITE
    HTTPHEADER(COOKIE)
    VALUE(W-AUTHOR) VALUELENGTH(W-AUTHOR-LEN)
    ...
  END-EXEC.]]></example>
    <repair><![CDATA[Add neutralization logic on the header value between external input and the WEB WRITE HTTPHEADER command.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/113.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:113,OWASP:2021:A3,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties>
      <property name="neutralizationRoutines" descname="comma-separated list of routines/procedures that could be used to check/neutralize user input" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.NoAcceptFromUntrustedSource" message="NoAcceptFromUntrustedSource: Do not ACCEPT data from untrusted sources" class="com.optimyth.qaking.security.rules.cobol.NoAcceptFromUntrustedSource" technology="COBOL" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.2,ASVS-v4.0.2:13.3.1,ASVS-v4.0.2:5.1.3,ASVS-v4.0.2:5.1.4,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Typically external input coming from untrusted sources (operator console, command-line, system environment, etc.)
could affect Cobol program execution and reach a sensitive resource, opening potential security vulnerabilities.
For example, a logical backdoor could ask external input from an attacker if certain conditions are met.

Additionally, batch programs could expect input from user, which may halt batch processing.
Most sites prohibit ACCEPT FROM CONSOLE to interact with system console.

This rule checks input (ACCEPT statement) from sources considered untrusted.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid programs to accept untrusted inputs, limiting potential security issues.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  IDENTIFICATION DIVISION.
  PROGRAM-ID. TEST1.
  ENVIRONMENT DIVISION.
  SPECIAL-NAMES.
    CONSOLE IS KEYBOARD.
  DATA DIVISION.
  PROCEDURE DIVISION.
*   VIOLATION, CONSOLE input not allowed
    ACCEPT ANSWER FROM KEYBOARD.]]></example>
    <repair><![CDATA[Do not ACCEPT from untrusted inputs, at least from programs not explicitly allowing such inputs.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/20.html,PCI-DSS:6.5.2]]></reference>
    <normatives>
      <security><![CDATA[CWE:20,CWETOP25:2021:4,PCI-DSS:6.5.2]]></security>
    </normatives>
    <properties>
      <property name="excludePattern" descname="regular expression pattern matching program names where untrusted source input is allowed." value=""/>
      <property name="untrustedSources" descname="comma-separated list of environment names considered illegal." value="CONSOLE,COMMAND-LINE,SYSIN,SYSIPT,ENVIRONMENT-VALUE,ARGUMENT-VALUE"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.NoActiveDebug" message="NoActiveDebug: Information Exposure Through Debug Information" class="com.optimyth.qaking.security.rules.cobol.NoActiveDebugRule" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,infoleak]]></tags>
    <description><![CDATA[The application contains debugging code that can expose sensitive information to untrusted parties.

Emits a violation when debug is active in a Cobol program: WITH DEBUGGING MODE clause in SOURCE COMPUTER paragraph under CONFIGURATION SECTION,
plus debug sections (USE FOR DEBUGGING ...) in PROCEDURE DIVISION DECLARATIVES.

Certain dialects, like Acu-COBOL, provide a STOP "literal" statement for suspending execution and waiting for debugger to connect.
They are also reported as violations of this rule.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid sensitive information leakage, including system details that could be leveraged for further attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  IDENTIFICATION DIVISION.
  PROGRAM-ID. SAMPLE.
  ENVIRONMENT DIVISION.
  CONFIGURATION SECTION.
  SOURCE-COMPUTER. IBM-370 WITH DEBUGGING MODE.
  OBJECT-COMPUTER.  IBM-370.
  DATA DIVISION.
  WORKING-STORAGE SECTION.
   01 X PIC X.
  PROCEDURE DIVISION.
  DECLARATIVES.
  DEBUG SECTION.
       USE FOR DEBUGGING ON ALL PROCEDURES.
  COBOL-II-DEBUG-PARA.
       DISPLAY 'ENTERING... ' DEBUG-NAME.
  END DECLARATIVES.
  PGM SECTION.
D      DISPLAY 'HI'
       PERFORM 1000-PARA.
       STOP RUN.
  1000-PARA.
D      DISPLAY 'THIS IS THE COBOL DEBUGGING PROGRAM'.
       PERFORM 110-PARA.
  110-PARA.
D      DISPLAY 'DEBUGGED'.]]></example>
    <repair><![CDATA[* Deactivate debugging, removing the WITH DEBUGGING MODE phrase
  SOURCE-COMPUTER. IBM-370.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/215.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:215,OWASP:2021:A5]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.OSCommandInjection" message="OSCommandInjection: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" class="com.optimyth.qaking.security.rules.cobol.OSCommandInjectionRule" technology="COBOL" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[The Cobol program constructs all or part of an operating system (OS) command using externally-influenced input,
without properly neutralizing special characters that could modify the intended OS command to be executed.

This flaw could allow attackers to execute unexpected, dangerous commands directly on the operating system.
There are two variants:

1. The program could intend to execute a single, fixed program, taking external input as argument(s) to the program.
   If the program does not remove command separators from the external input, the attacker could place such command separators
   into the arguments, which allows him to execute additional, unexpected OS commands or programs. For example,
   shell metacharacters like ";", "&" or "|" are typically used for command separators.

2. The program accepts an input that it uses to fully select which program to run, as well as which commands to use.
   The program simply redirects this entire command to the operating system. If the input is under attacker control,
   then the attacker can execute arbitrary OS commands or programs.

In the first variant, the programmer clearly intends that external, untrusted input will be part of the arguments of the OS command
to execute, but the attacker could force the execution of additional OS commands. In the second variant, the programmer
does not intend for the command to be accesible to any untrusted party, but the programmer probably has not accounted for
alternate ways in which malicious attackers could control program inputs.

When the attacker is able to execute unauthorized commands (typically with the privileges of the process running the Cobol program),
he/she could gain further privileges, produce a denial-of-service condition, read files or directories, read or modify application data,
modify application or system configuration, or hide activities, among others.

This check looks for flaws in OS command execution calls for different COBOL systems: SYSTEM, C$RUN, C$SYSTEM
in certain Unix/Windows compilers, or QCMDEXC in IBM's ILE COBOL compiler, among others.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid execution of unexpected system commands.]]></benefits>
    <inconvenients><![CDATA[None]]></inconvenients>
    <example><![CDATA[ WORKING-STORAGE SECTION.
   78 little-endian VALUE "yes".
*> return code from shell is somewhat hidden
   01 return-code-ws     PIC S9(8) COMP-5.
   01 FILLER REDEFINES return-code-ws.
$if little-endian defined
       05 FILLER          PIC X.
       05 high-order-byte PIC S9 COMP-5.
       05 FILLER          PIC X.
       05 low-order-byte PIC S9 COMP-5.
$else
       05 FILLER          PIC XX.
       05 high-order-byte PIC S9 COMP-5.
       05 low-order-byte PIC S9 COMP-5.
$end
   01 prefix   PIC X(10) VALUE "ls -l "
   01 filename PIC X(250).

   01 null-terminated-command.
     05 command      PIC X(256).
     05 FILLER       PIC X VALUE x"00".

   01 done-flag PIC X VALUE "n".
     88 done VALUE "y".

 PROCEDURE DIVISION.
     PERFORM get-user-input
     PERFORM UNTIL done
       STRING prefix filename DELIMITED BY SIZE INTO command
*>     FLAW: system() call with user-controlled command
       CALL "SYSTEM" USING null-terminated-command
                     RETURNING return-code-ws
       IF low-order-byte = 0
         DISPLAY "return code from shell is: ", high-order-byte
       END-IF
       PERFORM get-user-input
     END-PERFORM.
     STOP RUN.

   get-user-input.
     DISPLAY spaces
     DISPLAY "Enter directory to be listed"
     DISPLAY " (enter to quit)"
     ACCEPT filename
     IF filename = ""
       MOVE "y" TO done-flag.]]></example>
    <repair><![CDATA[*> Add proper input validation to the user input, or follow other remediation strategies
*> Example:
   get-user-input.
     DISPLAY spaces
     DISPLAY "Enter directory to be listed"
     DISPLAY " (enter to quit)"
     ACCEPT filename
     CALL check-filename USING filename GIVING is-valid-filename
     IF is-valid-filename = 0 THEN
       PERFORM show-invalid-filename-error
       STOP RUN
     END-IF
     IF filename = ""
       MOVE "y" TO done-flag.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/78.html,Calling UNIX/POSIX APIs from COBOL: http://www-01.ibm.com/support/knowledgecenter/SS6SG3_4.1.0/com.ibm.entcobol.doc_4.1/PGandLR/tasks/tpenv14.htm]]></reference>
    <normatives>
      <security><![CDATA[CWE:77,CWE:78,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.8,WASC:31]]></security>
    </normatives>
    <properties>
      <property name="neutralizationRoutines" descname="comma-separated list of routines/procedures that could be used to check/neutralize user input" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.PathTraversal" message="PathTraversal: Avoid non-neutralized user-controlled input to be part of a pathname (file or directory) used in I/O operations" class="com.optimyth.qaking.security.rules.cobol.PathTraversalRule" technology="COBOL" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.1,ASVS-v4.0.2:12.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software uses external input to construct a pathname that is intended to identify a file or directory located underneath a restricted parent directory,
but software does not properly neutralize elements within pathname, which may cause the pathname to resolve to a location outside the restricted directory.

Under Cobol this flaw is not frequent, but file operations may be performed with non standard Cobol statements
(like CICS READ) that could open the possibility to path modification and path traversal attacks.

Some Cobol dialects allow a DYNAMIC specification of pathnames (SELECT logical-file ASSIGN TO DYNAMIC data-entry),
so the filename could be assigned by program logic before OPEN the file.

This check detects if there is a potential untrusted user input that could affect the filename.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Filesystem paths should not be controlled by user-controlled inputs.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  IDENTIFICATION DIVISION.
  PROGRAM-ID. TESTPROG.

  ENVIRONMENT DIVISION.

  DATA DIVISION.
  WORKING-STORAGE SECTION.
  01 W-CONSTANTS.
    05 W-CONSTANTS-FILE PIC X(5) VALUE 'FNAME'.

  01 PATHNAME.
    05 DIRNAME PIC X(20) VALUE 'BASEPATH.'.
    05 FILENAME PIC X(10).
    05 FNAME-LEN PIC 9(4).

  01 W-RECORD.
    05 A PIC X(16).
    05 B PIC 9(4).
    05 C PIC X(64).

  PROCEDURE DIVISION.
  INIT SECTION.

  EXEC CICS
    WEB READ FORMFIELD(W-CONSTANTS-FILE)
    VALUE(FILENAME) VALUELENGTH(FNAME-LEN)
  END-EXEC.

  ...

* Violation, part of path under external input control
  EXEC CICS
    READ FILE(PATHNAME)
    INTO(W-RECOR)
    RIDFLD(ACCTNO)
    UPDATE
  END-EXEC.]]></example>
    <repair><![CDATA[* Call neutralization routine between filename input and file access
  CALL NORMALIZE USING PATHNAME.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/22.html,http://cwe.mitre.org/data/definitions/73.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:22,CWE:73,CWETOP25:2021:8,OWASP:2021:A4,OWASP:2021:A5,PCI-DSS:6.5.8,WASC:33]]></security>
    </normatives>
    <properties>
      <property name="neutralizationRoutines" descname="comma-separated list of routines/procedures that could be used to check/neutralize user input" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.SqlInjection" message="SqlInjection: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" class="com.optimyth.qaking.security.rules.cobol.SQLInjectionRule" technology="COBOL" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The software constructs all or part of an SQL command using externally-controlled input, but it does not neutralize properly
that input that could modify the intended SQL command when it is sent to a database interaction method.

Checks for EXEC SQL constructs that use dynamic SQL commands (PREPARE, EXECUTE IMMEDIATE), where the query is possibly tainted by user input
(or read from any other external input, with SQLDA descriptors ignored).

Usage of dynamic SQL is considered something to be warned to users, but only 'tainted' SQL used in dynamic SQL constructs
are considered a security violation.
It must be known that most (but not all) embedded SQL constructs in Cobol use bound parameters, normally safe againts SQL injection attacks.
One exception is dynamic SQL (like EXECUTE IMMEDIATE), which is not frequently used in Cobol.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid SQL injection allowing unintended accesses to database that result in confidentiality / integrity losses.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[   ACCEPT USER.
   ACCEPT ITM.
   MOVE "SELECT * FROM items WHERE owner = '" TO QUERY1.
   MOVE "' AND itemname = '" TO QUERY2.
   MOVE "'" TO QUERY3.

   STRING
     QUERY1, USER, QUERY2, ITM, QUERY3 DELIMITED BY SIZE
     INTO QUERY
   END-STRING.

   ...

 * Violation: QUERY could have ANY sql code,
 * and will be happily executed with program priviledges
   EXEC SQL
     EXECUTE IMMEDIATE :QUERY
   END-EXEC.

   EXEC SQL
     PREPARE Q1 FROM :QUERY
   END-EXEC.]]></example>
    <repair><![CDATA[ * Avoid EXECUTE IMMEDIATE
   EXEC SQL
     SELECT f INTO :F
     FROM items
     WHERE owner = :USER AND itemname = :ITM
   END-EXEC.
 * Or if not possible, neutralize external input before execution
   CALL 'CLEAN' USING BY REFERENCE ITM, USER.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="unconditional" descname="If true, violation emitted on any dynamic SQL statement, even when no connection with external input." value="false"/>
      <property name="neutralizationRoutines" descname="comma-separated list of routines/procedures that could be used to check/neutralize user input" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.COBOL.SEC.WeakCryptoHash" message="WeakCryptoHash: Weak cryptographic hashes cannot guarantee data integrity" class="com.optimyth.qaking.security.rules.cobol.WeakCryptoHash" technology="COBOL" active="true">
    <tags><![CDATA[CWEScope:Access-Control,crypto]]></tags>
    <description><![CDATA[Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.

As an example, MD5 and SHA-1 are popular cryptographic hash algorithms often used to verify the integrity of messages and other data.
Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5 and SHA-1 should no longer be relied upon to verify the authenticity of data in security-critical contexts.
Techniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be relied upon for security.
In the case of SHA-1, current techniques still require a significant amount of computational power and are more difficult to implement.
However, attackers have found the Achilles' heel for the algorithm, and techniques for breaking it will likely lead to the discovery of even faster attacks.

The rule checks if the cryptographic hash algorithm used is one of the allowed ones, emitting a violation if not.
The 'allowed' property contains the list of hash algoritms considered safe by the rule.

The rule supports the following Cryptographic APIs:
- IBM ICSF (Integrated Cyrptographic Service Facility) for z/OS.
- iSeries Cryptographic Services API.
considering the API operations (one-way hash, HMAC generation and verification) that use cryptographic hash functions.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Better credentials management]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  PROGRAM-ID. HASHTEST.
  DATA DIVISION.
  WORKING-STORAGE SECTION.
  77 HASH-ALGO PIC X(8) VALUE 'MD5     '.
  77 HASH-MODE PIC X(8) VALUE 'ONLY    '.
  01 RULE-ARRAY-S PIC X(16).

  PROCEDURE DIVISION.
  MAIN.
  STRING HASH-ALGO HASH-MODE INTO RULE-ARRAY-S.
* VIOLATION, MD5 not allowed (ICSF API)
  CALL 'CSNBOWH'
  USING RETURN-CODE-S REASON-CODE-S
        EXIT-DATA-LENGTH-S EXIT-DATA-S
        RULE-ARRAY-COUNT-S RULE-ARRAY-S
        TEXT-LENTGH-S TEXT-S
        CHAIN-VECTOR-LEN-S CHAIN-VECTOR-S
        HASH-LEN-S HASH-S.]]></example>
    <repair><![CDATA[  PROGRAM-ID. HASHTEST.
  DATA DIVISION.
  WORKING-STORAGE SECTION.
  77 HASH-ALGO PIC X(8) VALUE 'SHA-256 '.
  77 HASH-MODE PIC X(8) VALUE 'ONLY    '.
  01 RULE-ARRAY-S PIC X(16).

  PROCEDURE DIVISION.
  MAIN.
  STRING HASH-ALGO HASH-MODE TO RULE-ARRAY-S.
* FIXED, SHA-256 allowed (ICSF API)
  CALL 'CSNBOWH'
  USING RETURN-CODE-S REASON-CODE-S
        EXIT-DATA-LENGTH-S EXIT-DATA-S
        RULE-ARRAY-COUNT-S RULE-ARRAY-S
        TEXT-LENTGH-S TEXT-S
        CHAIN-VECTOR-LEN-S CHAIN-VECTOR-S
        HASH-LEN-S HASH-S.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/328.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:328,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:50]]></security>
    </normatives>
    <properties>
      <property name="allowed" descname="Comma-separated list of allowed hash algorithms." value="SHA-256,SHA-384,SHA-512"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <categories>
    <category name="COBOL" technology="COBOL" active="true" weight="1.0">
      <description><![CDATA[COBOL rules]]></description>
      <children>
        <category name="OPT.CRITERIUM_VALUE.CQM.EFFICIENCY" technology="COBOL" active="true" weight="8.0">
          <description><![CDATA[Efficiency]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.MAINTAINABILITY" technology="COBOL" active="true" weight="10.0">
          <description><![CDATA[Maintainability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.PORTABILITY" technology="COBOL" active="true" weight="5.0">
          <description><![CDATA[Portability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.RELIABILITY" technology="COBOL" active="true" weight="10.0">
          <description><![CDATA[Reliability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.SECURITY" technology="COBOL" active="true" weight="4.0">
          <description><![CDATA[Security]]></description>
        </category>
      </children>
    </category>
  </categories>
</ruleset>
