<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="qaking_csharp" updated="">
  <description>EdcastModel</description>
  <rule name="OPT.CSHARP.CodeInjection" message="CodeInjection: Improper Control of Generation of Code ('Code Injection')" class="com.optimyth.csharp.rules.security.CodeInjection" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.5,ASVS-v4.0.2:5.2.8,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[Code injection is a general term for attack types which consist of injecting code that is dynamically evaluated and executed by the vulnerable application.

In .NET applications, as most of popular languages and frameworks, several ways to evaluate code dynamically can be used, from Razor template engine to C# or VB .NET code compilation and execution.

Code injection attacks can lead to loss of data integrity and can often result in the execution of arbitrary code.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent code injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public void executeCode()
{
    CodeDomProvider domProvider = CodeDomProvider.CreateProvider("CSharp");
    CompilerParameters cp = new CompilerParameters();
    CompilerResults cr = domProvider.CompileAssemblyFromSource(cp,Request.QueryString["EXPRESSION"]);   // sink
}]]></example>
    <repair><![CDATA[public void executeCode()
{
    CodeDomProvider domProvider = CodeDomProvider.CreateProvider("CSharp");
    CompilerParameters cp = new CompilerParameters();
    String expression = validate(Request.QueryString["EXPRESSION"]);  // neutralize user input
    CompilerResults cr = domProvider.CompileAssemblyFromSource(cp,expression);   // ok
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/94.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:94,CWETOP25:2021:28,OWASP:2021:A3,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.CodeInjectionWithDeserialization" message="CodeInjectionWithDeserialization: Dynamic code injection during object deserialization" class="com.optimyth.csharp.rules.security.CodeInjectionWithDeserialization" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.5.2,ASVS-v4.0.2:5.5.1,ASVS-v4.0.2:5.5.3,CWEScope:Availability,CWEScope:Integrity,code-injection,serialization]]></tags>
    <description><![CDATA[When a serialization library deserializes untrusted content from a certain exchange format (binary, XML, JSON...) to recover
the original object graph, attackers may provide attack payloads that may result in unexpected code execution
or a denial-of-service condition.

(De)serialization of object graphs is a complex issue, due to the object-oriented nature of such graphs:
Generics, interface fields, polymorphism... Default constructors need to be invoked, fields and properties
should be set reflectively, and special constructors, type converters, or serialization callbacks need to be invoked.

By controlling the deserialized field values, attackers may abuse the logic of these methods to run arbitrary code.
The deserialization library may be abused, so attackers may control the type of reconstructed objects, the library
or the GC might call methods on reconstructed objects. Many libreries perform a simple type control, often
involving cast *after* deserialization.

In general, deserialization vulnerabilities generally require three ingredients:
- Potential attackers can modify the stream to be deserialized.
- Type information is parsed from the stream.
- The set of types that can be generated is not tightly constrained.

Note: In addition, the stream often needs to be parsed (from XML or other stream format), and the parser itself may be vulnerable
to other attacks, like exfiltrations / scans via XML External Entity, or denial-of-service attacks via XML Entity Expansion.
The rule OPT.CSHARP.SEC.XMLEntityInjection looks for vulnerable XML parser configurations.

Which libraries should I use, and how?
In short, some libraries (FastJSON, Sweet.Jayson, FSPickler) should NEVER be used with untrusted sources.
Others might be configured incorrectly to open deserialization flaws, typically when a too-much permissive type resolver is used:
Json.Net, JavaScriptSerializer, DataContractJsonSerializer...

If the attacker cannot control the content to be deserialized, typically there is no problem per-se with these libraries.
And even when the attacker can control such content, the types to be deserialized may be fixed by the application, or limited to
a white-list of allowed types, and that makes deserialization safe, at least for most libraries. For example, XmlSerializer
or DateContractSerializer are safe when the type is fixed to a safe type (unless the applicacion shoots itself in the foot).
JSON.Net is also typically safe when TypeNameHandling is set to None (but vulnerable otherwise, be careful).

Please note that for most libraries using binary formats, including .Net's BinaryFormatter, are fairly difficult
to configure for safe type control against attack payloads in user-controlled content.

Note: 2016 was known as the "Year of Java Deserialization apocalypse". That situation motivated the security industry
to avoid Java native serialization, and move to a (secure) JSON/XML-based serialization, properly configured.
A similar generic recommendation should be followed under .Net.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid code injection thru serialized objects]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Web;
using Newtonsoft.Json;

// Example using the popular Json.Net
public class MyDeserializer {
  public Product deserializeProduct(HttpContext context) {
    string json = context.Request.Item["json"];
    // VIOLATION, too permisive type control
    return JsonConvert.DeserializeObject<Product>(json, new JsonSerializerSettings() {
      TypeNameHandling = TypeNameHandling.All
    });
  }
}]]></example>
    <repair><![CDATA[using System;
using System.Web;
using Newtonsoft.Json;

// Example using the popular Json.Net
public class MyDeserializer {
  public Product deserializeProduct(HttpContext context) {
    string json = context.Request.Item["json"];
    // FIXED, the default TypeNameHandling.None is much more strict
    return JsonConvert.DeserializeObject<Product>(json);
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/502.html,https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf,https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf,https://www.alphabot.com/security/blog/2017/net/How-to-configure-Json.NET-to-create-a-vulnerable-web-API.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:502,CWETOP25:2021:13,OWASP:2021:A8,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.CommandInjection" message="CommandInjection: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" class="com.optimyth.csharp.rules.security.CommandInjectionRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[The software constructs all or part of an operating system (OS) command using externally-controlled input, but it does not neutralize properly that input that could modify the intended command when it is sent to a function that executes the command (e.g. exec(), system(), or the backtick operator).

The rule detects a path in code between an user-input statement (source) and a command execution call (sink), with command depending on non neutralized input. This allows for an attacker to change the intended command to execute or to add a malicious extra command, executed with the application rights.

A neutralization function either validates inputs and report an (neutral) error without allowing command execution, or replaces sensitive shell characters in the input to avoid that the resulting command has different semantics.
If possible, use "accept known good" input validation strategy (whitelist).

First, ask yourself if you really need to execute OS commands. Most operating system operations can be performed using .NET framework.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid execution of malicious commands.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      public void processCommand()
      {
          Process.Start(Request.Item["COMMAND"]);  // VIOLATION
      }]]></example>
    <repair><![CDATA[      public void processCommand()
      {
          string commandToExecute = validate(Request.Item["COMMAND"]);
          Process.Start(commandToExecute);  // OK
      }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/78.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:77,CWE:78,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:31]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.CrossSiteRequestForgery" message="CrossSiteRequestForgery: Cross-Site Request Forgery (CSRF)" class="com.optimyth.csharp.rules.security.CrossSiteRequestForgeryRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.3,ASVS-v4.0.2:4.2.2,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[When a user is authenticated in a web site, an attacker with knowledge about the web site can perform malicious requests
against the vulnerable site and execute actions while user remains authenticated.

Usually the attacker forces an authenticated user to launch the malicious request using social engineering,
or by exploiting an XSS vulnerability.

In web sites developed with ASP.Net framework, anti-forgery tokens, also known as request verification tokens,
should be utilized to prevent CSRF attacks.

Anti-forgery tokens are random values generated in the server when a form is requested, and they are included in every request,
so the server can verify not only that user is authenticated, but that the request was originated from the application.

This rule checks:
(1) if a code fragment (an MVC / Web API controller or state-changing method, or a WebForms page) should be protected against CSRF attacks.
(2) if such code is protected with one of the recommended anti-CSRF protection schemes:
(2.1) For a WebForms page, checks whether ViewStateUserKey is set (without disabling EnableViewStateMac). Parent pages and master pages
      are taken into account.
(2.2) For a MVC controller action method, checks for [ValidateAntiForgeryToken] attribute (or a call to AntiForgery.Validate()).
(2.3) Alternatives, like common Captcha controls like Google's Recaptcha, are checked for.
(3) If no protection is found for the candidate code, a violation is reported.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid attackers to forge requests that appear to be originated from an authenticated victim ("CSRF attacks").]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Example: sensitive WebForms page
// VIOLATION, no CSRF protection
public partial class Checkout : System.Web.UI.Page
{
  protected void Page_Load(object sender, EventArgs e)
  {
    SensitiveOperation();
  }
}

// Example: sensitive MVC action
public class ProductController : Controller
{
   [HttpPost]  // VIOLATION
   public ActionResult PostSensitive(int? id)
   {
     // ...
   }
}]]></example>
    <repair><![CDATA[// Example: sensitive WebForms page
// Anti-CSRF logic typically done in master page (template in recent ASP.Net versions)
public partial class SiteMaster : MasterPage {
  private const string AntiCsrfTokenKey = "__AntiCsrfToken";
  private const string AntiCsrfUserNameKey = "__AntiCsrfUserName";
  private string _antiCsrfTokenValue;

  protected void Page_Init(object sender, EventArgs e) {
    var csrfCookie = Request.Cookies[AntiCsrfTokenKey];
    Guid csrfCookieValue;
    if (csrfCookie != null && Guid.TryParse(csrfCookie.Value, out csrfCookieValue)) {
      // Use the anti-CSRF token from the cookie
      _antiCsrfTokenValue = csrfCookie.Value;
      Page.ViewStateUserKey = _antiCsrfTokenValue;

    } else {
      // Generate a new anti-CSRF token and save to the cookie
      _antiCsrfTokenValue = Guid.NewGuid().ToString("N");
      Page.ViewStateUserKey = _antiCsrfTokenValue;

      var responseCookie = new HttpCookie(AntiCsrfTokenKey) {
        HttpOnly = true,
        Value = _antiCsrfTokenValue
      };
      if (FormsAuthentication.RequireSSL && Request.IsSecureConnection) {
        responseCookie.Secure = true;
      }
      Response.Cookies.Set(responseCookie);
    }

    Page.PreLoad += master_Page_PreLoad;
  }

  // before each page load (where sensitive action is performed)
  protected void master_Page_PreLoad(object sender, EventArgs e) {
    if (!IsPostBack) {
      // Set anti-CSRF token (using ViewState)
      ViewState[AntiCsrfTokenKey] = Page.ViewStateUserKey;
      ViewState[AntiCsrfUserNameKey] = Context.User.Identity.Name ?? String.Empty;

    } else {
      // Validate the anti-CSRF token and check
      if ((string)ViewState[AntiCsrfTokenKey] != _antiCsrfTokenValue
          || (string)ViewState[AntiCsrfUserNameKey] != (Context.User.Identity.Name ?? String.Empty)) {
          throw new InvalidOperationException("Validation of Anti-CSRF token failed.");
      }
    }
  }
}

// Example: sensitive MVC action, simply add [ValidateAntiForgeryToken]
// and make sure that the token is generated in the request view/form with
// @Html.AntiForgeryToken() / @AntiForgery.GetHtml()
public class ProductController : Controller
{
   [HttpPost] [ValidateAntiForgeryToken]
   public ActionResult PostSensitive(int? id)
   {
     // ...
   }
}]]></repair>
    <reference><![CDATA[For MVC: https://www.asp.net/mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages,https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet,For Web API: https://www.asp.net/web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks,For WebForms: https://msdn.microsoft.com/li]]></reference>
    <normatives>
      <security><![CDATA[CWE:352,CWETOP25:2021:9,OWASP:2013:A8,PCI-DSS:6.5.9,WASC:9]]></security>
    </normatives>
    <properties>
      <property name="checkStateModification" descname="When true, exclude from analysis any method with no operations changing application state; if false, each candidate method should have explicit anti-CSRF protection." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.CrossSiteScripting" message="CrossSiteScripting: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')" class="com.optimyth.csharp.rules.security.CrossSiteScriptingRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software places user-controlled input in page content. An attacker could inject browser script code that is executed in the client browser.
The end-user is the attacked subject, and the software is the vehicle for the attack. This attack is known as Cross-Site Scripting (XSS).

There are three kinds of XSS:
* Reflected XSS: Attacker causes victim to supply malicious content to a vulnerable web application, which renders HTML content
  embedding a malicious script executed in victim's browser.
  A variation of this is named DOM-based XSS, where the vulnerable software does not generate content depending on user input
  but include script code that use user-controlled input.

* Persistent XSS: Attacker provides malicious content to the vulnerable application, which is stored somewhere.
  When stored data is fetched and rendered,

Note: This rule only considers the first case ("Reflected XSS").

When other user access to vulnerable pages that embed without proper neutralization the attacker content,
script code is executed in the victim's browser.

The script executed in the victim's browser could perform malicious activities, like stealing active authentication tokens
(sometimes in the form of cookies) and performing operations on a insecure webapp (on behalf of the victim) that trusts
too much identity artifacts in browser and do not request additional authorization for operations ('Cross-Site Request Forgery attack', CSRF).

Many browsers could limit the damage via security restrictions (e.g. 'same origin policy'), but user browsers generally allow scripting languages
(e.g. JavaScript) in their browsers (disabling JavaScript severely limits a web application).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XSS vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[In this example, we assume ValidateRequest is disabled.

XSS.aspx:
            
<%@ Page Language="C#" AutoEventWireup="true" CodeBehind="XSS.aspx.cs" Inherits="Test.XSS"  ValidateRequest="false" %>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
    <title></title>
</head>
<body>
    <form id="form1" runat="server">
    <div>
      <asp:Label ID="lblName" runat="server" />
    </div>
    </form>
</body>
</html>

XSS.aspx.cs:

namespace Test
{
    public partial class XSS : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            string id = Request.QueryString["name"] as string;

            if (id == null)
            {
                lblName.Text = "NA";
            }
            else
            {
                lblName.Text = id;
            }
        }
    }
}

Using an URL like:
http://myhost.com/XSS?name=<a href="http://www.foo.com">Continue...</a>
we will add a link in page requested by user.]]></example>
    <repair><![CDATA[This is a very simple example that can be solve by enabling validation request.

Another alternative, using Microsoft Anti-XSS library, might be:

namespace Test
{
    public partial class XSS : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            string id = Request.QueryString["name"] as string;

            if (id == null)
            {
                lblName.Text = "NA";
            }
            else
            {
                lblName.Text = AntiXssEncoder.HtmlEncode(id,false); // FIXED
            }
        }
    }
}]]></repair>
    <reference><![CDATA[https://msdn.microsoft.com/en-us/library/ff649310.aspx,https://lockmedown.com/preventing-xss-in-asp-net-made-easy/,http://cwe.mitre.org/data/definitions/79.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:24]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input)" value="user_input, database_input, file_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.DoSRegexp" message="DoSRegexp: Prevent denial of service attack through malicious regular expression" class="com.optimyth.csharp.rules.security.DoSRegexp" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.1.1,CWEScope:Access-Control,ReDoS,denial-of-service]]></tags>
    <description><![CDATA[Regular expressions are a formal language for identifying strings of text, parsing, and matching them.

Most regular expressions engines are built over a non-deterministic Finite Automaton (NFA). They use backtracking and,
while these regular expression engines can quickly confirm a positive match, confirming a negative match can take much more longer.

There are lots of well-known regular expression patterns that, using selected inputs, take a time exponentially related to input size.

An attacker controlling, as a whole or in part, a regular expression, can carry out a denial of service attack. 

In .NET framework >= 4.5, a new implementation of IsMatch method of Regexp class allows providing a timeout for regular expression matching.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent denial of service attacks due to regular expressions.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Text.RegularExpressions;

public class MyPage : System.Web.UI.Page
{
    protected void Button1_Click(object sender, System.EventArgs e)
    {
        bool isValid = RegExp.IsMatch(  // VIOLATION
          Request.QueryString["INPUT"], Request.QueryString["VALIDATE"], RegexOptions.IgnoreCase
        );
        if (isValid) {
          // ...
        }
    }
}]]></example>
    <repair><![CDATA[using System.Text.RegularExpressions;

public class MyPage : System.Web.UI.Page
{
    protected void Button1_Click(object sender, System.EventArgs e)
    {
        bool isValid = RegExp.IsMatch(
          Request.QueryString["INPUT"], Request.QueryString["VALIDATE"], RegexOptions.IgnoreCase,
          TimeSpan.FromMilliseconds(500) // FIXED
        );
        if (isValid) {
          // ...
        }
    }
}]]></repair>
    <reference><![CDATA[https://msdn.microsoft.com/nl-nl/magazine/ff646973(en-us).aspx,https://cwe.mitre.org/data/definitions/400.html,https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS,https://msdn.microsoft.com/en-us/library/gg578045.aspx]]></reference>
    <normatives>
      <security><![CDATA[CWE:400,CWETOP25:2021:27,OWASP:2021:A3]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.InsecureRandomness" message="InsecureRandomness: Standard pseudo-random number generators cannot withstand cryptographic attacks" class="com.optimyth.csharp.rules.security.InsecureRandomness" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.3.1,ASVS-v4.0.2:2.6.2,ASVS-v4.0.2:2.9.2,ASVS-v4.0.2:6.3.1,ASVS-v4.0.2:6.3.2,ASVS-v4.0.2:6.3.3,CWEScope:Access-Control,CWEScope:Confidentiality,crypto,prng]]></tags>
    <description><![CDATA[Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness
in security-sensitive context.

Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators (PRNGs)
approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.

There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties,
but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use
in cases where security depends on generated values being unpredictable.

Cryptographic PRNGs address this problem by generating output that is more difficult to predict.
For a value to be cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish
between it and a truly random value.

In general, if a PRNG algorithm is not advertised as being cryptographically secure, then it is probably a statistical PRNG
and should not be used in security-sensitive contexts, where its use can lead to serious vulnerabilities such as
easy-to-guess temporary passwords, predictable cryptographic keys, session hijacking, and DNS spoofing.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// The following code uses a statistical PRNG to create a URL for a receipt
// that remains active for some period of time after a purchase.

string GenerateReceiptURL(string baseUrl) {
    Random Gen = new Random();
    return (baseUrl + Gen.Next().toString() + ".html"); // VIOLATION
}

// This code uses the Random.Next() function to generate "unique" identifiers
// for the receipt pages it generates.
// Because Random.Next() is a statistical PRNG, it is easy for an attacker
// to guess the strings it generates.
// It would be more secure a cryptographic PRNG in this context.]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://msdn.microsoft.com/en-us/library/system.random(v=vs.110).aspx,http://cwe.mitre.org/data/definitions/330.html,http://cwe.mitre.org/data/definitions/338.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:330,CWE:338,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="pattern" descname="Regular expression for detecting when a non-cryptographic PRNG is used in a security context.
When blank, any non-cryptographic PRNG usage is reported as a rule violation." value="password|passwd|receipt|session|user|key|csrf|token|hash|mac|digest|uuid|guid|crypto|encrypt|decrypt"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.JSONInjection" message="JSONInjection: Avoid using non-neutralized user-controlled input in JSON entities" class="com.optimyth.csharp.rules.security.JSONInjection" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[JSON is a lightweight, text-based data interchange format with parsers available in many languages.
JSON format is often used for serializing and transmitting structured data over a network connection, as an alternative to XML.

An attacker can take advantage of non-neutralized input data written to or interpreted as JSON in several ways, depending on
the use of JSON in the application.

A change on JSON entity structure can cause an application fail or in the worst case a businness logic manipulation.

Input data must be validated before processing as JSON.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent JSON injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      public void saveData()
      {
          string jsonData = Request.QueryString["DATA"];
          Product item = JsonConvert.DeserializeObject<Product>(jsonData);   // sink
      }]]></example>
    <repair><![CDATA[      public void saveData()
      {
          string jsonData = Request.QueryString["DATA"];
          jsonData = validate(jsonData);   // neutralization
          Product item = JsonConvert.DeserializeObject<Product>(jsonData);  // ok
      }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/91.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:91,OWASP:2021:A3]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.LdapInjection" message="LdapInjection: Avoid non-neutralized user-controlled input in LDAP search filters" class="com.optimyth.csharp.rules.security.LdapInjectionRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.7,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software constructs all or part of an LDAP query using externally-influenced input, but it does not neutralize or
    incorrectly neutralizes special elements that could modify the intended LDAP query when sent to LDAP server.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[It improves the safety.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      public void searchLdap()
      {
          DirectorySearcher src = new DirectorySearcher("(manager=" + Request.Item["USER"] + ")"); // VIOLATION
      }]]></example>
    <repair><![CDATA[      public void searchLdap()
      {
          string inputUser = Request.Item["USER"];
          string filter = validate(inputUser);
          DirectorySearcher src = new DirectorySearcher("(manager=" + filter + ")"); // OK
      }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/90.html,https://blogs.msdn.microsoft.com/securitytools/2009/08/10/ldap-injection-and-mitigation/]]></reference>
    <normatives>
      <security><![CDATA[CWE:90,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:29]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
      <property name="parametersAsSources" descname="If true, method parameters are considered untrusted inputs." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.MVCNonActionPublicMethods" message="MVCNonActionPublicMethods: Protect public methods that are not action methods in controllers" class="com.optimyth.csharp.rules.security.MVCNonActionPublicMethods" technology="CSHARP" active="true">
    <tags><![CDATA[ASP.NET MVC,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[In ASP.NET MVC controllers, every public method  (exluding constructors and static methods)
is web accessible, regardless of return type.

Methods in controllers that are not action methods should be declared protected or private when feasible. If a method must
be public, it can be decorated with NonAction attribute or using properties to restrict a method access (See #2 link reference).

This way, an attempt of invoking the method will finish with error.]]></description>
    <priority>1</priority>
    <effort>1</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid that non action methods in controllers were web accessible.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Web.Mvc;

public class ClientController : Controller
{
  // GET: Client
  public ActionResult Index()
  {
     // Load the data for the client
     var clients = Client.GetClients();

     // Return the view.
     return View(clients);
  }

  public void DeleteClient(int clientId) {   // VIOLATION - web accessible
    //...
  }
}]]></example>
    <repair><![CDATA[using System.Web.Mvc;

public class ClientController : Controller
{
  // GET: Client
  public ActionResult Index()
  {
     // Load the data for the client
     var clients = Client.GetClients();

     // Return the view.
     return View(clients);
  }

  [NonAction]
  public void DeleteClient(int clientId) {   // OK
    //...
  }
}]]></repair>
    <reference><![CDATA[https://docs.microsoft.com/en-us/dotnet/framework/misc/securing-method-access,http://cwe.mitre.org/data/definitions/862.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:862,CWETOP25:2021:18,OWASP:2021:A1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.MVCPostInControllers" message="MVCPostInControllers: Restrict allowed HTTP verbs for state-change operations in MVC controllers" class="com.optimyth.csharp.rules.security.MVCPostInControllers" technology="CSHARP" active="true">
    <tags><![CDATA[ASP.NET MVC,ASVS-v4.0.2:13.2.3,ASVS-v4.0.2:4.2.2,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[In an MVC controller (for classic MVC, MVC Core, or Web API), actions that change the state of the application
(perform database modifications, changes in files, etc.) should have the HTTP verbs restricted, to reduce the opportunity
for cross-site request forgery (CSRF) and other attacks.

The HTTP 1.1 standard define multiple verbs: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE and CONNECT. With HTML, typically
only GET and POST have explicit support. A CSRF attack works by tricking the victim's browser into performing actions
on the application, when the victim has an open authenticated session. Forced by browser's security policy, the attacker
typically uses GET requests (so restricting to POST, PUT, DELETE at least avoids "one-click" CSRF attacks).

The rule forces that any state-change controller method restricts the allowed HTTP verbs, like POST, PUT and DELETE.

Note: In MVC or Web API applications, anti-forgery tokens can be used to prevent CSRF attacks.
If the action method is protected by any anti-forgery mechanism, like [ValidateAntiForgeryToken], no violation is emitted,
even if the action method does not restrict HTTP verbs (a GET request typically cannot pass the validation).]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[More control on which HTTP inputs change application state; reduce risk for CSRF vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  // VIOLACIÃ“N, GET may invoke this action
  public ActionResult Create(MyModel model)
  {
    // ... inserts into database ...
    return View();
  }]]></example>
    <repair><![CDATA[  // OK, action restricted to POST
  [HttpPost]
  [ValidateAntiForgeryToken] // anti-CSRF token
  public ActionResult Create(MyModel model)
  {
    // ... inserts into database ...
    return View();
  }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/352.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:352,CWETOP25:2021:9,OWASP:2013:A8,PCI-DSS:6.5.9,WASC:9]]></security>
    </normatives>
    <properties>
      <property name="allowedVerbs" descname="List with the allowed HTTP verbs (POST, PUT and GET by default) for state-changing actions." value="POST,PUT,DELETE"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.MVCPreventOverpostingModelDefinition" message="MVCPreventOverpostingModelDefinition: Prevent over-posting attacks in model definition" class="com.optimyth.csharp.rules.security.MVCPreventOverpostingModelDefinition" technology="CSHARP" active="true">
    <tags><![CDATA[ASP.NET MVC,ASVS-v4.0.2:13.2.6,ASVS-v4.0.2:13.3.2,ASVS-v4.0.2:3.5.3,CWEScope:Integrity,over-posting]]></tags>
    <description><![CDATA[In ASP.NET MVC applications, default model binding will attempt to move data from request to model for each property received in request.

Over-posting attacks try to modify data that should not be modifiable, adding parameters to requests.

In ASP.NET MVC, if an attacker add a property to a request, and that property exists in model, by default the model will be updated with the value provided by the attacker.

There are several ways to prevent over-posting attacks:

- Add Bind attribute, with a whitelist or blacklist approach.
- Use UpdateModel or TryUpdateModel methods with whitelist or blacklist parameter list.
- Create a specific model for views, just containing properties that users should be able to modify.

This rule is focused on model definition. It emits a violation when in a class there are Required properties, and Bind attribute is missing.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent over-posting attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    public class Product {    // VIOLATION
      [Required]
      public string Name { get; set; }
      [Required]
      public string Comment { get; set; }
      public float Price { get; set; }
    }]]></example>
    <repair><![CDATA[    [Bind(Include="Name, Comment")]    // OK
    public class Product {
      [Required]
      public string Name { get; set; }
      [Required]
      public string Comment { get; set; }
      public float Price { get; set; }
    }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/345.html,http://bradwilson.typepad.com/blog/2010/01/input-validation-vs-model-validation-in-aspnet-mvc.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:915,OWASP:2021:A8,WASC:12]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.MVCPreventUnderpostingModelComposition" message="MVCPreventUnderpostingModelComposition: Prevent under-posting attacks in model composition" class="com.optimyth.csharp.rules.security.MVCPreventUnderpostingModelComposition" technology="CSHARP" active="true">
    <tags><![CDATA[ASP.NET MVC,ASVS-v4.0.2:13.2.6,ASVS-v4.0.2:13.3.2,ASVS-v4.0.2:3.5.3,CWEScope:Integrity,under-posting]]></tags>
    <description><![CDATA[A model can contain an optional property that is another model with Required properties.

Under-posting attacks leave out properties in the request.

In ASP.NET MVC, the attacker can leave out the value of an optional property corresponding to a child model with Required properties. The optional property will have null value and validation of Required properties of child model will not be performed.

There are several ways to prevent these under-posting attacks:

- Create a specific model for views, just containing properties that users should be able to modify.
- Add Required attribute to child models with Requiered properties.
- Perform additional validations in other layers of the application.

This rule is focused un model definition. It emits a violation when in a class it finds an optional property that is a child model with Required properties.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevet under-posting attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    public class Product {
      [Required]
      public string Name { get; set; }
      [Required]
      public string Comment { get; set; }
      public Restrictions Conditions { get; set; }  // VIOLATION
    }
    public class Restrictions {
      [Required]
      public int? Amount { get; set; }
    }]]></example>
    <repair><![CDATA[    public class Product {
      [Required]
      public string Name { get; set; }
      [Required]
      public string Comment { get; set; }
      [Required]
      public Restrictions Conditions { get; set; }  // OK
    }
    public class Restrictions {
      [Required]
      public int? Amount { get; set; }
    }]]></repair>
    <reference><![CDATA[http://bradwilson.typepad.com/blog/2010/01/input-validation-vs-model-validation-in-aspnet-mvc.html,http://cwe.mitre.org/data/definitions/345.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:345,OWASP:2021:A8,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.MVCPreventUnderpostingModelDefinition" message="MVCPreventUnderpostingModelDefinition: Prevent under-posting attacks in model definition" class="com.optimyth.csharp.rules.security.MVCPreventUnderpostingModelDefinition" technology="CSHARP" active="true">
    <tags><![CDATA[ASP.NET MVC,ASVS-v4.0.2:13.2.6,ASVS-v4.0.2:13.3.2,ASVS-v4.0.2:3.5.3,CWEScope:Integrity,under-posting]]></tags>
    <description><![CDATA[When the Required attribute is used with a model property, the value is checked to be not null; and when value is null, validation fails.

Under-posting attacks leave out properties in the request.

In ASP.NET MVC, the attacker can leave out a mandatory property of a non nullable type. If validation resides in Required attribute,
it will not work when the property is non nullable.

There are several ways to prevent these under-posting attacks:

- Make the property a nullable version of the value type, using the ? modifier. For example: int? instead of int.
- Create a specific model for views, just containing properties that users should be able to modify.
- Perform additional validations in other layers of the application.

This rule is focused on model definition. It emits a violation when in a class there are Required properties, and
they are not nullables due to its type.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevet under-posting attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    public class Product {
      [Required]
      public string Name { get; set; }
      [Required]
      public string Comment { get; set; }
      [Required]
      public float Price { get; set; }  // VIOLATION
    }]]></example>
    <repair><![CDATA[    public class Product {
      [Required]
      public string Name { get; set; }
      [Required]
      public string Comment { get; set; }
      [Required]
      public float? Price { get; set; }  // OK
    }]]></repair>
    <reference><![CDATA[https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-2.2#notes-on-the-use-of-the-required-attribute,http://bradwilson.typepad.com/blog/2010/01/input-validation-vs-model-validation-in-aspnet-mvc.html,http://cwe.mitre.org/data/definitions/345.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:345,OWASP:2021:A8,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.NullDereference" message="NullDereference: NULL Pointer Dereference" class="com.optimyth.csharp.rules.security.NullDereferenceRule" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[A null dereference is the access - for instance, to access a property or invoke a method -
to a reference pointing to null, instead of a valid object.

When it happens, a NullReferenceException is thrown, aborting normal execution flow.

Null dereference is a reliability problem, but it can also affect security in several ways:
- Generating debugging information visible for the attacker.
- Leading to the end of the process, so a possible denial of service attack.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unexpected behaviours.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[		public string myMethod() {
			string name = Request.QueryString["name"];
	    string shortName = name.Trim();   // VIOLATION
	    return shortName;
		}]]></example>
    <repair><![CDATA[		public string myMethod() {
			string name = Request.QueryString["name"];
			if (name == null) { return; }     // OK
	    string shortName = name.Trim();
	    return shortName;
		}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/476.html]]></reference>
    <normatives>
      <security><![CDATA[Agile Alliance:Clear-CNUL,CWE:476,CWETOP25:2021:15]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.OftenMisusedAuthentication" message="OftenMisusedAuthentication: An attacker could replace the DNS entries" class="com.optimyth.csharp.rules.security.OftenMisusedAuthenticationRule" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[It is recommended not to base the security of a system on DNS names. Many DNS servers are susceptible to attacks, if your software is running on an affected server attackers could redirect your network traffic through their computers or make it appear that their IP addresses are part of your domain.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevents IP forgery vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[IPAddress hostIPAddress = IPAddress.Parse(RemoteIpAddress);
IPHostEntry hostInfo = Dns.GetHostByAddress(hostIPAddress);
if (hostInfo.HostName.EndsWith("mydomain.com")) { // VIOLATION
  ok = true;
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/807.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:807,OWASP:2013:A2,PCI-DSS:6.5.8,SANS25:2010:6,SANS25:2011:10,WASC:24]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.OpenRedirect" message="OpenRedirect: URL Redirection to Untrusted Site ('Open Redirect')" class="com.optimyth.csharp.rules.security.OpenRedirectRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.5,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Avoid using unvalidated input to build the URL used in a redirect.

The rule detects a path in code between an input statement (source) and a redirect statement (sink), to an URL depending on non neutralized input.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent Open redirect attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      public void redirect()
      {
          Response.Redirect(Request.Form["NEW_URL"]);  // VIOLATION
      }]]></example>
    <repair><![CDATA[      public void redirect()
      {
          string newUrl = validate(Request.Form["NEW_URL"]);
          Response.Redirect(newUrl);  // OK
      }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/601.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:601,CWETOP25:2021:37,OWASP:2013:A10,PCI-DSS:6.5.8,WASC:33]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.PathTraversal" message="PathTraversal: Avoid non-neutralized user-controlled input composed in a pathname to a resource" class="com.optimyth.csharp.rules.security.PathTraversalRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.1,ASVS-v4.0.2:12.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software uses external input to construct a pathname that is intended to identify a file or directory
that is located underneath a restricted parent directory, but the software does not properly neutralize
special elements within the pathname that can cause the pathname to resolve to a location outside the
restricted directory.

It the software does not restrict access to files outside certain restricted directories, the attacker may fetch
sensitive files, and if the file is written with contents controlled by user input, the attacker may change
configuration files (like Web.config among others), web contents ('web defacement'), or libraries
(for more insidious code injection attacks).

Access to system files (like /etc/password in Unix/Linux systems) could also be allowed with account permissions
for the process running the software.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Filesystem paths should not be controlled by untrusted inputs.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.IO;
using Microsoft.AspNetCore.Mvc;

public class MyController : Controller
{
  private const string uploadsDir = "~/uploads/"; // hardcoded, for simplicity

  public IActionResult RemoveUploadedFile(string fileName)
  {
    var userId = _userManager.GetUserId(HttpContext.User);

    // fileName might come from a 'hidden' form field, but attacker may create a custom HTTP request
    // with dots encoded in complex ways in fileName input, to 'escape' up to another user uploads,
    // or even out of uploadsDir...
    var userDir = Path.Combine(uploadsDir, userId);
    var fileToDelete = Path.Combine(userDir, fileName);

    // VIOLATION - vulnerable to path traversal attack
    File.Delete( fileToDelete );

    return Content("Uploaded file " + fileName + " removed");
  }
}]]></example>
    <repair><![CDATA[using System;
using System.IO;
using Microsoft.AspNetCore.Mvc;

public class MyController : Controller
{
  private const string uploadsDir = "~/uploads/"; // hardcoded, for simplicity

  public IActionResult RemoveUploadedFile(string fileName)
  {
    // assume that userId only allows letters and digits...
    var userId = _userManager.GetUserId(HttpContext.User);

    // fileName might come from a 'hidden' form field, but attacker may create a custom HTTP request
    // with dots encoded in complex ways in fileName input, to 'escape' up to another user uploads,
    // or even out of uploadsDir...
    var userUploadsDir = Path.Combine(uploadsDir, userId);
    var fileToDelete = Path.Combine(userUploadsDir, fileName);

    // FIXED: paths are canonicalized and then checked that
    // file path is under the intended directory

    var fullDirPath = Path.GetFullPath(userUploadsDir);
    var fullFilePath = Path.GetFullPath(fileToDelete);

    if ( fullFilePath.StartsWith(fullDirPath, StringComparison.Ordinal) )
    {
      File.Delete( fullFilePath );
      return Content("Uploaded file " + fileName + " removed");
    }
    else
    {
      // log this request, could be a Path traversal attack
      return BadRequest("Invalid resource");
    }
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/73.html,http://cwe.mitre.org/data/definitions/22.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:22,CWE:73,CWETOP25:2021:8,OWASP:2021:A4,OWASP:2021:A5,PCI-DSS:6.5.8,WASC:33]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.PotentialInfiniteLoop" message="PotentialInfiniteLoop: Loop with Unreachable Exit Condition ('Infinite Loop')" class="com.optimyth.csharp.rules.security.PotentialInfiniteLoop" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Availability,essential,potential-bug]]></tags>
    <description><![CDATA[The program contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.
Such infinite loop conditions are due typically to logical errors in the loop exit conditions and/or loop variables update,
where the loop exit condition is never reached.

An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory, and might compromise software availability.

NOTE: Rule UncheckedInputInLoopCondition (CWE-606) checks when an untrusted input, not validated, might influence
loop termination leading to a denial-of-service condition.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[T[][] arr = fetchArray();

for (int i=0; i < arr.Length; i++) {
  T[] row = arr[i];
  // VIOLATION: infinite loop
  // a typo after copy+paste external loop, inner loop var j not updated
  for (int j=0; j < row.length; i++) {
     doSomething(row[j]);
  }
}]]></example>
    <repair><![CDATA[T[][] arr = fetchArray();

for (int i=0; i < arr.Length; i++) {
  T[] row = arr[i];
  // FIXED
  for (int j=0; j < row.Length; j++) {
     doSomething(row[j]);
  }
}]]></repair>
    <reference><![CDATA[https://blog.jooq.org/2015/01/16/infinite-loops-or-anything-that-can-possibly-go-wrong-does/]]></reference>
    <normatives>
      <security><![CDATA[CWE:835,CWETOP25:2020:36]]></security>
    </normatives>
    <properties>
      <property name="allowExplicitInfiniteLoops" descname="Intentional non-empty infinite loops, coded as while(true) Ã³ for(;;), are allowed." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.AccessibilitySubversionRule" message="AccessibilitySubversionRule: .Net access restriction subverted (Reflection)" class="com.optimyth.csharp.rules.security.AccessibilitySubversionRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.10.1,ASVS-v4.0.2:1.4.2,ASVS-v4.0.2:1.4.4,essential]]></tags>
    <description><![CDATA[.Net imposes access restrictions for code in one class to access fields, methods and
constructors in objects of different classes (the access level specifiers with public, protected and private keywords
enforce in code such restrictions).

Using reflection, .Net allows a programmer to get around the access control checks provided by these specifiers.
For example, a programmer may access a private field by using the method GetFields(BindingFlags.NonPublic).

The rule emits a security flaw when reflection is used along with the BindingFlags.NonPublic flag.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended accesses to elements that should be protected.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Reflection;

public class Test
{
    public static int Main ()
    {
        System.Type t;
        t.GetFields (BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static); // VIOLATION
    }
}]]></example>
    <repair><![CDATA[Do not use reflection to access non public members.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/284.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:284,CWETOP25:2020:30,OWASP:2021:A1,PCI-DSS:6.5.8,WASC:02]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.AnonymousLdapBind" message="AnonymousLdapBind: Access Control - Anonymous LDAP Bind" class="com.optimyth.csharp.rules.security.AnonymousLdapBind" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Without proper access control, executing an LDAP statement that contains a user-controlled value can allow an attacker to access unauthorized records.
Executing LDAP queries under an anonymous bind, effectively without authentication, can allow an attacker to abuse a poorly configured LDAP environment.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.DirectoryServices;
using System.DirectoryServices.Protocols;

public class AnonymousLdapBind {
  private const string LDAP_URL = "LDAP://ad.example.com:389/ou=People,dc=example,dc=com";

  public void m(string username) {
    // VIOLATION, anonymous bind
    DirectoryEntry de = new DirectoryEntry(LDAP_URL);
    doSomething(de, username);
  }

  public void ldapConn(String target, string username) {
    // VIOLATION, anonymous bind
    using(LdapConnection con = new LdapConnection(new LdapDirectoryIdentifier(ConfigReader.ADServer, 636))) {
      con.AuthType = AuthType.Anonymous;
      con.Bind();
      con.SendRequest(new SearchRequest(target, "(&(objectClass=user)(cn=" + username + "))"), SearchScope.Subtree, null);
    }
  }
}]]></example>
    <repair><![CDATA[using System.DirectoryServices;
using System.DirectoryServices.Protocols;

public class AnonymousLdapBind {
  private const string LDAP_URL = "LDAP://ad.example.com:389/ou=People,dc=example,dc=com";

  public void m(string username) {
    // FIXED
    DirectoryEntry de = new DirectoryEntry();
    de.Path = LDAP_URL;
    de.AuthenticationType = AuthenticationTypes.None; // basic authentication
    de.Username = MY_USER;
    de.Password = MY_PASS;
    doSomething(de, username);
  }

  public void ldapConn(String target, string username) {
    // FIXED
    using(LdapConnection con = new LdapConnection(new LdapDirectoryIdentifier(ConfigReader.ADServer, 636))) {
      con.Credential = new NetworkCredential(MY_USER, MY_PASS);
      con.AuthType = AuthType.Basic;
      con.Bind();
      con.SendRequest(new SearchRequest(target, "(&(objectClass=user)(cn=" + username + "))"), SearchScope.Subtree, null);
    }
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/285.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:285,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.AvoidCertificateEquals" message="AvoidCertificateEquals: Never use X509Certificate.Equals() in a security context" class="com.optimyth.csharp.rules.security.AvoidCertificateEquals" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.9.2,ASVS-v4.0.2:9.2.1,CWEScope:AccessControl,CWEScope:Confidentiality,CWEScope:Integrity,certificates,essential]]></tags>
    <description><![CDATA[When validating X509 certificates, at certain points it is necessary to check that a received certificate matches another one, trusted certificate
(or one in a set of trusted certificates).

Application developers might assume that the Equals() method of the X509Certificate class performs a robust comparison.
Unfortunately, such comparison is weak, as only the issuer distinguished name (DN) and the certificate serial number are compared.

An attacker may clone a legitimate certificate (which is public by definition), copy the issuer name and serial number (and the subject name if necessary),
and sign the cloned certificate (self-signed or with an attacker-controlled CA keypair). When only Equals() is used for comparison,
the Equals() method will return true even then the original and the cloned certificates are completely different: the public/private keypair
(the public part is signed in the certificate with the CA private key) and the signature are different.

So the attacker may pass this cloned certificate as 'equal' to another legitimate certificate with same issued DN and serial number.
Equals() should never be used in a security context, like in certificate validation.

The Microsoft documentation says "The Equals method should not be used when comparing certificates for security purposes.
Instead, use a hash of the RawData property, or the Thumbprint property."]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid accepting a cloned certificate as legitimate in trust decisions.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public bool IsTrusted(X509Certificate2 candidate, X509Certificate2[] trusted)
{
  foreach(X509Certificate2 t in trusted)
  {
    if( candidate.Equals(t) ) return true; // VIOLATION
  }
  return false;
}]]></example>
    <repair><![CDATA[public bool IsTrusted(X509Certificate2 candidate, X509Certificate2[] trusted)
{
  foreach(X509Certificate2 t in trusted)
  {
    if( candidate.Thumbprint.Equals(t.Thumbprint) ) return true; // FIXED
  }
  return false;
}]]></repair>
    <reference><![CDATA[https://posts.specterops.io/subverting-x509certificate-equals-in-net-92b97d1ae59b,https://docs.microsoft.com/dotnet/api/system.security.cryptography.x509certificates.x509certificate.equals]]></reference>
    <normatives>
      <security><![CDATA[CWE:295,CWETOP25:2021:26]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.AvoidHostNameChecks" message="AvoidHostNameChecks: Avoid checks on client-side hostname, that are not reliable due to DNS poisoning" class="com.optimyth.csharp.rules.security.AvoidHostNameChecks" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.3.3,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Many DNS servers are susceptible to DNS poisoning attacks, so you should assume that your software will someday run
in an environment with a compromised DNS server. If attackers are allowed to make DNS updates (sometimes called DNS cache poisoning),
they can route your network traffic through their machines or make it appear as if their IP addresses are part of your domain.
Do not base the security of your software on DNS names.

Note: If client hostname check is the unique possibility, perform proper forward and reverse DNS lookups for detectin potential DNS spoofing.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Net;
using System.Web;

public class AvoidHostNameChecks
{
  public void connect()
  {
    string remoteIpAddress = Request.ServerVariables["REMOTE_ADDR"];
    IPAddress hostIPAddress = IPAddress.Parse(remoteIpAddress);
    IPHostEntry hostInfo = Dns.GetHostByAddress(hostIPAddress);
    if (hostInfo.HostName.EndsWith("trustme.com")) {  //VIOLATION
      trusted = true;
    }
  }
}]]></example>
    <repair><![CDATA[Do not use client hostname for any access control decision.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/350.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:350,OWASP:2021:A4,PCI-DSS:6.5.8,WASC:24]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.ConnectionStringParameterPollution" message="ConnectionStringParameterPollution: Connection string polluted with untrusted input" class="com.optimyth.csharp.rules.security.ConnectionStringParameterPollution" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[When the connection string for an application resource (like database, remote server, persistence entity manager...) could
be affected by an untrusted source, not properly neutralized, the application is vulnerable to a Connection String Parameter Pollution attack.

An attack targeted at this vulnerability may use special characters (like ';' or ':') to add unexpected parts to the connection string,
for example to gain extra privileges, or to deactivate security features.

"Untrusted input" means, in this context, a user-controlled application input, an environment variable, or data fetched
from an external web source.

It should be suspicious that a connection string depends on untrusted input. Normally the application configuration uses
a fixed connection string, but other attacks, depending on where the connection string is stored (like an SQL injection or
path traversal attack) may affect the configuration item. This rule only checks for connection strings that are constructed
programmatically with untrusted input.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Configuration;
using System.Data.SqlClient;

public class InsecureConnectionString {
  public void run() {
    string connStr = Environment.GetEnvironmentVariable("MyConnStr"); // considered untrusted source
    using(var connection = new SqlConnection(connStr))  // VIOLATION
    {
      // ...
    }
  }
}]]></example>
    <repair><![CDATA[// Validate (white-list approach) the untrusted input combined into the connection string.
// Alternatively, fetch connection string from a trusted source, like app configuration:

  public void run() {
    // FIXED, connection string taken from app configuration, considered trusted...
    string connStr = ConfigurationManager.ConnectionStrings["MyConnStr"].ConnectionString;
    using(var connection = new SqlConnection(connStr))
    {
      // ...
    }
  }]]></repair>
    <reference><![CDATA[https://www.blackhat.com/presentations/bh-dc-10/Alonso_Chema/Blackhat-DC-2010-Alonso-Connection-String-Parameter-Pollution-wp.pdf,https://msdn.microsoft.com/en-us/library/ms254494(v=vs.110).aspx,https://msdn.microsoft.com/en-us/library/89211k9b(v=vs.110).aspx]]></reference>
    <normatives>
      <security><![CDATA[CWE:15,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.DangerousFileUpload" message="DangerousFileUpload: Unrestricted Upload of File with Dangerous Type" class="com.optimyth.csharp.rules.security.DangerousFileUpload" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.2.1,ASVS-v4.0.2:12.5.2,ASVS-v4.0.2:13.1.5,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The software allows to upload files without restricting the content uploaded and/or where the uploaded content is stored.

If attacker may influence where on filesystem the file with uploaded content is written, it may overwrite configuration
and other sensitive system files (this depends on the permissions granted to the web server process).

If attacker may influence, on the file path to write, not the full path, but part of it (for example, the file extension),
the attacker may choose .aspx or similar extension. If the target resource is available for the attacker, the app is vulnerable
to an indirect code injection attack.

If the uploaded file is included (as a web resource) in web content, the attacker may even succeed in a stored cross-site scripting
attack targeted at a victim's browser.

The attacker may use unrestricted file upload sites for file space denial-of-service, automatic command execution
(in vulnerable virus scanner tools that try to process the uploaded malicious content), and more esoteric attacks.

This rule checks for some explicit validations are performed on the file-upload object, for the different frameworks,
from ASP.Net WebForms FileUpload control and HttpPostedFile type, to MVC HttpPostedFileBase and MVC Core IFormFile types.

The validations that are checked are:
- Input size check, to ensure that the content size does not exceed a limit.

- If the file is stored, and something from HTTP message is used to compile the filepath, at least a proper neutralization
  is done (for example, on the FileName property).

- Any check on the uploaded contents, before storage, is accepted as a proper neutralization.

- Any additional checks (on content-type, filename or extension patterns, etc.) are ignored, as they typically do
  not neutralize most of the attacks.

Remember that a "file upload", in technical terms, is an HTTP message with Content-Type=multipart/form-data.
Each form item is a part with a Content-Disposition header. A file HTML control provides a filename value, and Content-Type header.
But remember that no single bit from a HTTP message could be trusted, as our willy attacker may craft the HTML message entirely.
So the message may lie about the true content type, the filename could be anything (even an syntactically invalid filename),
the content could be as large as target webapp accepts, etc.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Force restricting the uploaded content, to reduce the risk with file uploading.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- In .aspx page -->
<form id="image_upload" runat="server">
  <asp:Label runat="server" id="DescLabel" text="Choose photo: " />
  <asp:FileUpload id="FileUploadControl" runat="server" />
  <asp:Button runat="server" id="UploadButton" text="Upload" onclick="UploadButton_Click" />
  <br /><br />
  <asp:Label runat="server" id="StatusLabel" text="Upload status: " />
</form>

<!-- Code-behind for upload -->
using System.Web;
// ... Page partial class not shown

protected void UploadButton_Click(object sender, EventArgs e)
{
  if(FileUploadControl.HasFile)
  {
    try
    {
      string filename = Path.GetFileName(FileUploadControl.FileName);
      // The uploaded contents are not unrestricted, and written in the web content directory...
      // Many attacks, like .aspx code injection, stored XSS and many others, are possible !!!
      FileUploadControl.SaveAs(Server.MapPath("~/upload/") + filename); // VIOLATION, unrestricted upload
      StatusLabel.Text = "Upload status: File uploaded!";
    }
    catch(Exception ex)
    {
      StatusLabel.Text = "Upload status: The file could not be uploaded. The following error occured: " + ex.Message;
    }
  }
}]]></example>
    <repair><![CDATA[<!-- Add a validation on the extensions that the user may choose -->
<asp:FileUpload id="FileUploadControl" runat="server" />
<asp:RegularExpressionValidator id="FileUploadRegex" runat="server"
     ErrorMessage="Only .img, .gif, .png or .jpg files allowed!"
     ValidationExpression ="^.+\.(img|gif|png|jpg)$" ControlToValidate="FileUploadControl"/>

<!-- Restrict allowed contents before writing to file -->
using System.Web;
using System.Drawing;
using System.Drawing.Imaging;
// ... Page partial class not shown

protected void UploadButton_Click(object sender, EventArgs e)
{
  if(FileUploadControl.HasFile)
  {
    try
    {
      ValidationResult result = ValidateUpload(FileUploadControl);
      if(result.IsValid) {
        string filename = Path.GetFileName(FileUploadControl.FileName);
        // Our logic insists in storing uploaded content in webroot
        FileUploadControl.SaveAs(Server.MapPath("~/upload/") + filename);
        StatusLabel.Text = "Upload status: File uploaded!";

      } else {
        StatusLabel.Text = "Upload status: ERROR - " + result.Message;
      }
    }
    catch(Exception ex)
    {
      // Remember, error messages shown to users should not convey system information
      StatusLabel.Text = "Upload status: The file could not be uploaded.";
      log.error("Upload status: The file could not be uploaded: " + filename, ex);
    }
  }
}

private const int MAX_SIZE = 1 * 1024 * 1024; // 1 MB limit

// Validates uploaded size and content (we are expecting an image with certain restrictions)
private ValidationResult ValidateUpload( FileUploadControl fileUpload ) {
  HttpPostedFile file = fileUpload.PostedFile;
  if(file.ContentLength > MAX_SIZE) return new ValidationResult(false, "Too big file, max size: 1MB");

  try
  {
    using (var img = Image.FromStream(file.InputStream))
    {
      var fmt = img.RawFormat;
      bool isProperFormat =
        ImageFormat.Bmp.Equals(fmt) || ImageFormat.Gif.Equals(fmt) ||
        ImageFormat.Jpeg.Equals(fmt) || ImageFormat.Png.Equals(fmt);

      if(!isProperFormat) {
        return new ValidationResult(false, "Invalid image format, allowed types are: bmp, gif, jpg or png");
      }
    }

    return new ValidationResult(true, ""); // ALLOWED!
  }
  catch {
    return new ValidationResult(false, "Uploaded content is not an image");
  }
}]]></repair>
    <reference><![CDATA[http://stackoverflow.com/questions/6388812/how-to-validate-uploaded-file-in-asp-net-mvc,https://cwe.mitre.org/data/definitions/434.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:434,CWETOP25:2021:10]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.HardcodedCredential" message="HardcodedCredential: Use of Hard-coded Credentials" class="com.optimyth.csharp.rules.security.HardcodedCredential" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.4,ASVS-v4.0.2:3.5.2,ASVS-v4.0.2:6.4.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The software contains hard-coded credentials, such as an username or password, which is used for security purposes (like authentication
with an external system). Any person with access to the source code have straight access to the credentials. Additionally,
an attacker may fetch the compiled code and decompile it to fetch the hardcoded credentials.

Credentials used for security purposes are sensitive information that should not be disclosed to actors, like developers.

If the hardcoded credentials need to be changed, source code needs to be changed, recompiled, and application needs redeployment,
which increases the impact of this bad practice, as credential renewal will take longer.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid credential leakage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Diagnostics;
using System.Data.SqlClient;

public class HardCodedCreds {
  // some hardcoded credentials
  private const string UNAME = "MyAccount";
  private const string PASS = "MyPass";
  private const string DOMAIN = "MyDomain";
  private const string CONN_STR = "server=(local);user id=ab;password= a!Pass113;initial catalog=AdventureWorks";

  public void runProcess() {
    SecureString pwd = getSecurePassword();
    Process proc = Process.Start("notepad.exe", UNAME, pwd, DOMAIN); // VIOLATION
    // ...
    SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(CONN_STR);  // VIOLATION
    builder.Password = "p4ssw0rd"; // VIOLATION
    SqlConnection conn = new SqlConnection(builder.ConnectionString);
    // ...
  }
}]]></example>
    <repair><![CDATA[using System;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Configuration;

public class NoHardCodedCreds {
  // credentials taken from configuration
  private const string UNAME = ConfigurationManager.AppSettings["MyUsername"]; // FIXED
  private const string PASS = ConfigurationManager.AppSettings["MyPassword"]; // FIXED
  private const string DOMAIN = ConfigurationManager.AppSettings["MyDomain"];
  private const string CONN_STR = ConfigurationManager.AppSettings["MyConnectionString"]; // FIXED

  public void runProcess() {
    SecureString pwd = getSecurePassword();
    Process proc = Process.Start("notepad.exe", UNAME, pwd, DOMAIN);
    // ...
    SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(CONN_STR);
    builder.Password = ConfigurationManager.AppSettings["dbpass"]; // FIXED
    SqlConnection conn = new SqlConnection(builder.ConnectionString);
    // ...
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/798.html,https://www.kiuwan.com/docs/display/K5/Avoid+hard-coded+or+in-comment+passwords+in+code]]></reference>
    <normatives>
      <security><![CDATA[CWE:798,CWETOP25:2021:16,OWASP:2021:A7]]></security>
    </normatives>
    <properties>
      <property name="passwordPattern" descname="Regular expression for matching field names containing passwords." value=""/>
      <property name="usernamePattern" descname="Regular expression for matching field names containing user ids." value=".*(user|username).*|(^|.*_)id(_.*|$)"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.HardcodedCryptoKey" message="HardcodedCryptoKey: Use of Hard-coded Cryptographic Key" class="com.optimyth.csharp.rules.security.HardcodedCryptoKey" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,crypto,essential]]></tags>
    <description><![CDATA[Never hard-code cryptographic keys (or passwords used to generate them) in your program.

Crypto keys are used for encryption/decryption, for generation of message authentication codes (MAC), during generation
of password-based encryption keys (the password is the "crypto key" that generates key material for the cipher), and other usages.
Source code is the worst place for key storage, as any change in keys needs recompilation, and it is easy to reverse-engineer
an application binary to learn any keys or secrets that may be embedded in it.

Instead, store crypto keys in some private location. The System.Security.Cryptography.ProtectedData uses
Microsoft's DPAPI to save/load sensitive credentials (connection strings, passwords, cryptographic keys...).

A crypto key may be stored in configuration file (App.Config or Web.Config), but section containing it needs to be encrypted,
to mitigate the impact if the file is leaked. See "Encrypting Configuration Information"
(https://msdn.microsoft.com/en-us/library/53tyfkaw.aspx) for full details.

Some data used in cryptographic operations (like initial vector for block ciphers, salt for password hashes, etc.)
are not "private", and it is recommended to generate a good random instance at the origin, and add it to the message
in plaintext, so the destination may use it. The security depends on properly protecting the "secret" thing
(private key in a public/private keypair, encryption key in a symmetric cipher, key in an HMAC, etc.).

Long-term cryptographic keys (in contrast with ephemeral ones), with the Crypto Next Generation (CNG) API,
are better stored in a safe key storage. In the constructor (for example, AesCng(string)), the name of the key could be provided.
Private keys in a public/private keypair should NEVER be unprotected (in raw form) and they should be stored in an even
safer key storage (the impact for a compromise of a private key is typically huge and brutal).]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Security.Cryptography;

public static class PBECipher
{
  private const int Keysize = 256;
  private const string passPhrase = "NotSecretAtAll!";

  public static string Encrypt(string plainText) {
    using (var pbe = new Rfc2898DeriveBytes(passPhrase, 32)) // VIOLATION, passPhrase is hardcoded
    {
      pbe.IterationCount = 10000;
      var keyBytes = pbe.GetBytes(Keysize / 8);
      var salt = pbe.Salt;
      using (var aes = new AesManaged()) {
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;
        var iv = Generate256BitsOfRandomEntropy();
        using (var encryptor = aes.CreateEncryptor(keyBytes, iv)) {
          /* ... perform encryption ... */
        }
      }
    }
  }
}

internal static class MyCipher {
  private static readonly byte[] Key = { 0x1f, 0x3f, 0x24, 0x91, 0x3a, 0x0c, 0x11, 0x6a };
  private static readonly byte[] Iv = { 0, 0, 0, 0, 0, 0, 0, 0 }; // a fixed IV is another bad practice

  internal static string Encrypt(String plainText) {
    var des = new DESCryptoServiceProvider(); // Remember, DES is obsolete (too weak...)
     var enc = des.CreateEncryptor(Key, Iv); // VIOLATION
     // ...
  }
}]]></example>
    <repair><![CDATA[using System;
using System.Configuration;
using System.Security.Cryptography;

// KeyStore.fetchKey() provides a more robust way of keeping encryption keys in configuration, protected
public static class KeyStore
{
  private IDataProtector _protector = new DpapiDataProtector("myapp", "protect symmetric keys", "other purpose");

  // Fetch a symmetric key from configuration, using IDataProtector (DPAPI...)
  internal byte[] fetchKey(string keyname) {
    // for simplicity, no check of errors...
    Configuration webConf = WebConfigurationManager.OpenWebConfiguration(null);
    string entry = webConf.AppSettings.Settings[keyname].Value;
    string base64Key = _protector.Unprotect(entry);
    return Convert.fromBase64String(base64Key);
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/321.html,https://msdn.microsoft.com/en-us/library/53tyfkaw.aspx]]></reference>
    <normatives>
      <security><![CDATA[CWE:321,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.3.1,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.HardcodedSalt" message="HardcodedSalt: A hardcoded salt can compromise system security" class="com.optimyth.csharp.rules.security.HardcodedSalt" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,crypto,essential]]></tags>
    <description><![CDATA[A hardcoded salt can compromise system security in a way that cannot be easily remedied.

Salt, a random set of bytes, is used in password hashing schemes.
A dictionary attack is an attack in which the attacker attempts to retrieve a cleartext password, by comparing the stored hashed password
with previously computed values for the most likely password. This attack is made much more difficult by the introduction of salt,
or random bytes, used in the password hashing function, and appended to the hashed password in storage (salt is not secret).

If attackers know the salt value, they can precompute rainbow tables for the application, and more easily reverse hashed values.
A random salt (different for each encrypted entry) should be used, instead or a fixed (hardcoded) value.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Using a strong salt along with a secure algorithm makes data harder to leak.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.IO;
using System.Text;
using System.Security.Cryptography;

public class rfc2898test
{
  public static void Main(string[] passwordargs)
  {
    string pwd = passwordargs[0];
    // Hardcoded salt
    byte[] salt = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x28 };

    int iterations = 1000;

    try
    {
      Rfc2898DeriveBytes k1 = new Rfc2898DeriveBytes(pwd, salt, iterations); // VIOLATION
      // ...
    }
    catch (Exception e)
    {
      // ...
    }
  }
}]]></example>
    <repair><![CDATA[using System;
using System.IO;
using System.Text;
using System.Security.Cryptography;

public class rfc2898test
{
  public static void Main(string[] passwordargs)
  {
    string pwd = passwordargs[0];
    // Create a random salt
    byte[] salt = new byte[8];

    using (RNGCryptoServiceProvider prng = new RNGCryptoServiceProvider())
    {
      // Fill the array with a random value.
      prng.GetBytes(salt); ' FIXED
    }

    int iterations = 1000;

    try
    {
      Rfc2898DeriveBytes k1 = new Rfc2898DeriveBytes(pwd, salt, iterations);
      // ...
    }
    catch (Exception e)
    {
      // ...
    }
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/760.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:760,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.HttpParameterPollution" message="HttpParameterPollution: HTTP parameter pollution (HPP)" class="com.optimyth.csharp.rules.security.HttpParameterPollution" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.1,CWEScope:Integrity,http-parameter-pollution]]></tags>
    <description><![CDATA[Concatenating untrusted input into path, query string, or parameters for HTTP message (in the URL or in the request body)
may allow an attacker to override/add unexpected request parameters. Attacker may change the intended
HTTP request semantics, and may give him/her access to unauthorized data or bypass web application
firewall validations.

Note: Do not confuse HPP with Server-Side Request Forgery (SSRF), where the attacker has control over the
full request URL, including host and port. For HPP attack, attacker has control over other parts like the query string
part of the URL. Remember the format of an HTTP URL: scheme://user:password@host:port/path?query#fragment
where query is typically param=value&param2=value. HPP is about attackers controlling path, query or fragment,
while SSRF means controlling scheme, user, password, host or port.

Like other injection issues, with HPP attackers play with "&" to inject additional parameter (similar to the quote
in SQL injection), "../" to change the path, ";" (to add matrix parameters to URL at different path segments), or "#"
to remove ending URL characers (like "--" comment delimiter in SQL injection).

Controlling the path typically changes the semantics of the action represented by the HTTP resource.
Some REST services use request parameter like _method for selecting the HTTP method, which may be subverted by an HPP attack
(an HTTP header manipulation flaw could also be leveraged with X-HTTP-Method-Override or similar headers in certain frameworks).

For example, imagine a web application that calls to a remote home-banking REST API. The webapp emits
a (GET) url https://mybank.com/show-balance/account/X/monetaryUnit?date=now to show the balance for the user account X,
where X is taken from a trusted source, but where monetaryUnit is taken from a cookie, and concatenated without
any validation or encoding into the URL. An attacker could pass a Cookie request header set to "../../../transfer/X/to/Y?_method=POST#",
so the vulnerable web application will create https://mybank.com/show-balance/account/X/../../../transfer/X/to/Y?_method=POST#?date=now
which is equivalent to a POST https://mybank.com/transfer/X/to/Y.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unexpected behaviour for HTTP parameter pollution attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Net;
using System.Web.Http;
using System.Collections.Specialized;

public class HttpParameterPollution : ApiController {
  public const string SVC_URL = "http://myorg.com/webapi/search";

  // productId input could be "xyz&action=delete"
  public IHttpActionResult Search(string productId) {
    // Calls a remote REST service
    WebClient client = new WebClient();
    client.BaseAddress = SVC_URL;
    NameValueCollection parameters = new NameValueCollection();
    parameters.Add("product", productId);
    parameters.Add("action", "search");
    client.QueryString = parameters; // VIOLATION, HTTP parameter pollution
    Stream data = client.OpenRead(url);
    string result = processServiceResult(data);
    return Ok(result);
  }
}]]></example>
    <repair><![CDATA[// Validate input (productId in the example), making sure that it matches a productId,
// so no extra HTTP parameters could be injected.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/235.html,RESTing On Your Laurels will Get YOu Pwned - https://www.defcon.org/images/defcon-21/dc-21-presentations/Kang-Cruz/DEFCON-21-Kang-Cruz-RESTing-On-Your-Laurels-Will-Get-You-Pwned-Updated.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:235,OWASP:2021:A4,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.HttpSplittingRule" message="HttpSplittingRule: Improper neutralization of CR/LF Sequences in HTTP headers" class="com.optimyth.csharp.rules.security.HttpSplittingRule" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software places user-controlled input in HTTP headers. An attacker could inject line separators (CR/LF sequences)
that could split the response message generated by the software into two messages. The second response is completely
under the control of the attacker (intermediate web proxies may cache it), with could produce multiple conditions
(web defacement, cache poisoning, cross-site scripting or page hijacking, see CWE-113 for full details).

If software needs to generate HTTP headers depending on user-controlled input, such input should be properly
neutralized (a white-list validation excluding CR/LF is recommended). Please note that cookies are received and
sent in 'Cookie' header in HTTP messages, so if the software generates a Cookie from user input, the input should
be properly validated as well.

NOTE: ASP.NET 2.0 applications on IIS 7.0 always rejects new lines in response headers (even if ASP.NET
enableHeaderChecking is set to false), so if you're using IIS 7.0 you should disable this rule (see
https://docs.microsoft.com/en-us/iis/application-frameworks/building-and-running-aspnet-applications/aspnet-20-breaking-changes-on-iis#changes-in-response-header-processing).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Web;

public class Sample {
  public void HttpSplitting(HttpRequest req, HttpResponse res) {
    String author = req.Form["author"];
    HttpCookie cookie = new HttpCookie("author", author);
    // VIOLATION, cookie written in HTTP response 'Set-Cookie' header
    res.Cookies.Add(cookie);
  }
}]]></example>
    <repair><![CDATA[using System.Web;

public class Sample {
  public void HttpSplitting(HttpRequest req, HttpResponse res) {
    String author = req.Form["author"];
    // white-list validation, or at least remove CR/LF characters from input
    author = neutralize(author);
    HttpCookie cookie = new HttpCookie("author", author);
    res.Cookies.Add(cookie);
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/113.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:113,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:25]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.ImproperAuthentication" message="ImproperAuthentication: Avoid that a user can perform actions to which he does not have access" class="com.optimyth.csharp.rules.security.ImproperAuthentication" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.1,ASVS-v4.0.2:2.3.3,ASVS-v4.0.2:2.7.1,ASVS-v4.0.2:2.7.2,ASVS-v4.0.2:2.7.3,ASVS-v4.0.2:2.8.4,ASVS-v4.0.2:2.8.5,ASVS-v4.0.2:9.2.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Authentication is one of the fundamental pieces of software and is a key point in the safety of it.
Â Â Â Â Â Â Â Â 
If the authentication is done incorrectly a potential attacker could access the system by skipping the validations
of security provided for it.

This rule verifies that the authentication is done indepently of the data entered by the user, either
through forms or cookies or other sources controlled by the user.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Preventing the decision to perform authentication does not depend on the data provided by the user can prevent a malicious attacker from accessing the system without authentication.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Web;
using Microsoft.AspNet.Identity.Owin;

namespace Test {
  
  public class SourceClass {
    public HttpResponseMessage Post([FromBody]JToken jsonbody)
      {
        AccountController accountController = new AccountController();

        dynamic data = JObject.Parse(jsonbody.ToString());
    
        string userId = data.userid;
        string userPassword = data.password;
    
        HttpCookieCollection Cookies = context.Request.Cookies;
        HttpCookie roleCookie = Cookies.Item["ROLE"];
        string role = null;
        
        var result = null;
        if(roleCookie == null){ 
          result = SignInManagerExtensions.PasswordSignIn(userId, userPassword, false, false); //VIOLATION
        }else{
          return new HttpResponseMessage(HttpStatusCode.Accepted);
        }
    
        if (result.Equals(SignInStatus.Success))
        {
          return new HttpResponseMessage(HttpStatusCode.Accepted);
        }
        else
        {
          return new HttpResponseMessage(HttpStatusCode.Forbidden);
        }
    }
  }
}]]></example>
    <repair><![CDATA[using System;
using System.Web;
using Microsoft.AspNet.Identity.Owin;

namespace Test {
  
  public class SourceClass {
    public HttpResponseMessage Post([FromBody]JToken jsonbody)
      {
        AccountController accountController = new AccountController();

        dynamic data = JObject.Parse(jsonbody.ToString());
    
        string userId = data.userid;
        string userPassword = data.password;
    
        var result = SignInManagerExtensions.PasswordSignIn(userId, userPassword, false, false); 
        
        if (result.Equals(SignInStatus.Success))
        {
          return new HttpResponseMessage(HttpStatusCode.Accepted);
        }
        else
        {
          return new HttpResponseMessage(HttpStatusCode.Forbidden);
        }
    }
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/287.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:287,CWETOP25:2021:14]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.InformationExposureThroughDebugLog" message="InformationExposureThroughDebugLog: Avoid exposing sensible information through log" class="com.optimyth.csharp.rules.security.InformationExposureThroughDebugLog" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:7.1.1,ASVS-v4.0.2:7.1.2,ASVS-v4.0.2:8.3.5,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Logs can be very helpful at development stages but they should be used on later stages
because they can show rewarding information.

When a log shows sensible information, it can create a security leak, making useless any other system protection
mechanisms. Also sensible data can have many legal implications due to the established limitations about personal
information storage.

This rule reports violation when the log shows information that could be considered sensible.]]></description>
    <priority>4</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding exposing sensible data improves security because it could provide rewarding information to a malicious attacker.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using Microsoft.Extensions.Logging;

namespace Test {
  
  public class SourceClass {
    private readonly ILogger _logger;
    
    public SourceClass(ILogger<TodoController> logger)
    {
      _logger = logger;
    }
    
    public void process()
    {
      string password = "password";
      _logger.LogInformation(LoggingEvents.GetItem, "Password {password}", password); //VIOLATION
    }
  }
}]]></example>
    <repair><![CDATA[Avoid logging sensible data.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/532.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:532,CWETOP25:2021:39]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.InformationExposureThroughErrorMessage" message="InformationExposureThroughErrorMessage: Avoid sensitive information exposure through error messages" class="com.optimyth.csharp.rules.security.InformationExposureThroughErrorMessage" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.1,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[When an error message is generated, care should be taken to ensure that it does not contain
sensitive information about the environment, users or any other information that may be considered sensitive.

Such information may be valuable itself or may be useful for further attacks with a higher impact.

Also attention should not only be paid to information explicitly included into error messages (for example by using Console.WriteLine),
but also to certain functions that may produce an error that unexpectedly shows sensitive information. In this situations
it is necessary to check that the possible errors are handled somehow.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid sensitive information leakage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;

public class MyClass {
  public static void Main(string[] args) {
		try
		{
		    string cs="database=northwind;server=mySQLServer...";
		    SqlConnection conn=new SqlConnection(cs);
			  Console.WriteLine(cs);
		}
		catch (Exception e)
		{
		    Console.WriteLine(e.ToString());        // VIOLACION
		}
  }
}]]></example>
    <repair><![CDATA[using System;

public class MyClass {
  public static void Main(string[] args) {
		try
		{
		    string cs="database=northwind;server=mySQLServer...";
		    SqlConnection conn=new SqlConnection(cs);
			Console.WriteLine(cs);
		}
		catch (Exception e)
		{
		    Console.WriteLine("Error to execute...");        // VIOLACION
		}
  }
}]]></repair>
    <reference><![CDATA[]]></reference>
    <normatives>
      <security><![CDATA[CWE:209,OWASP:2021:A4,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.InsecureEmailTransport" message="InsecureEmailTransport: Insecure Mail Transport" class="com.optimyth.csharp.rules.security.InsecureEmailTransport" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.1.1,ASVS-v4.0.2:6.1.2,ASVS-v4.0.2:6.1.3,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[When sending e-mail messages (with SMTP, the protocol commonly used), the transport protocol should be encrypted for confidentiality.
Otherwise, emails sent by the application could be eavesdropped by attackers.

This rule detects usages of .Net's SmtpClient class without SSL enabled.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Net.Mail;

public class EmailTransport {
  public void SendEmail(string to, string subject, string body) {
    string to = "destination@acme.com";
    string from = "source@acme.com";
    MailMessage message = new MailMessage(from, to);
    message.Subject = subject;
    message.Body = body;
    SmtpClient client = new SmtpClient("smtp.acme.com");
    client.UseDefaultCredentials = true;
    client.Send(message); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[using System;
using System.Net.Mail;

public class EmailTransport {
  public void SendEmail(string to, string subject, string body) {
    string to = "destination@acme.com";
    string from = "source@acme.com";
    MailMessage message = new MailMessage(from, to);
    message.Subject = subject;
    message.Body = body;
    SmtpClient client = new SmtpClient("smtp.acme.com");
    client.UseDefaultCredentials = true;
    client.EnableSsl = true; // FIXED
    client.Send(message);
  }
}

// Alternatively, you may configure SSL in Web.Config:
<configuration>
  <system.net>
    <mailSettings>
      <smtp deliveryMethod="network" from="user@acme.com">
        <network
          host="smtp.acme.com" port="587" defaultCredentials="true"
          enableSsl="true"
          username="user@acme.com" password="******" />
      </smtp>
    </mailSettings>
  </system.net>
</configuration>]]></repair>
    <reference><![CDATA[https://msdn.microsoft.com/library/system.net.mail.smtpclient.enablessl.aspx]]></reference>
    <normatives>
      <security><![CDATA[CWE:311,OWASP:2021:A4,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.InsecureTransport" message="InsecureTransport: Insecure transport" class="com.optimyth.csharp.rules.security.InsecureTransport" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.1.1,ASVS-v4.0.2:6.1.2,ASVS-v4.0.2:6.1.3,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[An insecure transport is used in a request for a remote resource.

In .Net software, this rule requires that all requests for a remote HTTP resource are performed
on a secure transport (SSL/TLS).

Request content over an insecure transport is cleartext, and any sensitive information it contains may be eavesdropped.

NOTE: Obviously the remote resource must support HTTPS... If that is not the case, and HTTPS in not possible,
mute the reported defect, or deactivate this rule.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improve security at transport layer, avoiding sensible data, like bank details, interception.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Net.Http;

public class Test
{
  public static int Main ()
  {
    HttpClient httpClient = new HttpClient();
    // VIOLATION, unsafe transport
    httpClient.BaseAddress = new Uri("http://foobar.com/");
  }
}]]></example>
    <repair><![CDATA[using System;
using System.Net.Http;

public class Test
{
  public static int Main ()
  {
    HttpClient httpClient = new HttpClient();
    // FIXED
    httpClient.BaseAddress = new Uri("https://foobar.com/");
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/311.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:311,OWASP:2021:A4,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="checkFtpConn" descname="When true then insecure FTP connections are checked too." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.LogForging" message="LogForging: Improper Output Neutralization for Logs" class="com.optimyth.csharp.rules.security.LogForging" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:7.3.1,ASVS-v4.0.2:7.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[When the application writes untrusted input to a log destination,
a "log forging" attack could be launched to inject false log entries, corrupt log entries,
or even exploit a vulnerability in an external "log viewer" application.

Corrupted log entries could hinder detection for malicious activity, or implicate another party
in the commission of a malicious act.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using Microsoft.Extensions.Logging;
using System;
using System.IO;
using System.Web;
 
public class LogForgingHandler : IHttpHandler {
  private ILogger logger;
 
  public void ProcessRequest(HttpContext ctx) {
    String username = ctx.Request.QueryString["username"];
    logger.Warn(username + " log in requested."); //VIOLATION
  }
}]]></example>
    <repair><![CDATA[// Neutralize message with untrusted input, before passing to logging API

using Microsoft.Extensions.Logging;
using System;
using System.IO;
using System.Web;
 
public class LogForgingHandler : IHttpHandler {
  private ILogger logger;
 
  public void ProcessRequest(HttpContext ctx) {
    String username = ctx.Request.QueryString["username"];
    //Remove new-lines to neutralize attack
    logger.Warn(username.Replace(Environment.NewLine, "") + " log in requested");
  }
}]]></repair>
    <reference><![CDATA[https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/117.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:117,OWASP:2021:A9,PCI-DSS:10.5.2,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.MailCommandInjection" message="MailCommandInjection: Mail Command Injection" class="com.optimyth.csharp.rules.security.MailCommandInjection" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Integrity]]></tags>
    <description><![CDATA[Mail command injection vulnerabilities occur when an attacker can influence the commands sent to an SMTP, POP3, or IMAP mail server.
If the library or the developer fails to safely encode the line breaks, an attacker controlling any of the arguments for these commands
will be able to inject line breaks and new commands after them.

As line breaks are the usual mechanism that attackers use to change the expected behaviour, this vulnerability
is considered a special CRLF Injection attack.

What the attacker may launch by exploting a Mail Command Injection vulnerability include:
- Generate spam (SMTP). The application acts as a "mail proxy" that attackers may use to create spam messages.
- Read messages from other users (POP3/IMAP).
- Abusing a trusted server to send HTML emails with malicious contents.
- Change authentication or security options, to skip security controls in mail servers.

See "MX Injection: Capturing and Exploiting Hidden Mail Servers", from Vicente Aguilera, for a full description on
the benefits that an attacker may gain.

The rule checks when vulnerable mail libraries are called with untrusted input, without validation, which might be vulnerable
to Mail Command Injection attacks.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid Mail Command Injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Web;
using System.Net.Mail;

namespace Test {
  
  public class SourceClass {
  
    public void processContext(HttpContext context)
    {
      string to = context.Request.Item["to"];
      string body = context.Request.Item["body"];
      SmtpClient client = new SmtpClient();
      client.Send("from@company.com", to, "subject", body); //VIOLATION
    }
  }
}]]></example>
    <repair><![CDATA[// validate untrusted subject input with a white-list strategy,
// or at least ensure that line breaks (CR/LF) are removed from to.]]></repair>
    <reference><![CDATA[http://projects.webappsec.org/w/page/13246948/Mail%20Command%20Injection,http://www.webappsec.org/projects/articles/121106.pdf,OWASP Testing for IMAP/SMTP injection: https://www.owasp.org/index.php/Testing_for_IMAP/SMTP_Injection_(OTG-INPVAL-011)]]></reference>
    <normatives>
      <security><![CDATA[CWE:93,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:30]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.NoSQLInjection" message="NoSQLInjection: Improper neutralization of special elements in data query logic (NoSQL injection)" class="com.optimyth.csharp.rules.security.NoSQLInjection" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,NoSQL]]></tags>
    <description><![CDATA[The application generates a query intended to access or manipulate data in a data store such as a NoSQL database,
but it does not neutralize or incorrectly neutralizes special elements that can modify the intended logic of the query.

Depending on the capabilities of the query language, an attacker could inject additional login into the query to:
- Modify the intended selection criteria, thus changing which data entities (e.g., records) are returned, modified, or otherwise manipulated.
- Append additional commands to the query.
- Return more or fewer entities than intended.
- Cause entities to be sorted in an unexpected way.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent NoSQL injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Data;
using System.Data.Common;
using MongoDB.Driver;

public class InvoiceProvider {
     private MongoServer server;
     private string database { get; set; }

     public MongoDataService(string connectionString)
     {
        MongoClient client = new MongoClient(connectionString);
        server = client.GetServer();
     }

     public string findOne(string databaseName, string collectionName)
     {
        string query = Request.QueryString["EXPRESSION"];
        var db = server.GetDatabase(databaseName);
        var collection = db.GetCollection(collectionName);
        BsonDocument bsonDoc = MongoDB.Bson.Serialization.BsonSerializer.Deserialize<BsonDocument>(query);

        var result = collection.FindOne(new QueryDocument(bsonDoc));        // VIOLATION
        if (result!=null)
        {
            return result.ToJson();
        } else {
            return "";
        }

     }
}]]></example>
    <repair><![CDATA[using System.Data;
using System.Data.Common;
using MongoDB.Driver;

public class InvoiceProvider {
     private MongoServer server;
     private string database { get; set; }

     public MongoDataService(string connectionString)
     {
        MongoClient client = new MongoClient(connectionString);
        server = client.GetServer();
     }

     public string findOne(string databaseName, string collectionName)
     {
        string query = sanitize (Request.QueryString["EXPRESSION"]);
        var db = server.GetDatabase(databaseName);
        var collection = db.GetCollection(collectionName);
        BsonDocument bsonDoc = MongoDB.Bson.Serialization.BsonSerializer.Deserialize<BsonDocument>(query);

        var result = collection.FindOne(new QueryDocument(bsonDoc));        // OK, query sanitized
        if (result!=null)
        {
            return result.ToJson();
        } else {
            return "";
        }

     }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/943.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:943,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.PlaintextStorageOfPassword" message="PlaintextStorageOfPassword: Plaintext Storage of a Password" class="com.optimyth.csharp.rules.security.PlaintextStorageOfPassword" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.7.5,CWEScope:Access-Control,credentials]]></tags>
    <description><![CDATA[Storing a password in plaintext may result in a system compromise.

Password management issues occur when a password is stored in plaintext in an application's properties or configuration file.
Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Reflection;
using MySql.Data.MySqlClient;
using System.IO;
using System.Linq;
using System.Collections.Generic;

namespace default_namespace{
    class MainClass63650{
        public static void Main(string[] args){
                var data = new Dictionary<string, string>();
                foreach (var row in File.ReadAllLines("./config.properties"))
                    data.Add(row.Split('=')[0], string.Join("=",row.Split('=').Skip(1).ToArray()));

                Console.WriteLine(data["password"]);        // VIOLATION
        }
    }
}]]></example>
    <repair><![CDATA[using System;
using System.Reflection;
using MySql.Data.MySqlClient;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Security.Cryptography;

namespace default_namespace{
    class MainClass63650{
        public static void Main(string[] args){
                var data = new Dictionary<string, string>();
                foreach (var row in File.ReadAllLines("./config.properties"))
                    data.Add(row.Split('=')[0], string.Join("=",row.Split('=').Skip(1).ToArray()));

                var p = RSA.Decrypt(data["password"], RSA.ExportParameters(true), false);
                Console.WriteLine(p);        // Ok
        }

    }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/256.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:522,CWETOP25:2021:21,OWASP:2021:A4,PCI-DSS:6.3.1]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
      <property name="pattern" descname="Regular expression for matching field names containing credentials." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.ProcessControl" message="ProcessControl: Do not load executables or libraries from untrusted sources" class="com.optimyth.csharp.rules.security.ProcessControl" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.14.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,code-injection,scripting]]></tags>
    <description><![CDATA[Loading libraries or executables from an untrusted source or in an untrusted environment can cause an application
to execute malicious code on behalf of an attacker.

Sometimes a developed or third-party library needs to be be run during application execution. For example, System.AppDomain type provides
methods for running libraries or for loading types from a library. If the path to the library depends on external untrusted input,
for example configuration entries, an attacker that could modify the external input could manage to execute uninteded code,
with the privileges of the application.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid code injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Configuration;

public class ProcessControl {
  public void runAssembly() {
    // if an attacker manages to alter configuration, this is catastrophic
    string libpath = ConfigurationManager.AppSettings["MY_LIBRARY"];
    Environment.ExitCode = AppDomain.CurrentDomain.ExecuteAssembly(libpath); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[// Validate the library path, to avoid executing code from an unintended library.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/114.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:114,CWE:494,OWASP:2021:A1,OWASP:2021:A8,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="allowSystemConfiguration" descname="If false, any kind of input is considered untrusted; if true, only user input is considered untrusted" value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.ProperPaddingWithPublicKeyCrypto" message="ProperPaddingWithPublicKeyCrypto: Use of RSA Algorithm without Optimal Asymmetric Encryption Padding (OAEP)" class="com.optimyth.csharp.rules.security.ProperPaddingWithPublicKeyCrypto" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,RSA]]></tags>
    <description><![CDATA[The software uses the RSA algorithm for cryptographic operations (encryption/decryption, digital signature creation/verification),
but does not use a padding considered adequate for the operation.

RSA operations should always use some padding to make it robust againt cryptographic attacks.
Microsoft's cryptography API does not allow RSA operations without padding, which is a good starting point.

PKCS#1 standard defined a padding scheme that was improved against certain weaknesses by the new OAEP (Optimal Asymmetric
Encryption Padding) for encryption/decryption, or the PSS (Probabilistic Signature Scheme) for digital signature.
These are considered the state-of-the-art padding schemes, and are recommended against the older PKCS#1 padding.

With a less robust padding scheme, the cryptographic operation may be vulnerable to certain crypto-analytic attacks.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Security.Cryptography;

public class BadPadding {
  private byte[] encrypt(byte[] msg, string pubkeyXml) {
    using(var provider = new RSACryptoServiceProvider()) {
      provider.FromXmlString(pubkeyXml);
      return provider.Encrypt(msg, false); // VIOLATION, false means PKCS1 padding
    }
  }

  private byte[] decrypt(byte[] msg, string pairXml) {
    using(var provider = new RSACryptoServiceProvider()) {
      provider.FromXmlString(pairXml);
      return provider.Decrypt(msg, false); // VIOLATION, false means PKCS1 padding
    }
  }

  private byte[] encrypt2(byte[] msg, string pubkeyXml) {
    using(var provider = new RSACryptoServiceProvider()) {
      provider.FromXmlString(pubkeyXml);
      return provider.Encrypt(msg, RSAEncryptionPadding.Pkcs1); // VIOLATION
    }
  }

  private byte[] decrypt2(byte[] msg, string pairXml) {
    using(var provider = new RSACryptoServiceProvider()) {
      provider.FromXmlString(pairXml);
      return provider.Decrypt(msg, RSAEncryptionPadding.Pkcs1); // VIOLATION
    }
  }

  private byte[] sign(byte[] dataToSign, RSAParameters key) {
    using(var rsa = new RSACryptoServiceProvider()) {
      rsa.ImportParameters(key);
      return rsa.SignData(dataToSign, HashAlgorithmName.SHA1, RSASignaturePadding.Pkcs1); // VIOLATION
    }
  }

  private bool verify(byte[] dataToVerify, byte[] sig, RSAParameters key) {
    using(var rsa = new RSACryptoServiceProvider()) {
      rsa.ImportParameters(key);
      return rsa.VerifyData(dataToVerify, sig, HashAlgorithmName.SHA1, RSASignaturePadding.Pkcs1); // VIOLATION
    }
  }
}]]></example>
    <repair><![CDATA[using System;
using System.Security.Cryptography;

public class OkPadding {
  private byte[] encrypt(byte[] msg, string pubkeyXml) {
    using(var provider = new RSACryptoServiceProvider()) {
      provider.FromXmlString(pubkeyXml);
      return provider.Encrypt(msg, true); // OK, true means OAEP
    }
  }

  private byte[] decrypt(byte[] msg, string pairXml) {
    using(var provider = new RSACryptoServiceProvider()) {
      provider.FromXmlString(pairXml);
      return provider.Decrypt(msg, true); // OK, true means OAEP
    }
  }

  private byte[] encrypt2(byte[] msg, string pubkeyXml) {
    using(var provider = new RSACryptoServiceProvider()) {
      provider.FromXmlString(pubkeyXml);
      return provider.Encrypt(msg, RSAEncryptionPadding.OaepSHA512); // OK
    }
  }

  private byte[] decrypt2(byte[] msg, string pairXml) {
    using(var provider = new RSACryptoServiceProvider()) {
      provider.FromXmlString(pairXml);
      return provider.Decrypt(msg, RSAEncryptionPadding.OaepSHA512); // OK
    }
  }

  private byte[] sign(byte[] dataToSign, RSAParameters key) {
    using(var rsa = new RSACryptoServiceProvider()) {
      rsa.ImportParameters(key);
      return rsa.SignData(dataToSign, HashAlgorithmName.SHA1, RSASignaturePadding.Pss); // OK
    }
  }

  private bool verify(byte[] dataToVerify, byte[] sig, RSAParameters key) {
    using(var rsa = new RSACryptoServiceProvider()) {
      rsa.ImportParameters(key);
      return rsa.VerifyData(dataToVerify, sig, HashAlgorithmName.SHA1, RSASignaturePadding.Pss); // OK
    }
  }
}]]></repair>
    <reference><![CDATA[https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/,https://cwe.mitre.org/data/definitions/780.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:780,OWASP:2021:A2]]></security>
    </normatives>
    <properties>
      <property name="allowedPaddingForEncryption" descname="Comma-separated list of allowed padding schemes for encryption/decryption." value="OaepSHA1,OaepSHA256,OaepSHA384,OaepSHA512"/>
      <property name="allowedPaddingForSignature" descname="Comma-separated list of allowed padding schemes for digital signatures." value="Pss"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.ResourceInjection" message="ResourceInjection: Improper control of resource identifiers (&quot;Resource Injection&quot;)" class="com.optimyth.csharp.rules.security.ResourceInjection" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software takes from an untrusted source the identifier for a system resource (like a port number),
and allows access to a non-expected resource. Attackers may use the flaw for malicious behaviour,
for example a port scan, change software configuration, transmit sensitive information to a third-party server,
etc.

OWASP project uses the term "Insecure Direct Object Reference" instead of "Resource Injection".

Note: Please note that other rules may check injection flaws for specific resources (like Path Traversal rule for filesytem resources,
or SSRF for network addresses). This rule reports injection flaws on resource identifiers not covered by other rules.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Int32;
using System.Web;
using System.Net;

public class ResourceInjection {
  public Socket connect(string address, HttpRequest req) {
    int rPort = Int32.Parse( req.Item("rPort") );

    IPEndPoint endpoint = new IPEndPoint(address, rPort); // VIOLATION
    socket = new Socket(endpoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
    socket.Connect(endpoint);

    return socket;
  }
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Resource_Injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:99,OWASP:2021:A3,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.ServerInsecureTransport" message="ServerInsecureTransport: Insecure transport in HTTP servers]" class="com.optimyth.csharp.rules.security.ServerInsecureTransport" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.1.1,ASVS-v4.0.2:6.1.2,ASVS-v4.0.2:6.1.3,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[For sensitive applications, a secure transport (like TLS/SSL) provides confidentiality and integrity in communications
with the server.

The rule demands that HTTP servers use SSL/TLS transport, to ensure server-side authentication, confidentiality and
integrity of the communications with clients.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improve security at transport layer, avoiding sensible data, like bank details, interception.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;

public class Test
{
    public void Connect()
    {
        Socket sck;
        NetworkStream peer0 = new NetworkStream(sck);  // VIOLATION
        // ... not covered by SSL/TLS ...
    }
}]]></example>
    <repair><![CDATA[using System;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;

public class Test
{
    public void Connect ()
    {
        Socket sck;
        NetworkStream peer0 = new NetworkStream(sck);
        SSLStream peer = new SSLStream(peer0);     // Ok
    }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/319.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:319,CWETOP25:2021:35,OWASP:2021:A2,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="onlyHttps" descname="If true, any HTTP server put to listen will be reported as violation, even when an HTTPS server is started." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.UnsafeCookieRule" message="UnsafeCookieRule: Generate server-side cookies with adequate security properties" class="com.optimyth.csharp.rules.security.UnsafeCookieRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:3.2.3,ASVS-v4.0.2:3.4.1,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Checks that cookies generated in server side have the following security properties:

* Non persistent - Cookie is not stored persistently by the browser (it is hold in memory)
* HttpOnly - Cookie is not accessible by client-side scripts (not all browsers support this)
* Secure - Cookie is sent in HTTP/SSL communications only (more difficult to capture on the net)
* Path - Path should not match a certain patterns that allow transmission to unintended web applications.
* Domain - Domain should not be too wide so the cookie is sent to unintended servers.

HttpOnly, for example, could mitigate some CSRF (cross-site request forgery) issues as it makes
more difficult for the attacker to capture sensitive cookies from client-side code generated by
exploiting an XSS vulnerability in a web application.

Other rules (like HttpSplittingRule) check other conditions, like HTTP Splitting, that could be
produced when the cookie value depends on user-controlled input non properly neutralized.

NOTE: Not setting domain or path forces browser to send the cookie to the originator's domain and
application path, so this is considered secure.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Web;

class UnsafeCookie
{
  static public void AddCookie(string sessionToken, HttpResponse response) {
    // May report violation when forceHttpOnly or avoidUnsecureCookies are set
    HttpCookie cookie = new HttpCookie("sessionID", sessionToken);
    cookie.Domain = ".com"; // VIOLATION, overly broad domain
    cookie.Path = "/"; // VIOLATION, overly broad path
    cookie.Expires = new DateTime(2100,1,1); // VIOLATION, persistent cookie
    response.Cookies.Add(cookie);
  }
}]]></example>
    <repair><![CDATA[using System;
using System.Web;

class UnsafeCookie
{
  static public void AddCookie(string sessionToken, HttpResponse response) {
    HttpCookie cookie = new HttpCookie("sessionID", sessionToken);
    cookie.Domain = "www.myorg.com"; // FIXED (removal is also ok)
    cookie.Path = "/myApp"; // FIXED (removal is also ok)
    // No Expires means that cookie is non persistent
    response.Cookies.Add(cookie);
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/200.html,http://cwe.mitre.org/data/definitions/539.html,http://cwe.mitre.org/data/definitions/614.html,http://cwe.mitre.org/data/definitions/1004.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:1004,CWE:200,CWE:539,CWE:614,CWETOP25:2021:20,PCI-DSS:6.5.3,WASC:13]]></security>
    </normatives>
    <properties>
      <property name="domainPatternToAvoid" descname="Domain pattern to avoid" value="\.[^\.]+"/>
      <property name="avoidPersistentCookies" descname="Avoid persistent cookies" value="true"/>
      <property name="avoidUnsecureCookies" descname="Avoid unsecure cookies" value="true"/>
      <property name="pathPatternToAvoid" descname="Path pattern to avoid" value="/"/>
      <property name="forceHttpOnly" descname="Set HttpOnly" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.UnsafeReflection" message="UnsafeReflection: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')" class="com.optimyth.csharp.rules.security.UnsafeReflection" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,reflection]]></tags>
    <description><![CDATA[If the application uses untrusted external input to determine which class to instantiate or which method to invoke
using the reflection API, a potential attacker may run unexpected code through the application that were not intended
by the application developers.

This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause
unexpected behaviour in the application.

"Untrusted input" means, in this context, a user-controlled application input, an environment variable or configuration entry,
or data fetched from an external web source.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limit potential unexpected code execution, or uncontrolled access to sensitive information.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Reflection;

public class UnsafeReflection {

  private static object InvokeReflectively(string classname, string method, object[] args) {
    Type type = Type.GetType(classname);
    MethodInfo method = type.GetMethod(method);
    return method.Invoke(null, args); // static
  }

  static int Main(string[] args) {
    string classname = args[0];
    string method = args[1];
    object[] callArgs = new object[args.Length-2];
    Array.Copy(args,0,callArgs,0,callArgs.Length);

    ret = InvokeReflectively(classname, method, callArgs); // VIOLATION
    Console.WriteLine( ret );
  }
}]]></example>
    <repair><![CDATA[// Validate externally-controlled parameters affecting targets of reflexion code]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/470.html,OWASP Unsafe Reflection: https://www.owasp.org/index.php/Unsafe_Reflection]]></reference>
    <normatives>
      <security><![CDATA[CWE:470,OWASP:2021:A3,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.UnvalidatedAspNetModel" message="UnvalidatedAspNetModel: Unvalidated model in MVC controller" class="com.optimyth.csharp.rules.security.UnvalidatedAspNetModel" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.2,ASVS-v4.0.2:13.3.1,ASVS-v4.0.2:5.1.3,ASVS-v4.0.2:5.1.4,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,aspnet,core.mvc,mvc]]></tags>
    <description><![CDATA[ASP.Net provide different web frameworks following the model-view-controller paradigm. ASP.Net MVC, Web API and ASP.Net Core
are the most common instances. Such frameworks use "actions" implemented as methods in the controller class, receiving model data
(bound from the input message), and generating the result by delegating to a view.

These frameworks allow validation controls on model properties, using attributes typically in the System.ComponentModel.DataAnnotations namespace.
When a model type has validated properties, and the type is passed as parameter to an action method, the method should check,
using ModelState.IsValid, that the enforced validations pass, and give an error response without performing any sensitive operation.

When this is not done, validations are ignored and unvalidated inputs may lead to security flaws (SQL and other injection flaws, access control violations, and many more).

To avoid such flaws, the rule checks that action methods using parameters with validated model types are checking the ModelState.IsValid property.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Error handling and fault isolation</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.ComponentModel.DataAnnotations;

namespace MyApi.Models
{
  // Model type that enforce validations
  public class Product
  {
    public int Id { get; set; }
    [Required]
    public string Name { get; set; }
    public decimal Price { get; set; }
    [Range(0, 999)]
    public double Weight { get; set; }
  }
}

using MyApi.Models;
using System.Net;
using System.Net.Http;
using System.Web.Http;

namespace MyApi.Controllers
{
  public class ProductsController : ApiController
  {
    public HttpResponseMessage Post(Product product)
    {
      if (ModelState.IsValid) // OK, model validation performed
      {
        // Do something with the product (not shown).
        return new HttpResponseMessage(HttpStatusCode.OK);
      }
      else
      {
        return Request.CreateErrorResponse(HttpStatusCode.BadRequest, ModelState);
      }
    }

    public HttpResponseMessage Get(int productId) // OK, no model with validation
    {
      // Fetch product with the given ID (not shown)
    }

    public HttpResponseMessage Delete(Product product) // VIOLATION, ModelState.IsValid not called
    {
      // Delete product (not shown)
      return new HttpResponseMessage(HttpStatusCode.OK);
    }
  }
}]]></example>
    <repair><![CDATA[    // Fix reported method with check on the validity of the model
    public HttpResponseMessage Delete(Product product)
    {
      if(ModelState.IsValid)
      {
        // Delete product (not shown)
        return new HttpResponseMessage(HttpStatusCode.OK);
      }
      else
      {
        return Request.CreateErrorResponse(HttpStatusCode.BadRequest, ModelState);
      }
    }
    
    // Since ASP.NET Core MVC 2.1, use Microsoft.AspNetCore.Mvc.ApiControllerAttribute to annotate the class
    
using MyApi.Models;
using System.Net;
using System.Net.Http;
using System.Web.Http;
using System.Web.Mvc;
using Microsoft.AspNetCore.Mvc;

namespace MyApi.Controllers
{
  [ApiController]                                     // OK (automatic validation of model state)
  public class ProductsController : Controller
  {
    public HttpResponseMessage Post(Product product)
    {
        // Do something with the product (not shown).
        return new HttpResponseMessage(HttpStatusCode.OK);
    }

    public HttpResponseMessage Get(int productId)
    {
      // Fetch product with the given ID (not shown)
    }

    public HttpResponseMessage Delete(Product product) 
    {
      // Delete product (not shown)
      return new HttpResponseMessage(HttpStatusCode.OK);
    }
  }
}]]></repair>
    <reference><![CDATA[https://www.asp.net/web-api/overview/formats-and-model-binding/model-validation-in-aspnet-web-api,https://www.strathweb.com/2018/02/exploring-the-apicontrollerattribute-and-its-features-for-asp-net-core-mvc-2-1/,https://cwe.mitre.org/data/definitions/20.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:20,CWETOP25:2021:4,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SEC.XMLEntityInjection" message="XMLEntityInjection: XML entity injection" class="com.optimyth.csharp.rules.security.XMLEntityInjection" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.5.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[In XML parsers, when XML document to parse could be altered by untrusted input, and the
untrusted input may alter the Document Type Definition (DTD, embedded or external), the parser should be configured to
avoid two kinds of potential attacks:

* XML entity expansion DoS (XML bomb or "billion laughs attack"), CWE-776, where well-formed DTD with
  internal entities are expanded exponentially until they exhaust memory.

* XML external entity injection (XXE), CWE-611, where an external entity controlled by the attacker refers to the URL
  of a resource that gives unauthorized access to sensitive files on the server machine, or to a resource
  like /dev/random in Unix systems that, when entity is expanded, leads to a denial-of-service condition.
  A variant of this attack is the server-side request forgery (SSRF), where the URL for external DTD or XML-Schema
  is processed by the URL handler used by the XML parser, allowing the attacker access to an unexpected
  network resource (for cross-site request forgery attacks or port-scanning enumeration).

Please note that most .Net parsers are not vulnerable by default to XML entity injection attacks because their
default settings have both entity expansion and external entity resolution disabled.

XML parsing could be hidden in other frameworks and libraries. For example, with REST, when a resource has an XML
representation, the REST framework typically use an underlying XML parser for processing the request message, which
obviously is fully under control of a potential attacker.

To be safe during XML processing coming from untrusted sources, a number of XML features should be not enabled
when configuring the parser.

The rule checks that there is a path between an untrusted input and the XML document to parse,
then verifies that the XML parser is configured to avoid both external entity and entity expansion attacks.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XML entity attacks that could cause denial-of-service and information leakage.]]></benefits>
    <inconvenients><![CDATA[Dependencies on certain features related to DTD or entity expansion may render runtime errors.]]></inconvenients>
    <example><![CDATA[using System;
using System.Reflection;
using System.Xml;
using System.Xml.Serialization;

public class Test
{
    public T parseXML()
    {
        // source
        string xml = Request.QueryString["EXPRESSION"];
        MemoryStream stream = new MemoryStream(Encoding.Default.GetBytes(xml));

        XmlSerializer serializer = new XmlSerializer(typeof(T), Namespace);

        XmlReaderSettings settings = new XmlReaderSettings();
        settings.DtdProcessing = DtdProcessing.Parse;
        settings.XmlResolver = new XmlSecureResolver(new XmlUrlResolver(), "http://serverName/data/");;

        // VIOLATION, XmlReader settings vulnerable to XML Entity Injection
        using (XmlReader reader = XmlReader.Create(stream, settings))
        {
          return (T)serializer.Deserialize(reader);
        }
    }
}]]></example>
    <repair><![CDATA[using System;
using System.Reflection;
using System.Xml;
using System.Xml.Serialization;

public class Test
{
    public T parseXML()
    {
        // source
        string xml = Request.QueryString["EXPRESSION"];
        MemoryStream stream = new MemoryStream(Encoding.Default.GetBytes(xml));

        XmlSerializer serializer = new XmlSerializer(typeof(T), Namespace);

        // FIXED: safe configuration:
        // DTD ignored, external entities disabled, and limit entities expansion
        XmlReaderSettings settings = new XmlReaderSettings();
        settings.DtdProcessing = DtdProcessing.Ignore;
        settings.MaxCharactersFromEntities = 1024;
        settings.XmlResolver = null;

        using (XmlReader reader = XmlReader.Create(stream, settings))
        {
          return (T)serializer.Deserialize(reader);
        }
    }
}]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#XmlDocument,https://cwe.mitre.org/data/definitions/776.html,https://cwe.mitre.org/data/definitions/611.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:611,CWE:776,CWETOP25:2021:23,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:43,WASC:44]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.ServerSideRequestForgery" message="ServerSideRequestForgery: Server-Side Request Forgery (SSRF)" class="com.optimyth.csharp.rules.security.ServerSideRequestForgery" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.6.1,ASVS-v4.0.2:5.2.6,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[A server side request forgery vulnerability appears when an attacker can send requests from a vulnerable server to remote services.

SSRF attacks allow accessing, through vulnerable server, internal systems located behind a firewall that normally would not be accessible.

There are two kinds of SSRF attacks:

- Trusted SSRF: we just can send requests to a list of predefined remote services.
- Remote SSRF: we can send requests to any remote IP and port.

SSRF attacks are commonly used  for port scanning and attacking systems from the internal network.

This rule checks if there are connections established using untrusted input data.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent SSRF attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    public async Task<JsonObject> GetAsync(string port)
    {
        string ip = Request.QueryString["HOST"];
        HttpClient httpClient = new HttpClient();
        var response = await httpClient.GetAsync("http://" + ip + ":" + port);   // VIOLATION

        response.EnsureSuccessStatusCode();

        string content = await response.Content.ReadAsStringAsync();
        return await Task.Run(() => JsonObject.Parse(content));
    }]]></example>
    <repair><![CDATA[    public async Task<JsonObject> GetAsync(string port)
    {
        string ip = validateIp(Request.QueryString["HOST"]);   // validate input
        HttpClient httpClient = new HttpClient();
        var response = await httpClient.GetAsync("http://" + ip + ":" + port);   // OK

        response.EnsureSuccessStatusCode();

        string content = await response.Content.ReadAsStringAsync();
        return await Task.Run(() => JsonObject.Parse(content));
    }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/918.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:918,CWETOP25:2021:24,OWASP:2021:A10,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SqlInjection" message="SqlInjection: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" class="com.optimyth.csharp.rules.security.SqlInjectionRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The software constructs all or part of an SQL command using externally-controlled input, but it does not neutralize properly
that input that could modify the intended SQL command when it is sent to a database interaction method.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent SQL injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  public void deleteOldData()
  {
    string user = Request.Form["OLD_USER"];
    string query = "DELETE FROM MYTABLE WHERE USER ='" + user + "'";
    using(SqlConnection conn = new SqlConnection(connString))
    {
      SqlCommand cmd = new SqlCommand(query, conn); // VIOLATION
      cmd.Connection.Open();
      cmd.ExecuteNonQuery();
    }
  }

  public void select()
  {
    string filter = Request.Form["FILTER"];
    string query = "SELECT F1, F2 FROM MYTABLE";
    if( !String.IsNullOrEmpty(filter) ) query += " WHERE F3 = '" + filter + "'";

    using(SqlConnection conn = new SqlConnection(connString))
    {
      SqlCommand cmd = new SqlCommand(query, conn); // VIOLATION
      cmd.Connection.Open();
      var reader = cmd.ExecuteReader();
      // ...
    }
  }]]></example>
    <repair><![CDATA[  public void deleteOldData()
  {
    string user = Request.Form["OLD_USER"];
    string query = "DELETE FROM MYTABLE WHERE USER = @user";
    using(SqlConnection conn = new SqlConnection(connString))
    {
      SqlCommand cmd = new SqlCommand(query, conn);
      cmd.Parameters.AddWithValue("@user", user); // OK
      cmd.Connection.Open();
      cmd.ExecuteNonQuery();
    }
  }

  public void select()
  {
    string filter = Request.Form["FILTER"];
    string query = "SELECT F1, F2 FROM MYTABLE";
    if( !String.IsNullOrEmpty(filter) ) query += " WHERE F3 = @filter";

    using(SqlConnection conn = new SqlConnection(connString))
    {
      SqlCommand cmd = new SqlCommand(query, conn);
      if( !String.IsNullOrEmpty(filter) ) cmd.Parameters.AddWithValue("@filter", filter); // OK
      cmd.Connection.Open();
      var reader = cmd.ExecuteReader();
      // ...
    }
  }]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet,http://stackoverflow.com/questions/35163361/how-can-i-add-user-supplied-input-to-an-sql-statement,https://msdn.microsoft.com/library/ff648339.aspx]]></reference>
    <normatives>
      <security><![CDATA[CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
      <property name="parametersAsSources" descname="If true, method parameters are considered untrusted inputs." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.StoredCrossSiteScripting" message="StoredCrossSiteScripting: Web content generation from improper sanitized database data and escaped output (Stored Cross-site Scripting, XSS)" class="com.optimyth.csharp.rules.security.CrossSiteScriptingRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software places input taken from database in page content. An attacker could inject browser script code that is executed in the client browser.
The end-user is the attacked subject, and the software is the vehicle for the attack. This attack is known as Cross-Site Scripting (XSS).

There are three kinds of XSS:
* Reflected XSS: Attacker causes victim to supply malicious content to a vulnerable web application, which renders HTML content
  embedding a malicious script executed in victim's browser.
  A variation of this is named DOM-based XSS, where the vulnerable software does not generate content depending on user input
  but include script code that use user-controlled input.

* Persistent XSS: Attacker provides malicious content to the vulnerable application, which is stored somewhere.
  When stored data is fetched and rendered,

This rule analyzes only the "Persistent XSS" case.

When other user access to vulnerable pages that embed without proper neutralization the attacker content,
script code is executed in the victim's browser. For this, you should add other input kinds (e.g. file_input and/or database_input)
to the 'inputs' rule property.

The script executed in the victim's browser could perform malicious activities, like stealing active authentication tokens
(sometimes in the form of cookies) and performing operations on a insecure webapp (on behalf of the victim) that trusts
too much identity artifacts in browser and do not request additional authorization for operations ('Cross-Site Request Forgery attack', CSRF).

Many browsers could limit the damage via security restrictions (e.g. 'same origin policy'), but user browsers generally allow scripting languages
(e.g. JavaScript) in their browsers (disabling JavaScript severely limits a web application).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XSS vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[In this example, we assume that ValidateRequest is disabled.

StoredXSS.aspx:

<%@ Page Language="C#" AutoEventWireup="true" CodeBehind="StoredXSS.aspx.cs" Inherits="Test.StoredXSS"  ValidateRequest="false" %>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
    <title></title>
</head>
<body>
    <form id="form1" runat="server">
    <div>
      <asp:Label ID="lblName" runat="server" />
    </div>
    </form>
</body>
</html>

StoredXSS.aspx.cs:

using System;
using System.Data;
using System.Data.SqlClient;

namespace Test
{
    public partial class StoredXSS : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            using(SqlConnection conn = getSqlConnection())
            {
              SqlCommand cmd = new SqlCommand("SELECT * FROM Customers", conn);
              conn.Open();
              SqlDataReader reader = cmd.ExecuteReader(CommandBehaviour.CloseConnection);
              while(reader.Read()) {
                lblName.Text += reader[0]; // VIOLATION
              }
            }
        }

        protected SqlConnection getSqlConnection() {
          // ...
        }
    }
}

An attacker may insert a malicious payload like "<script>...</script>" in first column of the Customers table
(probably, in another available point allowing insertions in that table), causing the execution of unexpected
JavaScript code in the victim's browser.]]></example>
    <repair><![CDATA[Activating validation request at .aspx page, the issue is fixed.

Other choice using Microsoft Anti-XSS library might be:

namespace Test
{
    public partial class StoredXSS : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            using(SqlConnection conn = getSqlConnection())
            {
              SqlCommand cmd = new SqlCommand("SELECT * FROM Customers", conn);
              conn.Open();
              SqlDataReader reader = cmd.ExecuteReader(CommandBehaviour.CloseConnection);
              while(reader.Read()) {
                lblName.Text += AntiXssEncoder.HtmlEncode(reader[0], false); // FIXED
              }
            }
        }

        protected SqlConnection getSqlConnection() {
          // ...
        }
    }
}]]></repair>
    <reference><![CDATA[https://msdn.microsoft.com/en-us/library/ff649310.aspx,http://cwe.mitre.org/data/definitions/79.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:24]]></security>
    </normatives>
    <properties>
      <property name="inputs" value="database_input,network_input"/>
      <property name="storedXss" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.SystemInformationLeak" message="SystemInformationLeak: Exposure of System Data to an Unauthorized Control Sphere" class="com.optimyth.csharp.rules.security.SystemInformationLeakRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.2,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[The fact that data from the system or debugging information can cause an attacker to gain information on how act for an attack on the system.
This fact occurs when system data or debugging information are exposed to third parties through a sequence of output or a log function.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Error handling and fault isolation</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class MyClass {
  public static void Main(string[] args) {
		try
		{
		  string cs="database=northwind;server=mySQLServer...";
			SqlConnection conn=new SqlConnection(cs);
			Console.WriteLine(cs); //VIOLACION
		}
		catch (Exception e)
		{
		  Response.Write(e.ToString());
		}
  }
}]]></example>
    <repair><![CDATA[public class MyClass {
  public static void Main(string[] args) {
		try
		{
		  string cs="database=northwind;server=mySQLServer...";
			SqlConnection conn=new SqlConnection(cs);
		}
		catch (Exception e)
		{
		  Response.Write("Error to execute...");
		}
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/497.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:497,OWASP:2021:A1,PCI-DSS:6.5.5]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="system_information"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.TooMuchOriginsAllowed" message="TooMuchOriginsAllowed: CORS policy (Cross-origin resource sharing) too broad" class="com.optimyth.csharp.rules.security.TooMuchOriginsAllowed" technology="CSHARP" active="true">
    <tags><![CDATA[CORS,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Too much allowed origins in HTML5 Access-Control-Allow-Origin header.
        
Traditionally, web browsers enforced the Same Origin Policy (SOP) to avoid cross-domain JavaScript to access
certain contents in web page. This policy prevents a malicious script on one page from obtaining
access to sensitive data on another web page ("victim") with a different origin. A strict separation between content
from unrelated sites must be maintained on the browser to prevent loss of data confidentiality or integrity.

Cross-Origin Resource Sharing (CORS) relaxes the SOP. To do this, essentially two HTTP headers (Origin, emitted by client,
and Access-Control-Allow-Origin, emitted by server). This allows, for example, to Ajax requests (XMLHttpRequest) for
accessing content from different origin that should be forbidden by the SOP.

With Access-Control-Allow-Origin header, server defines which other domains are allowed to access content in its domain
using cross-origin requests. A too much permissive value (like '*') will allow a malicious application to communicate
with the vulnerable application in unexpected ways, leading to different security problems.

NOTE: CORS is intended to avoid data read from pages coming from other origins, and it is enforced by modern browsers.
Remember that an attacker has full control over an HTTP request message, so do not rely on CORS Origin header for
validating the source of a request, or for CSRF protection.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limits read application data from content coming from hostile origins.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Net.Http;
using System.Web.Http;
using System.Web.Http.Cors;
using System.Web.Mvc;

// WebAPI2 controller with too-broad CORS policy
[EnableCors(origins: "*", headers: "*", methods: "*")] // VIOLATION
public class TestController : ApiController
{
    // Controller methods not shown...
}

// Another example: A custom attribute for reflecting Origin in CORS header,
// without whitelisting: a too-broad CORS policy

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public class MyEnableCorsAttribute : FilterAttribute, IActionFilter {
       private const string IncomingOriginHeader = "Origin";
       private const string OutgoingOriginHeader = "Access-Control-Allow-Origin";
       private const string OutgoingMethodsHeader = "Access-Control-Allow-Methods";
       private const string OutgoingAgeHeader = "Access-Control-Max-Age";

       public void OnActionExecuted(ActionExecutedContext filterContext) {
           // Do nothing
       }

       public void OnActionExecuting(ActionExecutingContext filterContext)
       {
           var originHeader = filterContext.HttpContext.Request.Headers.Get(IncomingOriginHeader);
           var response = filterContext.HttpContext.Response;

           if (!String.IsNullOrWhiteSpace(originHeader)) {
               response.AddHeader(OutgoingOriginHeader, originHeader); // VIOLATION
               response.AddHeader(OutgoingMethodsHeader, "GET,POST,OPTIONS");
               response.AddHeader(OutgoingAgeHeader, "3600");
           }
       }
}]]></example>
    <repair><![CDATA[using System.Net.Http;
using System.Web.Http;
using System.Web.Http.Cors;
using System.Web.Mvc;

[EnableCors(origins: "https://myorg.com, https://api.myorg.com", headers: "*", methods: "*")] // FIXED
public class TestController : ApiController
{
    // Controller methods not shown...
}

// Now the Origin is white-listed before reflecting it in the CORS header

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public class MyEnableCorsAttribute : FilterAttribute, IActionFilter {
       private const string IncomingOriginHeader = "Origin";
       private const string OutgoingOriginHeader = "Access-Control-Allow-Origin";
       private const string OutgoingMethodsHeader = "Access-Control-Allow-Methods";
       private const string OutgoingAgeHeader = "Access-Control-Max-Age";

       public void OnActionExecuted(ActionExecutedContext filterContext) {
           // Do nothing
       }

       public void OnActionExecuting(ActionExecutingContext filterContext)
       {
           var isLocal = filterContext.HttpContext.Request.IsLocal;
           var originHeader = filterContext.HttpContext.Request.Headers.Get(IncomingOriginHeader);
           var response = filterContext.HttpContext.Response;

           // FIXED - the origin is now white-listed
           if (!String.IsNullOrWhiteSpace(originHeader) &&
               (isLocal || IsAllowedOrigin(originHeader))) {
               response.AddHeader(OutgoingOriginHeader, originHeader);
               response.AddHeader(OutgoingMethodsHeader, "GET,POST,OPTIONS");
               response.AddHeader(OutgoingAgeHeader, "3600");
           }
       }

       protected bool IsAllowedOrigin(string origin) {
           // Replace with your own logic to check the origin header.
           // hardcoded allowed origins here for simplicity
           string[] allowed = {
             "https://api.myorg.com",
             "https://www.myorg.com",
             "https://api.affiliate.com"
             };
           return allowed.Contains(origin);
       }
}]]></repair>
    <reference><![CDATA[https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties,http://enable-cors.org/server_aspnet.html,https://docs.microsoft.com/aspnet/web-api/overview/security/enabling-cross-origin-requests-in-web-api,http://cwe.mitre.org/data/definitions/942.html,https://w3c.github.io/webappsec-cors-for-developers]]></reference>
    <normatives>
      <security><![CDATA[CWE:942,OWASP:2021:A5,PCI-DSS:6.5.10,WASC:15]]></security>
    </normatives>
    <properties>
      <property name="disallowedOriginPattern" descname="Regular expression for CORS origins do not considered valid" value="\*|null"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.WeakCryptographicHash" message="WeakCryptographicHash: Weak cryptographic hash" class="com.optimyth.csharp.rules.security.WeakCryptographicHash" technology="CSHARP" active="true">
    <tags><![CDATA[CAS350,CAS351,CWEScope:Accountability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,crypto,hash]]></tags>
    <description><![CDATA[MD5, SHA-1 and RIPEMD160 are popular cryptographic hash functions often used to verify the integrity of messages, and for other usages.
Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5, SHA-1 or RIPEMD160
should no longer be relied upon in security-critical contexts.

Techniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be relied upon for security.
In the case of SHA-1 or RIPEMD160, current techniques still require a significant amount of computational power and are more difficult to implement.
However, attackers have found the Achilles heal for the algorithm, and techniques for breaking it will likely lead to the discovery
of even faster attacks. In particular, Google has reported recently an example of colliding SHA-1 hashes.

RIPEMD-160 may be used (for some time in the future) in legacy applications.

The rule checks also for HMAC (message authentication codes based on hash functions) implementations for the forbidden hash algorithms.
HMACSHA384 is considered safe; MACTripleDES should be used only in legacy applications; HMACMD5 or HMACSHA1 should not be used
in new applications, even when the security of such HMAC schemes is not as much compromised as with their hash function counterparts.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Security.Cryptography;
...
var hashAlg = MD5.Create(); // VIOLATION]]></example>
    <repair><![CDATA[using System.Security.Cryptography;
...
var hashAlg = SHA256.Create(); // FIXED]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/328.html,https://msdn.microsoft.com/en-us/library/mt612873.aspx,https://en.wikipedia.org/wiki/Hash_function_security_summary,https://msdn.microsoft.com/en-us/library/mt612872.aspx]]></reference>
    <normatives>
      <security><![CDATA[CWE:328,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:50]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Comma-separated list of allowed hash functions." value="RIPEMD160, HMACRIPEMD160, MACTripleDES, SHA256, SHA384, SHA512, HMACSHA256, HMACSHA384, HMACSHA512"/>
      <property name="forbiddenAlgorithms" descname="List of weak hash algorithms" value="MD5, SHA1, HMACMD5, HMACSHA1"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.WeakEncryption" message="WeakEncryption: Insufficient RSA key length" class="com.optimyth.csharp.rules.security.WeakEncryption" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.8.3,ASVS-v4.0.2:6.2.3,ASVS-v4.0.2:6.2.4,ASVS-v4.0.2:6.2.5,ASVS-v4.0.2:6.2.6,ASVS-v4.0.2:6.2.7,ASVS-v4.0.2:9.1.2,ASVS-v4.0.2:9.1.3,CWEScope:Access-Control,CWEScope:Confidentiality,cipher,crypto]]></tags>
    <description><![CDATA[An otherwise strong RSA public-key algorithm is vulnerable to brute force attack when a small key size is used.

Current cryptography guidelines suggest that key lengths of at least 1024 bits should be used with the RSA algorithm.
However, increased computing power and advances in factoring techniques are challenging the security of RSA encryption,
for key lengths lower than 1024 bits.

Note: Rule WeakKeySize generalizes this rule for key lengths under different ciphers and digital signature primitives.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); // VIOLATION
...
RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(512); // VIOLATION]]></example>
    <repair><![CDATA[RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(1024); // OK]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/325.html,http://projects.webappsec.org/w/page/13246936/Information%20Leakage]]></reference>
    <normatives>
      <security><![CDATA[CWE:326,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="minKeySize" descname="Minimun key size" value="1024"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.WeakKeySize" message="WeakKeySize: Weak cryptography, insufficient key length" class="com.optimyth.csharp.rules.security.WeakKeySize" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.6.1,ASVS-v4.0.2:1.6.2,ASVS-v4.0.2:1.6.3,ASVS-v4.0.2:1.6.4,ASVS-v4.0.2:2.6.3,ASVS-v4.0.2:2.7.6,ASVS-v4.0.2:2.8.2,ASVS-v4.0.2:2.8.3,ASVS-v4.0.2:2.9.1,ASVS-v4.0.2:6.2.1,ASVS-v4.0.2:6.2.3,ASVS-v4.0.2:6.2.4,ASVS-v4.0.2:6.2.5,ASVS-v4.0.2:6.2.6,ASVS-v4.0.2:6.2.7,ASVS-v4.0.2:6.4.2,ASVS-v4.0.2:9.1.2,ASVS-v4.0.2:9.1.3,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[A robust cryptographic algorithm (like RSA or AES) with a small key length could be vulnerable to brute-force type attacks.

For symmetric ciphers, AES-CBC (FIPS 197) is the most often recommended algorithm nowadays, with a block size of at least
64 bits (128 bits for the better). Recommended minimum key length for AES is 128 bits for most usages, but for long-range
security, 192 bits or even 256 bits are often recommended.

DES and DESede (or "triple-DES") are, nowadays, not robust enough for most applications. Many algorithms used in the past,
like Blowfish or RC2, are now deemed insecure.

For asymetric cryptography ("public key"), the algorithm most often used is RSA. Most experts consider 2048 as the
most adequate key length for common needs, as its usage in digital signature and other applications demand cryptographic
robustness for a long period of time. Experts now consider 1024 bits for RSA keys (modulus) not enough secure.

Algoritms based on elliptic curves cryptography (like EC-DSA) typically require smaller key sizes, around 200 bits.

See http://www.keylength.com for an interactive site showing current recommendations in cryptographic algorithms,
key length and other issues to take into account.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Security.Cryptography;
// ... rest of code not shown
using (RSA rsa = new RSACryptoServiceProvider(1024, cspParams)) // VIOLATION
{
  // ...
}]]></example>
    <repair><![CDATA[using System.Security.Cryptography;
// ... rest of code not shown
using (RSA rsa = new RSACryptoServiceProvider(2048, cspParams)) // OK
{
  // ...
}]]></repair>
    <reference><![CDATA[http://www.keylength.com/,http://cwe.mitre.org/data/definitions/326.html,http://cwe.mitre.org/data/definitions/310.html,http://cwe.mitre.org/data/definitions/320.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:310,CWE:320,CWE:326,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="minKeySize" descname="Comma-separated list of minimum key size per algorithm." value="AES/128, TripleDES/192, RC2/128, RSA/2048, DSA/2048, ECDsa/256, ECDiffieHellman/256"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.WeakSymmetricEncryptionAlgorithm" message="WeakSymmetricEncryptionAlgorithm: Weak symmetric encryption algorithm" class="com.optimyth.csharp.rules.security.WeakSymmetricEncryptionAlgorithm" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.9.3,ASVS-v4.0.2:6.2.2,ASVS-v4.0.2:8.3.7,CAS350,CAS351,CWEScope:Accountability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,crypto]]></tags>
    <description><![CDATA[Encryption algorithms like DES, Triple-DES and RC2 are nowadays too weak for cryptographic usage,
in particular for ensuring information confidentiality.

DES is currently broken, as an small key size renders it unsafe against brute-force attacks.

RC2 is currently broken, as a related-key attack, where an attacker finds mathematical relationships
between key values, renders it unsafe as well.

Triple-DES (or 3DES) is weak, and should be migrated to a more robust standard cipher.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System.Security.Cryptography;
...
var hashAlg = DES.Create(); // VIOLATION]]></example>
    <repair><![CDATA[using System.Security.Cryptography;
...
var hashAlg = Aes.Create(); // FIXED]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/327.html,https://msdn.microsoft.com/en-us/library/mt612873.aspx,https://msdn.microsoft.com/en-us/library/mt612872.aspx]]></reference>
    <normatives>
      <security><![CDATA[CWE:327,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="List of allowed cipher algorithms" value="AES,RIJNDAEL"/>
      <property name="forbiddenAlgorithms" descname="List of weak cipher algorithms" value="DES,RC2,TripleDES"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.WeakSymmetricEncryptionModeOfOperation" message="WeakSymmetricEncryptionModeOfOperation: Do not use weak modes of operation with symmetric encryption" class="com.optimyth.csharp.rules.security.WeakSymmetricEncryptionModeOfOperation" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.9.3,ASVS-v4.0.2:6.2.2,ASVS-v4.0.2:8.3.7,CWEScope:Accountability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,crypto]]></tags>
    <description><![CDATA[For block ciphers, like AES, Triple-DES or RC5, mode of operation is the way the plaintext/ciphertext blocks are combined during
encryption/decyption of the message.

Many modes of operation (like CTR, OFB or CFB) transforms a block cipher into a stream cipher. Other modes (named Authenticated Encryption modes)
were designed to combine secrecy and authentication in a single cryptographic primitive (like OCB, CCM or GCM modes).

This rule detects modes that are considered too weak for general usage. For example, ECB mode (the simplest mode, with no feedback)
is typically a too-weak mode because encrypting the same block always produce the same cipher block. This allows the attacker
to (1) detect whether two ECB-encrypted messages are identical, (2) detect whether two EBC-encrypted messages share a common prefix
or other common substrings aligned at block boundaries, or (3) detect whether (and where) a single ECB-encrypted message contains
repetitive data (zeros, spaces or null bytes), repeated header fields, or repeated phrases in text, and (4) without additional message
authentication, an attacker can insert previously ciphertext blocks anywhere ("too-much malleable").

A real case that lead to a massive real-world data compromise was the 2013 Adobe password database leak.

Please note that most modes (except EBC) require a unique binary sequence, called initialization vector (IV) for each encryption operation,
that should not be reused (and typically should be random for most modes). Besides choosing a proper mode of operation,
a proper IV generation and last-block padding should be also taken into account.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[using System;
using System.Security.Cryptography;

public class Encryption {
  public void encrypt(byte[] cipherKey) {
    var cipher = new TripleDESCryptoServiceProvider();
    cipher.Mode = CipherMode.ECB; // VIOLATION
    cipher.Padding = PaddingMode.PKCS7;
    cipher.Key = cipherKey;
    // ...
  }
}]]></example>
    <repair><![CDATA[using System;
using System.Security.Cryptography;

public class Encryption {
  public void encrypt(byte[] cipherKey) {
    var cipher = new TripleDESCryptoServiceProvider();
    cipher.Mode = CipherMode.CBC; // FIXED
    // ... CBC mode needs an initial vector.
    // Use a different cryptographic random number for each message
    cipher.IV = GenerateInitialVector();
    cipher.Padding = PaddingMode.PKCS7;
    cipher.Key = cipherKey;
    // pass the IV with the encrypted bytes for decryption
  }
}]]></repair>
    <reference><![CDATA[http://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption,http://cwe.mitre.org/data/definitions/327.html,https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation]]></reference>
    <normatives>
      <security><![CDATA[CWE:327,OWASP:2021:A2,PCI-DSS:6.5.8,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="forbiddenModes" descname="List of weak modes of operation for block ciphers." value="ECB"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.XMLInjection" message="XMLInjection: XML Injection (aka Blind XPath Injection)" class="com.optimyth.csharp.rules.security.XMLInjection" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The extensible markup language (XML) is used in a wide range of applications, from remote procedure calls to storage, exchange and retrieval of data.

By injecting XML content or structures into an XML document, an attacker can alter the logic of the application or insert malicious content.

Input data must be validated before writing into an XML document.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent XML injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      public void saveData()
      {
          string element = Request.QueryString["ELEMENT"];
          string value = Request.QueryString["VALUE"];
          using (XmlWriter writer = XmlWriter.Create("foo.xml"))
          {
            writer.WriteStartElement ("product");
            writer.WriteElementString (element, value);  // VIOLATION
            writer.WriteEndElement();
          }
      }]]></example>
    <repair><![CDATA[      public void saveData()
      {
          string element = Request.QueryString["ELEMENT"];
          string value = Request.QueryString["VALUE"];
          using (XmlWriter writer = XmlWriter.Create("foo.xml"))
          {
            writer.WriteStartElement ("product");
            writer.WriteElementString (System.SecurityElement.Escape(element), System.SecurityElement.Escape(value));  // OK
            writer.WriteEndElement();
          }
      }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/91.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:91,OWASP:2021:A3,WASC:23]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.XPathInjection" message="XPathInjection: Improper Neutralization of Data within XPath Expressions ('XPath Injection')" class="com.optimyth.csharp.rules.security.XpathInjectionRule" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.10,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[.NET framework offers an API to execute a XPath search on a XML DOM tree. If the location path depends on non-neutralized user-input, a potential XPath Injection vulnerability could be present, enabling user control on the nodes returned by the XPath search functions.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[It improves the safety.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      public void FindUser()
      {
        string query = "/users/user[userID='" + Request.Item["USER_ID"] + "']";
        XPathDocument docNav = new XPathDocument(myXml);
        XPathNavigator nav = docNav.CreateNavigator();
        nav.Evaluate(query);  // VIOLATION
      }]]></example>
    <repair><![CDATA[      public void FindUser()
      {
          string userToFind = validate(Request.Item["USER_ID"]);
          string query = "/users/user[userID='" + userToFind + "']";
          XPathDocument docNav = new XPathDocument(myXml);
          XPathNavigator nav = docNav.CreateNavigator();
          nav.Evaluate(query);  // OK
      }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/643.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:643,OWASP:2021:A3,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
      <property name="parametersAsSources" descname="If true, method parameters are considered untrusted inputs." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.XQueryInjection" message="XQueryInjection: Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')" class="com.optimyth.csharp.rules.security.XQueryInjection" technology="CSHARP" active="true">
    <tags><![CDATA[CWEScope:Confidentiality]]></tags>
    <description><![CDATA[XQuery is primarily a query language for data stored in XML form, although it is also used for manipulating XML documents, competing with XSLT, or generating HTML documents.

When an XQuery Expression is constructed using untrusted input, an attacker can take control over the information selected, or can take control over the content of an XML document or an HTML document if you are using XQuery expressions for that kind of manipulations.

Input data must be validated before using it in an XQuery expression.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent XQuery injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      public bool validateData()
      {
          string productQuery = "for \\$product in doc(products.xml)//product[productid='" + Request["productId"] + "'] return \\$product";

          Processor processor = new Processor();

          XdmNode startNode = processor.NewDocumentBuilder().Build(getDocument());
          XQueryCompiler compiler = processor.NewXQueryCompiler();
          XQueryExecutable executor = compiler.Compile(productQuery);  // VIOLATION
          XQueryEvaluator evaluator = executor.Load();
          if (evaluator.EvaluateSingle() == null ) { return false; }
          else { return true; }
      }]]></example>
    <repair><![CDATA[      public bool validateData()
      {
          string productId = sanitize(Request["productId"]);
          string productQuery = "for \\$product in doc(products.xml)//product[productid='" + productId + "'] return \\$product";

          Processor processor = new Processor();

          XdmNode startNode = processor.NewDocumentBuilder().Build(getDocument());
          XQueryCompiler compiler = processor.NewXQueryCompiler();
          XQueryExecutable executor = compiler.Compile(productQuery);  // OK
          XQueryEvaluator evaluator = executor.Load();
          if (evaluator.EvaluateSingle() == null ) { return false; }
          else { return true; }
      }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/652.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:652,OWASP:2021:A3,WASC:23]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.CSHARP.XSLTInjection" message="XSLTInjection: Avoid using non-neutralized user-controlled input when creating XSL stylesheets" class="com.optimyth.csharp.rules.security.XSLTInjection" technology="CSHARP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.14.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[XSLT is a language for transforming XML documents into XHTML documents or to other XML documents. XSLT adopts the XPath language syntax for expressions. There are also built-in and custom extension functions for building expressions for XML data queries and transformations.

If a XSL stylesheet is created using untrusted input, an attacker can take control over the transformation applied, controlling the final document content so the attacker could perform an XSS attack, expose sensitive information from the application, or execute arbitrary code.

Input data must be validated before using it in an XSL stylesheet.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent XSLT injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      public void transform()
      {
          XslCompiledTransform transformer = new XslCompiledTransform();
          transformer.Load(Request["operation"] + "_output.xsl");   // VIOLATION

          xslt.Transform("template.xml", "output.html");
      }]]></example>
    <repair><![CDATA[      public void transform()
      {
          string operation = validate(Request["operation"]);
          XslCompiledTransform transformer = new XslCompiledTransform();
          transformer.Load(operation + "_output.xsl");   // OK

          xslt.Transform("template.xml", "output.html");
      }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/494.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:91,OWASP:2021:A3,WASC:23]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <categories>
    <category name="CSHARP" technology="CSHARP" active="true" weight="1.0">
      <description><![CDATA[CSHARP rules]]></description>
      <children>
        <category name="OPT.CRITERIUM_VALUE.CQM.EFFICIENCY" technology="CSHARP" active="true" weight="8.0">
          <description><![CDATA[Efficiency]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.MAINTAINABILITY" technology="CSHARP" active="true" weight="10.0">
          <description><![CDATA[Maintainability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.PORTABILITY" technology="CSHARP" active="true" weight="5.0">
          <description><![CDATA[Portability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.RELIABILITY" technology="CSHARP" active="true" weight="10.0">
          <description><![CDATA[Reliability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.SECURITY" technology="CSHARP" active="true" weight="4.0">
          <description><![CDATA[Security]]></description>
        </category>
      </children>
    </category>
  </categories>
</ruleset>
