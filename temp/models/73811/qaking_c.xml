<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="qaking_c" updated="">
  <description>Nykaa_Web</description>
  <rule name="OPT.C.CERTC.ARR33" message="ARR33: Guarantee that copies are made into storage of sufficient size" class="com.optimyth.cpp.rules.certc.arr.ARR33CopiesMadeIntoStorageOfSufficientSize" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Copying data into an array that is not large enough to hold that data results in a buffer overflow.
To prevent such errors, data copied to the destination array must be restricted based on the size of the destination array, or, preferably, the destination array must be guaranteed to be large enough to hold the data to be copied.

Improper use of functions that limit copies with a size specifier, such as memcpy(), may result in a buffer overflow.

Note: Other rules check storage for blocks of character data, like STR31-C "Guarantee that storage for strings has sufficient space for character data and the null terminator". This rule only checks for memory copy functions, like memcpy() or memmove().]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Copying data to a buffer that is too small to hold that data results in a buffer overflow.
    Attackers can exploit this condition to execute arbitrary code.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[enum { WORKSPACE_SIZE = 256 };
void func(const int src[], size_t len) {
  int dest[WORKSPACE_SIZE];
  /* Non compliant: if len > 256, buffer overflow */
  memcpy(dest, src, len * sizeof(int));
  ...
}]]></example>
    <repair><![CDATA[/* Fix strategy #1: bounds checking */
enum { WORKSPACE_SIZE = 256 };
void func_bounds_checking(const int src[], size_t len) {
  int dest[WORKSPACE_SIZE];
  if (len > WORKSPACE_SIZE) {
    /* Handle error */
  }
  memcpy(dest, src, sizeof(int)*len);
  ...
}

/* Fix strategy #2: dynamic allocation */
void func_alloc(const int src[], size_t len) {
  int *dest; /* use pointer instead of auto array */
  if (len > SIZE_MAX / sizeof(int)) {
    /* handle integer overflow */
  }
  dest = (int *)malloc(sizeof(int) * len);
  if (dest == NULL) {
    /* Couldn't get the memory - recover */
  }
  memcpy(dest, src, sizeof(int) * len);
  ...
  free(dest);
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/676.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR33,CWE:119,CWE:131,CWE:676,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ARR35" message="ARR35: Do not allow loops to iterate beyond the end of an array" class="com.optimyth.cpp.rules.certc.arr.ARR35LoopMayIterateOutOfArray" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Loops are frequently used to traverse arrays to find the position of a particular element.
These loops may read or write memory as they traverse the array or use the position of an element, once discovered, to perform a copy or similar operation. Consequently, when searching an array for a particular element, it is critical that the element be found in the bounds of the array or that the iteration be otherwise limited to prevent the reading or writing of data outside the bounds of the array.

This rule is a generalization of STR32-C, "Null-terminate byte strings as required".
STR32-C requires that byte strings be null-terminated, within the memory allocated for the string, in situations where the termination of a loop depends on the existence of a null termination character.
This issue is a special case of a more general problem, where the termination condition of a loop depends on locating a particular element before the end of the array.
Failure to locate this element can result in a buffer overflow or a buffer overrun.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Incorrectly assuming that a loop termination element exists within an array can result in a buffer overflow and the execution
    of arbitrary code with the permissions of the vulnerable process or unintended information disclosure.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Vulnerability in DCOM RPC interface function, exploited by W32.Blaster worm */
HRESULT GetServerPath(WCHAR *pwszPath, WCHAR **pwszServerPath) {
  WCHAR *pwszFinalPath = pwszPath;
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1];
  hr = GetMachineName(pwszPath, wszMachineName);
  *pwszServerPath = pwszFinalPath;
}

HRESULT GetMachineName(
  WCHAR *pwszPath,
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])
{
  WCHAR *pwszServerName = wszMachineName;
  WCHAR *pwszTemp = pwszPath + 2;
  while ( *pwszTemp != L'\\' )
    *pwszServerName++ = *pwszTemp++; /* VIOLATION, no check on pwszServerName to avoid overflow on wszMachineName */

  *pwszServerName = '\0'; /* Properly terminate string with null character */
  /* ... */
}]]></example>
    <repair><![CDATA[HRESULT GetServerPath(WCHAR *pwszPath, WCHAR **pwszServerPath) {
  WCHAR *pwszFinalPath = pwszPath;
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1];
  hr = GetMachineName(pwszPath, wszMachineName);
  *pwszServerPath = pwszFinalPath;
}

HRESULT GetMachineName(
  WCHAR *pwszPath,
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])
{
  WCHAR *pwszServerName = wszMachineName;
  WCHAR *pwszTemp = pwszPath + 2;
  WCHAR *end_addr = pwszServerName + MAX_COMPUTERNAME_LENGTH_FQDN;

  /* FIXED, pwszServerName should not exceed end of array; end of input string also checked */
  while ( (*pwszTemp != L'\\') && (*pwszTemp != L'\0') && (pwszServerName < end_addr) )
    *pwszServerName++ = *pwszTemp++;

  /* ... */
  *pwszServerName = '\0'; /* Properly terminate string with null character */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR35,CWE:119,CWE:131,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ARR35_bis" message="ARR35: Do not allow loops to iterate beyond the end of an array" class="com.optimyth.cpp.rules.certc.arr.ARR35LoopMayIterateOutOfArray2" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Loops are frequently used to traverse arrays to find the position of a particular element.
These loops may read or write memory as they traverse the array or use the position of an element, once discovered, to perform a copy or similar operation. Consequently, when searching an array for a particular element, it is critical that the element be found in the bounds of the array or that the iteration be otherwise limited to prevent the reading or writing of data outside the bounds of the array.

This rule is a generalization of STR32-C, "Null-terminate byte strings as required".
STR32-C requires that byte strings be null-terminated, within the memory allocated for the string, in situations where the termination of a loop depends on the existence of a null termination character.
This issue is a special case of a more general problem, where the termination condition of a loop depends on locating a particular element before the end of the array.
Failure to locate this element can result in a buffer overflow or a buffer overrun.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Incorrectly assuming that a loop termination element exists within an array can result in a buffer overflow and the execution
    of arbitrary code with the permissions of the vulnerable process or unintended information disclosure.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[enum { ARR_SIZE = 100 };

int* reverse_numbers_array(void) {
  int *dyn_arr = (int *) calloc(ARR_SIZE, sizeof(int));
  for(int i = ARR_SIZE; i >= 0; i--) {
    // VIOLATION, when i==0, i-1 = -1, so buffer overflow...
    dyn_arr[i - 1] = i;
  }
  return dyn_arr;
}]]></example>
    <repair><![CDATA[enum { ARR_SIZE = 100 };

int* reverse_numbers_array(void) {
  int *dyn_arr = (int *) calloc(ARR_SIZE, sizeof(int));
  // fixed, i-1 ranges from ARR_SIZE - 1 to 0, no buffer overflow
  for(int i = ARR_SIZE; i > 0; i--) {
    dyn_arr[i - 1] = i;
  }
  return dyn_arr;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR35,CWE:119,CWE:131,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ARR38" message="ARR38: Do not add or subtract an integer to a pointer if resulting value does not refer to a valid array element" class="com.optimyth.cpp.rules.certc.arr.ARR38NoPointerArithOutOfArray" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Do not add or subtract an integer to a pointer if the resulting value does not refer to an element within the array (or to the nonexistent element just after the last element of the array).

According to C99, Section 6.5.6: "If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.
If the pointer resulting from the addition (or subtraction) is outside of the bounds of the array, an overflow has occurred and the result is undefined".

If the pointer resulting from the addition (or subtraction) is outside of the bounds of the array, an overflow has occurred and the result is undefined. See code example for some non-compliant pointer usages.

NOTE: This is a partial implementation of ARR38 rule. Only array dereferences are checked. See code example for more details.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[If adding or subtracting an integer to a pointer results in a reference to an element outside the array or one past
    the last element of the array object, the behavior is undefined but frequently leads to a buffer overflow,
    which can often be exploited to run arbitrary code.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[int ar[20];
int *ip;
/* Non compliant: &ar[20] is allowed (but ar[19] is last element), &ar[21] is undefined behaviour */
for (ip = &ar[0]; ip < &ar[21]; ip++) {
  *ip = 0;
}]]></example>
    <repair><![CDATA[int ar[20];
int *ip;
/* sizeof(ar) / sizeof(ar[0]) = number of elements in ar = 20 */
for (ip = &ar[0]; ip < &ar[ sizeof(ar) / sizeof(ar[0]) ]; ip++) {
  *ip = 0;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/129.html,https://wiki.sei.cmu.edu/confluence/display/c/ARR38-C.+Guarantee+that+library+functions+do+not+form+invalid+pointers]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR38,CWE:129]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ENV01" message="ENV01: Do not make assumptions about the size of an environment variable" class="com.optimyth.cpp.rules.certc.env.ENV01ControlSizeEnvironmentVar" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Environment]]></tags>
    <description><![CDATA[Do not make any assumptions about the size of environment variables, because an adversary might have full control over the environment.

If the environment variable needs to be stored, then the length of the associated string should be calculated and the storage dynamically allocated (see STR31-C, "Guarantee that storage for strings has sufficient space for character data and the null terminator").]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Making assumptions about the size of an environmental variable can result in a buffer overflow attack.
    If environment variable size is checked in operations that could overflow buffers and depend on such variables,
    buffer-overflow risk is reduced.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char copy[16];
char *temp = getenv("MY_ENV_VAR");
if (temp != NULL) {
  strcpy(copy, temp); /* VIOLATION, MY_ENV_VAR could have more than 15 characters */
}]]></example>
    <repair><![CDATA[/*
   strlen() used to calculate the size of MY_ENV_VAR,
   and the required space is dynamically allocated
 */
char *copy = NULL;
char *temp = getenv("TEST_ENV");
if (temp != NULL) {
  copy = (char *)malloc(strlen(temp) + 1);
  if (copy != NULL) {
    strcpy(copy, temp);
  }
  else {
    /* Handle error condition */
  }
  /* Remember to free allocated memory when not used anymore... */
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/ENV01-C.+Do+not+make+assumptions+about+the+size+of+an+environment+variable,https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ENV01,CWE:119,CWE:131,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ENV04" message="ENV04: Do not call system() if you do not need a command processor" class="com.optimyth.cpp.rules.certc.env.ENV04DoNotUseSystem" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,Environment]]></tags>
    <description><![CDATA[The C99 function system() executes a specified command by invoking an implementation-defined command processor, such as a UNIX shell or CMD.EXE in Windows NT and later Windows versions. The POSIX popen() function also invokes a command processor but creates a pipe between the calling program and the executed command, returning a pointer to a stream that can be used to either read from or write to the pipe.

Command interpreters such as the POSIX command-language interpreter sh and CMD.EXE, however, provide functionality in addition to executing a simple command. If this functionality is not required, it is a good idea not to use system() or any other function that invokes a command interpreter, as doing so significantly complicates the command-string sanitization.

To fix, replace calls to system() or popen() with calls to exec* family of functions (execve, execlp, execvp, execl, execle, execv or execve). Such functions do not use (unlike system() or popen()) a full shell interpreter, so they are not vulnerable to command injection attacks. Of course, if the functionality of the external program could be replaced by existing library calls, you may use them instead.

Additional precautions, such as to ensure that the external executable program launched cannot be modified by an untrusted user, are outside of the scope of this rule.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Reduce the risk due to command injection vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *input = NULL;
/* input gets initialized by user */

char cmdbuf[512];
int len_wanted = snprintf(
  cmdbuf, sizeof(cmdbuf), "any_cmd '%s'", input
);
if (len_wanted >= sizeof(cmdbuf)) {
  perror("Input too long");
}
else if (len_wanted < 0) {
  perror("Encoding error");
}
else if ( system(cmdbuf) == -1 ) { /* Non compliant */
  perror("Error executing input");
}]]></example>
    <repair><![CDATA[/*
This compliant solution is significantly different from the equivalent noncompliant code example.
First, input is incorporated into the args array and passed as an argument to execve().
This eliminates any concerns about buffer overflow or string truncation while forming the command string.
Second, this compliant solution must fork a new process before executing "/usr/bin/any_exe" in the child process.
While this is more complicated than calling system(), the added security is worth the additional effort
*/

char *input = NULL;
/* input gets initialized by user */

pid_t pid;
int status;
pid_t ret;
char *const args[3] = {"any_exe", input, NULL};
char **env;
extern char **environ;

/* ... Sanitize arguments ... */
pid = fork();
if (pid == -1) {
  perror("fork error");
}
else if (pid != 0) {
  while ((ret = waitpid(pid, &status, 0)) == -1) {
    if (errno != EINTR) {
      perror("Error waiting for child process");
      break;
    }
  }
  if ((ret != -1) &&
      (!WIFEXITED(status) || !WEXITSTATUS(status)) ) {
   /* Report unexpected child status */
  }
} else {
  /*... Initialize env as a sanitized copy of environ ...*/
  if (execve("/usr/bin/any_exe", args, env) == -1) {
    perror("Error executing any_exe");
    _exit(127); /* command not found error */
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/78.html,https://cwe.mitre.org/data/definitions/88.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ENV04,CWE:77,CWE:78,CWE:88,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:31]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.EXP34" message="EXP34: NULL Pointer Dereference" class="com.optimyth.cpp.rules.certc.exp.EXP34CheckNullPointerDereference" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Expressions]]></tags>
    <description><![CDATA[Attempting to dereference a null pointer results in undefined behavior, typically abnormal program termination.

This rule checks that any pointer to a memory area (typically as result from a function call like malloc() or fgets) if checked for NULL before dereference, as a null pointer dereference have undefined behaviour. If pointer is dereferenced without previous check against NULL (or zero), a violation is emitted on the call to the function call that could return true.

For functions that use errno to indicate error condition, a check against errno is considered an alternate way to check for the validity of the pointer.

In some situations and platforms, dereferencing a null pointer can lead to the execution of arbitrary code.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Dereferencing a null pointer results in undefined behavior, typically abnormal program termination.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[size_t size = strlen(input_str)+1;
str = (char *) malloc(size); /* VIOLATION, no check for null */
memcpy(str, input_str, size); /* str is dereferenced in memcpy */
/* ... */
free(str);
str = NULL;]]></example>
    <repair><![CDATA[size_t size = strlen(input_str)+1;
str = (char *) malloc(size);
if (str == NULL) {
  /* Handle Allocation Error */
} else {
  memcpy(str, input_str, size);
  /* ... */
  free(str);
  str = NULL;
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers,https://cwe.mitre.org/data/definitions/476.html,https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-deref]]></reference>
    <normatives>
      <security><![CDATA[Agile Alliance:Clear-CNUL,CERT-C:EXP34,CPPCOREGL:ES.65,CWE:476,CWETOP25:2021:15]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.FIO30" message="FIO30: Exclude unsanitized user input from format strings" class="com.optimyth.cpp.rules.certc.fio.FIO30ExcludeUserInputFromFormatStrings" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.4.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Input / Output]]></tags>
    <description><![CDATA[Never call any formatted I/O function with a format string containing user input.

An attacker who can fully or partially control the contents of a format string can crash a vulnerable process, view the contents of the stack, view memory content, or write to an arbitrary memory location and consequently execute arbitrary code with the permissions of the vulnerable process.

Formatted output functions are particularly dangerous because many programmers are unaware of their capabilities (for example, they can write an integer value to a specified address using the %n conversion specifier).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid format-string vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#define MSG_FORMAT "%s cannot be authenticated.\n"
void incorrect_password(const char *user) { /* user is untrusted */
  /* user names are restricted to 256 characters or less */
  static const char *msg_format = MSG_FORMAT;
  size_t len = strlen(user) + sizeof(MSG_FORMAT);
  char *msg = (char *)malloc(len);
  if (!msg) {
    /* Handle error condition */
  }
  int ret = snprintf(msg, len, msg_format, user);
  if (ret < 0 || ret >= len) {
    /* Handle error */
  }
  fprintf(stderr, msg); /* Non Compliant, user -snprintf-> msg (msg is format string) */
  syslog(LOG_INFO, msg); /* Non Compliant, same as above (msg is format string) */
  free(msg);
  msg = NULL;
}]]></example>
    <repair><![CDATA[#define MSG_FORMAT "%s cannot be authenticated.\n"
void incorrect_password(char const *user) {
  fprintf(stderr, MSG_FORMAT, user); /* Fixed, format string does not depend on untrusted sources */
  syslog(LOG_INFO, MSG_FORMAT, msg); /* Fixed, format string does not depend on untrusted sources */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/134.html,https://wiki.sei.cmu.edu/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO30,CWE:134,CWETOP25:2011:23,OWASP:2004:A5,PCI-DSS:6.5.1,WASC:10]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.INT35" message="INT35: Evaluate integer expressions in a larger size before comparing or assigning to that size" class="com.optimyth.cpp.rules.certc.integer.INT35EvalIntegerExprInLargerSize" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.4.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Integers]]></tags>
    <description><![CDATA[If an integer expression is compared to, or assigned to, a larger integer size, that integer expression should be evaluated
in that larger size by explicitly casting one of the operands.

NOTE: This rule uses the same implementation as MISRA-C 10.1 standard rule "The value of an expression of integer type
shall not be implicitly converted to a different underlying type". It checks that no illegal implicit conversions take place on integers.

The only integer type conversions that are guaranteed to be safe for all data values and all possible conforming implementations
are conversions of an integral value to a wider type of the same signedness.

The only allowed conversions are:
- A conversion to a wider integer type of the same signedness.
- A constant expression used as function call argument, or in return (signedness must match).

Specifically, the following implicit conversions are forbidden:
- Any implicit conversion between signed and unsigned types.
- Any conversion between integer and floating types.
- Any implicit conversion from wider to narrower types.
- Any implicit conversion of function arguments.
- Any implicit conversion of function return expressions to the function return type.
- Any implicit conversions of complex expressions.
- Any implicit conversion between switch expression and each case constant.

The rule detects dangerous implicit conversions between integer types.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Number handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Failure to cast integers before comparing or assigning them to a larger integer size can result in software vulnerabilities
    that can allow the execution of arbitrary code by an attacker with the permissions of the vulnerable process.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[unsigned int readdata( void ) {
  int amount = 0;
  ...
  if (result == ERROR) amount = -1;
  ...
  /* Non compliant: if error condition is met, return value is 4,294,967,295 on a system with 32-bit integers */
  return amount;
}

/*
  Sample classic integer overflow in OpenSSH 3.3, leading to buffer overflow.
  if nresp = 1,073,741,824 and sizeof(char*) = 4 (typical value), nresp * sizeof(char*) overflows with 32-bit integers,
  and argument to xmalloc (size_t type) will be 0. Most malloc implementations will happily allocate a 0-byte buffer,
  causing buffer overlow in loop
 */
int nresp = packet_get_int();
if (nresp > 0 && nresp < ) {
  response = xmalloc( nresp * sizeof(char*) );
  for (i = 0; i < nresp; i++) response[i] = packet_get_string(NULL);
}]]></example>
    <repair><![CDATA[int readdata( void ) {
  int amount = 0;
  ...
  if (result == ERROR) amount = -1;
  ...
  /* Compliant: no integer overflow, return type is also int */
  return amount;
}

/* checking for integer overflow is not easy... */
int nresp = packet_get_int();
size_t maxNum = ((size_t) -1) / sizeof(char*);
if (nresp > 0 && (size_t)nresp < maxNum) {
  size_t sz = (size_t)nresp * sizeof(char*);
  response = xmalloc( sz );
  for (i = 0; i < nresp; i++) response[i] = packet_get_string(NULL);
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/190.html,https://wiki.sei.cmu.edu/confluence/display/c/INT35-C.+Use+correct+integer+precisions]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:INT35,CWE:190,CWETOP25:2021:12]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM00" message="MEM00: Allocate and free memory in the same module at the same level of abstraction" class="com.optimyth.cpp.rules.certc.mem.MEM00AllocateFreeInSameAbstractionLevel" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[Allocating and freeing memory in different modules and levels of abstraction may make it difficult to determine when and if a block of memory has been freed, leading to programming defects such as double-free vulnerabilities, accessing freed memory, or writing to freed or unallocated memory.

To avoid these situations, memory should be allocated and freed at the same level of abstraction and ideally in the same code module.
This includes the use memory allocation (malloc, calloc, realloc) and deallocation functions (free).

Failing to follow this recommendation has led to real-world vulnerabilities. For example, freeing memory in different modules resulted in a vulnerability in MIT Kerberos 5.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[The mismanagement of memory can lead to freeing memory multiple times or writing to already freed memory.
Both of these coding errors can result in an attacker executing arbitrary code with the permissions of the vulnerable process.
Memory management errors can also lead to resource depletion and denial-of-service attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[enum { MIN_SIZE_ALLOWED = 32 };

int verify_size(char *list, size_t size) {
  if (size < MIN_SIZE_ALLOWED) {
    /* Handle error condition */
    free(list); /* Non compliant, free does not match allocation in same unit */
    return -1;
  }
  return 0;
}

void process_list(size_t number) {
  char *list = (char *)malloc(number);

  if (list == NULL) {
    /* Handle allocation error */
  }
  if (verify_size(list, number) == -1) {
    free(list); /* double-free problem */
    return;
  }
  /* Continue processing list */
  free(list);
}]]></example>
    <repair><![CDATA[enum { MIN_SIZE_ALLOWED = 32 };

int verify_size(char *list, size_t size) {
  if (size < MIN_SIZE_ALLOWED) {
    /* Handle error condition */
    /* Fixed, free() not called, caller must allocate and deallocate memory */
    return -1;
  }
  return 0;
}

void process_list(size_t number) {
  char *list = (char *)malloc(number);

  if (list == NULL) {
    /* Handle allocation error */
  }
  if (verify_size(list, number) == -1) {
    free(list);
    return;
  }
  /* Continue processing list */
  free(list);
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/MEM00-C.+Allocate+and+free+memory+in+the+same+module%2C+at+the+same+level+of+abstraction,https://cwe.mitre.org/data/definitions/415.html,https://cwe.mitre.org/data/definitions/416.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM00,CWE:415,CWE:416,CWETOP25:2020:38,CWETOP25:2021:7]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM30" message="MEM30: Do not access freed memory (Use after free)" class="com.optimyth.cpp.rules.certc.mem.MEM30DoNotAccessFreedMemory" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[Accessing memory once it is freed may corrupt the data structures used to manage the heap.
References to memory that has been deallocated are referred to as dangling pointers.
Accessing a dangling pointer can result in exploitable vulnerabilities.

When memory is freed, its contents may remain intact and accessible because it is at the memory manager's discretion when to reallocate or recycle the freed chunk. The data at the freed location may appear valid. However, this can change unexpectedly, leading to unintended program behavior. As a result, it is necessary to guarantee that memory is not written to or read from once it is freed.

Note: Reading memory that has already been freed can lead to abnormal program termination and denial-of-service attacks.
Writing memory that has already been freed can lead to the execution of arbitrary code with the permissions of the vulnerable process.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid abnormal program termination and denial-of-service issues due to detected dangling pointers.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Classical example, in Kernighan & Ritchie book */
for (p = head; p != NULL; p = p->next)
  free(p); /* p->next after, p was already freed: dangling pointer */
head = NULL;

int main(int argc, const char *argv[]) {
  char *buff;
  buff = (char *)malloc(BUFSIZ);
  if (!buff) {
    /* Handle error condition */
  }
  /* ... */
  free(buff);
  strncpy(buff, argv[1], BUFSIZ-1); /* Non compliant, buff reference is on a dangling pointer */
}]]></example>
    <repair><![CDATA[for (p = head; p != NULL; p = q) { /* Fixed: ref to q is OK */
  q = p->next;
  free(p);
}
head = NULL;

int main(int argc, const char *argv[]) {
  char *buff;
  buff = (char *)malloc(BUFSIZ);
  if (!buff) {
    /* Handle error condition */
  }
  /* ... */
  strncpy(buff, argv[1], BUFSIZ-1); /* Fixed, free() after usage */
  free(buff);
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/416.html,https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM30,CWE:416,CWETOP25:2021:7]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM31" message="MEM31: Free dynamically allocated memory exactly once (Double Free)" class="com.optimyth.cpp.rules.certc.mem.MEM31AvoidDoubleFree" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[Freeing memory multiple times has similar consequences to accessing memory after it is freed ("dangling pointers").
The underlying data structures that manage the heap can become corrupted in a way that can introduce security vulnerabilities into a program.
These types of issues are referred to as double-free vulnerabilities. In practice, double-free vulnerabilities can be exploited to execute arbitrary code.

To eliminate double-free vulnerabilities, it is necessary to guarantee that dynamic memory is freed exactly one time.
Programmers should be wary when freeing memory in a loop or conditional statement; if coded incorrectly, these constructs can lead to double-free vulnerabilities.
It is also a common error to misuse the realloc() function in a manner that results in double-free vulnerabilities (see MEM04-C, "Do not perform zero-length allocations").]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Reduce possibility of double-free errors. Freeing memory multiple times can result in an attacker executing arbitrary code with the permissions of the vulnerable process.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[size_t num_elem = /* some initial value */;
int error_condition = 0;
int *x = (int *)malloc(num_elem * sizeof(int));
if (x == NULL) {
  /* handle allocation error */
}
else {
  /* ... */
  if (error_condition == 1) {
    /* handle error condition*/
    free(x);
  }
  /* ... */
  free(x); /* Non compliant, previous potential free() may cause double-free condition */
}]]></example>
    <repair><![CDATA[size_t num_elem = /* some initial value */;
int error_condition = 0;
int *x = (int *)malloc(num_elem * sizeof(int));
if (x == NULL) {
  /* handle allocation error */
}
else {
  /* ... */
  if (error_condition == 1) {
    /* handle error condition*/
  }
  /* ... */
  free(x); /* Fixed, free() when error_condition == 1 was removed */
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/MEM31-C.+Free+dynamically+allocated+memory+when+no+longer+needed,https://cwe.mitre.org/data/definitions/415.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM31,CWE:415,CWETOP25:2020:38]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM32" message="MEM32: Detect and handle memory allocation errors" class="com.optimyth.cpp.rules.certc.mem.MEM32CheckMemoryAllocationErrors" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[The return values for memory allocation routines indicate the failure or success of the allocation.

According to the C standard, calloc(), malloc(), and realloc() return null pointers if the requested memory allocation fails.
Failure to detect and properly handle memory management errors can lead to unpredictable and unintended program behavior.
As a result, it is necessary to check the final status of memory management routines and handle errors appropriately.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid runtime errors: Failing to check return values from memory allocation functions may cause null pointer dereference.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *input_string = /* initialize from untrusted data */;
size_t size = strlen(input_string) + 1;
char *str = (char *)malloc(size); /* Non compliant, return value is not checked for NULL */
strcpy(str, input_string);
/* ... */
free(str);
str = NULL;]]></example>
    <repair><![CDATA[char *input_string = /* initialize from untrusted data */;
size_t size = strlen(input_string) + 1;
char *str = (char *)malloc(size);
if (str == NULL) {
  /* Handle allocation error */
}
else {
  strcpy(str, input_string);
  /* ... */
  free(str);
  str = NULL;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/476.html,https://cwe.mitre.org/data/definitions/252.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM32,CWE:252,CWE:476,CWETOP25:2021:15]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR02" message="STR02: Sanitize data passed to sensitive subsystems" class="com.optimyth.cpp.rules.certc.str.STR02SanitizeDataForComplexSubsystems" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,Characters and strings]]></tags>
    <description><![CDATA[String data passed to sensitive subsystems may contain special characters that can trigger commands or actions, resulting in a software vulnerability. It is therefore necessary to sanitize all string data passed to sensitive subsystems so that the resulting string is innocuous in the context in which it is interpreted.

These are some examples of sensitive subsystems: - command processor via a call to system() or similar function (see ENV03-C, "Sanitize the environment when invoking external programs").
- external programs.
- relational databases.
- third-party commercial off-the-shelf components (e.g., an enterprise resource planning subsystem).

You may specify the kinds of target complex subsystems to check in the 'sinkResources' property. You may add custom sources (input that need to be neutralized before reaching a controlled resource), sinks (API for access to sensitive resources), and neutralization functions (considered that 'untaints' a potentially malicious input and makes it save to reach a sink/sensitive resource). For adding your custom sources, sinks and neutralization functions, create an XML library descriptor and register it for analysis, as described un the manuals.

It is necessary to ensure that all valid data is accepted, while potentially dangerous data is rejected or sanitized.
This can be difficult when valid characters or sequences of characters also have special meaning to the subsystem and may involve validating the data against a grammar. In cases where there is no overlap, white listing can be used to eliminate dangerous characters from the data.

The white listing approach to data sanitization is to define a list of acceptable characters and remove any character that is not acceptable. The list of valid input values is typically a predictable, well-defined set of manageable size.

API for some subsytems may allow to pass input data as data, not as part of the command (e.g. parameters in an parameterized SQL statement). If possible, use white-listing validation plus such more secure API alternatives.]]></description>
    <priority>1</priority>
    <effort>4</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *addr = argv[0]; /* addr is user-controlled */
sprintf(buffer, "/bin/mail %s < /tmp/email", addr); /* Care with buffer overflow... */
/* VIOLATION: trivial command injection, no neutralization between source (program args) and sink (operating system shell) */
system(buffer);]]></example>
    <repair><![CDATA[Use a sanity-check function between source (argv[0]) and sink (buffer arg in system() call).]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/88.html,https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems,https://cwe.mitre.org/data/definitions/78.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR02,CWE:77,CWE:78,CWE:88,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:31]]></security>
    </normatives>
    <properties>
      <property name="sinkResources" descname="Comma-separated list of resource types to consider as sinks (filesystem, environment, other)" value="environment, filesystem, other"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR31" message="STR31: Guarantee that storage for strings has sufficient space for character data and the null terminator" class="com.optimyth.cpp.rules.certc.str.STR31SpaceForNullTerminator" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Characters and strings]]></tags>
    <description><![CDATA[Copying data to a buffer that is not large enough to hold that data results in a buffer overflow.

While not limited to null-terminated byte strings (NTBS), buffer overflows often occur when manipulating NTBS data.
To prevent such errors, limit copies either through truncation (see STR03-C, "Do not inadvertently truncate a null-terminated byte string") or, preferably, ensure that the destination is of sufficient size to hold the character data to be copied and the null-termination character.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[void f(char* src) {
  char dest[ARRAY_SIZE];
  size_t i;

  /* ... */
  for (i=0; src[i] && (i < sizeof(dest)); i++) {
    dest[i] = src[i];
  }
  dest[i] = '\0'; /* VIOLATION, possibly i == ARRAY_SIZE, off-by-one error */
  /* ... */
}

int main(int argc, char *argv[]) {
  /* ... */
  char prog_name[128];
  char editor_var[256];
  char *editor = getenv("EDITOR");

  strcpy(prog_name, argv[0]); /* VIOLATION, possible buffer-overflow on prog_name[] */
  /* ... */
  if (editor == NULL) {
    /* EDITOR environment variable not set */
  } else {
    strcpy(editor_var, editor); /* VIOLATION, possible buffer-overflow on editor_var[] */
  }
  /* ... */
}]]></example>
    <repair><![CDATA[void f(char* src) {
  char dest[ARRAY_SIZE];
  size_t i;

  /* ... */
  for (i=0; src[i] && (i < sizeof(dest) - 1); i++) {
    dest[i] = src[i];
  }
  dest[i] = '\0'; /* FIXED, i at most ARRAY_SIZE-1 */
  /* ... */
}

int main(int argc, char *argv[]) {
  const char prog_name = argv[0]; /* FIXED, no need to copy argv[0] input */
  char *editor_var;
  char *editor = getenv("EDITOR");

  /* ... */
  if (editor == NULL) {
    /* EDITOR environment variable not set */
  } else {
    size_t len = strlen(editor)+1;
    editor_var = (char *) malloc(len);
    if(editor_var == NULL) {
      /* Handle malloc() error */
    } else {
      memcpy(editor_var, editor, len); /* FIXED, no buffer overlow */
      editor_var[len-1] = '\0'; /* See rule STR32 */
    }
  }
  /* ... */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/119.html,https://cwe.mitre.org/data/definitions/676.html,https://cwe.mitre.org/data/definitions/193.html,https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+termin]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR31,CWE:119,CWE:131,CWE:193,CWE:676,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR33" message="STR33: Size wide character strings correctly" class="com.optimyth.cpp.rules.certc.str.STR33ProperSizeWideCharacterStr" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Characters and strings]]></tags>
    <description><![CDATA[Wide character strings may be improperly sized when they are mistaken for narrow strings or for multibyte character strings. Incorrect string sizes can lead to buffer overflows when used, for example, to allocate an inadequately sized buffer.

Improper string size calculations may include: using strlen() or other string length function that is not prepared for wide character strings; or not multiplying string length by the bytes per wchar_t (obtained with sizeof(wchar_t)). Remember to leave one extra wchar_t element for null string terminator.

For example, using strlen() on a wide-character string could return a number lower than the real characters in a wide character string, as a 0 byte could be present in non-null characters, but strlen() will confuse it with the zero termination character. Use wcslen() or other variants for getting the length of a wide character string.

NOTE: C/C++ 2011 added char16_t (for UTF-16) and char32_t (for UTF-32) for more portable wide character types, because the size in bytes of wchar_t is implementation-dependent.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid buffer overflow conditions due to improper computation of wide character strings.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[wchar_t wide_str1[] = L"0123456789";
wchar_t *wide_str2 = (wchar_t *)malloc( strlen(wide_str1) + 1 ); /* VIOLATION */
if (wide_str2 == NULL) {
/* Handle error */
}
/* ... */
free(wide_str2);
wide_str2 = NULL;]]></example>
    <repair><![CDATA[wchar_t wide_str1[] = L"0123456789";
wchar_t *wide_str2 = (wchar_t *) malloc(
  (wcslen(wide_str1) + 1) * sizeof(wchar_t) /* Proper calculation */
);
if (wide_str2 == NULL) {
  /* Handle error */
}
/* ... */
free(wide_str2);
wide_str2 = NULL;]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,,https://cwe.mitre.org/data/definitions/135.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR33,CWE:119,CWE:131,CWE:135,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR35" message="STR35: Do not copy data from an unbounded source to a fixed-length array" class="com.optimyth.cpp.rules.certc.str.STR35CopyUnboundedSourceToFixedLengthArray" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.1.2,ASVS-v4.0.2:5.4.1,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Characters and strings]]></tags>
    <description><![CDATA[Functions that perform unbounded copies often rely on external input to be a reasonable size.
Such assumptions may prove to be false, causing a buffer overflow to occur. For this reason, care must be taken when using functions that may perform unbounded copies.

For example, the gets() function is inherently unsafe and should never be used because it provides no way to control how much data is read into a buffer from stdin.

fgets() is frequenty used as a replacement for gets(), but it has some differences: fgets() return new-line character (not included in gets() returned string), and may return a partial line if the line exceeds its size parameter. Aternatively, gets_s() function (TR 24731) behaves like gets() but with size limit and a NULL return value that could be used to detect if line was truncated or an I/O error was found.

Formatted input (scanf() and variants) are another cause of buffer-overflow vulnerabilities. Unbounded string reads, like %s, read as much non-whitespace chars as available from input, which could produce a buffer overflow.

Rule also checks how arrays are filled in loops with functions like getchar(), or if a bounded %Ns format specifier is used with formatted input functions (like scanf).]]></description>
    <priority>1</priority>
    <effort>4</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid buffer overflow issues when input is not bounded.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[void badGets(void) {
  char buf[BUFSIZ];

  if (gets(buf) == NULL) { /* VIOLATION, gets() is totally unsafe */
    /* Handle error */
  }
}

void badGetchar(void) {
  char buf[BUFSIZ], *p;
  int ch;

  p = buf;
  while ( ((ch = getchar()) != '\n')
   && !feof(stdin)
   && !ferror(stdin))
  {
    *p++ = ch; /* VIOLATION, buf may overflow */
  }
  *p++ = 0;
}

void badScanf(void) {
  enum { CHARS_TO_READ = 9 };
  char buf[CHARS_TO_READ + 1];

  scanf("%s", buf); /* VIOLATION, buf may overflow */
  /* ... */
}]]></example>
    <repair><![CDATA[/*
  Alternatively, use fgets() on stdin.
  Remember, there are differences with gets()
 */
void getsReplacement(void) {
  char buf[BUFSIZ];

  /* FIXED, but only if TR 24731 available */
  if (gets_s(buf, sizeof(buf)) == NULL) {
    /* handle error */
  }
}

void properGetchar(void) {
  unsigned char buf[BUFSIZ];
  int ch;
  int index = 0;
  int chars_read = 0;

  while ( ( (ch = getchar()) != '\n')
    && !feof(stdin)
    && !ferror(stderr) )
  {
    if (index < BUFSIZ-1) { /* FIXED, overflow controlled */
      buf[index++] = (unsigned char)ch;
    }
    chars_read++;
  }
  buf[index] = '\0'; /* terminate NTBS */
  if (feof(stdin)) {
    /* handle EOF */
  }
  if (ferror(stdin)) {
    /* handle error */
  }
  if (chars_read > index) {
    /* handle truncation */
  }
}

/* Suggested by Kernighan and Pike */
void properScanf(void) {
  enum { CHARS_TO_READ = 9 };
  char buf[CHARS_TO_READ + 1];
  char format[32];

  /* Generates %Ns format */
  snprintf(format, sizeof(format), "%%%ds", CHARS_TO_READ);
  scanf(format, buf); /* FIXED */
  /* ... */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/120.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR35,CWE:120]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CorrectUseMemoryLeaks" message="CorrectUseMemoryLeaks: Allocated memory must be released in same scope" class="com.optimyth.cpp.rules.gen.GEN_CorrectUseMemoryLeaks" technology="C" active="true">
    <description><![CDATA[The memory allocated for an object (in the heap) must always be released in same scope where it was allocated.

Scope could range from a loop body block, to function or class or file. Unpaired allocation/deallocation in same scope increase the possibility of memory leaks.

Memory allocated using standard heap functions (malloc, calloc, realloc) shall be released with the free function.
For C++, allocated memory via new operator shall be released with the delete statement.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Reduces the risk of memory leaks at runtime that might lead to the depletion of memory.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  int GCD(int a, int b){
    int *buffer1 = (int*) malloc (100*sizeof(int)); /* VIOLATION, a trivial (and non-sense) memory leak */

    while( 1 ) {
      a = a % b;
      if( a == 0 )
        return b;
      b = b % a;
      if( b == 0 )
        return a;
    }
  }]]></example>
    <repair><![CDATA[  int GCD(int a, int b){
    int *buffer1 = (int *) malloc (100*sizeof(int));

    while( 1 ){
      a = a % b;
      if( a == 0 )
        return b;
      b = b % a;
      if( b == 0 )
        return a;
    }

    free (buffer1); /* FIXED */
  }]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/401.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:401,CWETOP25:2021:32]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.PotentialInfiniteLoop" message="PotentialInfiniteLoop: Loop with Unreachable Exit Condition ('Infinite Loop')" class="com.optimyth.cpp.rules.sec.PotentialInfiniteLoop" technology="C" active="true">
    <tags><![CDATA[CWEScope:AccessControl,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The program contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.
Such infinite loop conditions are due typically to logical errors in the loop exit conditions and/or loop variables update,
where the loop exit condition is never reached.

An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory, and might compromise software availability.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[T arr[ROWS][COLS] = fetchArray();

size_t i=0, j=0;
for (i=0; i < ROWS; i++) {
  T row[] = arr[i];
  // VIOLATION: infinite loop
  // a typo after copy+paste external loop, inner loop var j not updated
  for (j=0; j < COLS; i++) {
     doSomething(row[j]);
  }
}]]></example>
    <repair><![CDATA[T arr[ROWS][COLS] = fetchArray();

size_t i=0, j=0;
for (i=0; i < ROWS; i++) {
  T row[] = arr[i];
  // FIXED, j++ instead of i++
  for (j=0; j < COLS; j++) {
     doSomething(row[j]);
  }
}]]></repair>
    <reference><![CDATA[https://en.wikipedia.org/wiki/Infinite_loop]]></reference>
    <normatives>
      <security><![CDATA[CWE:835,CWETOP25:2020:36]]></security>
    </normatives>
    <properties>
      <property name="allowExplicitInfiniteLoops" descname="Intentional non-empty infinite loops, coded as while(true)  for(;;), are allowed." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.AnonymousLdapBind" message="AnonymousLdapBind: Access Control - Anonymous LDAP Bind" class="com.kiuwan.qaking.cpp.rules.security.AnonymousLdapBind" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Without proper access control, executing an LDAP statement that contains a user-controlled value can allow an attacker
to access unauthorized records.

Executing LDAP queries under an anonymous bind, effectively without authentication, can allow an attacker to abuse a
poorly configured LDAP environment.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <ldap.h>

// Example of anonymous LDAP bind with OpenLDAP
LDAP *bind_anonymous() {
  LDAP *ld = ldap_init(ldap_host, LDAP_PORT);
  ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &desired_version);

  // VIOLATION - anonymous bind (empty string also works)
  ldap_bind_s(ld, NULL, NULL, LDAP_AUTH_SIMPLE);

  return ld;
}]]></example>
    <repair><![CDATA[#include <ldap.h>

// Example of non-anonymous LDAP bind with OpenLDAP
LDAP *bind_as_user(char *user, char *pass) {
  LDAP *ld = ldap_init(ldap_host, LDAP_PORT);
  ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &desired_version);

  // Validation to make sure that anonymous bind is avoided
  if(isNonNullEmpty(user, pass)) {
    // FIXED - non-anonymous bind to LDAP server
    ldap_bind_s(ld, user, pass, LDAP_AUTH_SIMPLE);

  } else {
    // handle error
  }
  return ld;
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/285.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:285,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.ConnectionStringParameterPollution" message="ConnectionStringParameterPollution: Connection string polluted with untrusted input" class="com.kiuwan.qaking.cpp.rules.security.ConnectionStringParameterPollution" technology="C" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[When the connection string for an application resource (like database, remote server, persistence entity manager...) could
be affected by an untrusted source, not properly neutralized, the application is vulnerable to a Connection String Parameter Pollution attack.

An attack targeted at this vulnerability may use special characters (like ';' or ':') to add unexpected parts to the connection string,
for example to gain extra privileges, or to deactivate security features.

"Untrusted input" means, in this context, a user-controlled application input, an environment variable, or data fetched
from an external web source.

It should be suspicious that a connection string depends on untrusted input. Normally the application configuration uses
a fixed connection string, but other attacks, depending on where the connection string is stored (like an SQL injection or
path traversal attack) may affect the configuration item. This rule only checks for connection strings that are constructed
programmatically with untrusted input.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Example for SQLAPI++ library
#include <SQLAPI.h>

int main(int argc, char *argv[]) {
  SAConnection con;
  // VIOLATION - Connection string taken from unstrusted source
  con.Connect(argv[0], argv[1], argv[2], SA_SQLServer_Client);
  // ...
}]]></example>
    <repair><![CDATA[// Validate (white-list approach) the untrusted input combined into the connection string.
// Alternatively, fetch connection string from a trusted source, like a configuration system.

// And remember that connection strings may contain sensitive information that may need to be
// protected cryptographically.]]></repair>
    <reference><![CDATA[https://www.blackhat.com/presentations/bh-dc-10/Alonso_Chema/Blackhat-DC-2010-Alonso-Connection-String-Parameter-Pollution-wp.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:15,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.DoSRegexp" message="DoSRegexp: Prevent denial of service attack through malicious regular expression ('Regex Injection')" class="com.kiuwan.qaking.cpp.rules.security.DoSRegexp" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.1.1,CWEScope:Access-Control,ReDoS,denial-of-service]]></tags>
    <description><![CDATA[Regular expressions are a formal language for identifying strings of text, parsing, and matching them.

Most regular expressions engines are built over a non-deterministic Finite Automaton (NFA). They use backtracking and,
while these regular expression engines can quickly confirm a positive match, confirming a negative match can take much more longer.

There are lots of well-known regular expression patterns that, using selected inputs, take a time exponentially related to input size.

An attacker with total or partial control over a regular expression may carry out a denial-of-service attacks.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <bits/stdc++.h>

// Vulnerable regexp, leading to catastrophic backtracking
// Problem in second capture group, (([\\-.]|[_]+)?([a-zA-Z0-9]+))*
const char* emailValidation =
  "^([a-zA-Z0-9])"
  "(([\\-.]|[_]+)?([a-zA-Z0-9]+))*"
  "(@){1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$";

bool checkEmail(char* userInput) {
  std::regex redos(emailValidation); // VIOLATION
  std::cmatch m;
  return std::regex_match(userInput, m, redos);
}]]></example>
    <repair><![CDATA[// Rewrite regular expression so to avoid catastrophic backtracking.
// In the example, use an atomic group ?> quantifier:
const char* emailValidation =
  "^([a-zA-Z0-9])"
  "(?>([\\-.]|[_]+)?([a-zA-Z0-9]+))*"
  "(@){1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$";]]></repair>
    <reference><![CDATA[https://cpp.cs.cloud.vt.edu/docs-lecture14-lecture-14#redos,https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS,https://www.regular-expressions.info/boost.html,https://www.regular-expressions.info/stdregex.html,https://cwe.mitre.org/data/definitions/400.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:400,CWETOP25:2021:27]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.HardcodedCryptoKey" message="HardcodedCryptoKey: Hardcoded cryptographic keys" class="com.kiuwan.qaking.cpp.rules.security.HardcodedCryptoKey" technology="C" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,crypto,essential]]></tags>
    <description><![CDATA[Never hard-code cryptographic keys (or passwords used to generate them) in your program.

Crypto keys are used for encryption/decryption, for generation of message authentication codes (MAC), during generation
of password-based encryption keys (the password is the "crypto key" that generates key material for the cipher), and other usages.
Source code is the worst place for key storage, as any change in keys needs recompilation, and it is easy to reverse-engineer
an application binary to learn any keys or secrets that may be embedded in it.

Some data used in cryptographic operations (like initial vector for block ciphers, salt for password hashes, etc.)
are not "private", and it is recommended to generate a good random instance at the origin, and add it to the message
in plaintext, so the destination may use it. The security depends on properly protecting the "secret" thing
(private key in a public/private keypair, encryption key in a symmetric cipher, key in an HMAC, etc.).

Long-term cryptographic keys (in contrast with ephemeral ones), are better stored in a safe key storage.
Private keys in a public/private keypair should NEVER be unprotected (in raw form) and they should be stored in an even
safer key storage (the impact for a compromise of a private key is typically huge and brutal).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <string.h>

/* Example: C code using openssl */
void encrypt(const unsigned char *plaintext, unsigned char *cipherText, size_t *cipherLen) {
    /* Set up the key and iv. Do I need to say to not hard code these in a real application? :-) */

    /* A 256 bit key */
    unsigned char *key = (unsigned char *)"01234567890123456789012345678901";
    /* A 128 bit IV */
    unsigned char *iv = (unsigned char *)"0123456789012345";

    int len, ciphertext_len;
    int plaintext_len = strlen ((char *)plaintext);

    // error handling omitted, for simplicity
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv); // VIOLATION
    EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len);
    EVP_EncryptFinal_ex(ctx, ciphertext + len, &len);
    EVP_CIPHER_CTX_free(ctx);

    *cipherLen = ciphertext_len;
}]]></example>
    <repair><![CDATA[//... rest of code
    /* A 256 bit key */
    unsigned char *key = loadCryptoKey(); // FIXED
    /* A 128 bit IV */
    unsigned char *iv = generateRandomIV();
//... rest of code]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/321.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:321,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.3.1,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.HardcodedSalt" message="HardcodedSalt: Use of hardcoded salt" class="com.kiuwan.qaking.cpp.rules.security.HardcodedSalt" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[The software uses a one-way cryptographic hash against an input that should not be reversible, such as a password,
but the software uses a predictable salt as part of the input.

A hardcoded, fixed salt makes easier for attackers to pre-compute a dictionary of common passwords and their hash values,
effectively disabling the protection that an unpredictable salt would provide.

The rule will report any usage of a password hashing function that expects a salt, when the salt is hardcoded.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid compromising hashed values.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <Poco/PBKDF2Engine.h>

using std::string;
using Poco::DigestEngine;
using Poco::DigestEngine::Digest;
using Poco::PBKDF2Engine;
using Poco::HMACEngine;
using Poco::SHA1Engine;

string hash_password(const string& password) {
  // VIOLATION, hardcoded salt
  PBKDF2Engine<HMACEngine<SHA1Engine>> pbkdf2("hardcoded_salt", 4096, 256);
  pbkdf2.update(passphrase);
  Digest d = pbkdf2.digest();
  return DigestEngine::digestToHex(d);
}]]></example>
    <repair><![CDATA[// same include and using

// Random salt, needs to be stored with the password hash so it is returned with the hash
tuple<string, string> hash_password(const string& password) {
  string salt = create_random_salt(); // for example, 64 bits salt
  PBKDF2Engine<HMACEngine<SHA1Engine>> pbkdf2(salt, 4096, 256); // FIXED
  pbkdf2.update(passphrase);
  Digest d = pbkdf2.digest();
  return make_tuple(DigestEngine::digestToHex(d), salt);
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/760.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:760,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.HardcodedUsernamePassword" message="HardcodedUsernamePassword: Use of Hard-coded Credentials" class="com.kiuwan.qaking.cpp.rules.security.HardcodedUsernamePassword" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.4,ASVS-v4.0.2:3.5.2,ASVS-v4.0.2:6.4.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,credentials,essential]]></tags>
    <description><![CDATA[Hardcoded credentials (username / password) are visible to any person reading the source code.
If the resource protected by such hardcoded credentials is important, this may compromise system security.

With hardcoded credentials, change is difficult. If the target account is compromised, and the software
is deployed in production, a code change is needed, which forces a redeployment.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid credential leakage.
If an account is compromised, changing credentials in an external repository does not need changes in code plus software deployment.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <SQLAPI.h>

const char *u = "sa";
const char *p = "r00tp4zz?!";

SAConnection con;
// VIOLATION, hardcoded database username and password
con.Connect(connStr, u, p, SA_SQLServer_Client);]]></example>
    <repair><![CDATA[// Don't hard-code credentials. Load them from external configuration
// And, when possible, protect them wth encryption]]></repair>
    <reference><![CDATA[https://www.kiuwan.com/docs/display/K5/Avoid+hard-coded+or+in-comment+passwords+in+code,http://cwe.mitre.org/data/definitions/798.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:798,CWETOP25:2021:16,OWASP-M:2016:M2,OWASP:2021:A7,PCI-DSS:6.5.3,WASC:01]]></security>
    </normatives>
    <properties>
      <property name="passwordPattern" descname="Regular expression for matching field names containing passwords." value=""/>
      <property name="usernamePattern" descname="Regular expression for matching field names containing user ids." value=".*(user|username).*|(^|.*_)id(_.*|$)"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.InsecureRandomness" message="InsecureRandomness: Standard pseudo-random number generators cannot withstand cryptographic attacks" class="com.kiuwan.qaking.cpp.rules.security.InsecureRandomness" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.3.1,ASVS-v4.0.2:2.6.2,ASVS-v4.0.2:2.9.2,ASVS-v4.0.2:6.3.1,ASVS-v4.0.2:6.3.2,ASVS-v4.0.2:6.3.3,CWEScope:Access-Control,CWEScope:Confidentiality,crypto,prng]]></tags>
    <description><![CDATA[Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness
in security-sensitive context.

Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators
(PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.

There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties,
but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use in cases
where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating
output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly
improbable for an attacker to distinguish between it and a truly random value. In general, if a PRNG algorithm is not
advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in
security-sensitive contexts, where its use can lead to serious vulnerabilities such as easy-to-guess temporary passwords,
predictable cryptographic keys, session hijacking, and DNS spoofing.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Using non predictable keys improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Remember Knuth: "Random numbers should not be generated with a method chosen at random"

void createCSRFToken(const char *prefix, char **token) {
  char randBytes[32];
  srand(time(NULL)); // really bad seed, but...
  // returning 42 is probably as much "random" as this ;)
  for(int i=0; i<32; i++) {
    int rng = rand(); // VIOLATION, poor randomness
    randBytes[i] = (char)rng;
  }
  // deterministically work with randBytes
  // (convert to hex and concat with prefix into token, etc,)
  concat(prefix, randBytes, 32, token);
}]]></example>
    <repair><![CDATA[// Remember Von Neumann: "Any one who considers arithmetical methods
   of producing random digits is, of course, in a state of sin."

#include "sodium.h"
void createCSRFToken(const char *prefix, char **token) {
  char randBytes[32];
  // FIXED - better quality pseudo-random number for CSRF token,
  // libsodium's randombytes_buf() is crypto-quality PRNG
  // (and PRNG is automatically initialized from system entropy sources)
  randombytes_buf(randBytes, 32);
  concat(prefix, randBytes, token);
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/338.html,http://cwe.mitre.org/data/definitions/330.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MSC30,CWE:330,CWE:338,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="pattern" descname="Regular expression for detecting when a non-cryptographic PRNG is used in a security context.
When blank and checkInSecurityContext=true, no violations are emitted." value="password|passwd|receipt|session|user|key|csrf|token|hash|mac|digest|uuid|guid|crypto|encrypt|decrypt"/>
      <property name="checkInSecurityContext" descname="When set to true, PRNGs usages are only reported when they are used in a security context." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.InsecureSSL" message="InsecureSSL: Insecure SSL configuration" class="com.kiuwan.qaking.cpp.rules.security.InsecureSSL" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:9.2.4,CWEScope:Access-Control,CWEScope:Authentication,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,essential,ssl]]></tags>
    <description><![CDATA[The SSL / TLS standard provides guidelines on how to perform proper SSL validation checks on the client side.
They are not part of the standard, anyway. The implementation of the validation logic is left to the application developer,
that should setup SSL-related classes adequately.

Configuration for the SSL/TLS context in libraries is difficult, because the protocol evolutioned along time (from SSLv2 to the current TLSv1.3),
when certain attacks were discovered. The suite of allowed ciphers and modes for key exchange, encryption and authentication
allowed combinations that nowadays are considered unsafe. To support legacy systems (at client- or server- side)
often old protocol versions are allowed

Creating or configuring proper SSL validation checks is complex, and developers may fail providing a secure
SSL configuration. No certificate validity checks, no certificate chain signature verification, no or improper
server hostname validation (with respect to the identity contained in the server certificate) are common flaws.

Often, developers provide trust managers for accepting self-signed certificates, or even ignore certificate
state to allow expired or revoked certificates. Alternatively, the hostname validation is disabled to avoid
errors when the name in the certificate does not match the target hostname.

The problem with flawed SSL configuration is that it may allow man-in-the-middle attacks and other issues,
see references for full details.

The rule checks for SSL flaw patterns: forbidden SSL versions, or too-permissive certificate chain verification strategies.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid main-in-the-middle and other attacks that proper SSL configuration should block.]]></benefits>
    <inconvenients><![CDATA[Closing the gaps opened by a flawed SSL configuration may produce connection errors with certain legacy hosts.]]></inconvenients>
    <example><![CDATA[ #include <openssl/ssl.h>

 SSL_CTX *configure_tls(bool server) {
   SSL_METHOD* method;

   // version-flexible, do not fix any version (limited later)
   if (server) {
      method = (SSL_METHOD*) TLS_server_method();
   } else {
     method = (SSL_METHOD*) TLS_client_method();
   }

   SSL_CTX *ctx = SSL_CTX_new(method); // VIOLATION, SSLv3 and TLSv1_1 are allowed (but forbidden)

   SSL_CTX_set_min_proto_version(ctx, SSL3_VERSION); // SSLv2 not allowed (but POODLE breaks SSLv3)
   SSL_CTX_set_max_proto_version(ctx, TLS1_1_VERSION); // remove TLSv1_2 and TLSv1_3 (why ?)
   // drop TLSv1.0 support (leaving a "hole" in the list of allowed protocol version, which is discouraged)
   SSL_CTX_set_options(ctx, SSL_OP_NO_TLSv1); // remove TLS 1.0, vulnerable to BEAST
   // allowd are SSLv3 (broken!) and TLSv1_1 (not recommended)

   // in adition, accept any cert:

   SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL); // VIOLATION
   // or
   SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE, verify_nothing_callback);  // VIOLATION

   return ctx;
}

// Accept any certificates from the other side ;)
static int verify_nothing_callback(int preverify_ok, X509_STORE_CTX *certCtx) {
  log_chain(certCtx);
  return 1;
}]]></example>
    <repair><![CDATA[ SSL_CTX *configure_tls(bool server) {
   SSL_METHOD* method;

   // version-flexible, do not fix any version (limited later)
   if (server) {
      method = (SSL_METHOD*) TLS_server_method();
   } else {
     method = (SSL_METHOD*) TLS_client_method();
   }

   SSL_CTX *ctx = SSL_CTX_new(method);

   // FIXED: only TLSv1.2 and TLSv1.3 allowed
   // (TLSv1.2, released in 2008 is retained because TLS1.3 is too new as of today)
   SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);

   SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE, verify_callback); // FIXED

   return ctx;
}

// If provided, it should be programmed carefully:
// it should detect invalid certificate chain (incl. revocation status via OCSP) and hostname checks

static int verify_callback(int preverify_ok, X509_STORE_CTX *certCtx) {
  if( isInvalidChain(certCtx, preverify_ok) ) return 0;
  return preverify_ok;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/296.html,https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/,https://cwe.mitre.org/data/definitions/297.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:296,CWE:297,CWE:298,CWE:299,OWASP-M:2016:M3,OWASP:2021:A2,OWASP:2021:A7,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="forbiddenVersions" descname="Comma-separated list of forbidden protocol versions, including any of: SSLv2, SSLv3, TLSv1, TLSv1_1, TLSv1_2, TLSv1_3, DTLSv1, DTLSv1_2." value="SSLv2, SSLv3, TLSv1, TLSv1_1, DTLSv1"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.InsufficientKeySize" message="InsufficientKeySize: Weak cryptography, insufficient key length" class="com.kiuwan.qaking.cpp.rules.security.InsufficientKeySize" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.8.3,ASVS-v4.0.2:6.2.3,ASVS-v4.0.2:6.2.4,ASVS-v4.0.2:6.2.5,ASVS-v4.0.2:6.2.6,ASVS-v4.0.2:6.2.7,ASVS-v4.0.2:9.1.2,ASVS-v4.0.2:9.1.3,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[A robust cryptographic algorithm (like RSA or AES) with a small key length could be vulnerable to brute-force type attacks.

For symmetric ciphers, AES-CBC (FIPS 197) is the most often recommended algorithm nowadays, with a block size of at least
64 bits (128 bits for the better). Recommended minimum key length for AES is 128 bits for most usages, but for long-range
security, 192 bits or even 256 bits are often recommended.

DES and DESede (or "triple-DES") are, nowadays, not robust enough for most applications. Many algorithms used in the past,
like Blowfish or RC2, are now deemed insecure.

For asymetric cryptography ("public key"), the algorithm most often used is RSA. Most experts consider 2048 as the
most adequate key length for common needs, as its usage in digital signature and other applications demand cryptographic
robustness for a long period of time. Experts now consider 1024 bits for RSA keys (modulus) not enough secure.

Algoritms based on elliptic curves cryptography (like EC-DSA) typically require smaller key sizes, around 200 bits.

See http://www.keylength.com for an interactive site showing current recommendations in cryptographic algorithms,
key length and other issues to take into account.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Example: AES using openssl
// with AES/256 configured in minKeySize:
// Key with 16 byts = 128 bits, too small for long-term protection
EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv); // VIOLATION]]></example>
    <repair><![CDATA[// key should be modified to hold 32 bytes = 256 bits.
EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv); // FIXED]]></repair>
    <reference><![CDATA[http://www.keylength.com/,http://cwe.mitre.org/data/definitions/326.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:326,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Comma-separated list of allowed ciphers." value="Salsa20, XSalsa20, ChaCha20"/>
      <property name="minKeySize" descname="Comma-separated list of minimum key size per algorithm. For example, if AES should use 256 bit keys, use AES/256." value="RSA/2048, DSA/2048, EC/256, AES/128, DH/2048"/>
      <property name="forbiddenAlgorithms" descname="Comma-separated list of ciphers that should NOT be used." value="des, desx, gost, loki, blowfish, enigma, rc2, rc4, arc4, arcfour, rc4drop, threeway, kasumi, panama, skipjack, crypt"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.LdapInjection" message="LdapInjection: Avoid non-neutralized user-controlled input in LDAP search filters" class="com.kiuwan.qaking.cpp.rules.security.LdapInjection" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.7,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software constructs all or part of an LDAP query or search filter using externally-influenced input,
but it does not neutralize or incorrectly neutralizes special elements that could modify the intended LDAP query when sent to LDAP server.

Please note that RFC 4513 (which defines simple authentication method for bind operation in LDAP) specifies
that a null or empty password means either an anonymous authentication (when the dn is also empty or null),
or an authenticated authentication (when the dn is not null/empty). The rule considers both cases as anonymous binding.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[It improves the safety.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <ldap.h>

int main( int argc, char *argv[]) {
  int desired_version = LDAP_VERSION3;
  char *ldap_host = "localhost";
  char *root_dn = "cn=Manager, dc=example, dc=com";
  char *root_pw = "secret";

  char* base = "dc=example,dc=com";

  strings ss;
  ss.append("(&(objectClass=person)(cn=").append(argv[1]).append("))"); // concatenation
  char* filter = ss.c_str();

  LDAP *ld = ldap_init(ldap_host, LDAP_PORT);
  ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &desired_version);
  ldap_bind_s(ld, root_dn, root_pw, LDAP_AUTH_SIMPLE);
  ldap_search_s(ld, base, LDAP_SCOPE_SUBTREE, filter, NULL, 0, &msg); // VIOLATION

  for(LDAPMessage *entry = ldap_first_entry(ld, msg); entry != NULL; entry = ldap_next_entry(ld, entry)) {
    // ...
  }
}]]></example>
    <repair><![CDATA[// Do not concatenate untrusted input without validation into ldap search filters.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/90.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:90,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:29]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.NoSQLInjection" message="NoSQLInjection: Improper neutralization of special elements in data query logic (NoSQL injection)" class="com.kiuwan.qaking.cpp.rules.security.NoSQLInjection" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,NoSQL]]></tags>
    <description><![CDATA[The application generates a query intended to access or manipulate data in a data store such as a NoSQL database,
but it does not neutralize or incorrectly neutralizes special elements that can modify the intended logic of the query.

Depending on the capabilities of the query language, an attacker could inject additional login into the query to:
- Modify the intended selection criteria, thus changing which data entities (e.g., records) are returned, modified, or otherwise manipulated.
- Append additional commands to the query.
- Return more or fewer entities than intended.
- Cause entities to be sorted in an unexpected way.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent NoSQL injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// MongoDB C driver (libmongoc)
// Similar with C++ driver (mongocxx)

#include <mongoc/mongoc.h>

// do not hardcode this...
const char *MONGO_CONN_STR = "mongodb+srv://<username>:<password>@<cluster-url>/test?...";

int main(int argc, char *argv[]) {
    mongoc_client_t *client;
    mongoc_database_t *database;
    mongoc_collection_t *collection;
    bson_t query;
    char *query_str[1024];
    mongoc_cursor_t *cursor;

    mongoc_init();
    client = mongoc_client_new(MONGO_CONN_STR);
    database = mongoc_client_get_database(client, "test");
    collection = mongoc_database_get_collection(database, "mydocs");

    // The query is made by concatenating untrusted input, non validated/sanitized
    bson_init();

    strcat_s(query_str, sizeof query_str, "{\"product\" : ");
    // concat this way opens the door to NoSQL injection ;)
    strcat_s(query_str, sizeof query_str, argv[1]);
    strcat_s(query_str, sizeof query_str, "}");

    bson_init_from_json(&query, argv[0], -1, NULL);

    // VIOLATION, noSQL injection
    cursor = mongoc_collection_find_with_opts( collection, &query, NULL, NULL );
    // ... do something with the cursor ...

   bson_destroy (&query);
   mongoc_cursor_destroy (cursor);
   mongoc_collection_destroy(collection);
   mongoc_database_destroy(database);
   mongoc_client_destroy(client);
   mongoc_cleanup();
}]]></example>
    <repair><![CDATA[    // Same code as before
    long productId = strtol( argv[1], (char **)NULL, 10);
    query = BCON_NEW ( "product", BCON_INT64(productId) ); // FIXED

    cursor = mongoc_collection_find_with_opts( collection, &query, NULL, NULL );]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/943.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:943,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.PathTraversal" message="PathTraversal: Avoid non-neutralized user-controlled input composed in a pathname to a resource" class="com.kiuwan.qaking.cpp.rules.security.PathTraversal" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.1,ASVS-v4.0.2:12.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software uses external input to construct a pathname that is intended to identify a file or directory
that is located underneath a restricted parent directory, but the software does not properly neutralize
special elements within the pathname that can cause the pathname to resolve to a location outside the
restricted directory.

Under an application server, if the application server configuration does not restrict access to files outside
certain restricted directories, the attacker may fetch sensitive files, and if the file is written with contents
controlled by user input, the attacker may change configuration files (like web.xml among others), web contents
('web defacement'), or libraries (for more insidious code injection attacks). Access to system files
(the customary /etc/password in Unix/Linux systems) could also allowed with the app server account permissions.

It is recommended, besides ensuring that files depending on user-controlled input do not exit the intended directories,
that the OS account does have the minimal permissions, to reduce the impact of a successful path traversal attack.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Filesystem paths should not be controlled by user-controlled inputs.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *fname = getUntrustedInput();
// VIOLATION, user-controlled path opened without validation
FILE *file = fopen(fname, "w");
// ... write into f ...]]></example>
    <repair><![CDATA[char *fname = getUntrustedInput();

// Step#1: Canonicalize
// alternatives: realpath() or GetFullPathName
char *cfname = canonicalize_file_name(fname);

// Step#2: Ensure that path is inside allowed area
if(verify_file(cfname)) {
  FILE *f = fopen(cfname, "w"); // FIXED
  // ... write into f ...
}
free(cfname);]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources,http://cwe.mitre.org/data/definitions/22.html,http://cwe.mitre.org/data/definitions/73.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO01,CWE:22,CWE:73,CWETOP25:2021:8,OWASP:2021:A4,OWASP:2021:A5,PCI-DSS:6.5.8,WASC:33]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.ProcessControl" message="ProcessControl: Do not load executables or libraries from untrusted sources" class="com.kiuwan.qaking.cpp.rules.security.ProcessControl" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.14.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,code-injection,scripting]]></tags>
    <description><![CDATA[Loading libraries or executables from an untrusted source or in an untrusted environment can cause an application
to execute malicious code on behalf of an attacker.

Sometimes a developed or third-party library needs to be be run during application execution. For example, System.AppDomain type provides
methods for running libraries or for loading types from a library. If the path to the library depends on external untrusted input,
for example configuration entries, an attacker that could modify the external input could manage to execute uninteded code,
with the privileges of the application.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid code injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[void doSomething(const char *loadPath, const char *libname) {
  // ...

  // VIOLATION - if loadPath influenced by untrusted input,
  // an attacker may force loading libraries from unexpected locations
  SetDllDirectory(loadPath);

  // VIOLATION - if libname influenced by untrusted input
  // an attacker may force loading an unexpected library, including malicious code
  LoadLibrary(libname); // VIOLATION

  // ...
}]]></example>
    <repair><![CDATA[// Validate library path and library search directories, to avoid executing code from an unintended library.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/114.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:114,CWE:494,CWETOP25:2021:4,OWASP:2021:A1,OWASP:2021:A8,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="allowSystemConfiguration" descname="If false, any kind of input is considered untrusted; if true, only user input is considered untrusted" value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.ResourceInjection" message="ResourceInjection: Improper control of resource identifiers (&quot;Resource Injection&quot;)" class="com.kiuwan.qaking.cpp.rules.security.ResourceInjection" technology="C" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software takes from an untrusted source the identifier for a system resource (like a port number),
and allows access to a non-expected resource. Attackers may use the flaw for malicious behaviour,
for example a port scan, change software configuration, transmit sensitive information to a third-party server,
etc.

This vulnerability is also known as "Insecure Direct Object Reference" instead of "Resource Injection".

Note: Please note that other rules may check injection flaws for specific resources (like Path Traversal rule for
filesystem resources, or SSRF for network addresses). This rule reports injection flaws on resource identifiers not
covered by other rules.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#import <hiredis.h>

int main(int argc, char *argv[]) {

  char *host = argv[1];
  int port = (int) strtol(argv[2], (char **)NULL, 10);

  redisContext *ctx = redisConnect(host, port); // VIOLATION
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Resource_Injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:99,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.SqlInjection" message="SqlInjection: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" class="com.kiuwan.qaking.cpp.rules.security.SqlInjection" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The software constructs all or part of an SQL command using externally-controlled input, but it does not neutralize properly
that input that could modify the intended SQL command when it is sent to a database interaction method.

The rule detects a path in code between an input statement (source) and a database call (sink),
with SQL sentence depending on non neutralized input.

It must be known that if SQL does not depend on user-controlled input (e.g. Parametrized SQL, see repair example),
there is no possibility for an SQL injection.

Note: Using stored procedures in database operations does NOT prevent SQL injection if, for example, the SQL to send to
the database for execution of the stored procedure is composed by concatenating non properly neutralized user input.
The ways to avoid SQL injection are:
1) Use parametrized SQL, so SQL code and parameters are not mixed (no parameter could change semantics of the SQL).
2) If SQL code must depend on user input (e.g. to build 'dynamic' WHERE clauses), even with prepared statements,
   all user-controlled inputs used to compose such "dynamic" SQL should be neutralized.

A neutralization function either validates inputs and report an (neutral) error without allowing SQL execution,
or replaces sensitive SQL characters in the input to avoid that the resulting SQL has different semantics.

It is recommended to use parametrized SQL (when possible).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// vulnerable code using SQLAPI++
#include <SQLAPI.h>

// assume that username is externally-controlled
string username = getUserParameter();

// concatenation instead of parameterized query
string sql("select user, pass from users where username = '");
sql.append(username);
sql.append("'");

SAConnection con; // create connection object
con.Connect(dbname, dbuser, dbpass, SA_SQLServer_Client);
SACommand cmd(&con, sql.c_str()); // VIOLATION
cmd.Execute();
// ...]]></example>
    <repair><![CDATA[#include <SQLAPI.h>

// assume that username is externally-controlled
string username = getUserParameter();

// FIXED, parameterized query
char* sql = "select user, pass from users where username = :1";

SAConnection con; // create connection object
con.Connect(dbname, dbuser, dbpass, SA_SQLServer_Client);
SACommand cmd;
cmd.setCommandText(sql);
cmd << username; // binds username to parameter in prepared statement
cmd.Execute();
// ...]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.WeakCryptographicHash" message="WeakCryptographicHash: Weak cryptographic hash" class="com.kiuwan.qaking.cpp.rules.security.WeakCryptographicHash" technology="C" active="true">
    <tags><![CDATA[CWEScope:Accountability,CWEScope:Integrity,CWEScope:Non-Repudiation,crypto,hash]]></tags>
    <description><![CDATA[Use of weak cryptographic hash does not guarantee data integrity.

A (cryptographic) hash function maps data of arbitrary size ("the message") to a bit string of a fixed size ("the digest"),
designed to be a 'one-way' function, infeasible to invert. Ideally, a brute-force search of possible inputs to check
for a match on the expected digest (or a 'rainbow' table of precomputed message/hash pairs) should be the unique way
to recreate an input for a given digest.

Hash functions are the "workhorses" of modern cryptography, with many usages in digital signatures, message authentication codes (MACs),
symmetric key generation, indexing in hash tables, duplicate data detection, checksum against accidental data corruption...

A hash function hash() should have resistance against certain attacks:
* pre-image resistance: given hash value h, it should be difficult to find m such that h = hash(m).
* second pre-image resistance: given m1, it should be difficult to find another m2 such that hash(m1) = hash(m2).
* collision resistance ("birthday attack"): it should be difficult to find m1, m2 such that hash(m1) = hash(m2).
* length-extension resistance: given hash(m) and len(m) but not m, by choosing a suitable m' an attacker can calculate hash(m | m')
  (| denotes concatenation).

Resources needed for brute-force attacks obviously vary exponentially with hash size in bits, while for other attacks
could be half the bits in time or pre-image space (or much lower, if the algorithm has weaknesses).

MD5, SHA1 and SHA2 are often used to verify the integrity of data but last advances in cryptanalysis have discovered weaknesses in both algorithms.
In particular, they use the Merkle-Damgard construction, which are vulnerable to length-extension attacks against naive MAC generation
like hash(K | M).

Note: Modern crypto libraries may include the latest NIST standarized hash algorithm SHA-3 (Keccak),
which is a variable-size hash function (actually, a "cryptographic sponge") under sha3-224 ... sha3-512. When available
their usage is recommended in new code.

The rule looks for usages of crypto primitives (hash or hmac) using a weak algorithm.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid weak algorithms when verifying data integrity.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// The following example uses Microsoft CryptoAPI
// The rule would apply to any modern crypto library, like libcrypt, libsodium, openssl, crypto++...
#include <bcrypt.h>

void do_hash(const char *message) {
  BCRYPT_ALG_HANDLE hAlg = NULL;
  BCRYPT_HASH_HANDLE hHash = NULL;
  BCryptOpenAlgorithmProvider(&hAlg, BCRYPT_SHA1_ALGORITHM, NULL, 0);
  // VIOLATION - SHA-1 is now considered weak
  BCryptCreateHash(hAlg, &hHash, pbHashObject, cbHashObject, NULL, 0, 0);
  // ...
}]]></example>
    <repair><![CDATA[#include <bcrypt.h>

void do_hash(const char *message) {
  BCRYPT_ALG_HANDLE hAlg = NULL;
  BCRYPT_HASH_HANDLE hHash = NULL;
  // FIXED - Use SHA-2 (256 bits) hash, considered robust for most cryptographic usages
  BCryptOpenAlgorithmProvider(&hAlg, BCRYPT_SHA256_ALGORITHM, NULL, 0);
  BCryptCreateHash(hAlg, &hHash, pbHashObject, cbHashObject, NULL, 0, 0);
  // ...
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/328.html,https://en.wikipedia.org/wiki/Hash_function_security_summary,https://crackstation.net/hashing-security.htm]]></reference>
    <normatives>
      <security><![CDATA[CWE:328,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:50]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="List of robust hash functions">
        <value><![CDATA[
sha224, sha256, sha384, sha512, sha3, sha3-224, sha3-256, sha3-384, sha3-512, blake2b, blake2s, keccak, ripemd160, rmd160, ripemd256, ripemd320, whirlpool, dss1, bcrypt, pbkdf2
        ]]></value>
      </property>
      <property name="forbiddenAlgorithms" descname="List of weak hash functions">
        <value><![CDATA[
md2, md4, md5, sha1, gost, gost-crypto, tiger128, tiger160, tiger192, panama, haval128, snefru, ripemd128, adler32, crc32, crc32b, fnv132, fnv1a32, fnv164, fnv1a64, joaat, plaintext
        ]]></value>
      </property>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.WeakEncryption" message="WeakEncryption: Weak symmetric encryption algorithm" class="com.kiuwan.qaking.cpp.rules.security.WeakEncryption" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.9.3,ASVS-v4.0.2:6.2.2,ASVS-v4.0.2:8.3.7,CWEScope:Confidentiality,crypto]]></tags>
    <description><![CDATA[Using a weak encryption algorithms does not guarantee the confidentiality of sensitive data.

Home-grown ciphers, or standard algorithms that were proven flawed or weak, compromise the confidentiality of data.

Encryption algorithms like DES, Triple-DES and RC2 are nowadays too weak for cryptographic usage,
in particular for ensuring information confidentiality.

DES is currently broken, as an small key size renders it unsafe against brute-force attacks.

RC2 is currently broken, as a related-key attack, where an attacker finds mathematical relationships
between key values, renders it unsafe as well.

Triple-DES (or 3DES) is weak, and should be migrated to a more robust standard cipher.

The AES standard algorithm, with an adequate key length and proper setup (initial vector, mode, padding)
should be used instead, for cryptographic operations.

The rule checks usages of weak ciphers in cryptographic primitives, not registred in the allowed list, and registed in the forbidden list.
The rule does not check if the cipher operation is coded properly (key length, initial vector and feedback mode, padding).]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid compromising sensitive data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Encryption using openSSL
#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/err.h>

// iv and key must be in sync with the cipher chosen
int encrypt_failed(unsigned char *plaintext, int plaintext_len, unsigned char *key,
               unsigned char *iv, unsigned char *ciphertext) {
    EVP_CIPHER_CTX *ctx;
    int len;
    int ciphertext_len;

    if(!(ctx = EVP_CIPHER_CTX_new())) {
      handleErrors();
    }

    // VIOLATION, DES is weak encryption (old, keys with 56 bits, 8-byte blocks)
    if(1 != EVP_EncryptInit_ex(ctx, EVP_des_cbc(), NULL, key, iv)) {
      handleErrors();
    }

    if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) handleErrors();
    ciphertext_len = len;

    if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();
    ciphertext_len += len;

    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);

    return ciphertext_len;
}]]></example>
    <repair><![CDATA[// Encryption using openSSL
#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/err.h>

// iv and key must be in sync with the cipher chosen
int encrypt_failed(unsigned char *plaintext, int plaintext_len, unsigned char *key,
               unsigned char *iv, unsigned char *ciphertext) {
    EVP_CIPHER_CTX *ctx;
    int len;
    int ciphertext_len;

    if(!(ctx = EVP_CIPHER_CTX_new())) {
      handleErrors();
    }

    // FIXED - AES-256 is strong, keylen = 128 bits, block is 32 bytes
    if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) {
      handleErrors();
    }

    if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) handleErrors();
    ciphertext_len = len;

    if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();
    ciphertext_len += len;

    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);

    return ciphertext_len;
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/327.html,https://blog.cryptographyengineering.com/2012/05/19/how-to-choose-authenticated-encryption/]]></reference>
    <normatives>
      <security><![CDATA[CWE:327,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Comma-separated list of allowed ciphers." value="aes, rijndael, camellia, cast, cast5, tripledes, 3des, des3, des-ede, des-ede3, mars, twofish, saferplus, seed, serpent, idea, rc5, rc6, rabbit, trivium, salsa20, xsalsa20, chacha20"/>
      <property name="forbiddenAlgorithms" descname="Comma-separated list of ciphers that should NOT be used." value="des, desx, gost, loki, blowfish, enigma, rc2, rc4, arc4, arcfour, rc4drop, threeway, kasumi, panama, skipjack, crypt"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.XmlEntityInjection" message="XmlEntityInjection: XML entity injection" class="com.kiuwan.qaking.cpp.rules.security.XmlEntityInjection" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.5.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[In XML parsers, when XML document to parse could be altered by untrusted input, and the untrusted input may
alter the Document Type Definition (DTD, embedded or external), the parser should be configured to avoid
two kinds of potential attacks:

* XML entity expansion DoS (XEE, XML bomb or "billion laughs attack"), CWE-776, where well-formed DTD with
  internal entities are expanded exponentially until they exhaust memory.

* XML external entity injection (XXE), CWE-611, where an external entity controlled by the attacker refers to the URL
  of a resource that gives unauthorized access to sensitive files on the server machine, or to a resource
  like /dev/random in Unix systems that, when entity is expanded, leads to a denial-of-service condition.
  A variant of this attack is the server-side request forgery (SSRF), where the URL for external DTD or XML-Schema
  is processed by the URL handler used by the XML parser, allowing the attacker access to an unexpected
  network resource (for cross-site request forgery attacks or port-scanning enumeration).

A particular parser might be vulnerable to XML entity injection attacks when their default settings have both entity expansion
and external entity resolution enabled. Disabling validations does not help, as entity expansion / external entity loading is done,
even when validation is disabled.

DTD is not the unique element that an attacker could use for injection: XML-Schema attributes could be specified
on any tag, so SSRF injection may happen at any place in the XML document, not only at the start where DTD should
be placed, but fortunately common parsers do not seem to fetch schema URLs by default.

XML parsing could be hidden in other frameworks and libraries. For example, with REST, when a resource has an XML
representation, the REST framework typically use an underlying XML parser for processing the request message, which
obviusly is fully under control of a potential attacker.

To be safe during XML processing coming from untrusted sources, a number of XML features should be disabled
when configuring the parser:
* DTD interpretation - Ensure DOCTYPE tags are ignored, or documents containing them are rejected.
* Ignore or reject external entities.
* schemaLocation and noNamespaceSchemaLocation should not fetch URLs.
* XIncludes - Should be disabled or left disabled.

The rule checks that there is a path between an untrusted input and the XML document to parse,
then verifies that the XML parser is configured to avoid both external entity and entity expansion attacks.

Some of the common XML parsers available in the C/C++ ecosystem, like expat or libxml2,
may allow bad configuration leading to XXE or entity expansion attacks.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XML entity attacks that could cause denial-of-service and information leakage.]]></benefits>
    <inconvenients><![CDATA[Dependencies on certain features related to DTD or entity expansion may render runtime errors.]]></inconvenients>
    <example><![CDATA[// Vulnerable XML parser using libxml2:
char *input = getUserInput();
// XML_PARSE_NOENT allows expansion of entities
// XML_PARSE_DTDLOAD allows external DTD loading
xmlDocPtr doc = xmlReadMemory(input, strlen(input), "noname.xml", NULL, XML_PARSE_DTDLOAD | XML_PARSE_NOENT);

This code is vulnerable to well-known XML attack vectors like:

* "billion laughs" attack, 1K payload expands to 3GB!:
<?xml version="1.0"?>
<!DOCTYPE lolz [
 <!ENTITY lol "lol">
 <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
 <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
 <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
 <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
 <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
 <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
 <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
 <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>

* XXE (external entity attack), for sensitive file disclosure:
<!DOCTYPE roottag [
 <!ENTITY windowsfile SYSTEM "file:///c:/boot.ini">
]>
<roottag>
 <sometag>&windowsfile;</sometag>
</roottag>

* XXE, for denial-of-service under Unix servers:
<!DOCTYPE foo [
  <!ELEMENT root ANY >
  <!ENTITY unixfile SYSTEM "file:///dev/random" >
]>
<root>&unixfile;</root>]]></example>
    <repair><![CDATA[// FIXED, the default configuration is safe against XEE and XXE attacks
xmlDocPtr doc = xmlReadMemory(input, strlen(input), "noname.xml", NULL, 0);]]></repair>
    <reference><![CDATA[OWASP XML External Entity Processing: https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing,XML Schema, DTD, and Entity Attacks: http://www.vsecurity.com/download/papers/XMLDTDEntityAttacks.pdf,http://cwe.mitre.org/data/definitions/611.html,http://cwe.mitre.org/data/definitions/776.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:611,CWE:776,CWETOP25:2021:23,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:43,WASC:44]]></security>
    </normatives>
    <properties>
      <property name="parametersAsSources" descname="Assume that method parameters are untrusted inputs" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <categories>
    <category name="C" technology="C" active="true" weight="1.0">
      <description><![CDATA[C rules]]></description>
      <children>
        <category name="OPT.CRITERIUM_VALUE.CQM.EFFICIENCY" technology="C" active="true" weight="8.0">
          <description><![CDATA[Efficiency]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.MAINTAINABILITY" technology="C" active="true" weight="10.0">
          <description><![CDATA[Maintainability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.PORTABILITY" technology="C" active="true" weight="5.0">
          <description><![CDATA[Portability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.RELIABILITY" technology="C" active="true" weight="10.0">
          <description><![CDATA[Reliability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.SECURITY" technology="C" active="true" weight="4.0">
          <description><![CDATA[Security]]></description>
        </category>
      </children>
    </category>
  </categories>
</ruleset>
