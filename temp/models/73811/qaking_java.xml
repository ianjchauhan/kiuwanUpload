<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="qaking_java" updated="">
  <description>Nykaa_Web</description>
  <rule name="OPT.HIBERNATE.BindParametersInQueries" message="BindParametersInQueries: Use bind (or named) parameters in HQL and native SQL queries" class="com.optimyth.qaking.hibernate.rules.BindParametersInQueries" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Hibernate]]></tags>
    <description><![CDATA[It is commonly thought that ORM layers, like Hibernate, are automatically immune to SQL injection.
This is FALSE, as Hibernate includes a subset of SQL called HQL, and allows "native" SQL queries.
Often the ORM layer only minimally manipulates the inbound query before handing it off to the database for processing.

HQL, as well as native SQL, could also produce SQL injection conditions, when potentially tainted values (values that could be controlled by user inputs) are concatenated to the query string.

The rule checks that the first argument in Session.executeQuery (for HQL) and Session.executeSQLQuery (for native SQL) methods is composed by concatenating potentially user-controlled variables. The static analysis performed by the rule is not very precise, so false positives (and false negatives) could happen.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid potential SQL injection issues.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// trivial SQL injection case. tainted and tainted2 could be affected by user input
public List bad(String tainted, String tainted2, Session session) {
  String sql = "from DomesticCat cat where cat.name = " + tainted + " and cat.type = :type"; // NEVER DO THIS !
  Query q = session.createQuery(sql);
  q.setString("type", tainted2); // safe, but damage was already done
  return q.list();
}]]></example>
    <repair><![CDATA[public List ok(String tainted, String tainted2, Session session) {
  Query q = session.createQuery("from DomesticCat cat where cat.name = :name and cat.type = :type");
  // Secure, under most database drivers (where bound parameters in prepared statements are NOT part of the SQL)
  q.setString("name", tainted);
  q.setString("type", tainted2);
  return q.list();
}]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Hibernate-Guidelines,https://cwe.mitre.org/data/definitions/564.html,https://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:564,CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="searchInMappings" descname="If true, process hibernate mapping descriptors; if false, ignore mapping descriptors" value="true"/>
      <property name="searchInEntityCode" descname="If true, process JPA-annotated (@Entity) classes; if false, ignore JPA entities" value="true"/>
      <property name="searchInClientCode" descname="If true, process client Java code (non JPA-annotated entities); if false, ignore client code" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.AndroidStickyBroadcast" message="AndroidStickyBroadcast: Avoid Sticky Broadcasts" class="com.optimyth.qaking.android.rules.security.AndroidStickyBroadcast" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android,essential,infoleak]]></tags>
    <description><![CDATA[Sticky broadcasts are usually informational and designed to tell other processes some fact about
the system state (like "battery low"). Sticky broadcasts receipt cannot be secured with a permission,
and therefore are accessible to any receiver.

A normal broacasted Intent reaches receiver(s) configured for that intents, and ends. With sticky broadcasts,
the Intent continues in system (so other apps could be notified if they need the same information). Additionally,
a malicious app could overwrite sticky Intent data.

If these broadcasts contain sensitive data or reach a malicious receiver, an information leakage may happend.

Note: Sticky broadcasts are deprecated since API level 21 ("lollipop").

The rule looks for any call of the deprecated methods related to sticky broadcasts, and any <uses-permission> element
in AndroidManifest.xml requesting android.permission.BROADCAST_STICKY permission to send or remove such broadcast type.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid potential security issues, like sensitive information disclosure.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class MyActivity extends Activity {

  public void sendBroadcast() {
    AccountManager am = AccountManager.get(this);
    Account[] accounts = am.getAccountsByType("com.google");
    String googleMail = accounts[0].name;

    Intent intent = new Intent();
    intent.setAction("com.example.service.UserExists");
    intent.putExtra("Username", googleMail);

    sendStickyBroadcast(intent); // VIOLATION
  }
}

In AndroidManifest.xml, app must request the BROADCAST_STICKY
to send sticky broadcasts:
<!-- VIOLATION -->
<uses-permission android:name="android.permission.BROADCAST_STICKY"/>]]></example>
    <repair><![CDATA[Always avoid deprecated 'sticky' broadcasts.]]></repair>
    <reference><![CDATA[http://www.jssec.org/dl/android_securecoding_en.pdf,https://cwe.mitre.org/data/definitions/927.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:927,OWASP:2021:A4,PCI-DSS:7.1.2]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.ContentProviderUriInjection" message="ContentProviderUriInjection: Content Provider URI Injection" class="com.optimyth.qaking.android.rules.security.ContentProviderUriInjection" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android]]></tags>
    <description><![CDATA[Android content providers is a data access abstraction that uses URIs as query strings. Implementation of a content
provider translates the URI request to data operations on the backend data repository (e.g. an SQL database).

Accesses to content providers in app code are based on calls to a ContentResolver or ContentProviderClient.
Calls are typically insert / query / update / delete, with an URI argument used by the content provider
to perform the operation.

When untrusted input, without validation, is concatenated to compose an URI argument to such content provider methods,
an attacker may change the operation intended by the Android app, using typically .. and / characters, and perform
unexpected operations in the targeted content provider.

Depending on the implementation of the target content provider, this flaw could also allow path traversal or SQL injection
attacks against the target content provider via the vulnerable app, if the content provider contains such vulnerabilities.

This vulnerability is similar to the more traditional SQL Injection, where the URI semantics (playing similar role to SQL)
is changed when uncontrolled concatenation from untrusted data is performed.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import android.net.Uri;

// msgId is untrusted input, and the query arguments are encoded in the URI
// an attacker may pass "123/delete" instead or "123", changing the intended operation
Uri dataUri = Uri.parse(MyProvider.BASE_URI + "/" + msgId);

Cursor wCursor1 = getContentResolver().query(dataUri, null, null, null, null); // VIOLATION]]></example>
    <repair><![CDATA[// Add a proper validation to msgId:
if( isValidMsgId( msgId ) ) { // FIXED
  Uri dataUri = Uri.parse(MyProvider.BASE_URI + "/" + msgId);
  Cursor wCursor1 = getContentResolver().query(dataUri, null, null, null, null);
  // ...
}]]></repair>
    <reference><![CDATA[https://solidgeargroup.com/sql-injection-in-content-providers-of-android-and-how-to-be-protected/,https://oldbam.github.io/android/security/android-vulnerabilities-insecurebank-content-providers,https://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:89,CWETOP25:2021:6,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.DynamicallyLoadingCode" message="DynamicallyLoadingCode: Discourage dynamically loading code" class="com.optimyth.qaking.android.rules.DynamicallyLoadingCode" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android,code-injection]]></tags>
    <description><![CDATA[It is strongly discouraged to load code outside of the application APK. Doing so significantly increases the likelihood
of application compromise due to code injection or code tampering.

It also adds complexity around version management and application testing.
Finally, it can make it impossible to verify the behavior of an application, so it may be prohibited in some environments.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[String packageName = "android.myapp";
String apkName = getPackageManager().getApplicationInfo(packageName, 0).sourceDir;
DexClassLoader dexClassLoader = new DexClassLoader(apkName, "/dynamicClasses", null, getClass().getClassLoader());

Class myClass = Class.forName("android.myapp.DynClass", true, dexClassLoader);]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[Android Developers - http://developer.android.com/intl/es/training/articles/security-tips.html#DynamicCode,http://www.symantec.com/connect/blogs/android-class-loading-hijacking]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SEC03,CWE:114,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.IntentManipulation" message="IntentManipulation: Intent Manipulation" class="com.optimyth.qaking.android.rules.security.IntentManipulation" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android]]></tags>
    <description><![CDATA[If untrusted input is inserted into certain parts of an Android Intent, without proper sanitization, a malicious user or app
could force, via the tainted Intent, the execution of unintended code or inject malicious data in the vulnerable app.

Certain Intent properties could change the expected semantics of the Intent, like setAction(), setClass(), setClassName(),
or setComponent(). If the Intent is used to start an Activity or Service, for example, the attacker may change the
expected element launched, with potential nefarious consequences.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid Intent Manipulation attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;

public class IntentManipulation extends Activity {
  protected void onCreate(Bundle savedInstanceState) {
    // ...
    Intent request = getIntent(); // possibly coming from a malicious app
    String action = request.getAction();
    String type = request.getType();
    ComponentName component = request.getComponent();

    Intent targetService = new Intent();
    targetService.setAction(action); // VIOLATION
    targetService.setComponent(component); // VIOLATION
    targetService.setType(type);

    startService(targetService); // probably not the intended service !
  }
}]]></example>
    <repair><![CDATA[// Perform a white-list validation
protected void onCreate(Bundle savedInstanceState) {
  Intent request = getIntent(); // possibly coming from a malicious app
  String action = request.getAction();
  String type = request.getType();
  ComponentName component = request.getComponent();

  if( isValidAction(action) && isValidComponent(component) ) { // FIXED
    // ... rest of logic
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/99.html,http://oasam.org/en/oasam/oasam-dv-data-validation/oasam-dv-007-intent-injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:99,OWASP-M:2016:M7,OWASP:2021:A3,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.PreventBackupVulnerability" message="PreventBackupVulnerability: Inadecuate backup configuration" class="com.optimyth.qaking.android.rules.security.PreventBackupVulnerability" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.2.1,ASVS-v4.0.2:10.3.1,ASVS-v4.0.2:14.1.3,ASVS-v4.0.2:2.5.4,ASVS-v4.0.2:3.4.3,ASVS-v4.0.2:3.4.4,ASVS-v4.0.2:3.4.5,CWEScope:Confidentiality,Framework:Android,infoleak]]></tags>
    <description><![CDATA[The android:allowBackup attribute determines if an application's data can be backed-up and restored.

If the attribute is not specified, backup is enabled by default; if developer forgets to write this attribute,
sensitive app data may be leaked.

Note: Backup may have security consequences for an application. End-users may copy app data off of the device.
Once backed up, all application data can be read by the user. As backup services may use the cloud for storage,
backup for sensitive data threatens information confidentiality.

A malicious user may also change the data so after restore, unintended data, configurations and permissions could
be enabled, with data integrity loss.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unauthorized access to sensitive application data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- VIOLACION, active backup without fullBackupContent
     (when permitBackup=true) -->
<application
  android:name=".app"
  android:icon="@drawable/icon"
  android:label="@string/app_name"
  android:allowBackup="true">
  ...
</application>]]></example>
    <repair><![CDATA[<!-- FIXED, data to backup made explicit -->
<application
  android:name=".app"
  android:icon="@drawable/icon"
  android:label="@string/app_name"
  android:allowBackup="true" android:fullBackupContent="@xml/backupscheme">
  ...
</application>]]></repair>
    <reference><![CDATA[http://developer.android.com/training/backup/autosyncapi.html#configuring,https://cwe.mitre.org/data/definitions/16.html,https://cwe.mitre.org/data/definitions/359.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:FIO52-J,CWE:16,CWE:359,OWASP-M:2016:M2,OWASP:2021:A5,WASC:13]]></security>
    </normatives>
    <properties>
      <property name="permitBackup" descname="When true, allowBackup=true is permitted. When false, a violation is reported when backup is active." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.SecureRandom" message="SecureRandom: Do not use SecureRandom with a fixed seed" class="com.optimyth.qaking.android.rules.security.SecureRandom" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.3.1,ASVS-v4.0.2:6.3.2,ASVS-v4.0.2:6.3.3,CWEScope:Access-Control,Framework:Android,deprecated]]></tags>
    <description><![CDATA[Specifying a fixed seed will cause the instance to return a predictable sequence of numbers.
This may be useful for testing but it is not appropriate for secure use.

Do NOT seed the SecureRandom, except with SecureRandom's generateSeed(). The proper seeding will be called automatically.

SecureRandom.generateSeed() implementations tries to generate random seed (for example fetching from /dev/random or
/dev/urandom, or another random source devices, or by fetching from different randomness sources in the system).

By bypassing the internal secure seeding mechanism of SecureRandom implementations, you may compromise the security
of the output. If you seed it with anything that an attacker can potentially predict (e.g. the time when the
SecureRandom instance was created), then SecureRandom may not provide the level of security that your app needs.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class MyClass {
  public SecureRandom r;

  public long generateSessionId() {
    SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
    random.setSeed(System.currentTimeMillis()); // VIOLATION, predictable
    return random.nextLong();
  }
}]]></example>
    <repair><![CDATA[public class MyClass {
  public SecureRandom r;

  public long generateSessionId() {
    SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
    // FIXED: leave the internal seeding mechanism in SecureRandom implementation
    return random.nextLong();
  }
}]]></repair>
    <reference><![CDATA[https://www.cigital.com/blog/proper-use-of-javas-securerandom/]]></reference>
    <normatives>
      <security><![CDATA[CWE:338,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.JAX.AvoidExposingAllEndpointlPublicMethods" message="AvoidExposingAllEndpointlPublicMethods: Specify an endpoint interface to avoid exposing all the public methods" class="com.optimyth.qaking.jax.rules.AvoidExposingAllEndpointlPublicMethods" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality,Framework:JAX,Framework:JAX-WS]]></tags>
    <description><![CDATA[A JAX-WS can be developed following a bottom-up or a top-down approach.

Following the bottom-up strategy, the endpoint implementation classes must be annotated either with @WebService
(javax.jws.WebService), to define the service as a SEI-based endpoint, or with @WebServiceProvider
(javax.xml.ws.Provider), to define it as a provider-based endpoint.

A SEI-based endpoint define a service endpoint interface, either explicitly by specifying the endpointInterface
attribute into the @WebService, or implicitly by exposing the implementation class as an interface.

Possibly when exposing the implementation class, some methods would need to be restricted from the fact of being
exposed, and this can be performed by annotating these methods with @WebMethod(exclude=true).

Not using an endpoint interface or the @WebMethod annotation can cause to incorrectly exposing all the public
endpoint implementation class methods, which probably is an undesired effect.

This situation can lead to a security flaw, allowing an user to perform unwanted actions or to obtain private data.

This rule reports the endpoint class implementations not having defined neither an endpoint interface nor @WebMethod
annotations, that make clear that just the intended public methods are exposed.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid accessing to unwanted data or operations, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[package helloservice.endpoint;

import javax.jws.WebService;

// VIOLATION: When no explicit SEI interface,
// all normal public methods are exposed as web service operations
@WebService
public class MyWebService {
    private String message = "Hello, ";

    public String sayHello(String name) {
        return message + name + ".";
    }

    // this is probably unintentionally exposed
    public String forTestingShouldNotBeExposed() { /* ... */ }
}]]></example>
    <repair><![CDATA[package helloservice.endpoint;

import javax.jws.WebService;
import javax.jws.WebMethod;

// FIXED, using a SEI explicit interface
@WebService(endpointInterface = "helloservice.endpoint.MyWebServiceInterface")
public class MyWebService implements MyWebServiceInterface {
    private String message = "Hello, ";

    public String sayHello(String name) {
        return message + name + ".";
    }

    // do not include this in MyWebServiceInterface
    public String forTestingShouldNotBeExposed() { /* ... */ }
}

// Alternative fix, using @WebService(exclude = true)
@WebService
public class MyWebService {
    private String message = "Hello, ";

    public String sayHello(String name) {
        return message + name + ".";
    }

    @WebService(exclude = true)
    public String forTestingShouldNotBeExposed() { /* ... */ }
}]]></repair>
    <reference><![CDATA[https://axis.apache.org/axis2/java/core/docs/jaxws-guide.html#JAXWSIntro,https://cwe.mitre.org/data/definitions/200.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:200,CWETOP25:2021:20,OWASP:2021:A5,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.JAX.CheckHTTPMethods" message="CheckHTTPMethods: Check the HTTP method used to send the request" class="com.optimyth.qaking.jax.rules.CheckHTTPMethods" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality,Framework:JAX,Framework:JAX-WS]]></tags>
    <description><![CDATA[Usually SOAP services use HTTP Post method because the XML structure is too complex to be
especified into an HTTP GET query. However, it is possible to use it when complex types are not being used.

When an endpoint receives a request, the invoke() method is executed, regardless of the HTTP method used, so if no
action is taken, the same code is executed for all the HTTP methods.

It is a good practice to differentiate between the HTTP methods, so different actions can be performed. Also, if this
filtering is not performed, maybe a malicious attacker can send a unexpected petition to be processed by the server,
allowing him to access private sensible data.

This rule reports violation when the HTTP method is not checked into the endpoint invoke() method. This rule only
applies for the endpoints annotated with @WebServiceProvider.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unwanted accesses to private sensible data, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[package helloservice.endpoint;

import javax.jws.WebServiceProvider;
import javax.jws.WebMethod;

@WebServiceProvider
public class Hello3 {        // Violation
    public Source invoke(Source source)  {

    throw new HTTPException(500);
  }
}]]></example>
    <repair><![CDATA[package helloservice.endpoint;

import javax.jws.WebServiceProvider;
import javax.jws.WebMethod;

import javax.xml.ws.handler.MessageContext;

@WebServiceProvider
public class Hello {		// Ok
    public Source invoke(Source source)  {
    try {
        MessageContext messageContext = wsContext.getMessageContext();
        String httpMethod = (String)messageContext.get(MessageContext.HTTP_REQUEST_METHOD);
        // place here the proper logic to handle each of the possible HTTP methods
         if ("POST".equalsIgnoreCase(httpMethod)) {
           // ...
        }
        if ("GET".equalsIgnoreCase(httpMethod)) {
           // ...
        }

    } catch(Exception e) {
        e.printStackTrace();
    }
    throw new HTTPException(500);
  }
}]]></repair>
    <reference><![CDATA[http://www.oracle.com/technetwork/articles/take-a-rest-085683.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:200,CWETOP25:2021:20,OWASP:2021:A5,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.JAX.UseAuthenticatedSOAPMessages" message="UseAuthenticatedSOAPMessages: Use SOAP messages authentication" class="com.optimyth.qaking.jax.rules.UseAuthenticatedSOAPMessages" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.1,ASVS-v4.0.2:2.3.3,ASVS-v4.0.2:2.7.1,ASVS-v4.0.2:2.7.2,ASVS-v4.0.2:2.7.3,ASVS-v4.0.2:2.8.4,ASVS-v4.0.2:2.8.5,ASVS-v4.0.2:9.2.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:JAX,Framework:JAX-WS]]></tags>
    <description><![CDATA[SOAP messages are a way to exchange messages between two endpoints. They content important
data which should not be accessed or modified by a malicious attacker.

The WS-Security policy, a web services specification, offers several ways to protect a SOAP message, including:
  - Authentication check.
  - Signing the message.
  - Encrypting the message.

Message authentication is used to validate the user, and while there are different ways to perform it, the
specification recommends three:
  - Using username / password.
  - Using a PKI along with X.509 certificates.
  - Using Kerberos protocol.

This rule report violation when SOAP message authentication is not performed.

NOTE: To avoid to many irrelevant violations, by default issues are only reported in wsdl files containing a service, but
this behaviour might be modified by setting a false value for the property "reportOnlyServices".]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unauthorized system accesses, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- Violation -->
<?xml version="1.0" encoding="UTF-8"?>


<wsdl:definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://www.example.org/contract/DoubleIt" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsaws="http://www.w3.org/2005/08/addressing" xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702" xmlns:sp13="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802">

    <wsdl:binding name="Binding" type="Type">

    </wsdl:binding>

    <!-- UsernameToken with plain text password -->
    <wsp:Policy wsu:Id="Policy">
        <sp:SupportingTokens>
            <wsp:Policy>
                <sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient">
                    <wsp:Policy/>
                </sp:UsernameToken>
            </wsp:Policy>
        </sp:SupportingTokens>
    </wsp:Policy>

    <wsdl:service name="DoubleItService">
      <wsdl:port name="sample" binding="tns:sample">
        <soap:address location="http://localhost:9009/sample"/>
      </wsdl:port>
    </wsdl:service>

</wsdl:definitions>]]></example>
    <repair><![CDATA[<!-- Ok -->
<?xml version="1.0" encoding="UTF-8"?>


<wsdl:definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://www.example.org/contract/DoubleIt" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsaws="http://www.w3.org/2005/08/addressing" xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702" xmlns:sp13="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802">

    <wsdl:binding name="Binding" type="Type">

    </wsdl:binding>

    <!-- UsernameToken with hashed password and timestamp -->
    <wsp:Policy wsu:Id="Policy">
        <sp:SupportingTokens>
            <wsp:Policy>
                <sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient">
                    <wsp:Policy>
                        <sp:HashPassword/>
                    </wsp:Policy>
                </sp:UsernameToken>
            </wsp:Policy>
        </sp:SupportingTokens>
    </wsp:Policy>

    <wsdl:service name="DoubleItService">
      <wsdl:port name="sample" binding="tns:sample">
        <soap:address location="http://localhost:9009/sample"/>
      </wsdl:port>
    </wsdl:service>

</wsdl:definitions>]]></repair>
    <reference><![CDATA[https://msdn.microsoft.com/en-us/library/ms977327.aspx,http://www.ibm.com/developerworks/library/j-jws18/,https://cwe.mitre.org/data/definitions/287.html,http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/ws-securitypolicy-1.2-spec-os.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:287,CWETOP25:2021:14,OWASP:2021:A7,WASC:1]]></security>
    </normatives>
    <properties>
      <property name="reportOnlyServices" descname="When set to true, rule only reports violation for wsdls containing a service." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.JAX.UseEncryptedSOAPMessages" message="UseEncryptedSOAPMessages: Use encrypted SOAP messages" class="com.optimyth.qaking.jax.rules.UseEncryptedSOAPMessages" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.1.1,ASVS-v4.0.2:6.1.2,ASVS-v4.0.2:6.1.3,CWEScope:Confidentiality,CWEScope:Integrity,Framework:JAX,Framework:JAX-WS]]></tags>
    <description><![CDATA[SOAP messages are a way to exchange messages between two endpoints. They content important
data which should not be accessed or modified by a malicious attacker.

The WS-Security policy, a web services specification, offers several ways to protect a SOAP message, including:
  - Authentication check.
  - Signing the message.
  - Encrypting the message.

Message encryption is used to keep safe the confidential data contained into the message, by hiding the message content,
avoiding to be read by an malicious attacker.

This rule report violation when SOAP message encryption is not performed.

NOTE: To avoid to many irrelevant violations, by default issues are only reported in wsdl files containing a service, but
this behaviour might be modified by setting a false value for the property "reportOnlyServices".]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unauthorized system accesses, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- Violation -->
<?xml version="1.0" encoding="UTF-8"?>


<wsdl:definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://www.example.org/contract/DoubleIt" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsaws="http://www.w3.org/2005/08/addressing" xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702" xmlns:sp13="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802">

    <wsdl:binding name="Binding" type="Type">

    </wsdl:binding>

    <wsp:Policy wsu:Id="Policy">
        <sp:SupportingTokens>
            <wsp:Policy>
                <sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient">
                    <wsp:Policy/>
                </sp:UsernameToken>
            </wsp:Policy>
        </sp:SupportingTokens>
    </wsp:Policy>

    <wsdl:service name="DoubleItService">
      <wsdl:port name="sample" binding="tns:sample">
        <soap:address location="http://localhost:9009/sample"/>
      </wsdl:port>
    </wsdl:service>

</wsdl:definitions>]]></example>
    <repair><![CDATA[<!-- Ok -->
<?xml version="1.0" encoding="UTF-8"?>


<wsdl:definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://www.example.org/contract/DoubleIt" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsaws="http://www.w3.org/2005/08/addressing" xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702" xmlns:sp13="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802">

    <wsdl:binding name="Binding" type="Type">

    </wsdl:binding>

    <wsp:Policy wsu:Id="Policy">
        <sp:SupportingTokens>
            <wsp:Policy>
                <sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient">
                    <wsp:Policy/>
                </sp:UsernameToken>
            </wsp:Policy>
        </sp:SupportingTokens>
    <sp:AlgorithmSuite>
            <wsp:Policy>
                <sp:Basic128Rsa15/>
            </wsp:Policy>
        </sp:AlgorithmSuite>

        <sp:EncryptedParts>
            <sp:Body/>
            <sp:Header/>
        </sp:EncryptedParts>
    </wsp:Policy>

    <wsdl:service name="DoubleItService">
      <wsdl:port name="sample" binding="tns:sample">
        <soap:address location="http://localhost:9009/sample"/>
      </wsdl:port>
    </wsdl:service>

</wsdl:definitions>]]></repair>
    <reference><![CDATA[http://www.ibm.com/developerworks/library/j-jws18/,https://msdn.microsoft.com/en-us/library/ms977327.aspx,http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/ws-securitypolicy-1.2-spec-os.html,http://cwe.mitre.org/data/definitions/311.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC61-J,CWE:311,OWASP:2021:A4]]></security>
    </normatives>
    <properties>
      <property name="reportOnlyServices" descname="When set to true, rule only reports violation for wsdls containing a service." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.JAX.UseSecuredTransportLayer" message="UseSecuredTransportLayer: Avoid using HTTP instead of HTTPS" class="com.optimyth.qaking.jax.rules.UseSecuredTransportLayer" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.1.1,ASVS-v4.0.2:6.1.2,ASVS-v4.0.2:6.1.3,CWEScope:Confidentiality,CWEScope:Integrity,Framework:JAX,Framework:JAX-WS]]></tags>
    <description><![CDATA[Communications sent over HTTP (Hypertext Transfer Protocol) protocol are in plain text, so
they are fully exposed to attacks such as man in the middle. This situation is not acceptable when sensible information
is being communicated.

Using HTTPS (Hypertext Transfer Protocol Secure) allows to perform encrypted connections between the user and the server
using SSL (Secure Sockets Layer) or TLS (Transport Layer Security) certificates. These certificates use an asymmetric
public key infrastructure (PKI) system, which consists in two keys, one of them public distributed to the users, and the
other private stored into the server.

When a connection to a web page is started the server sends a SSL/ TSL certificate to the user's browser, and then they
stablish a secure connection.

HTTPS protocol can be enabled by adding the <sp:TransportToken> and <sp:HttpsToken/> tags into the wsdl descriptor.

This rule reports violation when a secure transport protocol is not being used.

NOTE: To avoid to many irrelevant violations, by default issues are only reported in wsdl files containing a service, but
this behaviour might be modified by setting a false value for the property "reportOnlyServices".]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improve security at transport layer, avoiding sensible data, like bank details, interception.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- Violation -->
<?xml version="1.0" encoding="UTF-8"?>

<wsdl:definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://www.example.org/contract/DoubleIt" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsaws="http://www.w3.org/2005/08/addressing" xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702" xmlns:sp13="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802" >

    <wsdl:binding name="Binding" type="tns:Type">

    </wsdl:binding>

    <wsp:Policy wsu:Id="Policy">
        <sp:SupportingTokens>
            <wsp:Policy>
                <sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient">
                    <wsp:Policy/>
                </sp:UsernameToken>
            </wsp:Policy>
        </sp:SupportingTokens>

        <sp:SignedParts>
            <sp:Body/>
            <sp:Header/>
        </sp:SignedParts>
    </wsp:Policy>

    <wsdl:service name="DoubleItService">
      <wsdl:port name="sample" binding="tns:sample">
        <soap:address location="http://localhost:9009/sample"/>
      </wsdl:port>
    </wsdl:service>

</wsdl:definitions>]]></example>
    <repair><![CDATA[<?xml version="1.0" encoding="UTF-8"?>

<wsdl:definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://www.example.org/contract/DoubleIt" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsaws="http://www.w3.org/2005/08/addressing" xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702" xmlns:sp13="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802" >

    <wsdl:binding name="Binding" type="tns:Type">

    </wsdl:binding>

    <wsp:Policy wsu:Id="Policy">
        <sp:SupportingTokens>
            <wsp:Policy>
                <sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient">
                    <wsp:Policy/>
                </sp:UsernameToken>
            </wsp:Policy>
        </sp:SupportingTokens>

        <sp:SignedParts>
            <sp:Body/>
            <sp:Header/>
        </sp:SignedParts>

        <!-- Ok -->
        <sp:TransportToken>
            <wsp:Policy>
                <sp:HttpsToken >
                    <wsp:Policy>
                        <sp:RequireClientCertificate/>
                    </wsp:Policy>
                </sp:HttpsToken>
            </wsp:Policy>
        </sp:TransportToken>
    </wsp:Policy>

    <wsdl:service name="DoubleItService">
      <wsdl:port name="sample" binding="tns:sample">
        <soap:address location="http://localhost:9009/sample"/>
      </wsdl:port>
    </wsdl:service>

</wsdl:definitions>]]></repair>
    <reference><![CDATA[http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection,http://docs.oracle.com/cd/E12839_01/web.1111/e13713/transport.htm#WSSOV242,https://cwe.mitre.org/data/definitions/295.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:311,OWASP-M:2016:M3,OWASP:2021:A4,PCI-DSS:6.5.10,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="reportOnlyServices" descname="When set to true, rule only reports violation for wsdls containing a service." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.NullDereference" message="NullDereference: NULL Pointer Dereference" class="com.optimyth.qaking.security.rules.java.NullDereferenceRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,essential,potential-bug]]></tags>
    <description><![CDATA[A null dereference is the access - for instance, to access a property or invoke a method - to a reference pointing to null, instead of a valid object.

When it happens, a NullPointerException is thrown, aborting normal execution flow.

Null dereference is a reliability problem, but it can also affect security in several ways:

- Providing a mechanism to bypass security logic.
- Generating debugging information visible for the attacker.
- Leading to a non controlled end of the process, so a possible denial of service attack.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unexpected behaviours.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[		public String myMethod() {
			String name = null;
	    String shortName = name.trim();   // VIOLATION
	    return shortName;
		}]]></example>
    <repair><![CDATA[		public String myMethod() {
			String name = null;
			if (name == null) { return null; }     // OK
	    String shortName = name.trim();
	    return shortName;
		}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/476.html,https://www.securecoding.cert.org/confluence/display/java/EXP01-J.+Do+not+use+a+null+in+a+case+where+an+object+is+required]]></reference>
    <normatives>
      <security><![CDATA[Agile Alliance:Clear-CNUL,CERT-J:EXP01-J,CWE:476,CWETOP25:2021:15]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AccessibilitySubversionRule" message="AccessibilitySubversionRule: Java access restriction subverted (Reflection)" class="com.optimyth.qaking.security.rules.java.AccessibilitySubversionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.10.1,ASVS-v4.0.2:1.4.2,ASVS-v4.0.2:1.4.4,essential]]></tags>
    <description><![CDATA[Java imposes access restrictions for code in one class to access fields, methods and constructors in objects of
different classes (the access level specifiers with public, protected and private keywords enforce in code such restrictions).

Using reflection, Java allows a programmer to get around the access control checks provided by these specifiers.
For example, a programmer may use setAccessible(true) on a reflected field, method or constructor and bypass
the access limitations (if the SecurityManager allows it), so a private field could be read or changed, and
a private method or constructor could be called, from any class.

The rule emits a security flaw when setAccessible(true) is used on any java.lang.reflect.AccessibleObject subtype,
like Field, Method or Constructor.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended accesses to elements that should be protected.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[Field fields[] = SomeClass.class.getDeclaredFields();
for (Field field : fields) {
  if ( !Modifier.isPublic(field.getModifiers())) {
    field.setAccessible(true); /* VIOLATION */
  }
  System.out.print("Field: " + field.getName());
  System.out.println(", value: " + field.get(someObject));
}]]></example>
    <repair><![CDATA[Do not use reflection to increase accessibility of methods, constructors or fields.
Avoid any abuse of setAccessible(). For example, have you been told that Java Strings
are immutable?

import java.lang.reflect.*;

public class MutableStrings {
   static void mutate(String s) throws Exception {
      // value is private in java.lang.String, but who cares?
      Field value = String.class.getDeclaredField("value");
      value.setAccessible(true);
      value.set(s, s.toUpperCase().toCharArray());
   }
   public static void main(String args[]) throws Exception {
      final String s = "Hello world!";
      System.out.println(s); // "Hello world!"
      mutate(s);
      System.out.println(s); // "HELLO WORLD!"
   }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/SEC05-J.+Do+not+use+reflection+to+increase+accessibility+of+classes%2C+methods%2C+or+fields,http://cwe.mitre.org/data/definitions/284.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SEC05-J,CWE:284,CWETOP25:2020:30,OWASP:2021:A1,PCI-DSS:6.5.8,WASC:02]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AcegiInsecureChannelMixingRule" message="AcegiInsecureChannelMixingRule: Acegi Misconfiguration - Insecure Channel Mixing" class="com.optimyth.qaking.security.rules.java.AcegiInsecureChannelMixingRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Allowing transport protocol to switch between HTTP and HTTPS makes application vulnerable to session hijacking.

Many applications use cookies to communicate a user's session identifier. When the application is accessed over HTTPS,
cookies are protected (attackers are unable to sniff them). But if developers allow HTTP access to non-sensitive parts
of the application, the session identifier can be stolen.

When a user browses to an unprotected part of the site, the cookie containing the session ID is sent without encryption.
If attackers sniff the traffic, they can see the session ID and could take control of the user's session.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<bean class="org.acegisecurity.intercept.web.FilterSecurityInterceptor">
  <property name="filterInvocationDefinitionSource">
    <value>
      CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
      \A/secure/.*\Z=REQUIRES_SECURE_CHANNEL
      \A/acegilogin.jsp.*\Z=REQUIRES_SECURE_CHANNEL
      \A/j_acegi_security_check.*\Z=REQUIRES_SECURE_CHANNEL
      \A.*\Z=REQUIRES_INSECURE_CHANNEL
    </value>
  </property>
<bean>]]></example>
    <repair><![CDATA[<bean class="org.acegisecurity.intercept.web.FilterSecurityInterceptor">
  <property name="filterInvocationDefinitionSource">
    <value>
      CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
      \A.*\Z=REQUIRES_SECURE_CHANNEL
    </value>
  </property>
<bean>]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/5.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:5,OWASP:2021:A2,PCI-DSS:6.5.10,PCI-DSS:6.5.8,WASC:04]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AcegiRunAsAuthenticationReplacementRule" message="AcegiRunAsAuthenticationReplacementRule: Acegi Misconfiguration - Run-As Authentication Replacement" class="com.optimyth.qaking.security.rules.java.AcegiRunAsAuthenticationReplacementRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.1,ASVS-v4.0.2:2.3.3,ASVS-v4.0.2:2.7.1,ASVS-v4.0.2:2.7.2,ASVS-v4.0.2:2.7.3,ASVS-v4.0.2:2.8.4,ASVS-v4.0.2:2.8.5,ASVS-v4.0.2:9.2.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Using the Run-As authentication replacement feature in Acegi can lead to a privilege escalation vulnerability.

Acegi Security allows for temporarily replacing the Authentication object in the SecurityContext during the secure object callback phase.
This only occurs if the original Authentication object was successfully processed by the AuthenticationManager and AccessDecisionManager.
The RunAsManager creates this Authentication object. Typically developers use RunAsManager to configure one or more additional roles
for an authenticated user for the duration of a method invocation. This is useful for a secure bean that needs to access a remote application.
Since the remote application might demand different credentials, this allows translating between calling roles and those needed
by the remote application so that the remote access can succeed.

The new Authentication object (called RunAsUserToken) will be simply accepted as a valid Authentication object without
any further authentication or authorization check. Adding new roles or privileges to the new Authentication object
has the potential to temporarily elevate the user's privileges, allowing the user to take an unauthorized action.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!--
The following configuration shows using RunAsManager to add the role "UBER_BOSS" to a user who has the role "ROLE_PEON",
thus temporarily granting this user manager privileges, which enables him to get data from PrivateCatalog service.
-->
<bean id="bankManagerSecurity" class="org.acegisecurity.intercept.method.aopalliance.MethodSecurityInterceptor">
  ...
  <property name="objectDefinitionSource">
    <value>
      com.example.service.PrivateCatalog.getData=ROLE_PEON,RUN_AS_UBER_BOSS
      ...
    </value>
  </property>
</bean>]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/724.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:287,CWETOP25:2021:14,OWASP:2021:A7,PCI-DSS:6.5.10,PCI-DSS:6.5.8,WASC:01]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AnonymousLdapBindRule" message="AnonymousLdapBindRule: Access Control - Anonymous LDAP Bind" class="com.optimyth.qaking.security.rules.java.AnonymousLdapBindRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Without proper access control, executing an LDAP statement that contains a user-controlled value can allow an attacker to access unauthorized records.
Executing LDAP queries under an anonymous bind, effectively without authentication, can allow an attacker to abuse a poorly configured LDAP environment.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    The following code creates the DirContext ctx using an anonymous bind.
      ...
      env.put(Context.SECURITY_AUTHENTICATION, "none");
      DirContext ctx = new InitialDirContext(env);
      ...
    All LDAP queries executed against ctx will be performed without authentication and access control. An attacker might be able to manipulate one of these
    queries in an unexpected way to gain access to records that would otherwise be protected by the directory's access control mechanism.]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/285.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:285,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties>
      <property name="ldapContextClasses" descname="ldapContextClasses" value="javax.naming.InitialContext, InitialContext, javax.naming.directory.InitialDirContext,InitialDirContext,javax.naming.ldap.InitialLdapContext,InitialLdapContext"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CodeInjectionRule" message="CodeInjectionRule: Dynamic code injection in scripting API" class="com.optimyth.qaking.security.rules.java.CodeInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.4,ASVS-v4.0.2:5.5.4,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,code-injection,scripting]]></tags>
    <description><![CDATA[Scripting engines in Java allow execution of source code written in different languages.

When the application uses a scripting engine to execute source code that could be altered by an external, untrusted input,
a potential attacker may force the execution of unintended code (local or even remote code injection). Some scripting
engines allow execution of system commands or call Java, which makes this flaw more dangerous, even allowing arbitrary
system command execution.

Code and data in compiled languages are quite different, but under scripting languages this boundary is much more fuzzy.
External untrusted input should be passed to the script in the form of "parameters" or "binding variables" so any
source code injected by a potential attacker will NOT be considered source code by the scripting engine.

This rule supports the standard scripting API (javax.script) and other frameworks like JEXL, Groovy, Mozilla Rhino,
or Jython.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid local / remote code injection attacks on scripting engines.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import groovy.lang.GroovyShell;
...
String code = req.getParameter("hidden_code"); // not so hide...
... JavaScript interpreter in Java scripting API
ScriptEngine se = new ScriptEngineManager().getEngineByExtension("js");
// JavaScript engine allows Java calls, like java.lang.Runtime.getRuntime().exec("rm -rf /")
Object ret = se.eval(code); // VIOLATION
... with Groovy
Object ret2 = new GroovyShell().evaluate(req.getParameter("hidden_code")); // VIOLATION]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import groovy.lang.GroovyShell;
...
String code = getTrustedCode(); // not affected by untrusted input
String param = req.getParameter("hidden_param"); // not so hide...
...
ScriptEngine se = new ScriptEngineManager().getEngineByExtension("js");
se.put("param", param); // FIXED, variable binding at engine scope
Object ret = se.eval(code);
...
Binding variables = new Binding();
GroovyShell shell = new GroovyShell(variables);
variables.setVariable("param", param); // FIXED, separated data and code
Object ret2 = shell.evaluate(code);

// Additionally, create a "sandbox" for execution scripts:
// create an AccessControlContext with limited privileges and run the script
// using AccessController.doPrivileged(PrivilegedAction, AccessControlContext)

private static class RestrictedAccessControlContext {
  private static final AccessControlContext INSTANCE;

  static {
    INSTANCE = new AccessControlContext(
      new ProtectionDomain[] {
        new ProtectionDomain(null, null) // No permissions
      }
    );
  }
}

ScriptEngine engine = new ScriptEngineManager().getEngineByExtension("js");
try {
  AccessController.doPrivileged(
    new PrivilegedExceptionAction<Object>() {
      public Object run() throws ScriptException {
        engine.eval(  ...  ); // in a sandbox with no permissions
        return null;
      }
    }
  )
}]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Code_injection_in_Java,http://cwe.mitre.org/data/definitions/95.html,https://www.securecoding.cert.org/confluence/display/java/IDS52-J.+Prevent+code+injection]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS52-J,CWE:95,OWASP:2021:A3,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CodeInjectionWithDeserializationRule" message="CodeInjectionWithDeserializationRule: Dynamic code injection during XML / JSON deserialization" class="com.optimyth.qaking.security.rules.java.CodeInjectionWithDeserializationRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.5.2,ASVS-v4.0.2:5.5.1,ASVS-v4.0.2:5.5.3,CWEScope:Availability,CWEScope:Integrity,code-injection,serialization]]></tags>
    <description><![CDATA[Certain Java serialization frameworks (like JDKs XmlEncoder/XmlDecoder or XStream library) provide a framework
for arbitrary object persistence (without mapping information), serializing objects to XML documents.
Such frameworks allow to serialize constructor and method calls, to reconstruct object instances properly
(to call the object constructors or setter methods) during deserialization.

If the application deserializes XML documents from untrusted sources (e.g. in a REST framework), and if an attacker
can provide the XML document to be deserialized, he/she may be able to execute arbitrary code on the server, including
opening a reverse shell to launch commands.

If you think that this does not affect you, think twice. A top-level service framework (REST, XML-RPC...) could
transfer Java objects using an underlying XML persistence framework like XmlEncoder or XStream. A REST framework
typically process (HTTP) request messages, and marshals/unmarshals a resource representation (JSON, XML...),
potentially to Java objects. The underlying unmarshalling library could allow code injection if it does not limit
which objects could be unmarshalled and which code could be executed during deserialization.

As XStream is used in other frameworks (for example, XStreamMarshaller class in Spring OXM), the vulnerability could
be found in other places.

In other words, any application that allows a user to pass content that will be deserialized by XMLDecoder or XStream
is exposing a remote code execution flaw.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid code injection thru serialized objects in XML / JSON.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.beans.XMLDecoder;
import com.thoughtworks.xstream.XStream;

public class X {
  /*
  The following xml document will overwrite a sensitive file.
  Similar to new PrintWriter("/myapp/WEB-INF/sensitive.dat").println("hacked!")
  The bad guys could install a JSPShell page, modify configuration files, etc.
  <java>
    <object class="java.io.PrintWriter">
      <string>/myapp/WEB-INF/sensitive.dat</string>
      <void method="println">
        <string>hacked!</string>
      </void>
    </object>
  </java>
  */
  public static X deserialize(HttpServletRequest req) throws Throwable {
    InputSource src = new InputSource(
      new InputStreamReader(req.getInputStream(), "UTF-8")
    );
    XMLDecoder decoder = new XMLDecoder(src); // VIOLATION: untrusted source
    Object object = decoder.readObject();
    decoder.close();
    return (X)object;
  }

  /*
  Similar attack payload for XStream, using dynamic proxy
  Deserialization runs new ProcessBuilder("c:\\windows\\system32\\calc.exe").start()
  <dynamic-proxy>
    <interface>com.myorg.Z</interface>
    <handler class="java.beans.EventHandler">
      <target class="java.lang.ProcessBuilder">
        <command><string>c:\\windows\\system32\\calc.exe</string></command>
      </target>
      <action>start</action>
    </handler>
  </dynamic-proxy>
  */
  public static Z deserialize(HttpServletRequest req) throws Throwable {
    String xml = fetchBody(req.getReader());
    XStream st = new XStream();
    Z object = (Z) st.fromXML(xml); // VIOLATION: untrusted source
    decoder.close();
    return object;
  }
}]]></example>
    <repair><![CDATA[With XMLDecoder, add a custom classloader to limit which classes may be created during deserialization.

With XStream, limit the classes that could be serialized/deserialized.
Note: Do not use the (default) AnyTypePermission.ANY.

XStream xs = new XStream();
xs.addPermission(NoPermissionType.NONE); // clear out existing permissions
// allow some basics
xs.addPermission(NullPermission.NULL);
xs.addPermission(PrimitiveTypePermission.PRIMITIVES);
xs.allowTypeHierarchy(Collection.class);
// allow types from certain package
xs.allowTypesByWildcard(new String[] {
    MyClass.class.getPackage().getName()+".*"
});]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/502.html,https://securityblog.redhat.com/2014/01/23/java-deserialization-flaws-part-2-xml-deserialization/,http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html,https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#hessianburlap-binaryxml,http://x-stream.github.io/securit]]></reference>
    <normatives>
      <security><![CDATA[CWE:502,CWETOP25:2021:13,OWASP:2021:A8,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CommandInjectionRule" message="CommandInjectionRule: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" class="com.optimyth.qaking.security.rules.java.CommandInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[The software constructs all or part of an operating system command using externally-controlled input, but it does not neutralize
properly that input that could modify the intended command when it is sent to a method that executes the command
(e.g. java.lang.Runtime.exec()).

The rule detects a path in code between an user-input statement (source) and a command execution call (sink),
with command depending on non neutralized input. This allows for an attacker to change the intended command to execute
or to add a malicious extra command, executed with the application rights.

A neutralization function either validates inputs and report an (neutral) error without allowing command execution,
or replaces sensitive shell characters in the input to avoid that the resulting command has different semantics.
If possible, use "accept known good" input validation strategy (whitelist).

It is recommended either: to use API calls instead of external commands, when possible; or to ensure that the application (e.g.
deployed in a J2EE container) runs under a non-privileged account with rights for the intended commands.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class Clase{
  public void commandInjection(HttpServletRequest req) throws IOException {
    String btype = req.getParameter("backuptype");
    String cmd = new String("cmd.exe /K \"c:\\util\\rmanDB.bat " + btype+ "&&c:\\utl\\cleanup.bat\"");
    Runtime.exec(cmd); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class Clase{
  public void commandInjection(HttpServletRequest req) throws IOException {
    String input = req.getParameter("input");
    // Neutralized, take care if input ends in a log anyway...
    if(!pattern.match(input)) throw new ValidationException(input); // proper positive validation
    String cmd = new String("cmd.exe /K \"c:\\util\\MyCommand.bat " + input);
    Runtime.exec(cmd);
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method,http://cwe.mitre.org/data/definitions/78.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS07-J,CWE:77,CWE:78,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:31]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ConnectionStringParameterPollution" message="ConnectionStringParameterPollution: Connection string polluted with untrusted input" class="com.optimyth.qaking.security.rules.java.ConnectionStringParameterPollution" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.7,CWEScope:Integrity]]></tags>
    <description><![CDATA[When the connection string for an application resource (like database, remote server, persistence entity manager...) could
be affected by an untrusted source, not properly neutralized, the application is vulnerable to a Connection String Parameter Pollution attack.

An attack targeted at this vulnerability may use special characters (like ';' or ':') to add unexpected parts to the connection string,
for example to gain extra privileges, or to deactivate security features.

"Untrusted input" means, in this context, a user-controlled application input, an environment variable, or data fetched
from an external web source.

It should be suspicious that a connection string depends on untrusted input. Normally the application configuration uses
a fixed connection string, but other attacks, depending on where the connection string is stored (like an SQL injection or
path traversal attack) may affect the configuration item. This rule only checks for connection strings that are constructed
programmatically with untrusted input.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.sql.DriverManager;
import java.sql.Connection;
import java.text.MessageFormat;

public class X {
  private static final String URL = "jdbc:hsqldb:mem:{0}";

  public Connection getConnection(HttpServletRequest req) throws SQLException {
    String uname = req.getParameter("username");
    String jdbcUrl = MessageFormat.format(URL, uname);
    return DriverManager.getConnection(jdbcUrl, userPrefix + "_" + user, password); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[// Validate (white-list approach) the untrusted input combined into the connection string.]]></repair>
    <reference><![CDATA[https://www.blackhat.com/presentations/bh-dc-10/Alonso_Chema/Blackhat-DC-2010-Alonso-Connection-String-Parameter-Pollution-wp.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:15,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CookiesInSecurityDecision" message="CookiesInSecurityDecision: Reliance on Cookies without Validation and Integrity Checking in a Security Decision" class="com.optimyth.qaking.security.rules.java.CookiesInSecurityDecision" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[Using a cookie for security decision is a bad practice. Remember that attackers control most parts of the HTTP message,
including cookies sent to the application. If a security check is based on the value of a cookie field (for example,
the cookie value), a attacker may choose a particular value to pass such security check, without any reliance to
past navigation thru the vulnerable application.

Attackers may exploit this vulnerability to bypass protection mechanisms such as authorization and authentication,
by modifying the cookie to contain an expected value.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid bypass of protection mechanisms, due to flawed security decisions based on cookies.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public void flawedAdminCheck(HttpServletRequest req, HttpServletResponse res) {
  Cookie[] cookies = req.getCookies();
  for(Cookie cookie : cookies) {
    if("role".equals(cookie.getName())) { // VIOLATION
      String role = cookie.getValue();
      if(req.isUserInRole(role) && "admin".equals(role)) { // VIOLATION
        doAdminOperation(req, res);
      }
    }
  }
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/784.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:784,OWASP:2021:A8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CrossSiteRequestForgeryRule" message="CrossSiteRequestForgeryRule: Cross-site request forgery (CSRF)" class="com.optimyth.qaking.security.rules.java.CrossSiteRequestForgeryRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.3,ASVS-v4.0.2:4.2.2,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,csrf]]></tags>
    <description><![CDATA[A sensitive operation associated with an web URL (servlet, JSP, WebUI, Struts Action ...) may be invoked from
a request coming from a legitimate, authenticated user (with identity typically encoded in a session ID cookie)
but where an attacker was able to force the user agent to submit the request.

For an CSRF attack to succeed, various elements must occur together:
1. Trusted user is logged in the vulnerable webapp
2. Trusted user agent is tricked by the attacker (e.g. in a web app he controls) to send an HTTP request to the
   vulnerable URL
3. The server-side logic under that URL accepts the request as if it was really initiated by the legitimate user,
   without explicit verification that the user really intended to perform the operation, simply because the
   session ID cookie for the logged-in user appears in the HTTP request.

The result is that the vulnerable application accepts the operation (controlled by attacker) as if it was submitted
by the trusted, logged-in, user. This is an abuse of the trust the web application puts on HTTP requests coming from
logged-in users.

A CSRF vulnerability is a design flaw, where certain web operations (sensitive, as an attacker may gain benefit
from the legitimate user) are not protected by a control that avoids this kind of attack to succeed. Essentially,
a CSRF flaw occurs when a web resource performing sensitive operations do not check that the request came from
from same webapp + same user (the application, at server side, needs to explicitely check the request provenance somehow).

NOTE: Other attacks, like Cross-site WebSocket hijacking (https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html)
follow the same path and are prevented along the very same techniques.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid CSRF attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// No "bad code" for CSRF. The lack of anti-CSRF protection
// in web actions performing sensitive operations is the flaw.]]></example>
    <repair><![CDATA[Add a particular anti-CSRF control (sometimes in each action class,
sometimes in webapp configuration.

For example, for OWASP CSRFGuard, In web.xml file:

	Activate the CsrfGuardFilter:
	<filter>
		<filter-name>CSRFGuard</filter-name>
		<filter-class>org.owasp.csrfguard.CsrfGuardFilter</filter-class>
	</filter>

	Configure anti-CSRF filter:
  <listener>
    <listener-class>org.owasp.csrfguard.CsrfGuardServletContextListener</listener-class>
  </listener>
  <listener>
    <listener-class>org.owasp.csrfguard.CsrfGuardHttpSessionListener</listener-class>
  </listener>
  <context-param>
    <param-name>Owasp.CsrfGuard.Config</param-name>
    <param-value>WEB-INF/Owasp.CsrfGuard.properties</param-value>
  </context-param>

	Map the filter to URL patterns for sensitive actions to be protected:
	<filter-mapping>
		<filter-name>CSRFGuard</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/352.html,https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet,https://en.wikipedia.org/wiki/Cross-site_request_forgery]]></reference>
    <normatives>
      <security><![CDATA[CWE:352,CWETOP25:2021:9,OWASP:2013:A8,PCI-DSS:6.5.1,WASC:9]]></security>
    </normatives>
    <properties>
      <property name="checkStateChange" descname="When true, potential vulnerable sources not performing any state-change operation are not reported." value="true"/>
      <property name="patterns" descname="ANT patterns, comma-separated, for source files to process. Try to select sensitive operations that need CSRF protection." value=""/>
      <property name="checkers" descname="Comma-separated names of CSRF protection frameworks (CSRFGuard, ESAPI, JSF, HDIV, Struts1, Struts2 or SpringSecurity; or empty for all of them)." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CrossSiteScriptingRule" message="CrossSiteScriptingRule: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')" class="com.optimyth.qaking.security.rules.java.CrossSiteScriptingRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,essential]]></tags>
    <description><![CDATA[Software places user-controlled input in page content. An attacker could inject browser script code that is executed
in the client browser. The end-user is the attacked subject, and the software is the vehicle for the attack.
There are two main kinds of XSS:

* Reflected XSS: Attacker causes victim to supply malicious content to a vulnerable web application, which
  renders HTML content embedding a malicious script executed in victim's browser. A variation of this is named
  DOM-based XSS, where the vulnerable software does not generate content depending on user input but include
  script code that use user-controlled input.

* Persisted XSS: Attacker provides malicious content to vulnerable application. When other user access to
  vulnerable pages that embed without proper neutralization the attacker content, script code is executed in the
  victim's browser.

The script executed in the victim's browser could perform malicious activities.

Many browsers could limit the damage via security restrictions (e.g. 'same origin policy'), but user browsers
generally allow scripting languages (e.g. JavaScript) in their browsers (disabling JavaScript severely limits
a web site).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

public class CrossSiteScriptingCode {
  public void directXSS(HttpServletRequest req, HttpServletResponse res) throws IOException {
    PrintWriter w = res.getWriter();
    w.println( req.getParameter("input") ); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import org.owasp.html.*;

public class CrossSiteScriptingCode {
  public void directXSS(HttpServletRequest req, HttpServletResponse res) throws IOException {
    PrintWriter w = res.getWriter();
    // OWASP Java HTML Sanitizer (upgrade to r88 or later)
    // Use your own security library if needed
    PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.LINKS);
    String safeHTML = policy.sanitize( req.getParameter("input") );
    w.println(safeHTML); // OK
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html,https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet,https://www.google.es/about/appsecurity/learning/xss/,https://www.securecoding.cert.org/confluence/display/java/IDS51-J.+Properly+encode+or+escape+output]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS51-J,CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.7,WASC:08]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input, database_input, file_input"/>
      <property name="checkXssProtectionHeaderDisabled" descname="When true rule reports violation if X-XSS-Protection filter is disabled" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.DatabaseAccessControlRule" message="DatabaseAccessControlRule: Avoid queries in the database except from the specific classes" class="com.optimyth.qaking.security.rules.java.DatabaseAccessControlRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Avoid queries in the database except from the specified classes (architecture class).
The rule will show a violation each time it finds a call to a method of the "queryMethods" list, performed ​​from an object whose type is contained in the "statementClasses" list, but only if it is done from a class that is not among those that comply with the pattern indicated in the "architectureClassesPattern" property.
By using the rule properties you can parameterize which classes or packages are allowed to contain database queries statements.
Use Java regular expressions to define class and package names patterns.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class NotArquitectureClass {
  protected void method(){
    //...
    PreparedStatement preparedStatement = dbConnection.prepareStatement("insert into TM_DEFECT (DEFECT_ID,PRIORITY) values (?,?)");
    //...
    preparedStatement.executeUpdate();              //VIOLATION
    //...
  }
}]]></example>
    <repair><![CDATA[public class ArquitectureClass {  //FIXED
  protected void method(){
    //...
    PreparedStatement preparedStatement = dbConnection.prepareStatement("insert into TM_DEFECT (DEFECT_ID,PRIORITY) values (?,?)");
    //...
    preparedStatement.executeUpdate();
    //...
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/566.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:285,OWASP:2021:A1]]></security>
    </normatives>
    <properties>
      <property name="statementClasses" descname="statementClasses" value="java.sql.Statement, Statement, java.sql.PreparedStatement, PreparedStatement"/>
      <property name="queryMethods" descname="queryMethods" value="execute, executeBatch, executeQuery, executeUpdate"/>
      <property name="architectureClassesPattern" descname="architectureClassesPattern" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.DynamicMethodInvocation" message="DynamicMethodInvocation: Dynamic method invocation in Struts 2" class="com.optimyth.qaking.security.rules.java.struts2.DynamicMethodInvocation" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CVE:2013:4316,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,Framework:struts2]]></tags>
    <description><![CDATA[Struts 2 added a feature (Dynamic Method Invocation, DMI) allowing an Action to expose service methods other than execute()
(or other @Action annotated methods). When DMI is enabled, the ! character could be used in the action URL to invoke
any public method in the action class.

Developers that are not aware of DMI could unexpectedly expose internal business logic to attackers.

The rule reports violation when 'struts.enable.DynamicMethodInvocation' configuration property set to true
(in struts.properties or any Struts .xml configuration file), which enable DMI.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unexpected invocations on public action methods.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[# In struts.properties
struts.enable.DynamicMethodInvocation = true

<!-- In struts.xml configuration file -->
<constant name="struts.enable.DynamicMethodInvocation" value="true" />]]></example>
    <repair><![CDATA[# In struts.properties
struts.enable.DynamicMethodInvocation = false

<!-- In struts.xml configuration file -->
<constant name="struts.enable.DynamicMethodInvocation" value="false" />]]></repair>
    <reference><![CDATA[https://struts.apache.org/docs/s2-019.html,http://cwe.mitre.org/data/definitions/285.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:285,OWASP:2021:A1,PCI-DSS:6.5.8,WASC:02]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.FormatStringInjectionRule" message="FormatStringInjectionRule: Exclude unsanitized user input from format strings" class="com.optimyth.qaking.security.rules.java.FormatStringInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.4.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Java JDK contains formatting methods, named format() or printf(), that format a sequence of values according to a format string.
Classes with formatting methods: PrintStream/PrintWriter, Formatter, MessageFormat, and String.
Except MessageFormat, format string is loosely similar to C printf() format string.

If the format string is constructed with untrusted input, an attacker may produce unexpected application behaviour.
It may cause an exception such as java.util.MissingFormatArgumentException to be thrown (which, if not catched, may lead
to a denial-of-service condition), or information leak.

Consequently, unsanitized input from untrusted source should never be incorporated into format strings.

Note: The risks here are much lower that the equivalent vulnerability in C/C++ and the %n format modifier, anyway.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid denial of service.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[class X {
  public static void main(String[] args) {
    ...
    if(!isProperExpirationDate(args[0])) {
      // VIOLATION - args[0] may contain format specifiers
      System.out.format(
        args[0] + " not valid. HINT: %s",
        args[1]
      );
    }
  }
}]]></example>
    <repair><![CDATA[class X {
  public static void main(String[] args) {
    ...
    if(!isProperExpirationDate(args[0])) {
      // FIXED - constant format string
      System.out.format(
        "%s not valid. HINT: %s",
        args[0], args[1]
      );
    }
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/IDS06-J.+Exclude+unsanitized+user+input+from+format+strings,http://cwe.mitre.org/data/definitions/134.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS06-J,CWE:134,CWETOP25:2011:23,OWASP:2004:A5,PCI-DSS:6.5.1,WASC:10]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.HardcodedCryptoKey" message="HardcodedCryptoKey: Hardcoded cryptographic keys" class="com.optimyth.qaking.security.rules.java.HardcodedCryptoKey" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,crypto,essential]]></tags>
    <description><![CDATA[Never hard-code cryptographic keys (or passwords used to generate them) in your program.

Crypto keys are used for encryption/decryption, for generation of message authentication codes (MAC), during generation
of password-based encryption keys (the password is the "crypto key" that generates key material for the cipher), and other usages.
Source code is the worst place for key storage, as any change in keys needs recompilation, and it is easy to reverse-engineer
an application binary to learn any keys or secrets that may be embedded in it.

Some data used in cryptographic operations (like initial vector for block ciphers, salt for password hashes, etc.)
are not "private", and it is recommended to generate a good random instance at the origin, and add it to the message
in plaintext, so the destination may use it. The security depends on properly protecting the "secret" thing
(private key in a public/private keypair, encryption key in a symmetric cipher, key in an HMAC, etc.).

Long-term cryptographic keys (in contrast with ephemeral ones), are better stored in a safe key storage.
Private keys in a public/private keypair should NEVER be unprotected (in raw form) and they should be stored in an even
safer key storage (the impact for a compromise of a private key is typically huge and brutal).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public SecretKey hardcodedCryptoKey() throws GeneralSecurityException {
  final String hardcoded = "hardcoded-password"; // hardcoded crypto key
  final byte[] salt = getRandomSalt();
  KeySpec keyspec = new PBEKeySpec(hardcoded.toCharArray(), salt, 65536, 256); // VIOLATION
  SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
  SecretKey tmp = factory.generateSecret(keyspec);
  return new SecretKeySpec(tmp.getEncoded(), "AES");
}]]></example>
    <repair><![CDATA[public SecretKey nonHardcodedCryptoKey() throws GeneralSecurityException {
  final String pass = loadKeyFromSafeInput(); // FIXED
  final byte[] salt = getRandomSalt();
  KeySpec keyspec = new PBEKeySpec(pass.toCharArray(), salt, 65536, 256);
  SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
  SecretKey tmp = factory.generateSecret(keyspec);
  return new SecretKeySpec(tmp.getEncoded(), "AES");
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/321.html,https://wiki.sei.cmu.edu/confluence/display/java/MSC03-J.+Never+hard+code+sensitive+information]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC03-J,CWE:321,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.3.1,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.HardcodedSaltRule" message="HardcodedSaltRule: A hardcoded salt can compromise system security" class="com.optimyth.qaking.security.rules.java.HardcodedSaltRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,crypto,deprecated]]></tags>
    <description><![CDATA[A hardcoded salt can compromise system security in a way that cannot be easily remedied.

It is never a good idea to hardcode a salt. Not only does a hardcoded salt allow all of the project's developers to view
the salt, it also makes fixing the problem extremely difficult.

Once the code is in production, the salt cannot be easily changed. If attackers know the salt value, they can precompute
rainbow tables for the application, and more easily reverse hashed values.

For example:
...
Encryptor instance = ESAPI.encryptor();
String hash1 = instance.hash(input, "HereComesTheSalt...");
...
This code will run successfully, but anyone who has access to it will have access to the salt. Once the program has shipped,
there is no going back from the salt "HereComesTheSalt...".
A devious employee with access to this information can use it to break into the system.

Even worse, if attackers have access to the bytecode for application, they can use the javap -c command to access the disassembled code,
which will contain the values of the used salt.

NOTE: This rule is deprecated by the OPT.JAVA.SEC_JAVA.WeakPasswordHashing, which performs more checks on the password hashing logic.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private static final String SALT = "MySalt";
// ...
Encryptor instance = ESAPI.encryptor();
String hash = instance.hash(message, "HereComesTheSalt...");      //VIOLATION
hash = encryptor.hash(message, SALT);                             //VIOLATION

//The rule can lead to some false negatives, for example:
private static final String SALT = "MySalt";
public String getSalt(){
  return SALT;
}
// ...
Encryptor instance = ESAPI.encryptor();
String hash = instance.hash(sb, getSalt());      //NOT VIOLATION, BUT FALSE NEGATIVE]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/MSC03-J.+Never+hard+code+sensitive+information,http://cwe.mitre.org/data/definitions/760.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC03-J,CWE:760,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="encryptorClasses" descname="Comma-separated list of encryptor classes" value="org.owasp.esapi.Encryptor, Encryptor"/>
      <property name="hashSignatures" descname="Comma-separated list of hash methods signatures" value="hash/2"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.HardcodedUsernamePassword" message="HardcodedUsernamePassword: Use of Hard-coded Credentials" class="com.optimyth.qaking.security.rules.java.HardcodedUsernamePassword" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.4,ASVS-v4.0.2:3.5.2,ASVS-v4.0.2:6.4.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,credentials,essential]]></tags>
    <description><![CDATA[Hardcoded credentials (username / password) are visible to any person reading the source code.
If the resource protected by such hardcoded credentials is important, this may compromise system security.

With hardcoded credentials, change is difficult. If the target account is compromised, and the software
is deployed in production, a code change is needed, which forces a redeployment.

Please note that source code access is not always necessary: if an attacker has access to the JAR file,
he/she may dis-assembly it to recover the password in clear.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid credential leakage.
If an account is compromised, changing credentials in an external repository does not need changes in code
plus software deployment]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.sql.*;

public class Hardcoded {
  private static final String JDBC_URL = "jdbc:...";
  private static final String USER = "mydbuser";
  private static final String PASS = "notSoSecret!";

  public void connect() {
    Connection conn = DriverManager.getConnection(JDBC_URL, USER, PASS); // VIOLATION
    // ...
  }
}]]></example>
    <repair><![CDATA[import java.sql.*;

public class JdbcConnectionConfig { /* ... */ }

public class Hardcoded {
  public void safeConnect() {
    JdbcConnectionConfig conf = getConnectionConfigFromTrustedSource();
    Connection conn = DriverManager.getConnection(conf.getUrl(), conf.getUser(), conf.getPass()); // FIXED
    // ...
  }
}]]></repair>
    <reference><![CDATA[https://security.web.cern.ch/security/recommendations/en/password_alternatives.shtml,http://cwe.mitre.org/data/definitions/798.html,https://www.kiuwan.com/docs/display/K5/Avoid+hard-coded+or+in-comment+passwords+in+code,https://www.securecoding.cert.org/confluence/display/java/MSC03-J.+Never+hard+code+sensitive+information]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC03-J,CWE:798,CWETOP25:2021:16,OWASP-M:2016:M2,OWASP:2021:A7,PCI-DSS:6.5.3,WASC:01]]></security>
    </normatives>
    <properties>
      <property name="passwordPattern" descname="Regular expression for matching field names containing passwords." value=""/>
      <property name="usernamePattern" descname="Regular expression for matching field names containing user ids." value=".*(user|username).*|(^|.*_)id(_.*|$)"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.HttpParameterPollutionRule" message="HttpParameterPollutionRule: HTTP parameter pollution (HPP)" class="com.optimyth.qaking.security.rules.java.HttpParameterPollutionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.1,CWEScope:Integrity,http-parameter-pollution]]></tags>
    <description><![CDATA[Concatenating untrusted input into path, query string, or parameters for HTTP message (in the URL or in the request body)
may allow an attacker to override/add unexpected request parameters. Attacker may change the intended
HTTP request semantics, and may give him/her access to unauthorized data or bypass web application
firewall validations.

Note: Do not confuse HPP with Server-Side Request Forgery (SSRF), where the attacker has control over the
full request URL, including host and port. For HPP attack, attacker has control over other parts like the query string
part of the URL. Remember the format of an HTTP URL: scheme://user:password@host:port/path?query#fragment
where query is typically param=value&param2=value. HPP is about attackers controlling path, query or fragment,
while SSRF means controlling scheme, user, password, host or port.

Like other injection issues, with HPP attackers play with "&" to inject additional parameter (similar to the quote
in SQL injection), "../" to change the path, ";" (to add matrix parameters to URL at different path segments), or "#"
to remove ending URL characers (like "--" comment delimiter in SQL injection).

Controlling the path typically changes the semantics of the action represented by the HTTP resource.
Some REST services use request parameter like _method for selecting the HTTP method, which may be subverted by an HPP attack
(an HTTP header manipulation flaw could also be leveraged with X-HTTP-Method-Override or similar headers in certain frameworks).

For example, imagine a web application that calls to a remote home-banking REST API. The webapp emits
a (GET) url https://mybank.com/show-balance/account/X/monetaryUnit?date=now to show the balance for the user account X,
where X is taken from a trusted source, but where monetaryUnit is taken from a cookie, and concatenated without
any validation or encoding into the URL. An attacker could pass a Cookie request header set to "../../../transfer/X/to/Y?_method=POST#",
so the vulnerable web application will create https://mybank.com/show-balance/account/X/../../../transfer/X/to/Y?_method=POST#?date=now
which is equivalent to a POST https://mybank.com/transfer/X/to/Y.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unexpected behaviour for HTTP parameter pollution attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[String lang = req.getParameter("lang"); // untrusted input

// Using Apache Commons HttpClient API:
GetMethod get = new GetMethod("http://www.host.com");
get.setQueryString("lang=" + lang + "&poll_id=" + poll_id); /* VIOLATION */
get.execute();

// Using java.net.URLConnection API:
String queryString = "?lang=" + lang + "&poll_id=" + poll_id;
URL url = new URL("http://www.host.com" + queryString); /* VIOLATION */
URLConnection urlConn = url.openConnection();
...
InputStream response = url.getInputStream();]]></example>
    <repair><![CDATA[String lang = req.getParameter("lang"); // untrusted input
validate(lang); // custom validation
// url-encode so special query string chars (&,;?%) in lang are safe
lang = URLEncoder.encode(lang);
... same as before ...]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/235.html,RESTing On Your Laurels will Get YOu Pwned]]></reference>
    <normatives>
      <security><![CDATA[CWE:235,OWASP:2021:A3,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.HttpSplittingRule" message="HttpSplittingRule: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')" class="com.optimyth.qaking.security.rules.java.HttpSplittingRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software places user-controlled input in HTTP headers. An attacker could inject line separators (CR/LF sequences)
    that could split the response message generated by the software into two messages. The second response is completely
    under the control of the attacker (intermediate web proxies may cache it), with could produce multiple conditions
    (web defacement, cache poisoning, cross-site scripting or page hijacking, see CWE-113 for full details).

    If software needs to generate HTTP headers depending on user-controlled input, such input should be properly
    neutralized (a white-list validation excluding CR/LF is recommended). Please note that cookies are received and
    sent in 'Cookie' header in HTTP messages, so if the software generates a Cookie from user input, the input should
    be properly validated as well.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;

public class Sample {

  public void httpSplitting(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String author = req.getParameter("author");
    Cookie cookie = new Cookie("author", author);
    res.addCookie(cookie);    // VIOLATION, cookie is encoded as 'Cookie' header field in HTTP response message
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;

public class Sample {

  public void httpSplitting(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String author = req.getParameter("author");
    // This could emit an exception for white-list validation, or at least remove CR/LF sequences from the input
    //  Neutralize function must be registered into the metadata to be considered by the rule.
    author = neutralize(author);
    Cookie cookie = new Cookie("author", author);
    res.addCookie(cookie); // VIOLATION, cookie is encoded as 'Cookie' header field in HTTP response message
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/113.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:113,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:25]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.IBatisSqlInjectionRule" message="IBatisSqlInjectionRule: Improper Neutralization of Special Elements used in an SQL Command in iBatis ('SQL Injection')" class="com.optimyth.qaking.security.rules.java.IBatisSqlInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[IBatis (or MyBatis for newest versions) is a database persistence framework with support for custom SQL, stored procedures and advanced mappings.
This framework eliminates JDBC code and the manual setting of parameters and retrieval of results, using either XML mapping
descriptors or Java annotations for configuration and declaring the SQL operations and the map between Java objects and
database elements.

Mapping entries in iBatis typically use named parameters that automatically map between input parameters (either map entries
or object fields) and the SQL parameters, and use prepared statements to send SQL to the database. This mode of operation
is largely safe with respect to SQL injection. The #field# or #{field} placeholders in the SQL code are replaced by
prepared parameter placeholders and the field data is injected as parameter in the SQL statement, which is safe against
SQL injection attacks.

But sometimes dynamic SQL is needed, for example to modify part of the SQL according to the values of the input parameters.
iBatis offers a satisfactory way to compose safe dynamic SQL, using XML dynamic elements while avoiding mixing SQL code and
SQL parameters. But it also offers the possibility to concatenate input parameters directly into SQL statements, using the
$field$ or ${field} constructs. They are often used in GROUP BY and ORDER BY clauses, and when certain elements like
column lists or table names need to be modified.

The rule checks for those concatenation constructs, emitting a violation on each SQL operation that uses them, as they could
be potential avenues for SQL injection attacks.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid SQL injection flaws in the iBatis / MyBatis mapping configurations.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- VIOLATION, dynamic concatenation variables $altFilter$ and $orderedFields[]$ -->
<!-- Suppose that altFilter is either empty or contains the fragment AND COL_2 = '...' -->
<select id="mySelect" parameterClass="map" resultMap="myRowMapperVO">
  SELECT * FROM MYTABLE
  WHERE COL_1 = #data.col_1#
  $altFilter$
  <isNotEmpty property="orderBy">
  ORDER BY $orderBy$
  </isNotEmpty>
</select>]]></example>
    <repair><![CDATA[<select id="mySelect" parameterClass="map" resultMap="myRowMapperVO">
  SELECT * FROM MYTABLE
  WHERE COL_1 = #data.col_1#
  <isNotEmpty property="data.col_2">
  AND  COL_2 = #data.col_2#
  </isNotEmpty>
  <dynamic prepend="ORDER BY">
    <isEqual property="orderBy" compareValue="COL_1">COL_1</isEqual>
    <isEqual property="orderBy" compareValue="COL_2">COL_2</isEqual>
    <isEqual property="orderBy" compareValue="COL_3">COL_3</isEqual>
  </dynamic>
</select>]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/89.html,https://www.securecoding.cert.org/confluence/display/java/IDS00-J.+Prevent+SQL+injection]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS00-J,CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InadequatePaddingRule" message="InadequatePaddingRule: Inadequate padding" class="com.optimyth.qaking.security.rules.java.InadequatePaddingRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Accountability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[When used in practice, encryption algorithms are generally combined with some padding scheme. 
The goal of the padding scheme is to prevent a number of attacks that potentially work against the encryption algorithm without padding.

The rule can be parameterized to specified which methods of which classes have to be checked:
- allowedPaddings: comma-separated list of allowed paddings.
- encryptionMethodsSignature: comma-separated list of encryption methods signatures. It should be specified in a certain way: ClassName.methodName/parameterPosition (where 'parameterPosition' is a number that indicates the position that the 'transformation' string parameter occupies between the encryption method arguments: Class1.encryptMethod/2,Class2.otherEncryptMethod/1, ... )

NOTE: do not mistake the position of the 'transformation' string parameter in the method arguments with the 'padding' part of the transformation string for encryption calls such as Cipher.getInstance(). For example:
Cipher.getInstance/1 corresponds to Cipher.getInstance("RSA/NONE/PKCS5Padding", provider) where "RSA/NONE/PKCS5Padding" (first argument) is encoded with the number '1' in the list of signatures although the padding is encoded in the third place of the transformation string.

CGM mode doesn't require a padding.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private static final String TRANSFORMATION = "RSA/NONE/NoPadding";
//...
Cipher c = Cipher.getInstance("RSA/NONE/NoPadding");     //VIOLATION
Cipher c = Cipher.getInstance(TRANSFORMATION);           //VIOLATION

//The rule can lead to some false negatives, for example:
private static final String TRANSFORMATION = "RSA/NONE/NoPadding";
public String getTransformation(){
  return TRANSFORMATION;
}
// ...
Cipher cipher = Cipher.getInstance(getTransformation());  //NOT VIOLATION, BUT FALSE NEGATIVE]]></example>
    <repair><![CDATA[private static final String TRANSFORMATION = "RSA/NONE/PKCS5Padding";
//...
Cipher c = Cipher.getInstance("RSA/NONE/PKCS5Padding");     // OK
Cipher c = Cipher.getInstance(TRANSFORMATION);              // OK]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/325.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:325,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="encryptionMethodsSignature" descname="Comma-separated list of encryption methods signatures" value="Cipher.getInstance/1"/>
      <property name="allowedPaddings" descname="Comma-separated list of allowed algorithms" value="PKCS5Padding,OAEPPadding"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InformationExposureThroughDebugLog" message="InformationExposureThroughDebugLog: Avoid exposing sensible information through log" class="com.optimyth.qaking.security.rules.java.InformationExposureThroughDebugLog" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:7.1.1,ASVS-v4.0.2:7.1.2,ASVS-v4.0.2:8.3.5,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Logs can be very helpful at development stages but they should be used on later stages
because they can show rewarding information.

When a log shows sensible information, it can create a security leak, making useless any other system protection
mechanisms. Also sensible data can have many legal implications due to the established limitations about personal
information storage.

This rule reports violation when the log shows information that could be considered sensible.]]></description>
    <priority>4</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding exposing sensible data improves security because it could provide rewarding information to a malicious attacker.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.util.logging.Logger;
import java.net.InetAddress;

public class Sample {

	private Logger logger = Logger.getLogger("com.my.Log");

	public void method () {
		InetAddress machine = null;

		try {
			machine = InetAddress.getByName (name);

		} catch (UnknownHostException e) {
			logger.severe(name + "," + machine.getHostAddress() + "," + e.toString());		// VIOLATION
		}
	}
}]]></example>
    <repair><![CDATA[Avoid logging sensible data.]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/FIO13-J.+Do+not+log+sensitive+information+outside+a+trust+boundary,https://cwe.mitre.org/data/definitions/532.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:FIO13-J,CWE:532,CWETOP25:2021:39]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InformationExposureThroughErrorMessage" message="InformationExposureThroughErrorMessage: Avoid sensitive information exposure through error messages" class="com.optimyth.qaking.security.rules.java.InformationExposureThroughErrorMessage" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.1,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[When an error message is generated, care should be taken to ensure that it does not contain
sensitive information about the environment, users or any other information that may be considered sensitive.

Such information may be valuable itself or may be useful for further attacks with a higher impact.

Also attention should not only be paid to information explicitly included into error messages (for example by using System.out.println),
but also to certain functions that may produce an error that unexpectedly shows sensitive information, like when using the
constructor of FileInputStream class. In this situations it is necessary to check that the possible errors are handled somehow.

NOTE: This rule excludes JSPs because auto generated code cay produce several FPs.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid sensitive information leakage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[try {
  doSomething();

} catch (SecurityException e) {
  System.out.println(e.toString()); //VIOLATION
}]]></example>
    <repair><![CDATA[try {
  doSomething();

} catch (SecurityException e) {
  System.out.println("Something was wrong"); //FIXED
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/209.html,http://projects.webappsec.org/w/page/13246936/Information%20Leakage,https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:ERR01-J,CWE:209,OWASP:2021:A4,WASC:13]]></security>
    </normatives>
    <properties>
      <property name="allowThrowingExceptions" descname="When true, throwing an exception will not be reported by this rule." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsecureRandomnessRule" message="InsecureRandomnessRule: Standard pseudo-random number generators cannot withstand cryptographic attacks" class="com.optimyth.qaking.security.rules.java.InsecureRandomnessRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.3.1,ASVS-v4.0.2:2.6.2,ASVS-v4.0.2:2.9.2,ASVS-v4.0.2:6.3.1,ASVS-v4.0.2:6.3.2,ASVS-v4.0.2:6.3.3,CWEScope:Access-Control,CWEScope:Confidentiality,crypto,prng]]></tags>
    <description><![CDATA[Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness
in a security-sensitive context: security tokens (like anti-CSRF or password-reset tokens), values used in cryptographic
operations (session key material, initialization vector in block or stream ciphers), or password seeds.

Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators
(PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.

There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties,
but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use
in cases where security depends on generated values being unpredictable.

Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be
cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between it
and a truly random value.

In general, if a PRNG algorithm is not advertised as being cryptographically secure, then it is probably a
statistical PRNG and should not be used in security-sensitive contexts, where its use can lead to serious vulnerabilities
such as easy-to-guess temporary passwords, predictable cryptographic keys, or session hijacking, among others.

The rule also checks that the standard java.security.SecureRandom is initialized properly, which basically means that
its setSeed() method is not called with any seed generated by custom code, except SecureRandom.getSeed(int) or
SecureRandom.generateSeed(int), which are accepted as a proper seed with "adequate entropy".]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// A statistical PRNG used to generate random passwords (security context).

// VIOLATION, seed (and consequently each generated random value) could be predicted
private final Random rand = new Random(System.currentTimeMillis());

public String generateRandomPassword() {
  // used in a security context
  return Integer.toString(rand.nextInt(Integer.MAX_VALUE));
}]]></example>
    <repair><![CDATA[// Instantiate SecureRandom pero do NOT call setSeed().
// The PRNG will be seeded before generating first random value using sources with reasonable entropy.
// Specify at least the algorithm (and provider when possible)
// Periodically discard SecureRandom instance and create a new one
private final SecureRandom rand = SecureRandom.getInstance("SHA1PRNG"); // FIXED

public String generateRandomPassword() {
  return Integer.toString(rand.nextInt(Integer.MAX_VALUE));
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/MSC63-J.+Ensure+that+SecureRandom+is+properly+seeded,http://cwe.mitre.org/data/definitions/338.html,https://www.cigital.com/blog/proper-use-of-javas-securerandom/,https://cwe.mitre.org/data/definitions/330.html/,https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Gene]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC02-J,CERT-J:MSC63-J,CWE:330,CWE:338,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="checkSecurityContext" descname="When this property is enabled only the usages under a security context will be reported. Else every usage will be reported." value="true"/>
      <property name="pattern" descname="Regular expression for sensitive methods where non secure PRNG generation is not allowed" value="password|passwd|session|user|key|csrf|token|hash|digest|uuid|guid"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsecureSSL" message="InsecureSSL: Insecure SSL configuration" class="com.optimyth.qaking.security.rules.java.InsecureSSL" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:9.2.4,CWEScope:Access-Control,CWEScope:Authentication,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,essential,ssl]]></tags>
    <description><![CDATA[The SSL standard provides guidelines on how to perform proper SSL validation checks on the client side.
They are not part of the standard, anyway. The implementation of the validation logic is left to the application developer,
that should setup SSL-related classes adequately.

Creating or configuring proper SSL validation checks is complex, and developers may fail providing a secure
SSL configuration. No certificate validity checks, no certificate chain signature verification, no or improper
server hostname validation (with respect to the identity contained in the server certificate) are common flaws
that this rule tries to discover.

Often, developers provide trust managers for accepting self-signed certificates, or even ignore certificate
state to allow expired or revoked certificates. Alternatively, the hostname validation is disabled to avoid
errors when the name in the certificate does not match the target hostname. Android apps often present such flaws.

The problem with flawed SSL configuration is that it may allow man-in-the-middle attacks and other issues,
see references for full details.

The rule checks for SSL flaw patterns: non-default custom SSL socket factories, and too permissive TrustManagers /
SSLSocketFactories, or HostnameVerifiers with permissive verification strategies.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid main-in-the-middle and other attacks that proper SSL configuration should avoid.]]></benefits>
    <inconvenients><![CDATA[Closing the gaps opened by a flawed SSL configuration may produce connection errors with certain hosts.]]></inconvenients>
    <example><![CDATA[// Any server certificates are accepted
X509TrustManager trustAnything = new X509TrustManager() {
  @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {}
  @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {}
  @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0];}
};

SSLContext ctx = SSLContext.getInstance("SSL");

// VIOLATION, flawed customized SSL verification
ctx.init(null, new TrustManager[]{trustAnything}, SecureRandom.getInstance("SHA1PRNG"));

HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
URL url = new URL("https://spoofable.mybank.com/online-banking");
return url.openConnection().getInputStream();]]></example>
    <repair><![CDATA[SSLContext ctx = SSLContext.getInstance("SSL");

// FIXED, null here means to use the default (with proper validations) implementation
ctx.init(null, null, SecureRandom.getInstance("SHA1PRNG"));

HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
URL url = new URL("https://spoofable.mybank.com/online-banking");
return url.openConnection().getInputStream();]]></repair>
    <reference><![CDATA[An Analysis of Android SSL (In)Security - http://android-ssl.org/files/p50-fahl.pdf,https://cwe.mitre.org/data/definitions/296.html,https://www.securecoding.cert.org/confluence/display/java/MSC00-J.+Use+SSLSocket+rather+than+Socket+for+secure+data+exchange,https://cwe.mitre.org/data/definitions/297.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC00-J,CWE:296,CWE:297,CWE:298,CWE:299,OWASP:2021:A2,OWASP:2021:A7,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsecureTransport" message="InsecureTransport: Insecure transport" class="com.optimyth.qaking.security.rules.java.InsecureTransport" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.1.1,ASVS-v4.0.2:6.1.2,ASVS-v4.0.2:6.1.3,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Communications sent over HTTP (Hypertext Transfer Protocol) protocol are in plain text, so
they are fully exposed to attacks such as man in the middle. This situation is not acceptable when sensible information
is being communicated.

Using HTTPS (Hypertext Transfer Protocol Secure) allows to perform encrypted connections between the user and the server
using SSL (Secure Sockets Layer) or TLS (Transport Layer Security) certificates. These certificates use an asymmetric
public key infrastructure (PKI) system, which consists in two keys, one of them public distributed to the users, and the
other private stored into the server.

When a connection to a web page is started the server sends a SSL/ TSL certificate to the user's browser, and then they
establish a secure connection.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improve security at the transport layer, avoiding interception of potential sensible data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.net.URL;

String myURL = "http://myorg.com/myapi";
loadPage(new URL(myURL)); // VIOLATION]]></example>
    <repair><![CDATA[import java.net.URL;

// FIXED - Use HTTPS protocol
String myURL = "https://myorg.com/myapi";
loadPage(new URL(myURL));]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/326.html,http://cwe.mitre.org/data/definitions/311.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:311,OWASP:2021:A4,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="checkFtpConn" descname="When true then insecure FTP connections are checked too." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsufficientKeySizeRule" message="InsufficientKeySizeRule: Weak cryptography, insufficient key length" class="com.optimyth.qaking.security.rules.java.InsufficientKeySizeRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.6.1,ASVS-v4.0.2:1.6.2,ASVS-v4.0.2:1.6.3,ASVS-v4.0.2:1.6.4,ASVS-v4.0.2:2.6.3,ASVS-v4.0.2:2.7.6,ASVS-v4.0.2:2.8.2,ASVS-v4.0.2:2.8.3,ASVS-v4.0.2:2.9.1,ASVS-v4.0.2:6.2.1,ASVS-v4.0.2:6.2.3,ASVS-v4.0.2:6.2.4,ASVS-v4.0.2:6.2.5,ASVS-v4.0.2:6.2.6,ASVS-v4.0.2:6.2.7,ASVS-v4.0.2:6.4.2,ASVS-v4.0.2:9.1.2,ASVS-v4.0.2:9.1.3,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[A robust cryptographic algorithm (like RSA or AES) with a small key length could be vulnerable to brute-force type attacks.

For symmetric ciphers, AES-CBC (FIPS 197) is the most often recommended algorithm nowadays, with a block size of at least
64 bits (128 bits for the better). Recommended minimum key length for AES is 128 bits for most usages, but for long-range
security, 192 bits or even 256 bits are often recommended.

DES and DESede (or "triple-DES") are, nowadays, not robust enough for most applications. Many algorithms used in the past,
like Blowfish or RC2, are now deemed insecure.

For asymetric cryptography ("public key"), the algorithm most often used is RSA. Most experts consider 2048 as the
most adequate key length for common needs, as its usage in digital signature and other applications demand cryptographic
robustness for a long period of time. Experts now consider 1024 bits for RSA keys (modulus) not enough secure.

Algoritms based on elliptic curves cryptography (like EC-DSA) typically require smaller key sizes, around 200 bits.

See http://www.keylength.com for an interactive site showing current recommendations in cryptographic algorithms,
key length and other issues to take into account.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private static final String RSA = "RSA";
private static final int SIZE_MIN = 512;
// ...
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(512); //VIOLATION

KeyPairGenerator kg = KeyPairGenerator.getInstance(RSA);
kg.initialize(SIZE_MIN); //VIOLATION]]></example>
    <repair><![CDATA[private static final String RSA = "RSA";
private static final int SIZE_MIN = 2048;
// ...
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048); //OK

KeyPairGenerator kg = KeyPairGenerator.getInstance(RSA);
kg.initialize(SIZE_MIN); //OK]]></repair>
    <reference><![CDATA[http://www.keylength.com/,http://cwe.mitre.org/data/definitions/320.html,http://cwe.mitre.org/data/definitions/326.html,http://cwe.mitre.org/data/definitions/310.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:310,CWE:320,CWE:326,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="minKeySize" descname="Comma-separated list of minimum key size per algorithms" value="RSA/2048, DSA/2048, EC/256, AES/128, DiffieHellman/2048"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsufficientSessionExpirationRule" message="InsufficientSessionExpirationRule: Checks that session expiration interval is positive and does not exceed a limit" class="com.optimyth.qaking.security.rules.java.InsufficientSessionExpirationRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.8.1,ASVS-v4.0.2:2.8.6,ASVS-v4.0.2:3.3.1,ASVS-v4.0.2:3.3.2,ASVS-v4.0.2:3.3.3,ASVS-v4.0.2:3.3.4,ASVS-v4.0.2:3.6.1,ASVS-v4.0.2:3.6.2,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Checks that when setting in code (HttpSession.setMaxInactiveInterval()) a session
expiration interval, interval is not negative or zero (no expiration) and does not exceed a maximum interval.

If a negative interval is set, session never expires. If exceeds the maxExpiration parameter, session lives too much
time and it is considered a security issue.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Controlling session expiration interval improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpSession;

public class InsufficientSessionExpiration {

  public void bad(HttpSession session) {
    session.setMaxInactiveInterval(-1);   // VIOLATION
  }

  public void bad2(HttpSession session) {
    session.setMaxInactiveInterval(4*SECONDS_PER_HOUR);   // VIOLATION
  }

}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpSession;

public class InsufficientSessionExpiration {

  private static final int SECONDS_PER_HOUR = 60*60;

  public void ok(HttpSession session) {
    session.setMaxInactiveInterval(SECONDS_PER_HOUR);   // OK
  }

}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/613.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:613,OWASP:2021:A7]]></security>
    </normatives>
    <properties>
      <property name="maxExpiration" descname="Max time expiration allowed (seconds)" value="7200"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.J2eeFileDisclosureRule" message="J2eeFileDisclosureRule: File disclosure in server-side J2EE forward/include" class="com.optimyth.qaking.security.rules.java.J2eeFileDisclosureRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.12.1,ASVS-v4.0.2:12.5.1,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Constructing a server-side forward/include with user-controlled input could allow an attacker to view arbitrary files
and configuration files, or download application binaries (including application classes or jar files),
within protected directories (e.g. /WEB-INF).

If a user-controlled input (a request parameter, for example) is used as the relative path for a forward/include,
the attacker may force the vulnerable web resource to return the contents of a sensitive file. For example,
using "WEB-INF/web.xml" the attacker may view the J2EE web application configuration file. With "WEB-INF/lib/mySensitiveLibrary.jar"
the attacker may download the code for a library that should not be exposed. The attacker may gain important
information to launch other attacks.

NOTE: Even when the application server denies to serve resources under certain directories (like WEB-INF),
application code should not present this flaw to avoid issues when porting to other application server or
after changes in the configuration.

The rule checks for server-side forward/include using the servlet API, where the target relative URL could be tainted with
user-controlled input.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid attacks directed to accessing sensitive web application resources.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<% String header = request.getParameter("header"); %>
<jsp:include page="<%=header%>" /> <!-- VIOLATION -->]]></example>
    <repair><![CDATA[<%
  String header = (String)request.getAttribute("header"); // set by controller in server-side
  String headerUrl = application.getAttribute("MyUrlMapper").fetch(dest);
  if(headerUrl==null) headerUrl = "/emptyHeader.jsp";
%>
<jsp:include page="<%=headerUrl%>" />]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/552.html,https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet]]></reference>
    <normatives>
      <security><![CDATA[CWE:552,OWASP:2021:A1,PCI-DSS:6.5.1,WASC:38]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.JSONInjection" message="JSONInjection: Avoid using non-neutralized user-controlled input into JSON entities - JSON Injection" class="com.optimyth.qaking.security.rules.java.JSONInjection" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.6,ASVS-v4.0.2:13.3.2,ASVS-v4.0.2:3.5.3,CWEScope:Integrity]]></tags>
    <description><![CDATA[Unvalidated untrusted input is concatenated to a JSON stream, which is sent as request to a potentially service.
This allows an attacker to inject tailored content that change the semantics of the original JSON message.

Depending on how the JSON-formatted data is later used, the attacker could execute unexpected dynamic code, or
escape from authentication or authorization controls. If the resulting JSON string is evaluated in JavaScript
(JavaScript may eval a string and treat it as an array or JavaScript object), the attacker may add additional
code (for example, an attack payload like "'}; while(1); //" that could produce a denial-of-service condition.

Note: Do not confuse this issue with JSON (or JavaScript) hijacking, which is a browser-side vulnerability
where an attacker can steal sensitive information sent as JSON to victim's browser.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid JSON Injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import javax.servlet.http.HttpServletRequest;

public void sendJsonMessage(HttpServletRequest req) throws IOException {
  String username = req.getParameter("username");
  String password = req.getParameter("password");
  String jsonFragment = req.getParameter("jsonFragment");

  StringWriter sw = new StringWriter(1024);
  JsonGenerator gen = new JsonFactory().createGenerator(sw);
  gen.writeStartObject();

  gen.writeFieldName("username");
  gen.writeRawValue("\"" + username + "\""); // VIOLATION

  gen.writeFieldName("password");
  gen.writeRawValue("\"" + password + "\""); // VIOLATION

  gen.writeFieldName("role");
  gen.writeRawValue("\"default\"");

  gen.writeRaw(jsonFragment); // VIOLATION

  gen.writeEndObject();
  gen.close();

  sendJsonToSensitiveSite(sw.toString());
}]]></example>
    <repair><![CDATA[// Do not use writeRawValue() or writeRaw();
// use instead other writeXYZ() methods that escape properly inputs
// so they cannot change the semantics of the JSON elements built.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/345.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:91,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.LdapInjectionRule" message="LdapInjectionRule: Avoid non-neutralized user-controlled input in LDAP search filters" class="com.optimyth.qaking.security.rules.java.LdapInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.7,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software constructs all or part of an LDAP query using externally-influenced input, but it does not neutralize or
    incorrectly neutralizes special elements that could modify the intended LDAP query when sent to LDAP server.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.io.FileFilter;
import java.util.Properties;

public class LdapInjection {

  public NamingEnumeration ldapInjection(HttpServletRequest req, Properties env) throws NamingException {
    String base = "cn=root";
    String address = req.getParameter("input");
    DirContext context = new InitialDirContext(env);
    String query = "MyAttribute=" + address;
    return context.search(base, query, null);   // VIOLATION
  }

}]]></example>
    <repair><![CDATA[// Neutralize external input (e.g. address) before usage in query]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/IDS54-J.+Prevent+LDAP+injection,http://cwe.mitre.org/data/definitions/90.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS54-J,CWE:90,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:29]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.LogForging" message="LogForging: Improper Output Neutralization for Logs" class="com.optimyth.qaking.security.rules.java.LogForging" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:7.3.1,ASVS-v4.0.2:7.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[When the application writes untrusted input to a log destination (using any Java logging API),
a "log forging" attack could be launched to inject false log entries, corrupt log entries,
or even exploit a vulnerability in an external "log viewer" application.

Corrupted log entries could hinder detection for malicious activity, or implicate another party
in the commission of a malicious act.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import org.apache.log4j.Logger;
import javax.servlet.http.HttpServletRequest;

public class X {
  private static final Logger log = Logger.getLogger(X.class);
  public void doSomething(HttpServletRequest req) {
   String field = req.getParameter("hiddenField");
   try {
     int intVal = Integer.parseInt(field);
     // ...
   } catch (NumberFormatException nfe) {
     log.info("Cannot parse integer: " + field);
   }
  }
}]]></example>
    <repair><![CDATA[// Neutralize message with untrusted input, before passing to logging API
// See http://www.jtmelton.com/2010/09/21/preventing-log-forging-in-java/

public static String neutralizeMessage(String message) {
  // ensure no CRLF injection into logs for forging records
  String clean = message.replace( '\n', '_' ).replace( '\r', '_' );
  if ( ESAPI.securityConfiguration().getBooleanProp("Logger.LogEncodingRequired") ) {
      clean = ESAPI.encoder().encodeForHTML(clean);
      if (!message.equals(clean)) {
          clean += " (Encoded)";
      }
  }
  return clean;
}]]></repair>
    <reference><![CDATA[IDS03-J - Do not log unsanitized user input (CERT-J),https://cwe.mitre.org/data/definitions/117.html,http://www.jtmelton.com/2010/09/21/preventing-log-forging-in-java/,https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS03-J,CWE:117,OWASP-M:2016:M7,OWASP:2021:A9,PCI-DSS:10.5.2,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.MailCommandInjection" message="MailCommandInjection: Mail Command Injection" class="com.optimyth.qaking.security.rules.java.MailCommandInjection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Integrity]]></tags>
    <description><![CDATA[Mail command injection vulnerabilities occur when an attacker can influence the commands sent to an SMTP, POP3, or IMAP mail server.
If the library or the developer fails to safely encode the line breaks, an attacker controlling any of the arguments for these commands
will be able to inject line breaks and new commands after them.

As line breaks are the usual mechanism that attackers use to change the expected behaviour, this vulnerability
is considered a special CRLF Injection attack.

What the attacker may launch by exploting a Mail Command Injection vulnerability include:
- Generate spam (SMTP). The application acts as a "mail proxy" that attackers may use to create spam messages.
- Read messages from other users (POP3/IMAP).
- Abusing a trusted server to send HTML emails with malicious contents.
- Change authentication or security options, to skip security controls in mail servers.

See "MX Injection: Capturing and Exploiting Hidden Mail Servers", from Vicente Aguilera, for a full description on
the benefits that an attacker may gain.

The rule checks when vulnerable mail libraries are called with untrusted input, without validation, which might be vulnerable
to Mail Command Injection attacks.

Note: Many common java libraries, for example JavaMail, Apache Commons-Net, or Spring Mail support, are still vulnerable.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid Mail Command Injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.mail.*;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
// ...
String subject = request.getParameter("subject"); // untrusted
String message = request.getParameter("message");

Message msg = new MimeMessage(session);
msg.setSentDate(new Date());
msg.setFrom(new InternetAddress(userName));
msg.addRecipient(Message.RecipientType.TO, new InternetAddress(toAddress));
msg.setSubject(subject); // VIOLATION, vulnerable to mail command injection
msg.setText(message);

Transport.send(msg);]]></example>
    <repair><![CDATA[// validate untrusted subject input with a white-list strategy,
// or at least ensure that line breaks (CR/LF) are removed from subject.]]></repair>
    <reference><![CDATA[OWASP Testing for IMAP/SMTP injection: https://www.owasp.org/index.php/Testing_for_IMAP/SMTP_Injection_(OTG-INPVAL-011),http://www.webappsec.org/projects/articles/121106.pdf,http://projects.webappsec.org/w/page/13246948/Mail%20Command%20Injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:93,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:30]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.NonRandomIVWithCBCMode" message="NonRandomIVWithCBCMode: Not using a Random IV with CBC Mode" class="com.optimyth.qaking.security.rules.java.NonRandomIVWithCBCMode" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,crypto,essential]]></tags>
    <description><![CDATA[Not using a random initialization Vector (IV) with Cipher Block Chaining (CBC) Mode causes encryption to be susceptible to dictionary attacks.

CBC mode with predictable IV allows a well-known chosen plaintext attack, and is definitely unsecure.

Note: For other feedback modes, NIST recommends unpredictable IVs for CFB, and unique (non-repeating, like an increasing counter or message number) IVs
for OFB, CTR or PCBC, and for GCM plus other authenticated encryption modes, but certainly the IV should not be eligible by an attacker.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public void encrypt(SecretKey key) throws GeneralSecurityException {
  Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); // CBC mode
  byte[] predictableIV = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; // hardcoded IV, obviously predictable
  cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(predictableIV)); // VIOLATION
  // ...
}]]></example>
    <repair><![CDATA[public void encrypt(SecretKey key) throws GeneralSecurityException {
  Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); // CBC mode
  byte[] randomIV = new byte[16];
  new SecureRandom().nextBytes(randomIV);
  cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(randomIV)); // FIXED, random IV
  byte[] encodedIV = cipher.getParameters().getEncoded(); // needed for decryption, along with ciphertext
  // ...
}]]></repair>
    <reference><![CDATA[https://crypto.stackexchange.com/questions/3515/is-using-a-predictable-iv-with-cfb-mode-safe-or-not,http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:329,OWASP:2021:A2,PCI-DSS:3.6.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.NoSQLInjection" message="NoSQLInjection: Improper neutralization of special elements in data query logic (NoSQL injection)" class="com.optimyth.qaking.security.rules.java.NoSQLInjection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,NoSQL]]></tags>
    <description><![CDATA[The application generates a query intended to access or manipulate data in a data store such as a NoSQL database,
but it does not neutralize or incorrectly neutralizes special elements that can modify the intended logic of the query.

Depending on the capabilities of the query language, an attacker could inject additional login into the query to:
- Modify the intended selection criteria, thus changing which data entities (e.g., records) are returned, modified, or otherwise manipulated.
- Append additional commands to the query.
- Return more or fewer entities than intended.
- Cause entities to be sorted in an unexpected way.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent NoSQL injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import com.mongodb.*;
import com.mongodb.util.JSON;

public class LoginController {
  private DBCollection users = fetchUsersCollection();

  public User authenticate(HttpServletRequest req) {
    String user = req.getParameter("user"); // attacker-controlled
    String pass = req.getParameter("pass"); // attacker-controlled

    // The query object is tainted with non-neutralized untrusted input (user)
    String json = String.format("{ 'username' : '%s', 'password' : '%s' }", user, pass);
    // We parse here whatever JSON the attacker wishes to create...
    // $or operator is a common way to change query semantics
    // Attackers may even encode arbitrary JavaScript code in $where operator, if enabled
    DBObject dbQuery = (DBObject) JSON.parse(json);

    DBObject matched = users.findOne(dbQuery); // VIOLATION, NoSQL injection

    return matched != null ? User.from(matched) : null;
  }
}]]></example>
    <repair><![CDATA[import com.mongodb.*;
import com.mongodb.util.JSON;

public class Login {
  private DBCollection users = fetchUsersCollection();

  public User authenticate(HttpServletRequest req) {
    String user = req.getParameter("user");
    String pass = req.getParameter("pass");
    String passHash = computePasswordHash(user, pass);

    // FIXED, each key/value appended to BasicDBObject are encoded properly
    BasicDBObject dbQuery = new BasicDBObject("username", user).append("password", passHash);

    DBObject matched = users.findOne(dbQuery); // safe

    return matched != null ? User.from(matched) : null;
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/943.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:943,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.OpenRedirectRule" message="OpenRedirectRule: URL Redirection to Untrusted Site ('Open Redirect')" class="com.optimyth.qaking.security.rules.java.OpenRedirectRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.5,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a redirect.
This is client-side redirect, either by setting the Location header or by calling HttpServletResponse sendRedirect() method.

If the redirect URL is user-controlled (e.g. fetched from HTTP request parameter), an attacker may force an user to
provide a malicious URL encoded in a link to the vulnerable resource. The browser will redirect to the malicious URL,
and the attacker may deceive the victim user for phising or other malicious activities.

The rule checks for client-side redirections in server-side code, using servlet API. Redirections based on HTTP
headers "Location" and "Refresh" are also checked.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limits phising attacks, and unintended client-side redirections.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<%
  String dest = request.getParameter("dest");
  response.sendRedirect(dest); // VIOLATION
  response.setHeader("Location", dest); // OTHER VIOLATION
  response.setHeader("Refresh", "0;url="+dest); // OTHER VIOLATION
%>]]></example>
    <repair><![CDATA[<%
  String dest = (String)request.getAttribute("dest");
  String url = application.getAttribute("MyUrlMapper").fetch(dest);
  if(url==null) {
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
  } else {
    response.sendRedirect(dest); // FIXED
  }
%>]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet,http://cwe.mitre.org/data/definitions/601.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:601,CWETOP25:2021:37,OWASP:2013:A10,PCI-DSS:6.5.1,WASC:38]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PasswordInCommentRule" message="PasswordInCommentRule: Avoid hard-coded or in-comment passwords in code" class="com.optimyth.qaking.security.rules.java.PasswordInCommentRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Hardcoded passwords can compromise system security in a way that cannot be easily remedied.
It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem 
extremely difficult. Once the code is in production, the password cannot be changed without patching the software.
If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.

The rule checks if there are comments in the code that contain expressions that match with the pattern, so it can lead to several false positives and/or false negatives.

This rule not only applies to Java comments but only to HTML comments included into an HTTP response, however to allow this it's mandatory to enable the processHTMLEmbeddedComments
property.]]></description>
    <priority>5</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// password is: mypazzw0rk                               -> VIOLATION
// password is the first argument                        -> VIOLATION, BUT FALSE POSITIVE
// magic word for connecting to database is: mypazzw0rk  -> NOT VIOLATION, BUT FALSE NEGATIVE

public void bad(HttpServletRequest request, HttpServletResponse response) throws Throwable
{
  response.getWriter().println("<!--DB username = amy, password = cat-->");  // VIOLATION
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/MSC03-J.+Never+hard+code+sensitive+information,http://cwe.mitre.org/data/definitions/615.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC03-J,CWE:615,OWASP:2021:A7,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="processHTMLEmbeddedComments" descname="When enabled HTML comments included into an HTTP response are also analyzed." value="false"/>
      <property name="pattern" descname="Password pattern" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PasswordInConfigurationFile" message="PasswordInConfigurationFile: Use of credentials into configuration file" class="com.optimyth.qaking.security.rules.java.PasswordInConfigurationFile" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[Passwords written into a configuration file which is distributed along with the code are
visible to any person reading the source code. If the resource protected by such hardcoded credentials is important, this
may compromise system security.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid credential leakage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[[sample.properties]
my.secret.password=abcdefgh]]></example>
    <repair><![CDATA[Properties configuration file should not be distributed along with the project.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/260.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:260,OWASP:2021:A5]]></security>
    </normatives>
    <properties>
      <property name="pattern" descname="Regular expression for matching field names containing credentials." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PasswordInRedirectRule" message="PasswordInRedirectRule: Password Management - Password in Redirect" class="com.optimyth.qaking.security.rules.java.PasswordInRedirectRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.3,ASVS-v4.0.2:3.1.1,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Sending a password as part of an HTTP redirect will cause the password to be displayed, logged, or stored in a cache.
An HTTP redirect causes the user's web browser to issue an HTTP GET request. By convention, the parameters associated with an HTTP GET are not treated as sensitive data, 
so web servers log them, proxies cache them, and web browsers do not make an effort to conceal them.
Sending a password or other sensitive data as part of a redirect will likely cause the data to be mishandled and potentially revealed to an attacker.
The rule checks if there are parts of the redirect chain that contain expressions that match with the pattern, so it can lead to several false positives and/or false negatives.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public void method(HttpServletRequest req, HttpServletResponse res) throws IOException {
  res.sendRedirect("j_security_check?j_username=" + usr + "&j_password=" + pass);   //VIOLATION
  // ...
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/359.html,https://wiki.sei.cmu.edu/confluence/display/java/FIO52-J.+Do+not+store+unencrypted+sensitive+information+on+the+client+side]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:FIO52-J,CWE:598,OWASP:2021:A7,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="sendRedirectInResponseMethods" descname="Comma-separated list of send redirect methods" value="sendRedirect"/>
      <property name="passPattern" descname="Password key words pattern" value="(:|=|&amp;)[\w]*(?:password|passwd|contrase..?a|senha|passwort|mot\s+de\s+passe)\b"/>
      <property name="j_passwordPatter" descname="Password key words pattern" value="\b(j_password)\b"/>
      <property name="responseClasses" descname="Comma-separated list of response classes" value="javax.servlet.ServletResponse, ServletResponse, javax.servlet.http.HttpServletResponse, HttpServletResponse"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PathTraversalRule" message="PathTraversalRule: Avoid non-neutralized user-controlled input composed in a pathname to a resource" class="com.optimyth.qaking.security.rules.java.PathTraversalRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.1,ASVS-v4.0.2:12.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software uses external input to construct a pathname that is intended to identify a file or directory
that is located underneath a restricted parent directory, but the software does not properly neutralize
special elements within the pathname that can cause the pathname to resolve to a location outside the
restricted directory.

Under an application server, if the application server configuration does not restrict access to files outside
certain restricted directories, the attacker may fetch sensitive files, and if the file is written with contents
controlled by user input, the attacker may change configuration files (like web.xml among others), web contents
('web defacement'), or libraries (for more insidious code injection attacks). Access to system files
(the customary /etc/password in Unix/Linux systems) could also allowed with the app server account permissions.

It is recommended, besides ensuring that files depending on user-controlled input do not exit the intended directories,
that the OS account does have the minimal permissions, to reduce the impact of a successful path traversal attack.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;

public class PathTraversalCode {

  public InputStream indirectPathTraversal(HttpServletRequest req) throws IOException {
    String inputFile = req.getParameter("file");
    inputFile = inputFile + ".tmp";
    return new FileInputStream(SAFE_DIR.getAbsoluteFile() + inputFile);   // VIOLATION
  }

}]]></example>
    <repair><![CDATA[import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;

public class PathTraversalCode {

  public InputStream indirectPathTraversal(HttpServletRequest req) throws IOException {
    String inputFile = req.getParameter("file");
    inputFile = inputFile + ".tmp";
    String filename = new File(inputFile).getName();
    return new FileInputStream(new File(SAFE_DIR, filename));   // OK
  }

}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/22.html,http://cwe.mitre.org/data/definitions/73.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:22,CWE:73,CWETOP25:2021:8,OWASP:2021:A4,OWASP:2021:A5,PCI-DSS:6.5.8,WASC:33]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PlaintextStorageOfPassword" message="PlaintextStorageOfPassword: Plaintext Storage of a Password" class="com.optimyth.qaking.security.rules.java.PlaintextStorageOfPassword" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.7.5,CWEScope:Access-Control,credentials]]></tags>
    <description><![CDATA[Storing a password in plaintext may result in a system compromise.

Password management issues occur when a password is stored in plaintext in an application's properties or configuration file.
Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[FileInputStream is = new FileInputStream(CONFIG_FILE);
Properties config = new Properties();
config.load(is);

String dbHost = config.getProperty("db.host");
String dbUser = config.getProperty("db.user");
String dbPass = config.getProperty("db.pass");

Connection dbConn = DriverManager.getConnection(dbHost, dbUser, dbPass); // VIOLATION]]></example>
    <repair><![CDATA[FileInputStream is = new FileInputStream(CONFIG_FILE);
Properties config = new Properties();
config.load(is);

String dbHost = config.getProperty("db.host");
String dbUser = config.getProperty("db.user");
String encryptedDbPass = config.getProperty("db.pass");
String dbPass = decrypt(encryptedDbPass); // FIXED

Connection dbConn = DriverManager.getConnection(dbHost, dbUser, dbPass);]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/256.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:256,OWASP:2021:A4,PCI-DSS:6.3.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PlaySecurityMisconfiguration" message="PlaySecurityMisconfiguration: Security misconfiguration in Play framework." class="com.optimyth.qaking.security.rules.java.PlaySecurityMisconfiguration" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.9.1,ASVS-v4.0.2:13.2.3,ASVS-v4.0.2:2.2.5,ASVS-v4.0.2:4.2.2,ASVS-v4.0.2:5.3.3,ASVS-v4.0.2:8.3.1,ASVS-v4.0.2:9.1.1,ASVS-v4.0.2:9.2.2,Framework:Play]]></tags>
    <description><![CDATA[Play framework provides several filters that could block/mitigate common attacks in a web application.
These filters are configured in the application configuration files (like application.conf). In recent versions,
many filters are enabled and properly configured by default.

In particular, three filters are enabled by default:
- CSRFFilter, which provide protection against CSRF (cross-site request forgery) attacks, using a CSRF token that
  enables any sensitive action to execute only if the token is passed from another site resource, which avoids CSRF.

- SecurityHeadersFilter, which sets security-related HTTP headers for protection/mitigation of cross-site scripting,
  clickjacking, MIME sniffing, Adobe Flash cross-domain policy hijacking, Referer header leakage, and other security issues.

- AllowedHostsFilter, which sets a whitelist of hosts that can access the application. This is useful to prevent
  cache poisoning attacks.

In addition, a RedirectHttpsFilter (not enabled by default) could be enabled for redirecting all HTTP requests to HTTPS automatically.

Disabling these filters, or misconfiguring them with incorrect or too-permisive values, might open the avenue for security vulnerabilities.
The rule reports any suspicious configuration element.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[play.filters {
  # VIOLATION - CSRF filter disabled (when csrfFilter=true)
  disabled += play.filters.csrf.CSRFFilter
  # SecurityHeadersFilter and AllowedHostsFilter enabled unless disabled explicitly

  # VIOLATION - HTTPS Redirect not explcitly enabled (when redirectHttps=true)
  #enabled += play.filters.https.RedirectHttpsFilter

  # Security headers filter configuration
  headers {

    # VIOLATION - X-Frame-Options header not set.
    frameOptions = null

    # VIOLATION - X-XSS-Protection header disabled.
    xssProtection = "0"

    # VIOLATION - X-Content-Type-Options header not set to "nosniff".
    contentTypeOptions = null

    # VIOLATION - Too-permissive X-Permitted-Cross-Domain-Policies header.
    permittedCrossDomainPolicies = "all"

    # VIOLATION - Content-Security-Policy header not set.
    contentSecurityPolicy = null

    # VIOLATION - unsafe Referrer-Policy header.
    referrerPolicy = "unsafe-url"

    # VIOLATION - Allows an action to use .withHeaders to replace one or more of the above headers
    # (emittd when allowActionSpecificHeaders=true)
    allowActionSpecificHeaders = true
  }

  hosts {
    # VIOLATION - ".other.com" not allowed (when allowedHosts=localhost, .myorg.com)
    allowed = ["localhost", ".myorg.com", ".other.com"]
  }
}]]></example>
    <repair><![CDATA[play.filters {
  # Do not disable default filters, and enable RedirectHttpsFilter
  enabled += play.filters.https.RedirectHttpsFilter

  # Security headers filter configuration. When a value not specified, the default is deemed safe.
  headers {

    frameOptions = "DENY"

    xssProtection = "1"

    contentTypeOptions = "nosniff"

    permittedCrossDomainPolicies = "master-only"

    contentSecurityPolicy = "default-src 'self'"

    referrerPolicy = "origin-when-cross-origin, strict-origin-when-cross-origin"

    allowActionSpecificHeaders = false
  }

  hosts {
    allowed = ["localhost", ".myorg.com"]
  }
}]]></repair>
    <reference><![CDATA[https://nvisium.com/resources/blog/2017/10/04/play-2-6-security-analysis.html,https://www.playframework.com/documentation/2.6.x/resources/confs/filters-helpers/reference.conf,https://www.playframework.com/documentation/2.6.x/Filters]]></reference>
    <normatives>
      <security><![CDATA[CWE:183,CWE:319,CWE:352,CWE:693,CWE:79,CWETOP25:2021:2,CWETOP25:2021:35,CWETOP25:2021:9,OWASP:2021:A1,OWASP:2021:A2,OWASP:2021:A3,OWASP:2021:A4,WASC:47]]></security>
    </normatives>
    <properties>
      <property name="redirectHttps" descname="True if RedirectHttpsFilter should be enabled." value="false"/>
      <property name="allowActionSpecificHeaders" descname="True if it is allowed for actions to change the security headers programmatically." value="false"/>
      <property name="csrfFilter" descname="True if CSRFFilter should be enabled." value="true"/>
      <property name="allowedHosts" descname="Comma-separated list of allowed hosts. Leave empty to ignore the whitelist in app configuration." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PotentialInfiniteLoop" message="PotentialInfiniteLoop: Loop with Unreachable Exit Condition ('Infinite Loop')" class="com.optimyth.qaking.security.rules.java.PotentialInfiniteLoop" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,essential,potential-bug]]></tags>
    <description><![CDATA[The program contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.
Such infinite loop conditions are due typically to logical errors in the loop exit conditions and/or loop variables update,
where the loop exit condition is never reached.

An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory, and might compromise software availability.

NOTE: Rule OPT.JAVA.SEC_JAVA.UncheckedInputInLoopCondition (CWE-606) checks when an untrusted input, not validated, might influence
loop termination leading to a denial-of-service condition.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[T[][] arr = fetchArray();

for (int i=0; i < arr.length; i++) {
  T[] row = arr[i];
  // VIOLATION: infinite loop
  // a typo after copy+paste external loop, inner loop var j not updated
  for (int j=0; j < row.length; i++) {
     doSomething(row[j]);
  }
}]]></example>
    <repair><![CDATA[T[][] arr = fetchArray();

for (int i=0; i < arr.length; i++) {
  T[] row = arr[i];
  // FIXED
  for (int j=0; j < row.length; j++) {
     doSomething(row[j]);
  }
}]]></repair>
    <reference><![CDATA[https://blog.jooq.org/2015/01/16/infinite-loops-or-anything-that-can-possibly-go-wrong-does/]]></reference>
    <normatives>
      <security><![CDATA[CWE:835,CWETOP25:2020:36]]></security>
    </normatives>
    <properties>
      <property name="allowBooleanMethodsAsNeutralizers" descname="If true the methods defined in &quot;potentialInfiniteLoopNeutralizer&quot; will be considered as potential neutralizers of infinite loops.]" value="false"/>
      <property name="potentialInfiniteLoopNeutralizer" descname="Comma-separated list of methods that could neutralize an infinite loop. The methods must be indicated with the qualified name of the class, e.g., a.b.c.d(). ]" value=""/>
      <property name="allowExplicitInfiniteLoops" descname="Intentional non-empty infinite loops, coded as while(true) ó for(;;), are allowed." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ProcessControlRule" message="ProcessControlRule: Library loaded from untrusted source" class="com.optimyth.qaking.security.rules.java.ProcessControlRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.14.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,code-injection,scripting]]></tags>
    <description><![CDATA[Under Java, load() and loadLibrary() methods, in java.lang.System or java.lang.Runtime, load a native library.
For load(), the path to the library is specified, while for loadLibrary() the library name is specified and
a system-dependant search path is used (for example, java.library.path property, or LD_LIBRARY_PATH environmente variable).

If the argument depends on untrusted input (including in this category system environment or Java system properties),
a violation is emitted.

Additionally, any call to loadLibrary() (if rule property 'avoidLoadLibrary' is true) will produce a violation
of the rule, as according to the method documentation:

"Loads the dynamic library with the specified library name. A file containing native code is loaded from the
local file system from a place where library files are conventionally obtained. The details of this process are
implementation-dependent. The mapping from a library name to a specific filename is done in a system-specific manner",

so an attacker could place a malicious library with same name as the loaded library upper in the search path,
which may run with elevated privileges.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid native code injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  void m() {
    // considered unsafe if avoidLoadLibrary=true
    Runtime.getRuntime().loadLibrary("supposedlySafeLibInSearchPath"); /* VIOLATION */
  }

  // This is considered unsafe if allowSystemConfiguration=false
  private static final String PATH = System.getProperty("my.library.path");
  void m2() {
    File f = new File(PATH, "cannotSpoofMe.dll");
    System.load(f.getAbsolutePath()); /* VIOLATION */
  }]]></example>
    <repair><![CDATA[  void m() {
    // add a suppression or set avoidLoadLibrary=false
    Runtime.getRuntime().loadLibrary("supposedlySafeLibInSearchPath"); /* CONSIDERED SAFE */
  }

  // Set allowSystemConfiguration=true, or set allowSystemConfiguration=true
  private static final String PATH = System.getProperty("my.library.path");
  void m2() {
    File f = new File(PATH, "cannotSpoofMe.dll");
    System.load(f.getAbsolutePath()); /* CONSIDERED SAFE */
  }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/676.html,http://cwe.mitre.org/data/definitions/114.html,http://security.stackexchange.com/questions/35724/security-implications-of-javas-system-load-vs-system-loadlibrary]]></reference>
    <normatives>
      <security><![CDATA[CWE:114,CWE:494,CWE:676,OWASP:2021:A1,OWASP:2021:A8,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="allowSystemConfiguration" descname="If false, any kind of input is considered untrusted; if true, only user input is considered untrusted" value="false"/>
      <property name="avoidLoadLibrary" descname="If true, loadLibrary() method is always considered unsafe" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.RaceConditionFormatFlaw" message="RaceConditionFormatFlaw: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')" class="com.optimyth.qaking.security.rules.java.RaceConditionFormatFlaw" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.11.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,race-condition]]></tags>
    <description><![CDATA[A race condition happened when a code sequence runs concurrently with other code, and the code sequence needs exclusive
access to a shared resource, but a time window exists in which the shared resource can be modified by another code sequence.

In security-critical code, a race condition may have security implications, specially when a security decision is made
on class state affected by a race condition.

The Java language provides a simple primitive, synchronized blocks, for avoiding thread interference and memory consistency errors.
Race conditions typically appear with class state (mutable fields, static or not) is used in methods without synchronization blocks.
Objects of a class are said to be thread-safe when they always maintain a valid state, as observed by other objects,
in multi-threaded environments.

A traditional cause of race conditions in Java are classes in the standard library (JDK), and in particular the java.text.Format
subclasses (like NumberFormat, MessageFormat, DateFormat or SimpleDateFormat), which are not thread-safe.

This rule reports usages of methods in object fields of non thread-safe JDK classes, outside synchronized blocks.
JavaDoc for such classes include a note on synchronization; for example, for java.text.SingleDateFormat:
"Date formats are not synchronized. It is recommended to create separate format instances for each thread.
If multiple threads access a format concurrently, it must be synchronized externally."]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.text.SimpleDateFormat;
import java.util.Date;

public class X {
  private static final SimpleDateFormat DATE_FMT = new SimpleDateFormat("yyyy-MM-dd");

  public String format(Date date) {
    return DATE_FMT.format(date); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[import java.text.SimpleDateFormat;
import java.util.Date;
import org.apache.commons.lang3.time.FastDateFormat;
import java.time.format.DateTimeFormatter;

public class X {
  private static final SimpleDateFormat DATE_FMT = new SimpleDateFormat("yyyy-MM-dd");

  // Option #1 - synchronized block using mutable field as monitor object
  public String format2(Date date) {
    synchronized(DATE_FMT) {
      return DATE_FMT.format(date); // OK
    }
  }

  // Option #2 - add synchronized keyword to access method,
  // equivalent to method body enclosed in synchronized(this) block
  public synchronized String format3(Date date) {
    return sdf.format(date); // OK
  }

  // Option #3: Use a thread-safe date formatter API (like Apache commons-lang FastDateFormat)
  private static final FastDateFormat DATE_FORMATTER =
                       FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT);

  public String format4(Date date) {
    return DATE_FORMATTER.format(date); // OK, thread safe
  }

  // Option #4: Use Java8 DateTimeFormatter (immutable and thread-safe)
  private String format5(Date date) {
    return DateTimeFormatter.ISO_LOCAL_DATE.format(date);
  }
}]]></repair>
    <reference><![CDATA[http://stackoverflow.com/questions/6840803/simpledateformat-thread-safety,https://cwe.mitre.org/data/definitions/362.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:VNA02-J,CWE:362,CWETOP25:2021:33]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.RaceConditionServlet" message="RaceConditionServlet: Race Condition in a Java Servlet" class="com.optimyth.qaking.security.rules.java.RaceConditionServlet" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.11.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,race-condition]]></tags>
    <description><![CDATA[A race condition happened when a code sequence runs concurrently with other code, and the code sequence needs exclusive
access to a shared resource, but a time window exists in which the shared resource can be modified by another code sequence.

In security-critical code, a race condition may have security implications, specially when a security decision is made
on class state affected by a race condition.

HttpServlet is a singleton and so there is a unique instance. This way all threads runs the same instance of the servlet and access
the same fields.

This rule reports field declarations in Java Servelts.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServlet;

public class ExampleServlet extends HttpServlet {

    private Object thisIsNOTThreadSafe; //VIOLATION

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        thisIsNOTThreadSafe = request.getParameter("foo"); // BAD!! Shared among all requests!
    }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServlet;

public class ExampleServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Object thisIsThreadSafe; //OK
        thisIsThreadSafe = request.getParameter("foo"); // OK, this is thread safe.
    }
}]]></repair>
    <reference><![CDATA[https://stackoverflow.com/questions/3106452/how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreadi,https://securingtomorrow.mcafee.com/technical-how-to/testing-race-conditions-web-applications/,https://cwe.mitre.org/data/definitions/362.html,https://www.javaworld.com/article/2072798/java-web-development/write-thread-]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:VNA02-J,CWE:362,CWETOP25:2021:33]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ReflectedFileDownload" message="ReflectedFileDownload: Improper Neutralization of Input leads to Reflected File Download" class="com.optimyth.qaking.security.rules.java.ReflectedFileDownloadRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Reflected File Download (RFD) is a web attack vector that enables attackers to gain complete control over a victim’s
machine. It happens when the user follows a malicious link to a trusted domain resulting in a file download from that
domain. Once executed the attacker can execute commands on the Operating System level of the client’s computer.

In order for an attacker to run a successful RFD attack, the following requirements need to be met:
 - The application reflects user-controllable data.
 - The application allows attackers to treat the server response as a file download.
 - Attackers can prevent the content-disposition header from setting a file name, and at the same time can influence the
 URL in such a way that the browser will derive an attacker-controlled file name.
 - Attackers can control the content-disposition file name and extension.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
public class SampleController {
  @RequestMapping(value = {"/KO"}, method = RequestMethod.GET)
  public ResponseEntity<String> download(@RequestParam("filename") String fileName) {
    HttpHeaders headers = new HttpHeaders();
    headers.setContentDisposition(ContentDisposition.builder("attachment").filename(fileName + ".txt"));  // VIOLATION

    return ResponseEntity.ok()
      .headers(headers)
      .contentType(MediaType.parseMediaType("application/octet-stream"))
      .body(contents);
  }
}]]></example>
    <repair><![CDATA[import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
public class SampleController {
  @RequestMapping(value = {"/OK"}, method = RequestMethod.GET)
  public ResponseEntity<String> download(@RequestParam("filename") String fileName) {
    String safeFileName = org.apache.commons.io.FilenameUtils.getName(fileName);
    ContentDisposition contentDisposition = ContentDisposition.builder("attachment")
      .filename(safeFileName + ".txt") // Secure .txt file
      .build();
    HttpHeaders headers = new HttpHeaders();
    headers.setContentDisposition(contentDisposition);

    return ResponseEntity.ok()
      .headers(headers)
      .contentType(MediaType.parseMediaType("application/octet-stream"))
      .body(contents);
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html,https://securitylab.github.com/research/rfd-spring-mvc-CVE-2020-5398,https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/reflected-file-download-a-new-web-attack-vector/]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP-M:2016:M8,OWASP:2021:A3]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.RegexInjectionRule" message="RegexInjectionRule: Prevent denial of service attack through malicious regular expression ('Regex Injection')" class="com.optimyth.qaking.security.rules.java.RegexInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.1.1,CWEScope:Access-Control,ReDoS]]></tags>
    <description><![CDATA[If the software creates a regular expression ("pattern", "regex") from untrusted input, an attacker may supply
malicious input that produces a denial-of-service (DoS) condition during regular expression matching.

Alternatively, if the regular expression is used for input validation, the attacker-controlled regular expression
may fail to neutralize undesired input, which may bypass the intended restrictions or render useless
a security control.

In Java, the java.util.regex.Pattern class, and a few methods in java.lang.String class, provide
an API to regular expressions. The regular expression engine uses backtracking to match input strings,
and there are certain regular expressions (named "evil regexes") that take exponential time (relative to input size)
to match in the worst case.

If the attacker controls also the input to be matched, he/she could craft an input for the evil regex that
takes an inordinate amount of time to match, consuming resources (like CPU).
Evil regex typically has a group with repetition, and the repeated group has repetition or alternation with overlapping.
For example: "(a+)+", "([a-z]+)*", "(a|aa)+" or "(aa|aab?)*".

For example, a "(a+)+" regex will take long computing time when matching "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!"
takes many seconds to complete, and longer strings (with exponential time increase) may lead to DoS conditions.

Please note that regular expressions are often used for security controls and input validation.
Even OWASP validation regex repository contained some known evil regular expressions.
Note: Attackers may use tools like Google CodeSearch to find evil regex in open-source code ('CodeSearch hacking').

The rule checks for potential injection of untrusted input into regex APIs.

Note: Attacks like ReDoS are named "directed/intelligent/application" DoS, as an attacker with few resources
could render unavailable a web application, in contrast with brute-force DoS.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid DoS conditions produced by regular expression injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.util.regex.*;
import javax.servlet.http.HttpServletRequest;

public class WebValidation {
  public void check(HttpServletRequest req, String field) throws IllegalInputException {
    String regex = req.getParameter("validation_hidden_field"); // not so hidden...
    String input = req.getParameter(field);

    boolean isValid = Pattern.compile(regex) /* VIOLATION: easy path to DoS attack */
      .matcher(input).matches();

    if(!isValid) throw new IllegalInputException("Bad value for " + field);
  }
}]]></example>
    <repair><![CDATA[import java.util.regex.*;
import javax.servlet.http.HttpServletRequest;

public class WebValidation {
  public void check(HttpServletRequest req, String field) throws IllegalInputException {
    // never let regex coming from untrusted source
    String regex = MyRegexRepository.getRegex(field); /* FIXED */
    String input = req.getParameter(field);

    boolean isValid = Pattern.compile(regex)
      .matcher(input).matches();

    if(!isValid) throw new IllegalInputException("Bad value for " + field);
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/400.html,https://www.securecoding.cert.org/confluence/display/java/IDS08-J.+Sanitize+untrusted+data+included+in+a+regular+expression,https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS,https://en.wikipedia.org/wiki/ReDoS]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS08-J,CWE:400,CWETOP25:2021:27,OWASP:2004:A9,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.RequestParametersInSessionRule" message="RequestParametersInSessionRule: Request parameters should not be passed into Session without sanitizing" class="com.optimyth.qaking.security.rules.java.RequestParametersInSessionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.2,ASVS-v4.0.2:13.3.1,ASVS-v4.0.2:5.1.3,ASVS-v4.0.2:5.1.4,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,deprecated]]></tags>
    <description><![CDATA[Request parameters and other tainted data should not be passed into Session without sanitizing.
        
Sessions should only store trusted data, so that the developer accessing the data stored in a session would not have to decide whether to sanitize it.

Data stored in a session is usually considered by a developer as a safe one to use. If this data is not checked,
it could get into the security-sensitive parts of an application, opening it to all kinds of injection attacks.

Note: Rule OPT.JAVA.SEC_JAVA.TrustBoundaryViolationRule is more general, and deprecates this rule.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[The following code uses receives data via HttpServletRequest.getParameter() call and does not clean it before putting it into the session:

// ...
login = request.getParameter("login");
session.setAttribute(ATTR_LOGIN, login);]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/20.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:501,CWETOP25:2021:4,OWASP:2021:A4,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="sessionClasses" descname="sessionClasses" value="javax.servlet.http.HttpSession, HttpSession"/>
      <property name="requestClasses" descname="requestClasses" value="javax.servlet.ServletRequest, ServletRequest, javax.servlet.http.HttpServletRequest, HttpServletRequest"/>
      <property name="setParamsInSessionMethods" descname="setParamsInSessionMethods" value="setAttribute, putValue"/>
      <property name="getParamsInRequestMethods" descname="getParamsInRequestMethods" value="getAttribute, getParameter, getParameterValues"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ResourceInjection" message="ResourceInjection: Improper control of resource identifiers (&quot;Resource Injection&quot;)" class="com.optimyth.qaking.security.rules.java.ResourceInjection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software takes from an untrusted source the identifier for a system resource (like a port number),
and allows access to a non-expected resource. Attackers may use the flaw for malicious behaviour,
for example a port scan, change software configuration, transmit sensitive information to a third-party server,
etc.

OWASP project uses the term "Insecure Direct Object Reference" instead of "Resource Injection".

Note: Please note that other rules may check injection flaws for specific resources (like Path Traversal rule for filesytem resources,
or SSRF for network addresses). This rule reports injection flaws on resource identifiers not covered by other rules.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[String remotePort = request.getParameter("remotePort");
int rPort = Integer.parseInt(remotePort);
ServerSocket srvr = new ServerSocket(rPort); // VIOLATION
Socket skt = srvr.accept();]]></example>
    <repair><![CDATA[String remotePort = request.getParameter("remotePort");
Map<String,Integer> allowed = getAllowedPorts();
Integer rPort = allowed.get(remotePort); // FIXED, whitelist
if(rPort == null) rPort = getDefaultPort();

ServerSocket srvr = new ServerSocket(rPort.intValue());
Socket skt = srvr.accept();]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Resource_Injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:99,OWASP:2021:A3,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SameOriginMethodExecution" message="SameOriginMethodExecution: Same Origin Method Execution (SOME)" class="com.optimyth.qaking.security.rules.java.SameOriginMethodExecution" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[SOME is a web application attack which abuses callback endpoints by forcing a victim into
executing arbitrary scripting methods of any page on the endpoint’s domain.

In example, while JSONP is popular useful technology but it can make a website vulnerable as it uses a callback function
to get data from third-party services. By manipulating the callback parameter, attacker could execute arbitrary methods
on the affected website.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[package com.fwt.coutrollen;

import com.fasterxml.jackson.databind.util.JSONPObject;
import com.fwt.dto.HistogramDto;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import javax.servlet.http.HttpServletRequest;

@Controller
public class EchartsController {

    @CrossOrigin(origins = "*", maxAge = 3600)
    @ResponseBody
    @RequestMapping(value = "getDataJsonp",method = RequestMethod.GET)
    public Object getDataJsonp(HttpServletRequest request){
        String callback = request.getParameter("callback");
        System.out.println("inner getDataJsonp");
        System.out.println(callback);
        HistogramDto dto = new HistogramDto();
        dto.addData("100");
        dto.addData("50");
        dto.addData("120");
        dto.addData("40");
        dto.addData("170");
        // JSONPObject
        JSONPObject jsonpObject = new JSONPObject(callback, dto); // VIOLATION
        System.out.println(jsonpObject+":::");
        return jsonpObject;
    }

}]]></example>
    <repair><![CDATA[// Do not allow user to select the jsonp callback]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html,http://www.benhayak.com/2015/06/same-origin-method-execution-some.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.7,WASC:08]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input, database_input, file_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SecurityCheckInOverridableMethodRule" message="SecurityCheckInOverridableMethodRule: Methods that perform a security check must be declared private or final" class="com.optimyth.qaking.security.rules.java.SecurityCheckInOverridableMethodRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[Nonfinal member methods that perform security checks can be compromised when a malicious subclass overrides the methods
and omits the checks. Consequently, such methods must be declared private or final to prevent overriding.

Failure to declare a class's method private or final affords the opportunity for a malicious subclass
to bypass the security checks performed in the method.

The rule looks for calls to AccessController.checkPermission(), SecurityManager.checkXXX() or using of the classes configured in the parameter <securityClasses>, and
then checks that the containing method cannot be overridden (should be final or private, or belong to
a final class). If method could be overridden, a violation is emitted.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Security checks cannot be bypassed by subclassing and overriding the method with checks.]]></benefits>
    <inconvenients><![CDATA[Need to change class or method access modifiers, which may impact other classes.]]></inconvenients>
    <example><![CDATA[import java.security.AccessController;
import java.io.FilePermision;

public class X {
  public final void sensitiveOperation() {
    readSensitiveFile(FILE1);
    readSensitiveFile2(FILE2);
  }

  public void readSensitiveFile(File file) { /* VIOLATION */
    try {
      SecurityManager sm = System.getSecurityManager();
      if (sm != null) { // Check for permission to read file
        sm.checkRead(file);
      }
      // Access the file
    } catch (SecurityException se) {
      // Log exception
    }
  }

  void readSensitiveFile2(File file) { /* VIOLATION */
    FilePermission perm = new FilePermission(file.getAbsolutePath(), "read");
    AccessController.checkPermission(perm);
    // Access the file
  }
}]]></example>
    <repair><![CDATA[  // sensitive methods are made final
  // alternatively, made container class final
  public final /* FIXED */ void readSensitiveFile(File file) {
    try {
      SecurityManager sm = System.getSecurityManager();
      if (sm != null) { // Check for permission to read file
        sm.checkRead(file);
      }
      // Access the file
    } catch (SecurityException se) {
      // Log exception
    }
  }

  final /* FIXED */ void readSensitiveFile2(File file) {
    FilePermission perm = new FilePermission(file.getAbsolutePath(), "read");
    AccessController.checkPermission(perm);
    // Access the file
  }]]></repair>
    <reference><![CDATA[CERT-J/MET03-J: https://www.securecoding.cert.org/confluence/x/6AAMAg]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MET03-J,CWE:358,OWASP:2021:A1,PCI-DSS:6.5.6]]></security>
    </normatives>
    <properties>
      <property name="securityClasses" descname="Comma-separated list of security custom classes." value="java.lang.SecurityManager, SecurityManager"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ServerSideRequestForgeryRule" message="ServerSideRequestForgeryRule: Server-Side Request Forgery (SSRF)" class="com.optimyth.qaking.security.rules.java.ServerSideRequestForgeryRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.6.1,ASVS-v4.0.2:5.2.6,CWEScope:Confidentiality,CWEScope:Integrity,http-parameter-pollution]]></tags>
    <description><![CDATA[The software builds an URL using untrusted input, and retrieves the contents of this URL (e.g. a webservice),
without ensuring that the target (scheme, host, port ...) is the intended one.

This is an instance of the 'confused deputy' weakness, where the vulnerable application acts as a proxy
or relay for connections totally or partially controlled by an attacker.

As the connection originates from the host of the vulnerable application, that may hide the attacker origin,
and bypass network controls.

Attackers may leverage this flaw to use the application as a network proxy to:
* conduct port scanning in internal networks,
* access to local sensitive files using file:// scheme,
* use unintended protocols like tftp to gain unintended connections to internal or external hosts,
* bypass firewalls (the application host may be allowed to perform connections controlled by the attacker),
* attack web applications using injection attacks
and other malicious activity.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[String url = request.getParameter("hidden_url"); // not so hidden...

// Using java.net.URLConnection
URL url = new URL(url); // VIOLATION
InputStream is = url.openConnection().getContent();

// Using Apache Commons HttpComponents
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpget = new HttpGet(url); // VIOLATION
CloseableHttpResponse response = httpclient.execute(httpget);
...]]></example>
    <repair><![CDATA[String _url = request.getParameter("hidden_url"); // not so hidden...

// perform a white-list validation ensuring, for example,
// that the all URL parts are in expected sets
String url = validateUrl(_url);

... same as before ...]]></repair>
    <reference><![CDATA[SSRF bible. Cheat-sheet ONSec Labs,http://cwe.mitre.org/data/definitions/918.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:918,CWETOP25:2021:24,OWASP:2021:A10,PCI-DSS:6.5.8,WASC:42]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SpringNoAntiXssConfiguration" message="SpringNoAntiXssConfiguration: Use defaultHtmlEscape=true with SpringMVC for better cross-site scripting prevention" class="com.optimyth.qaking.spring.rules.SpringNoAntiXssConfiguration" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.3.1,ASVS-v4.0.2:14.1.3,ASVS-v4.0.2:2.5.4,ASVS-v4.0.2:3.4.3,ASVS-v4.0.2:3.4.4,ASVS-v4.0.2:3.4.5,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Spring-MVC,essential]]></tags>
    <description><![CDATA[The rule checks that, for a J2EE web application using Spring MVC, the default cross-site scripting (XSS) control is explicitly enabled.

Please note that defaultHtmlEscape only transforms potential XSS attack payloads during HTTP output construction,
for Spring tags in JSP pages. The default behavior, when no defaultHtmlEscape context parameter is defined, is to apply HTML escaping
to all Spring tags in the form tag library (that render values), but not to the other tags that merely expose values
but don’t render the values themselves.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Adds a simple XSS countermeasure to Spring MVC application.]]></benefits>
    <inconvenients><![CDATA[Automatic output encoding may interfere with application's current behaviour.]]></inconvenients>
    <example><![CDATA[<!-- web.xml does not contain defaultHtmlEscape context param, or sets it to false -->
<context-param>
  <param-name>defaultHtmlEscape</param-name>
  <param-value>false</param-value>
</context-param>]]></example>
    <repair><![CDATA[<!-- web.xml with explicit default HTML output-escaping configuration -->
<context-param>
  <param-name>defaultHtmlEscape</param-name>
  <param-value>true</param-value>
</context-param>]]></repair>
    <reference><![CDATA[Java/Spring web app security XSS - https://sgaur.wordpress.com/tag/spring/,OWASP XSS - https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet,Spring Security Cross-site Scripting - https://defensivecode.wordpress.com/2013/09/03/spring-security-xss/]]></reference>
    <normatives>
      <security><![CDATA[CWE:16,CWE:80,OWASP:2021:A5,PCI-DSS:6.5.7,WASC:08]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SpringUnrestrictedRequestMapping" message="SpringUnrestrictedRequestMapping: Spring CSRF unrestricted RequestMapping." class="com.optimyth.qaking.security.rules.java.SpringUnrestrictedRequestMapping" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.3,ASVS-v4.0.2:4.2.2,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,csrf]]></tags>
    <description><![CDATA[Methods annotated with @RequestMapping are, by default, mapped to all the HTTP request methods.

However, Spring Security CSRF protection is not enabled by default for the HTTP request methods GET, HEAD, TRACE, and OPTIONS
(as this could cause the tokens to be leaked). Therefore, state-changing methods annotated with @RequestMapping and not narrowing
the mapping to the HTTP request methods POST, PUT, DELETE, or PATCH are vulnerable to CSRF attacks.

The rule will emit a violation for any Spring MVC controller method that performs any state-change operations,
and is annotated with @RequestMapping (with no methods restriction, or with one  of GET / HEAD / OPTIONS / TRACE), or
@GetMapping.

Note: CSRF = Cross-Site Request Forgery, an attack where an attacker may force a victim to perform an unintended operation
on a vulnerable web resource.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended CSRF vulnerabilities, when an state-changing logic could be invoked by an attacker using GET method,
which is not CSRF-protected (and should not be, to avoid leaking CSRF tokens).]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

@Controller
public class MyController {

    // VIOLATION: GET, HEAD, OPTIONS and TRACE methods could be used by attacker,
    //            circumventing CSRF protection
    @RequestMapping("/path")
    public void writeData(@PathVariable int data) throws IOException {
        // State-changing operations performed within this method.
    }
}]]></example>
    <repair><![CDATA[import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMethod;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

@Controller
public class MyController {

    /**
     * For methods without side-effects specify the method(s) in @RequestMapping.
     * Alternatively, use @GetMapping (String 4.3 or later)
     */
    @RequestMapping(value="/path", method = RequestMethod.GET)
    public String readData() {
        // No state-changing operations performed within this method.
        return "";
    }

    /**
     * State-changing methods. Use explicit RequestMethod.POST or,
     * alternatively, @PostMapping (String 4.3 or later)
     */
    @RequestMapping(value = "/path", method = RequestMethod.POST)
    public void writeData(@PathVariable int data) throws IOException {
        // State-changing operations performed within this method.
    }
}]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet,https://en.wikipedia.org/wiki/Cross-site_request_forgery,https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#csrf-use-proper-verbs,http://cwe.mitre.org/data/definitions/352.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:352,CWETOP25:2021:9,OWASP:2013:A8,PCI-DSS:6.5.1,WASC:9]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SpringViewManipulation" message="SpringViewManipulation: Spring View Manipulation" class="com.optimyth.qaking.spring.rules.SpringViewManipulation" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[An unrestricted view name manipulation in Spring framework (Spring MVC), that uses Thymeleaf as templating engine,
may lead to remote code execution.

As Thymeleaf supports file layouts and fragments, a Spring MVC controller may create a dynamic view fragment name.
At runtime, the Spring ThymeleafView class parses the template name as an expression:

try {
   // By parsing it as a standard expression, we might profit from the expression cache
   fragmentExpression = (FragmentExpression) parser.parseExpression(context, "~{" + viewTemplateName + "}");
}

This is vulnerable to expression language injection attacks: for example, using a payload containing
__${T(java.lang.Runtime).getRuntime().exec("some OS command")}__::.

The __{ ... }__:: exploits the expression preprocessing feature in Spring, and the :: following ensure that
the input is considered as a view fragment that need expression evaluation.

So whenever untrusted data comes to a view name returned from the controller, it could lead to
Expression Language Injection, and therefore to Remote Code Execution.

Please note that the code in ThymeleafView is executed as a Spring expression when the '::' separator appears somewhere
in the view name, which can be forced by the attacker.

This happens even when the controller does not return a string (which Spring interprets as a view name) but with other
return types like void, java.util.Map or org.springframework.ui.Model, and it uses the URI (with parts of it under control
of the attacker) as part of an expression that is executed. See the full details in the references.

Please note that the rule detects if Thymeleaf is configured as the templating engine in the Spring web application.
Spring REST controllers (annotated with @RestController), and static view names are not vulnerable.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Assume that the Thymeleaf templating engine is registered in this Spring web application...

@Controller
public class MyController {

  @RequestMapping("/")
  public String index(@RequestParam String lang) {
    return "user/" + lang + "/index"; // VIOLATION - template path is tainted
  }

  @GetMapping("/fragment")
  public String fragment(@RequestParam String section) {
    return "welcome :: " + section; // VIOLATION
  }
}]]></example>
    <repair><![CDATA[@Controller
public class MyController {

  @RequestMapping("/")
  public String index(@RequestParam String lang) {
    if(isValidLanguage(lang)) { // FIXED
      return "user/" + lang + "/index";

    } else {
      return "user/esperanto/index";
    }
  }

  @GetMapping("/fragment")
  public String fragment(@RequestParam String section) {
    // FIXED, the external input is properly validated
    if(section != null && section.matches("a-zA-Z0-9")) {
      return "welcome :: " + section;

    } else {
      return "index"; // neutral home view
    }
  }
}]]></repair>
    <reference><![CDATA[https://www.veracode.com/blog/secure-development/spring-view-manipulation-vulnerability]]></reference>
    <normatives>
      <security><![CDATA[CWE:917,OWASP:2021:A3]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SqlInjectionRule" message="SqlInjectionRule: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" class="com.optimyth.qaking.security.rules.java.SqlInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The software constructs all or part of an SQL command using externally-controlled input, but it does not neutralize
properly that input that could modify the intended SQL command when it is sent to a database interaction method
(e.g. JDBC).

The rule detects a path in code between an user-input statement (source) and a database call (sink), with SQL sentence depending on
non neutralized input.

It must be known that if SQL does not depend on user-controlled input (e.g. Parametrized SQL), there is no possibility for an SQL injection.

Note: Using stored procedures in database operations does NOT prevent SQL injection if, for example, the SQL to send
to the database for execution of the stored procedure is composed by concatenating non properly neutralized user input.
The ways to avoid SQL injection are:

1) Use parametrized SQL, so SQL code and parameters are not mixed (no parameter could change the semantic of the SQL)

2) If SQL code must depend on user input (e.g. to build 'dynamic' WHERE clauses), even with prepared statements,
   all user-controlled inputs used to compose such "dynamic" SQL should be neutralized.

A neutralization function either validates inputs and report an (neutral) error without allowing SQL execution, or
replaces sensitive SQL characters in the input to avoid that the resulting SQL has different semantics.

It is recommended to use parametrized SQL (when possible).

The rule supports different database persistence libraries/frameworks, like JDBC, Hibernate, Java Persistence API (JPA),
JDO, or Spring.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.io.IOException;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.sql.Connection;
import java.sql.Statement;
import java.sql.ResultSet;

public class MyServlet extends HttpServlet {
  @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String username = request.getParameter("username");
    String password = request.getParameter("password");
    Connection conn = pool.getConnection();
    String sql = "select * from user where username='" + username +"' and password='" + password + "'";
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(sql);
  }
}]]></example>
    <repair><![CDATA[import java.io.IOException;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.sql.Connection;
import java.sql.Statement;
import java.sql.ResultSet;

public class MyServlet extends HttpServlet {
  @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String username = request.getParameter("username");
    String password = request.getParameter("password");
    Connection conn = pool.getConnection();

    PreparedStatement sqlStatement = conn.prepareStatement("select * from user where username=? and password=?"); //Fixed. Use prepared statements.
    sqlStatement.setString(1, username);
    sqlStatement.setString(2, password);
    ResultSet rs = sqlStatement.executeQuery(sql);
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/IDS00-J.+Prevent+SQL+injection,https://cwe.mitre.org/data/definitions/564.html,http://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS00-J,CWE:564,CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input"/>
      <property name="parametersAsSources" descname="Assume that method parameters are untrusted inputs" value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.TooMuchOriginsAllowedRule" message="TooMuchOriginsAllowedRule: CORS policy (Cross-origin resource sharing) too broad" class="com.optimyth.qaking.security.rules.java.TooMuchOriginsAllowedRule" technology="JAVA" active="true">
    <tags><![CDATA[CORS,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Too much allowed origins in HTML5 Access-Control-Allow-Origin header.

Traditionally, web browsers enforced the Same Origin Policy (SOP) to avoid cross-domain JavaScript to access
certain contents in web page. This policy prevents a malicious script on one page from obtaining
access to sensitive data on another web page ("victim") with a different origin. A strict separation between content
from unrelated sites must be maintained on the browser to prevent loss of data confidentiality or integrity.

Cross-Origin Resource Sharing (CORS) relaxes the SOP. To do this, essentially two HTTP headers (Origin, emitted by client,
and Access-Control-Allow-Origin, emitted by server). This allows, for example, to Ajax requests (XMLHttpRequest) for
accessing content from different origin that should be forbidden by the SOP.

With Access-Control-Allow-Origin header, server defines which other domains are allowed to access content in its domain
using cross-origin requests. A too much permissive value (like '*') will allow a malicious application to communicate
with the vulnerable application in unexpected ways, leading to different security problems.

NOTE: CORS is intended to avoid data read from pages coming from other origins, and it is enforced by modern browsers.
Remember that an attacker has full control over an HTTP request message, so do not rely on CORS Origin header for
validating the source of a request, or for CSRF protection.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limits read application data from content coming from hostile origins.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

class CorsExample {
  private static final String CORS_HEADER = "Access-Control-Allow-Origin";
  private static final String CORS_CREDS = "Access-Control-Allow-Credentials";
  private static final String CORS_ORIGINS_ALLOWED = "*";

  public void setCorsOrigins(HttpServletResponse res) {
    //...
    /* VIOLATION, too permisive */
    res.setHeader(CORS_HEADER, CORS_ORIGINS_ALLOWED);
    //...
  }

  // A more flexible alternative is to reflect the Origin header into Access-Control-Allow-Origin
  // but without validation this is dangerous
  public void reflectCorsOrigin(HttpServletRequest req, HttpServletResponse res) {
    String origin = req.getHeader("Origin");
    if(origin != null) {
      res.addHeader(CORS_HEADER, origin); // VIOLATION, no validation
      res.addHeader(CORS_CREDS, "true"); // with this, impact is higher
    }
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.util.Set;
import java.util.regex.Pattern;
import com.google.common.collect.Sets;
import org.springframework.web.util.WebUtils;

class CorsExample {
  private static final String CORS_HEADER = "Access-Control-Allow-Origin";
  private static final String CORS_CREDS = "Access-Control-Allow-Credentials";

  // hardcoded allowed origins, for simplicity
  private Set<String> allowed = Sets.newHashSet(
    "https://affiliate.com", "https://affiliate2.com"
  );
  // subdomains in my domain allowed. TLS always enforced !!!
  private Pattern mySubdomains = Pattern.compile("https://(\\w[\\w\\d\\-_]*)?myorg.com");

  public void setCorsOrigins(HttpServletResponse res) {
    //...
    res.addHeader(CORS_HEADER, "https://www.allowed.com"); // FIXED
    //...
  }

  public void reflectCorsOrigin(HttpServletRequest req, HttpServletResponse res) {
    if(WebUtils.isSameOrigin(req)) return; // same origin, no CORS header needed

    String origin = req.getHeader("Origin");
    // FIXED, white-listed
    if(origin != null && isAllowed(origin, req)) {
      res.addHeader(CORS_HEADER, origin);
      res.addHeader(CORS_CREDS, "true");
    }
  }

  // White-list the origin before reflecting it in the CORS header
  private boolean isAllowed(String origin, HttpServletRequest req) {
    return
      mySubdomains.matcher(origin).matches()) ||
      allowed.contains(origin);
  }
}]]></repair>
    <reference><![CDATA[https://www.baeldung.com/spring-cors,https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties,https://w3c.github.io/webappsec-cors-for-developers,http://cwe.mitre.org/data/definitions/942.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:942,OWASP:2021:A5,PCI-DSS:6.5.10,WASC:15]]></security>
    </normatives>
    <properties>
      <property name="disallowedOriginPattern" descname="Regular expression for CORS origins do not considered valid" value="\*|null"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.TrustBoundaryViolationRule" message="TrustBoundaryViolationRule: Trust boundary violation" class="com.optimyth.qaking.security.rules.java.TrustBoundaryViolationRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,trust-boundary]]></tags>
    <description><![CDATA[The product mixes trusted and untrusted data in the same data structure or structured message.

A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted.
By combining trusted and untrusted data in the same data structure, it becomes easier for programmers
to mistakenly trust unvalidated data. This violation may open attack avenues, like injection attacks,
when the application takes untrusted data from the trusted domain without validation.

When untrusted external input (e.g. input HTTP message contents) is set as session or web application attributes,
without proper validation / neutralization, the check emits a violation.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid security issues when data passed to trusted domain is used without specific validation from other places
in the application.]]></benefits>
    <inconvenients><![CDATA[Need explicit input validation before data movement.]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.owasp.esapi.ESAPI;

public class MyServlet extends HttpServlet {
  public void doPost(HttpServletRequest req, HttpServletResponse res) {
    String param = req.getParameter("input");
    req.getSession().setAttribute("trusted", param); /* VIOLATION */
    res.getWriter().println(ESAPI.encoder().encodeForHTML(param));
  }

  /*
    In other place, session data is considered trusted and not validated,
    allowing cross-site scripting and other security problems.
   */
  public void doGet(HttpServletRequest req, HttpServletResponse res) {
    String trusted = req.getSession().getAttribute("trusted");
    res.getWriter().println("pawned: " + trusted);
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.owasp.esapi.ESAPI;

public class MyServlet extends HttpServlet {
  public void doPost(HttpServletRequest req, HttpServletResponse res) {
    String param = req.getParameter("input");
    if(param != null && param.matches("[a-zA-Z0-9 ]")) { /* FIXED, validation */
      req.getSession().setAttribute("trusted", param);
    }
    res.getWriter().println(ESAPI.encoder().encodeForHTML(param));
  }

  /* Data in trusted domain is validated */
  public void doGet(HttpServletRequest req, HttpServletResponse res) {
    String trusted = req.getSession().getAttribute("trusted");
    res.getWriter().println("pawned: " + trusted);
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/501.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:501,OWASP:2021:A4,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.UnsafeCookieRule" message="UnsafeCookieRule: Generate server-side cookies with adequate security properties" class="com.optimyth.qaking.security.rules.java.UnsafeCookieRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:3.2.3,ASVS-v4.0.2:3.4.1,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Checks that cookies generated in server side have the following security properties:

    * Non persistent - Cookie is not stored persistently by the browser (it is hold in memory)
    * HttpOnly - Cookie is not accessible by client-side scripts (not all browsers support this)
    * Secure - Cookie is sent in HTTP/SSL communications only (more difficult to capture on the net)
    * Path - Path should not match a certain patterns that allow transmission to unintended web applications.
    * Domain - Domain should not be too wide so the cookie is sent to unintended servers.

    HttpOnly, for example, could mitigate some CSRF (cross-site request forgery) issues as it makes
    more difficult for the attacker to capture sensitive cookies from client-side code generated by
    exploiting an XSS vulnerability in a web application.

    Other rules (like SEC_JAVA.HttpSplitting) check other conditions, like HTTP Splitting, that could be
    produced when the cookie value depends on user-controlled input non properly neutralized.

    NOTE: forceHttpOnly property should be set only if Java code uses Java6 (in previous versions, the
    Cookie.setHttpOnly(boolean) method does not exist, and httpOnly flag for cookies can only be set
    by application server configuration, see https://www.owasp.org/index.php/HttpOnly. Under Java5-,
    do not set forceHttpOnly to true as this cannot be set in code.

    NOTE2: Not setting domain or path forces browser to send the cookie to the originator's domain and
    application path, so this is considered secure.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.ServletContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.net.MalformedURLException;

import com.opt.MyOwnCookie;

public class UnsafeCookie {

  private static final String COOKIE_NAME = "SecureCookie";

  public void sendPersistentUnsecureCookie(HttpServletResponse res) {
    Cookie cookie = new Cookie(COOKIE_NAME, "value"); // VIOLATION - no setHttpOnly(true)
    cookie.setMaxAge(24*60*60);          // VIOLATION - 1 day (persistent)

    cookie.setSecure(false);    // VIOLATION

    res.addCookie(cookie);
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.ServletContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.net.MalformedURLException;

import com.opt.MyOwnCookie;

public class UnsafeCookie {

  private static final String COOKIE_NAME = "SecureCookie";

  public void sendPersistentUnsecureCookie(HttpServletResponse res) {
    Cookie cookie = new Cookie("SensibleCookie", "value");

    cookie.setMaxAge(-1); // en memoria - cookie no persistente
    cookie.setSecure(true);
    cookie.setHttpOnly(true);
    cookie.setPath("/allowedPath");
    cookie.setDomain("allowedDomain.es");

    res.addCookie(cookie);
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/200.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:1004,CWE:200,CWE:539,CWE:614,CWETOP25:2021:20]]></security>
    </normatives>
    <properties>
      <property name="domainPatternToAvoid" descname="Domain pattern to avoid" value="\.[^\.]+"/>
      <property name="avoidPersistentCookies" descname="Avoid persistent cookies" value="true"/>
      <property name="avoidUnsecureCookies" descname="Avoid unsecure cookies" value="true"/>
      <property name="pathPatternToAvoid" descname="Path pattern to avoid" value="/"/>
      <property name="forceHttpOnly" descname="Set HttpOnly" value="true"/>
      <property name="checkAllCookieAllocations" descname="Check every Cookie allocation including those not being added to an HTTP response." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.UnsafeReflection" message="UnsafeReflection: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')" class="com.optimyth.qaking.security.rules.java.UnsafeReflection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,reflection]]></tags>
    <description><![CDATA[The software uses external input with reflection to select which classes or code to use, but it does not prevent
the input from selecting improper classes or code.

If the application uses external inputs to determine which class to instantiate or which method to invoke, then an attacker
could supply values to select unexpected classes or methods. If this occurs, then the attacker could execute code that
was not intended by the developer. It may bypass authentication or access control checks, or otherwise cause unexpected behaviour.

It the attacker is able to upload files in a location that appears in the classpath, or add new entries to the classpath,
this flaw could lead to execution of arbitrary code, chosen by the attacker.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limit potential unexpected code execution, or uncontrolled access to sensitive information.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.lang.reflect.Method;
// ...

/*
 * Action type and optional initialization method, specified in a "hidden" request parameter
 * Remind that "hidden" parameters are not hidden...
 */
private Action getInstance(HttpServletRequest req) throws Exception {
  String actionClass = req.getParameter("action");
  String init = req.getParameter("init");
  if(init == null) init = "init";

  @SuppressWarnings("unchecked")
  Class<Action> clazz = (Class<Action>) Class.forName(actionClass); // VIOLATION

  Action action = clazz.newInstance();
  Method initMethod = clazz.getMethod(init, HttpServletRequest.class); // VIOLATION
  initMethod.invoke(action, req);

  return action;
}]]></example>
    <repair><![CDATA[// Validate externally-controlled parameters affecting targets of reflexion code]]></repair>
    <reference><![CDATA[OWASP Unsafe Reflection: https://www.owasp.org/index.php/Unsafe_Reflection,Secure Coding Guidelines for the Java Programming Language, guideline 9,https://www.securecoding.cert.org/confluence/display/java/SEC05-J.+Do+not+use+reflection+to+increase+accessibility+of+classes%2C+methods%2C+or+fields,https://cwe.mitre.org/data/definitions/470.h]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SEC05-J,CWE:470,OWASP:2021:A3,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.WeakCryptographicHashRule" message="WeakCryptographicHashRule: Weak cryptographic hash" class="com.optimyth.qaking.security.rules.java.WeakCryptographicHashRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,crypto,hash]]></tags>
    <description><![CDATA[Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.
MD5 and SHA-1 are popular cryptographic hash algorithms often used to verify the integrity of messages and other data.

Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5 and SHA-1 should
no longer be used to verify data integrity in security-critical contexts.

Techniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be used
in any security context.

In the case of SHA-1, current techniques still require a significant amount of computational power and
are more difficult to implement. However, attackers have found the Achilles' heel for the algorithm, and techniques
for breaking it will likely lead to the discovery of even faster attacks.

Note: SHA-1 is not a recommended algorithm for password hashing, for digital signature generation/verification, and other uses (NIST).


The rule checks if the cryptographic hash algorithm used is one of the allowed ones; the rule can lead to false negatives
if the algorithm value argument cannot be inferred statically.

In addition, a violation is emitted for every custom implementation of java.security.MessageDigest. Such custom implementations
probably do not have the security level that standard implementations provide.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private final static String SHA_1 = "SHA-1";
// ...
MessageDigest messageDigest = MessageDigest.getInstance("MD5");  // VIOLATION
MessageDigest messageDigest2 = MessageDigest.getInstance(SHA_1); // VIOLATION
// ...
String hashAlgorithm = getHashAlgorithm();
MessageDigest messageDigest3 = MessageDigest.getInstance(hashAlgorithm); // DESCONOCIDO]]></example>
    <repair><![CDATA[private final static String SHA_256 = "SHA-256";
// ...
MessageDigest messageDigest = MessageDigest.getInstance("SHA-384"); // OK
MessageDigest messageDigest2 = MessageDigest.getInstance(SHA_256);  // OK]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/328.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:328,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:50]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Allowed cryptographic hash algorithms" value="SHA224, SHA256, SHA384, SHA512, HashSHA224, HashSHA256, HashSHA384, HashSHA512"/>
      <property name="forbiddenAlgorithms" descname="List of weak hash functions" value="MD2, MD5, SHA1, HashMD5, HashSHA1"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.WeakEncryptionRule" message="WeakEncryptionRule: Weak symmetric encryption algorithm" class="com.optimyth.qaking.security.rules.java.WeakEncryptionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.9.3,ASVS-v4.0.2:6.2.2,ASVS-v4.0.2:8.3.7,CWEScope:Accountability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,cipher,crypto]]></tags>
    <description><![CDATA[The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.

Old encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data.
Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength.
Cryptographic strength is often measured by the time and computational power needed to generate a valid key.
Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time.

For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm
was first developed, but today DES can be cracked in less than a day using commonly available equipment.

Encryption-related classes considered by the rule are Cipher, Mac, KeyGenerator or SecretKeyGenerator in javax.crypto
package.

The rule also considers a violation of this rule any custom implementation of the aforementioned classes (or the
corresponding Spi classes), as correct implementation for encryption/decryption algorithms is difficult,
and need deep analysis from the cryptographic community.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private static final String ALGORITHM = "DES/CBC/PKCS5Padding";

//...
Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding"); //VIOLATION
Cipher cipher = Cipher.getInstance(ALGORITHM);  //VIOLATION

// Probably cannot infer algorithm statically
Cipher cipher = Cipher.getInstance(getAlgorithm());]]></example>
    <repair><![CDATA[private static final String ALGORITHM = "AES/CBC/PKCS5Padding";
//...
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); //OK
Cipher cipher = Cipher.getInstance(ALGORITHM);  //OK]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms,http://cwe.mitre.org/data/definitions/327.html,http://projects.webappsec.org/w/page/13246936/Information%20Leakage]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC61-J,CWE:327,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Comma-separated list of allowed algorithms" value="DESEDE, AES, IDEA"/>
      <property name="forbiddenAlgorithms" descname="Comma-separated list of ciphers that should NOT be used." value="DES, RC2, RC4, RC5"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.WeakPasswordHashing" message="WeakPasswordHashing: Weak Password Hashing" class="com.optimyth.qaking.security.rules.java.WeakPasswordHashing" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.4.1,ASVS-v4.0.2:2.4.2,ASVS-v4.0.2:2.4.3,ASVS-v4.0.2:2.4.4,ASVS-v4.0.2:2.4.5,ASVS-v4.0.2:2.7.5,CWEScope:Access-Control,crypto]]></tags>
    <description><![CDATA[For storage of passwords, the proper way is to apply a one-way hash function that converts the provided password
into a fixed-length "fingerprint" that cannot be reversed. Due to the "avalanche effect" of the hash function,
a one-bit change in the input password results in a large change in the "fingerprint".

Password cracking traditionally used "rainbow tables" where passwords in a dictionary were hashed for a quick search
of plaintext passwords in a long list of hashes. To counteract this, the idea is to add a random salt to each password.

The one-way function is applied both when the password is provided by the end-user during registration (the resulting hash,
along with salt used, is then stored); and at user authentication, when the stored hash for the user is retrieved and compared
against the result of applying the hash function on the provided clean-text password concatenated with the stored salt.

High-end graphics cards (GPUs) and custom hardware can compute billions of hashes per second, so these attacks are still
very effective for brute-force password cracking, in particular when a large list of password hashes is exfiltrated.
To block this attack, "key stretching" (a CPU- and memory- intensive hash function) should be used. Do not try to invent your own;
there are many that passed the scrutiny of the cryptographic community.

The recommended password hashing scheme should, then:
- Use well-designed key stretching / password hashing algorithms, such as PBKDF2, BCrypt, SCrypt, or Argon2.

- Only for legacy reasons, use a common ("fast") hash function like SHA-256, but iterated a large number of times.
  In 2016, NIST recommended 10,000 iterations, but 150,000 is often seen as of 2020.

- Use a long-enough random salt when storing the password, and never reuse it.

- Configure the work factor parameters for the key stretching functions (or iterations in case of a common hash function)
  so its work factor makes brute-force password cracking unfeasible, without too much impact in the authentication process.

- Optionally, add a private and shared "secret key" to the hash (named "pepper"). The key has to be kept secret from an attacker
  even in the event of a breach, otherwise it provides no additional security.

Any non-conformance with the above recommendations will be reported:
- No password hashing at all (CWE-256 or CWE-257).
- Weak hash function (CWE-328).
- No salt or empty (CWE-759).
- Hardcoded or predictable salt (CWE-760).
- Too-small work factor parameters, including number of iterations with legacy "fast" hash functions (CWE-916).

Remember that users often reuse the same password in accounts across multiple systems.

Note: Many libraries automate the generation of random salt with proper length, avoiding errors like hardcoded/reused salt.
If not available, remember to use at least a random salt, generated properly with a Cryptographically Secure
Pseudo-Random Number Generator (CSPRNG), with a size equal to the size of the hash function output (128 bits at minimum).
Never use the username or other non-random information as salt.

Note: During authentication, the comparison between stored and computed hash values should take a length-constant time to avoid
leaking timing information for searches on the passwords space better than brute-force. Most password-hashing libraries
provide verification methods enforcing this.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import org.springframework.security.crypto.password.Pbkdf2PasswordEncoder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.apache.commons.codec.binary.Base64;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import static java.nio.charset.StandardCharsets.UTF_8;

// Spring security automates random salt processing...

public class PasswordAuthentication {

  // Better if this is not hardcoded, shown for illustration purposes
  private final String pepper = "@@:SRDf6BCq]2nf!";

  public String encodePbkdf2(String pwd) {
    // VIOLATION - small iteration count, 1024 is below the pbkdf2 threshold (10000)
    Pbkdf2PasswordEncoder pe = new Pbkdf2PasswordEncoder(pepper, 1024, 256);
    return pe.encode(pwd);
  }

  public static String encodeBCrypt(String pwd) {
    BCryptPasswordEncoder bcrypt = new BCryptPasswordEncoder(4); // VIOLATION - too weak !
    return bcrypt.encode(pwd);
  }

  private final String salt = "hardcodedIsBad";

  public String encodeFastHash(String pwd) throws NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance("SHA-256");
    md.update(pepper.getBytes(UTF_8));
    md.update(salt.getBytes(UTF_8));

    // VIOLATION, hardcoded salt and too-small iteration count (1000 < expected 150000)
    byte[] hash = md.digest(password.getBytes(UTF_8));

    for(int i=0; i < 1000; i++) {
      md.update(salt);
      hash = md.digest(hash);
    }

    return Base64.encodeBase64String(salt) + "$" + Base64.encodeBase64String(hash);
  }

}]]></example>
    <repair><![CDATA[// Identical code omitted...

public class PasswordAuthentication {

  public String encodePbkdf2(String pwd) {
    // Fixed, proper iteration count
    Pbkdf2PasswordEncoder pe = new Pbkdf2PasswordEncoder(pepper, 10000, 256);
    return pe.encode(pwd);
  }

  public static String encodeBCrypt(String pwd) {
    BCryptPasswordEncoder bcrypt = new BCryptPasswordEncoder(12); // FIXED
    return bcrypt.encode(pwd);
  }

  // Only use regular hash functions for legacy systems, never use this for new ones
  private final SecureRandom rand = new SecureRandom();

  public String encodeFastHash(String pwd) throws NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance("SHA-256");
    byte[] salt = rand.generateSeed(32); // 256 bits salt
    md.update(pepper.getBytes(UTF_8));
    md.update(salt.getBytes(UTF_8));

    // Fixed, random salt and adequate iteration count
    byte[] hash = md.digest(password.getBytes(UTF_8));

    for(int i=0; i < 150000; i++) {
      md.update(salt);
      hash = md.digest(hash);
    }

    return Base64.encodeBase64String(salt) + "$" + Base64.encodeBase64String(hash);
  }

}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/759.html,https://cwe.mitre.org/data/definitions/760.html,https://crackstation.net/hashing-security.htm,https://cwe.mitre.org/data/definitions/256.html,https://cwe.mitre.org/data/definitions/916.html,https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords,https://www.baeldung.co]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC03-J,CWE:256,CWE:759,CWE:760,CWE:916,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="thresholds" descname="Comma-separated list of algorithm.workFactor = threshold">
        <value><![CDATA[
pbkdf2 = 10000,
argon2.mem = 12, argon2.iterations = 3, argon2.parallel = 1,
scrypt.cpu = 16384, scrypt.mem = 8, scrypt.parallel = 1,
bcrypt.strength = 10,
fast.hash = 150000
        ]]></value>
      </property>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.WebXmlSecurityMisconfigurationsRule" message="WebXmlSecurityMisconfigurationsRule: Avoid misconfiguring security properties in web.xml descriptor" class="com.optimyth.qaking.security.rules.java.WebXmlSecurityMisconfigurationsRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.3.1,ASVS-v4.0.2:14.1.3,ASVS-v4.0.2:2.5.4,ASVS-v4.0.2:2.8.1,ASVS-v4.0.2:2.8.6,ASVS-v4.0.2:3.2.1,ASVS-v4.0.2:3.3.1,ASVS-v4.0.2:3.3.2,ASVS-v4.0.2:3.3.3,ASVS-v4.0.2:3.3.4,ASVS-v4.0.2:3.4.3,ASVS-v4.0.2:3.4.4,ASVS-v4.0.2:3.4.5,ASVS-v4.0.2:3.6.1,ASVS-v4.0.2:3.6.2,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,essential]]></tags>
    <description><![CDATA[The rule checks 7 common misconfigurations in web.xml descriptors:

    * No default error pages for 404/500 error codes and for uncaught exceptions.
    By default Java web applications display detailed error messages that disclose the server version and detailed stack trace information
    that can, in some situations, wind up displaying snippets of Java code. This information is a boon to hackers who are looking for as much
    information about their victims as possible.

    To avoid, set neutral error pages for 404 and 500 HTTP error codes, and for java.lang.Throwable uncaught exceptions
    (which means ALL uncaught exceptions)

    * No methods in security constraints.
    In security-constraint, do not list any http-method. Any non-listed method will be
    unprotected, so attackers may use an uncommon method (HEAD, TRACE, DELETE...) to access
    the protected resources.

    * Configure SSL for protected areas.
    SSL should be used to protect sensitive data in transit (protected resources)
    This check could be deactivated by setting checkSSLForProtectedAreas to false.

    * Send session ID under SSL only.
    Many web sites use SSL for authentication but then either revert back to non-SSL for subsequent communication
    or have parts of the site that can still be accessed via non-SSL. This leaves the session coookie (i.e. JSESSIONID)
    vulnerable to session hijacking attacks. To prevent this, session cookies can be created with the "Secure" flag,
    which ensures that the browser will never transmit the specified cookie over non-SSL.

    * Send session cookies with the HttpOnly flag set.
    Cookies can be created with the "HttpOnly" flag, which ensures that the cookie cannot be accessed via client side scripts.
    This helps mitigate some of the most common XSS attacks. Must be specified for Servlet 3.0+

    * Use cookies, not URL rewriting, to exchange session IDs with browsers.
    The tracking-mode element in the Servlet 3.0 specification allows you to define whether the JSESSIONID should be
    stored in a cookie or in a URL parameter. If the session id is stored in a URL parameter it could be inadvertently
    saved in a number of locations including the browser history, proxy server logs, referrer logs, web logs, etc.
    Accidental disclosure of the session id makes the application more vulnerable to session hijacking attacks.
    Instead, make sure the JSESSIONID is stored in a cookie (and has the Secure flag set).

    * Expire sessions with no too large timeouts.
    Users like long lived sessions because they are convenient. Hackers like long lived sessions because it gives them
    more time to conduct attacks like session hijacking and CSRF. Security vs usability will always be a dilemma.
    But never specify 0 or negative value, as this makes the session cookie to live forever.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    <!-- Some of the security properties are not available below Servlet 3.0 -->
    <security-constraint>
      <web-resource-collection>
        <web-resource-name>Protected Area</web-resource-name>
        <url-pattern>/private/*</url-pattern>
        <!-- This means that other HTTP methods can access resources with no protection! -->
        <http-method>GET</http-method>
        <http-method>POST</http-method>
      </web-resource-collection>
      <auth-constraint>...</auth-constraint>
      <!-- No user-data-constraint/transport-guarantee -->
    </security-constraint>

    <session-config>
      <session-timeout>-1</session-timeout>               <!-- VIOLATION: session does not expire -->
      <!-- not secure cookie, no httpOnly, tracking mode not fixed to COOKIE -->
    </session-config>

    <!-- No error pages for 404/500 or java.lang.Throwable -->]]></example>
    <repair><![CDATA[    <security-constraint>
      <web-resource-collection>
        <web-resource-name>Protected Area</web-resource-name>
        <url-pattern>/private/*</url-pattern>
      </web-resource-collection>
      <auth-constraint>...</auth-constraint>
      <!-- No user-data-constraint/transport-guarantee -->
    </security-constraint>

    <session-config>
      <session-timeout>60</session-timeout>
      <cookie-config>
        <http-only>true</http-only>
        <secure>true</secure>
      </cookie-config>
      <tracking-mode>COOKIE</tracking-mode>
    </session-config>

    <!-- Redirect uncaught errors to neutral error message pages -->
    <error-page>
      <error-code>500</error-code>
      <location>/error500.jsp</location>
    </error-page>
    <error-page>
      <exception-type>java.lang.Throwable</exception-type>
      <location>/error500.jsp</location>
    </error-page>
    <error-page>
      <error-code>404</error-code>
      <location>/error404.jsp</location>
    </error-page>]]></repair>
    <reference><![CDATA[http://software-security.sans.org/blog/2010/08/11/security-misconfigurations-java-webxml-files,ERR01-J: https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:ERR01-J,CWE:16,CWE:384,CWE:5,CWE:613,CWE:7,OWASP:2021:A5,OWASP:2021:A7,WASC:47]]></security>
    </normatives>
    <properties>
      <property name="checkSessionTimeoutExists" descname="If true, report violation when &lt;session-timeout&gt; element doesn't exist." value="true"/>
      <property name="checkSessionIdInCookieOnly" descname="If true, configure session ID to be sent only in cookies" value="true"/>
      <property name="checkSessionTimeout" descname="If true, configure a (finite) session timeout" value="true"/>
      <property name="checkErrorPages" descname="If true, default error pages must be configured" value="true"/>
      <property name="checkSSLForProtectedAreas" descname="If true, SSL must be set for protected areas" value="false"/>
      <property name="checkSecureSession" descname="If true, session ID should be configured as secure (sent only under SSL)" value="false"/>
      <property name="checkNoHttpMethodInSecurityContraints" descname="If true, security constraints should NOT specify http methods" value="true"/>
      <property name="checkHttpOnly" descname="If true, session cookie must use httpOnly flag (not accessible from client-side scripts)" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.XmlEntityInjectionRule" message="XmlEntityInjectionRule: XML entity injection" class="com.optimyth.qaking.security.rules.java.XmlEntityInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.5.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[In XML parsers, when XML document to parse could be altered by untrusted input, and the untrusted input may
alter the Document Type Definition (DTD, embedded or external), the parser should be configured to avoid
two kinds of potential attacks:

* XML entity expansion DoS (XML bomb or "billion laughs attack"), CWE-776, where well-formed DTD with
  internal entities are expanded exponentially until they exhaust memory.

* XML external entity injection (XXE), CWE-611, where an external entity controlled by the attacker refers to the URL
  of a resource that gives unauthorized access to sensitive files on the server machine, or to a resource
  like /dev/random in Unix systems that, when entity is expanded, leads to a denial-of-service condition.
  A variant of this attack is the server-side request forgery (SSRF), where the URL for external DTD or XML-Schema
  is processed by the URL handler used by the XML parser, allowing the attacker access to an unexpected
  network resource (for cross-site request forgery attacks or port-scanning enumeration).

Please note that Java parsers are particularly vulnerable to XML entity injection attacks because their
default settings have both entity expansion and external entity resolution enabled. Disabling validations
does not help, as entity expansion / external entity loading is done even when validation is disabled.

DTD is not the unique element that an attacker could use for injection: XML-Schema attributes could be specified
on any tag, so SSRF injection may happen at any place in the XML document, not only at the start where DTD should
be placed, but fortunately common Java XML parsers do not seem to fetch schema URLs by default.

XML parsing could be hidden in other frameworks and libraries. For example, with REST, when a resource has an XML
representation, the REST framework typically use an underlying XML parser for processing the request message, which
obviusly is fully under control of a potential attacker.

To be safe during XML processing coming from untrusted sources, a number of XML features should be disabled
when configuring the parser:
* DTD interpretation - Ensure DOCTYPE tags are ignored, or documents containing them are rejected.
* Ignore or reject external entities.
* schemaLocation and noNamespaceSchemaLocation should not fetch URLs.
* XIncludes - Should be disabled or left disabled.

The rule checks that there is a path between an untrusted input and the XML document to parse,
then verifies that the XML parser is configured to avoid both external entity and entity expansion attacks.

Secure configuration againts entity expansion or external entity injection attacks depends on the API used.
The following libraries are analyzed: JAXP, SAX, StAX, DOM4J, JDOM2, JAXB, TRAX.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XML entity attacks that could cause denial-of-service and information leakage.]]></benefits>
    <inconvenients><![CDATA[Dependencies on certain features related to DTD or entity expansion may render runtime errors.]]></inconvenients>
    <example><![CDATA[// JAXP, unsafe configuration
public Document doc(HttpServletRequest req) {
  DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
  /* VIOLATION, vulnerable to XML entity injection and "billion laughs attack" */
  return dbf.newDocumentBuilder().parse( req.getInputStream() );
}

This code is vulnerable to well-known XML attack vectors like:

* "billion laughs" attack, 1K payload expands to 3GB!:
<?xml version="1.0"?>
<!DOCTYPE lolz [
 <!ENTITY lol "lol">
 <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
 <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
 <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
 <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
 <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
 <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
 <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
 <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>

* XXE (external entity attack), for sensitive file disclosure:
<!DOCTYPE roottag [
 <!ENTITY windowsfile SYSTEM "file:///c:/boot.ini">
]>
<roottag>
 <sometag>&windowsfile;</sometag>
</roottag>

* XXE, for denial-of-service under Unix servers:
<!DOCTYPE foo [
  <!ELEMENT root ANY >
  <!ENTITY unixfile SYSTEM "file:///dev/random" >
]>
<root>&unixfile;</root>]]></example>
    <repair><![CDATA[public Document doc(HttpServletRequest req) {
  DocumentBuilderFactory dbf = getFactory();
  return dbf.newDocumentBuilder().parse( req.getInputStream() );
}

/* FIXED */
private static DocumentBuilderFactory getFactory() {
  DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
  // Use this if the JAXP parser accepts it
  dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
  // AND add the following to enforce limits on what the parser is allowed to do
  dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
  dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
  dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
  dbf.setXIncludeAware(false);
  dbf.setExpandEntityReferences(false);

  return dbf;
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/611.html,http://cwe.mitre.org/data/definitions/776.html,XML Schema, DTD, and Entity Attacks: http://www.vsecurity.com/download/papers/XMLDTDEntityAttacks.pdf,https://www.securecoding.cert.org/confluence/display/java/IDS16-J.+Prevent+XML+Injection,https://github.com/OWASP/CheatSheetSeries/blob/master/ch]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS16-J,CERT-J:IDS17-J,CWE:611,CWE:776,CWETOP25:2021:23,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:43,WASC:44]]></security>
    </normatives>
    <properties>
      <property name="parametersAsSources" descname="Assume that method parameters are untrusted inputs" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.XPathInjectionRule" message="XPathInjectionRule: Improper Neutralization of Data within XPath Expressions ('XPath Injection')" class="com.optimyth.qaking.security.rules.java.XPathInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.10,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[The software uses external input to dynamically construct an XPath expression used to
retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input.
This allows an attacker to control the structure of the query.

Effect: the attacker will have control over the information selected from the XML database and may use that ability
to control application flow, modify logic, retrieve unauthorized data, or bypass important checks (e.g. authentication).

This check looks for calls that create or execute an XPath expression, and detects if an untrusted input could
change the XPath code used at that call.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XPath injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private boolean doLogin(String loginID, char[] password)
  throws ParserConfigurationException, SAXException, IOException, XPathExpressionException {

  DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
  domFactory.setNamespaceAware(true);
  DocumentBuilder builder = domFactory.newDocumentBuilder();
  Document doc = builder.parse("users.xml");
  String pwd = hashPassword( password);

  XPathFactory factory = XPathFactory.newInstance();
  XPath xpath = factory.newXPath();
  // VIOLATION - xpath code concatenated with untrusted input
  XPathExpression expr = xpath.compile(
    "//users/user[login/text()='" + loginID + "' and password/text()='" + pwd + "' ]"
  );
  Object result = expr.evaluate(doc, XPathConstants.NODESET);
  NodeList nodes = (NodeList) result;

  for (int i = 0; i < nodes.getLength(); i++) {
    Node node = nodes.item(i).getChildNodes().item(1).getChildNodes().item(0);
    System.out.println( "Authenticated: " + node.getNodeValue());
  }

  return (nodes.getLength() >= 1);
}]]></example>
    <repair><![CDATA[// Escape metacharacters in input
loginID = loginID.replace("'", "&apos;");

// Alternatively, use XQuery APIs and avoid concatenating untrusted input
// XPath expression in login.qry
declare variable $loginID as xs:string external;
declare variable $password as xs:string external;
//users/user[@loginID=$loginID and @password=$password]

// Fixed doLogin()
private boolean doLogin(String loginID, String pwd)
  throws ParserConfigurationException, SAXException, IOException, XPathExpressionException {

  DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
  domFactory.setNamespaceAware(true);
  DocumentBuilder builder = domFactory.newDocumentBuilder();
  Document doc = builder.parse("users.xml");

  XQuery xquery = new XQueryFactory().createXQuery(new File("login.xry"));
  Map queryVars = new HashMap();
  queryVars.put("loginid", loginID);
  queryVars.put("password", pwd);
  NodeList nodes = xquery.execute(doc, null, queryVars).toNodes();

  for (int i = 0; i < nodes.getLength(); i++) {
    Node node = nodes.item(i).getChildNodes().item(1).getChildNodes().item(0);
    System.out.println( node.getNodeValue());
  }

  return (nodes.getLength() >= 1);
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/643.html,https://www.securecoding.cert.org/confluence/display/java/IDS53-J.+Prevent+XPath+Injection]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS53-J,CWE:643,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:39]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
      <property name="parametersAsSources" descname="Assume that method parameters are untrusted inputs" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.XsltInjection" message="XsltInjection: XML Injection (aka Blind XPath Injection)" class="com.optimyth.qaking.security.rules.java.XsltInjection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[If the software allows untrusted inputs to control part or all of an XSLT stylesheet,
an attacker may change the structure and content of resulting XML.

If the resulting XML ends in a browser, the attacker may choose contents to launch cross-site scripting
attacks, or execute operations at server with victim's identity allowed by the browser's same-origin policy
(a variantof the cross-site request forgery attack).

The attacker may also use this flaw to launch attacks targeted at the server, like fetching content
from arbitrary files, running arbitrary Java code, or executing OS commands, when certain XSLT functions
are not disabled.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XSLT Injection flaws allowing server-side and client-side attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.*;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

// A kind of XSLT-based responsive-web output,
// a "hidden" xslt.url parameter chooses which XSLT to use. Dangerous...
public void render(HttpServletRequest req, HttpServletResponse res) throws TransformerException, IOException {
  InputStream xmlUrl = openStream(req.getParameter("xml.url"));
  InputStream xsltUrl = openStream(req.getParameter("xslt.url"));

  Source xmlSource = new StreamSource(xmlUrl); // XML injection here, but this is another story
  Source xsltSource = new StreamSource(xsltUrl);
  Result result = new StreamResult(res.getOutputStream()); // "send to browser"

  TransformerFactory transFact = TransformerFactory.newInstance();
  Transformer trans = transFact.newTransformer(xsltSource); // VIOLATION, XSLT injection
  trans.transform(xmlSource, result);
}

Attackers may use as attack vectors:
* XSS payloads (run in browser rendering the transformation result):
<xsl:template match="/">
  <script>alert('You are XSSed')</script>
</xsl:template>

* Read arbitrary files from server:
<xsl:template match="/">
  <xsl:copy-of select="document('/etc/passwd')"/>
</xsl:template>

* Execute arbitrary Java code (if XSLT functions not disabled):
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:rt="http://xml.apache.org/xalan/java/java.lang.Runtime"
  xmlns:ob="http://xml.apache.org/xalan/java/java.lang.Object">
  <xsl:template match="/">
    <xsl:variable name="rtobj" select="rt:getRuntime()"/>
    <xsl:variable name="process" select="rt:exec($rtobj, 'rm -rf /')"/>
  </xsl:template>
</xsl:stylesheet>]]></example>
    <repair><![CDATA[// Do not allow external input to select the XSLT stylesheet to use.
// Instead, let the external input to choose between a fixed set of
// allowed stylesheets provided by the software.]]></repair>
    <reference><![CDATA[https://blog.csnc.ch/2015/06/xslt-security-and-server-side-request-forgery/]]></reference>
    <normatives>
      <security><![CDATA[CWE:91,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SPRING.AvoidDataSubmissionToNonEditableField" message="AvoidDataSubmissionToNonEditableField: Avoid data submissions to non editable fields" class="com.optimyth.qaking.spring.rules.AvoidDataSubmissionToNonEditableField" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.2,CWEScope:Integrity,Framework:Spring,Framework:Spring-MVC]]></tags>
    <description><![CDATA[Usually some model fields should not been edited, or at least its modification is not
expected, i.e. username, id,...

Spring MVC module automatically auto binds the HTML form data into the model by using all the available setters, even a
naive user doesn't expect they are going to be used.

Thus, a malicious attacker can send an infected request containing a value for some of the non editable fields.
Controller would receive this data and bind it to the model, allowing the attacker to perform malicious, unexpected,
activities.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent the modification of sensible data by a malicious user, allowing him to perform malicious activities as session hijacking , improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[@Controller
@RequestMapping(value = "/spring/cities")
public class SpringCityController { // VIOLATION

  @RequestMapping(value = "/{id}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
  public @ResponseBody
  SpringCity getById(@PathVariable("id") Integer id) {
    return new SpringCity("SpringCityById", 1982700, 52);
  }

  @RequestMapping(value = "/{id}", method = RequestMethod.PUT)
  public @ResponseBody
  SpringCity put(@ModelAttribute("customer") Customer customer, @RequestBody SpringCity SpringCity) {
    return SpringCity;
  }
}]]></example>
    <repair><![CDATA[import org.springframework.web.bind.WebDataBinder;

@Controller
@RequestMapping(value = "/spring/cities")
public class SpringCityController {

  @InitBinder
  public void initBinder(WebDataBinder binder) {
      binder.setDisallowedFields("administrator");
  }

  @RequestMapping(value = "/{id}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
  public @ResponseBody
  SpringCity getById(@PathVariable("id") Integer id) {
    return new SpringCity("SpringCityById", 1982700, 52);
  }

  @RequestMapping(value = "/{id}", method = RequestMethod.PUT)
  public @ResponseBody
  SpringCity put(@ModelAttribute("customer") Customer customer, @RequestBody SpringCity SpringCity) {
    return SpringCity;
  }
}]]></repair>
    <reference><![CDATA[http://projects.webappsec.org/w/page/13246913/Abuse%20of%20Functionality,https://cwe.mitre.org/data/definitions/915.html,https://www.owasp.org/index.php/Mass_Assignment_Cheat_Sheet]]></reference>
    <normatives>
      <security><![CDATA[CWE:915,OWASP:2021:A8,WASC:42]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <categories>
    <category name="JAVA" technology="JAVA" active="true" weight="1.0">
      <description><![CDATA[JAVA rules]]></description>
      <children>
        <category name="OPT.CRITERIUM_VALUE.CQM.EFFICIENCY" technology="JAVA" active="true" weight="8.0">
          <description><![CDATA[Efficiency]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.MAINTAINABILITY" technology="JAVA" active="true" weight="10.0">
          <description><![CDATA[Maintainability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.PORTABILITY" technology="JAVA" active="true" weight="5.0">
          <description><![CDATA[Portability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.RELIABILITY" technology="JAVA" active="true" weight="10.0">
          <description><![CDATA[Reliability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.SECURITY" technology="JAVA" active="true" weight="4.0">
          <description><![CDATA[Security]]></description>
        </category>
      </children>
    </category>
  </categories>
</ruleset>
