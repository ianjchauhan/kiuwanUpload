<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="qaking_c" updated="">
  <description>EDCAST_MOBILE</description>
  <rule name="OPT.C.CERTC.ARR01" message="ARR01: Do not apply the sizeof operator to a pointer when taking the size of an array" class="com.optimyth.cpp.rules.certc.arr.ARR01SizeofPointerInsteadArray" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Do not apply the sizeof operator to a pointer when taking the size of an array.

The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type.
However, using the sizeof operator to determine the size of arrays is error prone. This rule checks that sizeof operates on an array which is passed as a function argument, because C considers such parameter as a pointer, and sizeof returns the size of a pointer, not the size (number of bytes) of the array, as programmer expects.

The typical idion "sizeof(arr) / sizeof(arr[0])" to get the number of entries in array may not work, as sizeof(arr) return bytes of a pointer if arr is a function parameter. It is better to pass the number of items in array as argument.

The footnote in Section 6.5.3.4 of the C99 standard explains: "When applied to a parameter declared to have array or function type, the sizeof operator yields the size of the adjusted (pointer) type". Programmers, when using the above idiom, often do not have this in mind.]]></description>
    <priority>2</priority>
    <effort>5</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid logical errors and buffer overflow conditions due to incorrect sizeof usage on arrays.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[void clear(int array[]) {
  /*
    Non compliant:
    sizeof(array) == sizeof(int *), C considers array as int* because is function parameter.
    In many architectures, sizeof(int*)=4, sizeof(int)=4,
    so this code works as if every array passed has one element !
  */
  for (size_t i = 0; i < sizeof(array) / sizeof(array[0]); ++i) {
    array[i] = 0;
  }
}

enum {ARR_LEN = 100};
void clear2(int a[ARR_LEN]) {
  /* Non compliant, sizeof(a) returns sizeof(int*), not ARR_LEN */
  memset(a, 0, sizeof(a));
}
...
int array[] = ...;
clear(array);
clear2(array);]]></example>
    <repair><![CDATA[void clear(int array[], size_t len) {
  /* Fixed */
  for (size_t i = 0; i < len; ++i) {
    array[i] = 0;
  }
}

enum {ARR_LEN = 100};
void clear2(int a[], size_t len) {
  /* Fixed */
  memset(a, 0, len * sizeof(int));
}

int array[] = ...;
size_t len = sizeof(array) / sizeof(array[0]); /* work but when array is not a function parameter */
clear(array, len);
clear2(array, len);]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/ARR01-C.+Do+not+apply+the+sizeof+operator+to+a+pointer+when+taking+the+size+of+an+array,https://cwe.mitre.org/data/definitions/467.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR01,CWE:467]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ARR30" message="ARR30: Do not form or use out-of-bounds pointers or array subscripts on arrays." class="com.optimyth.cpp.rules.certc.arr.ARR30OutOfBoundPtrArrIndex" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Availability,CWEScope:Integrity]]></tags>
    <description><![CDATA[In de-references to C arrays, the index should be validated against the range of the array, ensuring that the index
(or offset when ) is not lower than 0 and not higher or equal than the number of entries on each array dimension.
In other case, an out-of-bounds de-reference may happen, which may lead to information exposure or modification of unintended
memory areas.

Please note that the array variable is also a pointer, and that arr[idx] is the same as *(arr + idx).]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[enum { ARRAY_SIZE = 100 };
static double buf[ARRAY_SIZE];

static void setArray(int idx, double v) {
  buf[idx] = v; /* VIOLATION - no check for array bounds */
}

static void setArray2(int idx, double v) {
  if (idx < ARRAY_SIZE) {
    buf[idx] = v; /* VIOLATION - no check for >= 0 */
  }
}]]></example>
    <repair><![CDATA[enum { ARRAY_SIZE = 100 };
static double buf[ARRAY_SIZE];

/* FIXED - check for array bounds */
static void setArray(int idx, double v) {
  if(idx >= 0 && idx < ARRAY_SIZE) {
    buf[idx] = v;
  }
}

/* FIXED - use unsigned index, validate on array size */
static void setArray2(size_t idx, int v) {
  if (idx < ARRAY_SIZE) {
    buf[idx] = v;
  }
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts,https://cwe.mitre.org/data/definitions/129.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:129]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ARR31" message="ARR31: Use consistent array notation across all source files" class="com.optimyth.cpp.rules.certc.arr.ARR31ConsistentArrayDeclaration" technology="C" active="true">
    <tags><![CDATA[Arrays]]></tags>
    <description><![CDATA[Use consistent notation to declare variables, including arrays, used in multiple files or translation units.
This requirement is not always obvious because within the same file, arrays are converted to pointers when passed as arguments to functions.

This means that the function prototype definitions "void func(char *a)" and "void func(char a[])" are equivalent.
However, outside of function prototypes, these notations are not equivalent if an array is declared using pointer notation in one file, and array notation in a different file.]]></description>
    <priority>4</priority>
    <effort>5</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Using different array notation across source files may result in the overwriting of system memory.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* main.c source file */
#include <stdlib.h>
enum { ARRAYSIZE = 100 };
char *a;
void insert_a(void);
int main(void) {
  a = (char *)malloc(ARRAYSIZE);
  if (a == NULL) {
    /* Handle allocation error */
  }
  insert_a();
  return 0;
}

/* insert_a.c source file */
/*
  Same identifier is declared as an array of char in insert_a.c file.
  In C, this is considered an incomplete type, the storage for which is defined elsewhere.
  Because definitions are inconsistent, assignment to a[0] results in undefined behavior.
 */
char a[]; /* Non Compliant, inconsistent with char *a in main.c */
void insert_a(void) {
  a[0] = 'a';
}]]></example>
    <repair><![CDATA[/* insert_a.h include file */
enum { ARRAYSIZE = 100 };
extern char *a;
void insert_a(void);

/* insert_a.c source file */
#include "insert_a.h"
char *a;
void insert_a(void) {
  a[0] = 'a';
}

/* main.c source file */
#include <stdlib.h>
#include "insert_a.h"
int main(void) {
  a = (char *)malloc(ARRAYSIZE);
  if (a == NULL) {
    /* Handle allocation error */
  }
  insert_a();
  return 0;
}]]></repair>
    <reference><![CDATA[]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR31]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ARR33" message="ARR33: Guarantee that copies are made into storage of sufficient size" class="com.optimyth.cpp.rules.certc.arr.ARR33CopiesMadeIntoStorageOfSufficientSize" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Copying data into an array that is not large enough to hold that data results in a buffer overflow.
To prevent such errors, data copied to the destination array must be restricted based on the size of the destination array, or, preferably, the destination array must be guaranteed to be large enough to hold the data to be copied.

Improper use of functions that limit copies with a size specifier, such as memcpy(), may result in a buffer overflow.

Note: Other rules check storage for blocks of character data, like STR31-C "Guarantee that storage for strings has sufficient space for character data and the null terminator". This rule only checks for memory copy functions, like memcpy() or memmove().]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Copying data to a buffer that is too small to hold that data results in a buffer overflow.
    Attackers can exploit this condition to execute arbitrary code.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[enum { WORKSPACE_SIZE = 256 };
void func(const int src[], size_t len) {
  int dest[WORKSPACE_SIZE];
  /* Non compliant: if len > 256, buffer overflow */
  memcpy(dest, src, len * sizeof(int));
  ...
}]]></example>
    <repair><![CDATA[/* Fix strategy #1: bounds checking */
enum { WORKSPACE_SIZE = 256 };
void func_bounds_checking(const int src[], size_t len) {
  int dest[WORKSPACE_SIZE];
  if (len > WORKSPACE_SIZE) {
    /* Handle error */
  }
  memcpy(dest, src, sizeof(int)*len);
  ...
}

/* Fix strategy #2: dynamic allocation */
void func_alloc(const int src[], size_t len) {
  int *dest; /* use pointer instead of auto array */
  if (len > SIZE_MAX / sizeof(int)) {
    /* handle integer overflow */
  }
  dest = (int *)malloc(sizeof(int) * len);
  if (dest == NULL) {
    /* Couldn't get the memory - recover */
  }
  memcpy(dest, src, sizeof(int) * len);
  ...
  free(dest);
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/676.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR33,CWE:119,CWE:131,CWE:676,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ARR35" message="ARR35: Do not allow loops to iterate beyond the end of an array" class="com.optimyth.cpp.rules.certc.arr.ARR35LoopMayIterateOutOfArray" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Loops are frequently used to traverse arrays to find the position of a particular element.
These loops may read or write memory as they traverse the array or use the position of an element, once discovered, to perform a copy or similar operation. Consequently, when searching an array for a particular element, it is critical that the element be found in the bounds of the array or that the iteration be otherwise limited to prevent the reading or writing of data outside the bounds of the array.

This rule is a generalization of STR32-C, "Null-terminate byte strings as required".
STR32-C requires that byte strings be null-terminated, within the memory allocated for the string, in situations where the termination of a loop depends on the existence of a null termination character.
This issue is a special case of a more general problem, where the termination condition of a loop depends on locating a particular element before the end of the array.
Failure to locate this element can result in a buffer overflow or a buffer overrun.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Incorrectly assuming that a loop termination element exists within an array can result in a buffer overflow and the execution
    of arbitrary code with the permissions of the vulnerable process or unintended information disclosure.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Vulnerability in DCOM RPC interface function, exploited by W32.Blaster worm */
HRESULT GetServerPath(WCHAR *pwszPath, WCHAR **pwszServerPath) {
  WCHAR *pwszFinalPath = pwszPath;
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1];
  hr = GetMachineName(pwszPath, wszMachineName);
  *pwszServerPath = pwszFinalPath;
}

HRESULT GetMachineName(
  WCHAR *pwszPath,
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])
{
  WCHAR *pwszServerName = wszMachineName;
  WCHAR *pwszTemp = pwszPath + 2;
  while ( *pwszTemp != L'\\' )
    *pwszServerName++ = *pwszTemp++; /* VIOLATION, no check on pwszServerName to avoid overflow on wszMachineName */

  *pwszServerName = '\0'; /* Properly terminate string with null character */
  /* ... */
}]]></example>
    <repair><![CDATA[HRESULT GetServerPath(WCHAR *pwszPath, WCHAR **pwszServerPath) {
  WCHAR *pwszFinalPath = pwszPath;
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1];
  hr = GetMachineName(pwszPath, wszMachineName);
  *pwszServerPath = pwszFinalPath;
}

HRESULT GetMachineName(
  WCHAR *pwszPath,
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])
{
  WCHAR *pwszServerName = wszMachineName;
  WCHAR *pwszTemp = pwszPath + 2;
  WCHAR *end_addr = pwszServerName + MAX_COMPUTERNAME_LENGTH_FQDN;

  /* FIXED, pwszServerName should not exceed end of array; end of input string also checked */
  while ( (*pwszTemp != L'\\') && (*pwszTemp != L'\0') && (pwszServerName < end_addr) )
    *pwszServerName++ = *pwszTemp++;

  /* ... */
  *pwszServerName = '\0'; /* Properly terminate string with null character */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR35,CWE:119,CWE:131,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ARR35_bis" message="ARR35: Do not allow loops to iterate beyond the end of an array" class="com.optimyth.cpp.rules.certc.arr.ARR35LoopMayIterateOutOfArray2" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Loops are frequently used to traverse arrays to find the position of a particular element.
These loops may read or write memory as they traverse the array or use the position of an element, once discovered, to perform a copy or similar operation. Consequently, when searching an array for a particular element, it is critical that the element be found in the bounds of the array or that the iteration be otherwise limited to prevent the reading or writing of data outside the bounds of the array.

This rule is a generalization of STR32-C, "Null-terminate byte strings as required".
STR32-C requires that byte strings be null-terminated, within the memory allocated for the string, in situations where the termination of a loop depends on the existence of a null termination character.
This issue is a special case of a more general problem, where the termination condition of a loop depends on locating a particular element before the end of the array.
Failure to locate this element can result in a buffer overflow or a buffer overrun.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Incorrectly assuming that a loop termination element exists within an array can result in a buffer overflow and the execution
    of arbitrary code with the permissions of the vulnerable process or unintended information disclosure.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[enum { ARR_SIZE = 100 };

int* reverse_numbers_array(void) {
  int *dyn_arr = (int *) calloc(ARR_SIZE, sizeof(int));
  for(int i = ARR_SIZE; i >= 0; i--) {
    // VIOLATION, when i==0, i-1 = -1, so buffer overflow...
    dyn_arr[i - 1] = i;
  }
  return dyn_arr;
}]]></example>
    <repair><![CDATA[enum { ARR_SIZE = 100 };

int* reverse_numbers_array(void) {
  int *dyn_arr = (int *) calloc(ARR_SIZE, sizeof(int));
  // fixed, i-1 ranges from ARR_SIZE - 1 to 0, no buffer overflow
  for(int i = ARR_SIZE; i > 0; i--) {
    dyn_arr[i - 1] = i;
  }
  return dyn_arr;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR35,CWE:119,CWE:131,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ARR38" message="ARR38: Do not add or subtract an integer to a pointer if resulting value does not refer to a valid array element" class="com.optimyth.cpp.rules.certc.arr.ARR38NoPointerArithOutOfArray" technology="C" active="true">
    <tags><![CDATA[Arrays,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Do not add or subtract an integer to a pointer if the resulting value does not refer to an element within the array (or to the nonexistent element just after the last element of the array).

According to C99, Section 6.5.6: "If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.
If the pointer resulting from the addition (or subtraction) is outside of the bounds of the array, an overflow has occurred and the result is undefined".

If the pointer resulting from the addition (or subtraction) is outside of the bounds of the array, an overflow has occurred and the result is undefined. See code example for some non-compliant pointer usages.

NOTE: This is a partial implementation of ARR38 rule. Only array dereferences are checked. See code example for more details.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[If adding or subtracting an integer to a pointer results in a reference to an element outside the array or one past
    the last element of the array object, the behavior is undefined but frequently leads to a buffer overflow,
    which can often be exploited to run arbitrary code.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[int ar[20];
int *ip;
/* Non compliant: &ar[20] is allowed (but ar[19] is last element), &ar[21] is undefined behaviour */
for (ip = &ar[0]; ip < &ar[21]; ip++) {
  *ip = 0;
}]]></example>
    <repair><![CDATA[int ar[20];
int *ip;
/* sizeof(ar) / sizeof(ar[0]) = number of elements in ar = 20 */
for (ip = &ar[0]; ip < &ar[ sizeof(ar) / sizeof(ar[0]) ]; ip++) {
  *ip = 0;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/129.html,https://wiki.sei.cmu.edu/confluence/display/c/ARR38-C.+Guarantee+that+library+functions+do+not+form+invalid+pointers]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ARR38,CWE:129]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ENV01" message="ENV01: Do not make assumptions about the size of an environment variable" class="com.optimyth.cpp.rules.certc.env.ENV01ControlSizeEnvironmentVar" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Environment]]></tags>
    <description><![CDATA[Do not make any assumptions about the size of environment variables, because an adversary might have full control over the environment.

If the environment variable needs to be stored, then the length of the associated string should be calculated and the storage dynamically allocated (see STR31-C, "Guarantee that storage for strings has sufficient space for character data and the null terminator").]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Making assumptions about the size of an environmental variable can result in a buffer overflow attack.
    If environment variable size is checked in operations that could overflow buffers and depend on such variables,
    buffer-overflow risk is reduced.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char copy[16];
char *temp = getenv("MY_ENV_VAR");
if (temp != NULL) {
  strcpy(copy, temp); /* VIOLATION, MY_ENV_VAR could have more than 15 characters */
}]]></example>
    <repair><![CDATA[/*
   strlen() used to calculate the size of MY_ENV_VAR,
   and the required space is dynamically allocated
 */
char *copy = NULL;
char *temp = getenv("TEST_ENV");
if (temp != NULL) {
  copy = (char *)malloc(strlen(temp) + 1);
  if (copy != NULL) {
    strcpy(copy, temp);
  }
  else {
    /* Handle error condition */
  }
  /* Remember to free allocated memory when not used anymore... */
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/ENV01-C.+Do+not+make+assumptions+about+the+size+of+an+environment+variable,https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ENV01,CWE:119,CWE:131,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ENV04" message="ENV04: Do not call system() if you do not need a command processor" class="com.optimyth.cpp.rules.certc.env.ENV04DoNotUseSystem" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,Environment]]></tags>
    <description><![CDATA[The C99 function system() executes a specified command by invoking an implementation-defined command processor, such as a UNIX shell or CMD.EXE in Windows NT and later Windows versions. The POSIX popen() function also invokes a command processor but creates a pipe between the calling program and the executed command, returning a pointer to a stream that can be used to either read from or write to the pipe.

Command interpreters such as the POSIX command-language interpreter sh and CMD.EXE, however, provide functionality in addition to executing a simple command. If this functionality is not required, it is a good idea not to use system() or any other function that invokes a command interpreter, as doing so significantly complicates the command-string sanitization.

To fix, replace calls to system() or popen() with calls to exec* family of functions (execve, execlp, execvp, execl, execle, execv or execve). Such functions do not use (unlike system() or popen()) a full shell interpreter, so they are not vulnerable to command injection attacks. Of course, if the functionality of the external program could be replaced by existing library calls, you may use them instead.

Additional precautions, such as to ensure that the external executable program launched cannot be modified by an untrusted user, are outside of the scope of this rule.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Reduce the risk due to command injection vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *input = NULL;
/* input gets initialized by user */

char cmdbuf[512];
int len_wanted = snprintf(
  cmdbuf, sizeof(cmdbuf), "any_cmd '%s'", input
);
if (len_wanted >= sizeof(cmdbuf)) {
  perror("Input too long");
}
else if (len_wanted < 0) {
  perror("Encoding error");
}
else if ( system(cmdbuf) == -1 ) { /* Non compliant */
  perror("Error executing input");
}]]></example>
    <repair><![CDATA[/*
This compliant solution is significantly different from the equivalent noncompliant code example.
First, input is incorporated into the args array and passed as an argument to execve().
This eliminates any concerns about buffer overflow or string truncation while forming the command string.
Second, this compliant solution must fork a new process before executing "/usr/bin/any_exe" in the child process.
While this is more complicated than calling system(), the added security is worth the additional effort
*/

char *input = NULL;
/* input gets initialized by user */

pid_t pid;
int status;
pid_t ret;
char *const args[3] = {"any_exe", input, NULL};
char **env;
extern char **environ;

/* ... Sanitize arguments ... */
pid = fork();
if (pid == -1) {
  perror("fork error");
}
else if (pid != 0) {
  while ((ret = waitpid(pid, &status, 0)) == -1) {
    if (errno != EINTR) {
      perror("Error waiting for child process");
      break;
    }
  }
  if ((ret != -1) &&
      (!WIFEXITED(status) || !WEXITSTATUS(status)) ) {
   /* Report unexpected child status */
  }
} else {
  /*... Initialize env as a sanitized copy of environ ...*/
  if (execve("/usr/bin/any_exe", args, env) == -1) {
    perror("Error executing any_exe");
    _exit(127); /* command not found error */
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/78.html,https://cwe.mitre.org/data/definitions/88.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ENV04,CWE:77,CWE:78,CWE:88,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:31]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.ENV32" message="ENV32: No atexit handler should terminate in any way other than by returning" class="com.optimyth.cpp.rules.certc.env.ENV32AtexitHandlerTerminateWithReturn" technology="C" active="true">
    <tags><![CDATA[Environment]]></tags>
    <description><![CDATA[No atexit()-registered handler should terminate in any way other than by returning.
It is important and potentially safety-critical for all the atexit() handlers to be allowed to perform their cleanup actions.
This is particularly true because the application programmer does not always know about handlers that may have been installed by support libraries.
Two specific issues include nested calls to exit() and terminating a call to an atexit()-registered handler by invoking longjmp.

The C99 exit() function is used for normal program termination (see ERR04-C, "Choose an appropriate termination strategy").
Nested calls to exit() result in undefined behavior. This can occur only when exit() is invoked from a function registered with atexit() or when exit() is called from within a signal handler (see SIG30-C, "Call only asynchronous-safe functions within signal handlers").

If a call to the longjmp function is made that would terminate the call to a function registered with atexit(), the behavior is undefined.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Initialization and shutdown</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid undefined behaviour during program termination.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <stdio.h>
#include <stdlib.h>

void exit1(void) { /* Compliant, no forbidden calls */
  /* ...cleanup code... */
  return;
}

void exit2(void) { /* Non compliant, calls exit() */
  if (/* condition */) {
    /* ...more cleanup code... */
    exit(0);
  }
  return;
}

int main(void) {
  if (atexit(exit1) != 0) {
    /* Handle error */
  }
  if (atexit(exit2) != 0) {
    /* Handle error */
  }
  /* ...program code... */
  exit(0);
}]]></example>
    <repair><![CDATA[/* Rest of code same as example */

void exit2(void) { /* Fixed, call to exit() removed */
  if (/* condition */) {
    /* ...more cleanup code... */
  }
  return;
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/ENV32-C.+All+exit+handlers+must+return+normally,https://cwe.mitre.org/data/definitions/705.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:ENV32,CWE:705]]></security>
    </normatives>
    <properties>
      <property name="forbiddenFunctions" descname="Comma-separated list of functions that should not be called in atexit handlers" value="longjmp, siglongjmp, exit"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.EXP01" message="EXP01: Use of sizeof() on a Pointer Type" class="com.optimyth.cpp.rules.certc.exp.EXP01SizeofPointer" technology="C" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity,Expressions]]></tags>
    <description><![CDATA[Do not take the size of a pointer to a type when you are trying to determine the size of the type.
Taking the size of a pointer to a type always returns the size of the pointer and not the size of the type.
This can be especially problematic when calculating the size of an array (see rule ARR01, "Do not apply the sizeof operator to a pointer when taking the size of an array").

The rule tries to infer the type of the sizeof argument expression, and emits a violation when pointer type.
This is typically a programmer error. Although sometimes the size of a pointer is relevant, e.g. when developing memory management frameworks, rule considers that sizeof on any expression of pointer type is a violation; if needed, set suppressions in the places where sizeof on pointer type expressions is allowed.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid buffer overflow and related security vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[double *allocate_array(size_t num_elems) {
  double *d_array;
  /* Non Compliant, programmer really wanted sizeof(double) */
  if ( num_elems > SIZE_MAX / sizeof(d_array) ) {
    /* handle error condition */
  }

  d_array = (double *)malloc(sizeof(d_array) * num_elems); /* Non Compliant */
  if (d_array == NULL) {
    /* handle error condition */
  }

  return d_array;
}]]></example>
    <repair><![CDATA[/*
   sizeof(*d_array) gives size of each element in array (a double),
   and works even if d_array == NULL or uninitialized,
   as sizeof operates on the type of the argument, not on its value
 */
double *allocate_array(size_t num_elems) {
  double *d_array;
  /* Fixed */
  if ( num_elems > SIZE_MAX / sizeof(*d_array) ) {
    /* handle error condition */
  }

  d_array = (double *)malloc(sizeof(*d_array) * num_elems); /* Fixed */
  if (d_array == NULL) {
    /* handle error condition */
  }

  return d_array;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/467.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:EXP01,CWE:467]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.EXP33" message="EXP33: Use of Uninitialized Variable" class="com.optimyth.cpp.rules.certc.exp.EXP33DoNotReferenceUninitializedMemory" technology="C" active="true">
    <tags><![CDATA[CWEScope:Authorization,CWEScope:Availability,CWEScope:Integrity,Expressions]]></tags>
    <description><![CDATA[Local, automatic variables can assume unexpected values if they are used before they are initialized.

C99 standard, Section 6.7.8, specifies, "If an object that has automatic storage duration is not initialized explicitly,
its value is indeterminate". In the common case, on architectures that make use of a program stack, this value defaults
to whichever values are currently stored in stack memory.

While uninitialized memory often contains zeroes, this is not guaranteed. Consequently, uninitialized memory can cause a program
to behave in an unpredictable or unplanned manner and may provide an avenue for attack.

In most cases, compilers warn about uninitialized variables. These warnings should be resolved as recommended by MSC00-C,
"Compile cleanly at high warning levels".

Additionally, memory dynamically allocated by functions such as malloc() should not be used before being initialized,
as its contents are indeterminate.

Note: The related rule MISRAC.InitialiseAutoVariablesBeforeUse checks for local variables non initialized before usage,
but do not check that dynamically allocated memory is initialized before usage.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Accessing uninitialized variables generally leads to unexpected program behavior.
In some cases, these types of flaws may allow the execution of arbitrary code.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <stdio.h>
#include <ctype.h>
#include <string.h>

int do_auth(void) {
  char *username;
  char *password;
  /* Get username and password from user, return -1 if invalid */
}

void report_error(const char *msg) {
  const char *error_log; /* programmer forgot to assign msg here */
  char buffer[24];
  sprintf(buffer, "Error: %s", error_log); /* VIOLATION: error_log uninitialized */
  printf("%s\n", buffer);
}

int main(void) {
  if (do_auth() == -1) {
    report_error("Unable to login");
  }
  return 0;
}]]></example>
    <repair><![CDATA[/* Rest of code remains the same */

/* Simplicity is the shortest path to security... */
void report_error(const char *msg) {
  printf("Error: %s\n", msg);
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/EXP33-C.+Do+not+read+uninitialized+memory,https://cwe.mitre.org/data/definitions/457.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:EXP33,CWE:457]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.EXP34" message="EXP34: NULL Pointer Dereference" class="com.optimyth.cpp.rules.certc.exp.EXP34CheckNullPointerDereference" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Expressions]]></tags>
    <description><![CDATA[Attempting to dereference a null pointer results in undefined behavior, typically abnormal program termination.

This rule checks that any pointer to a memory area (typically as result from a function call like malloc() or fgets) if checked for NULL before dereference, as a null pointer dereference have undefined behaviour. If pointer is dereferenced without previous check against NULL (or zero), a violation is emitted on the call to the function call that could return true.

For functions that use errno to indicate error condition, a check against errno is considered an alternate way to check for the validity of the pointer.

In some situations and platforms, dereferencing a null pointer can lead to the execution of arbitrary code.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Dereferencing a null pointer results in undefined behavior, typically abnormal program termination.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[size_t size = strlen(input_str)+1;
str = (char *) malloc(size); /* VIOLATION, no check for null */
memcpy(str, input_str, size); /* str is dereferenced in memcpy */
/* ... */
free(str);
str = NULL;]]></example>
    <repair><![CDATA[size_t size = strlen(input_str)+1;
str = (char *) malloc(size);
if (str == NULL) {
  /* Handle Allocation Error */
} else {
  memcpy(str, input_str, size);
  /* ... */
  free(str);
  str = NULL;
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers,https://cwe.mitre.org/data/definitions/476.html,https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-deref]]></reference>
    <normatives>
      <security><![CDATA[Agile Alliance:Clear-CNUL,CERT-C:EXP34,CPPCOREGL:ES.65,CWE:476,CWETOP25:2021:15]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.FIO01" message="FIO01: Be careful using functions that use file names for identification" class="com.optimyth.cpp.rules.certc.fio.FIO01AvoidFileNameFunctionsInSequence" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.11.3,ASVS-v4.0.2:11.1.6,CWEScope:Integrity,CWEScope:Non-Repudiation,Input / Output]]></tags>
    <description><![CDATA[Be careful using functions that use file names for identification.

Many file-related security vulnerabilities result from a program accessing an unintended file object because file names are only loosely bound to underlying file objects.
File names provide no information regarding the nature of the file object itself.
Furthermore, the binding of a file name to a file object is reasserted every time the file name is used in an operation.
File descriptors and FILE pointers are bound to underlying file objects by the operating system.

Accessing files via file descriptors or FILE pointers rather than file names provides a greater degree of certainty as to which object is actually acted upon.
It is recommended that files be accessed through file descriptors or FILE pointers where possible.

The rule checks that functions in filenameFunctions property are not called in sequence on the same filename.

See FIO10-C, "Take care when using the rename() function", and FIO08-C, "Take care when calling remove() on an open file".]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Many file-related vulnerabilities, such as "time-of-check, time-of-use" race conditions, can be exploited to cause a program to access an unintended file.
    Using FILE pointers or file descriptors to identify files (instead of using file names to identify files) reduces the chance of accessing an unintended file.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *file_name;
FILE *f_ptr;
/* Initialize file_name */

f_ptr = fopen(file_name, "w");
if (f_ptr == NULL) {
  /* Handle error */
}
/* ... more code ... */
/*
  Do not rely on filename to ensure that
  permissions changed on previously opened file
*/
if (chmod(file_name, S_IRUSR) == -1) { /* Non Compliant */
  /* Handle error */
}]]></example>
    <repair><![CDATA[/*
  POSIX defines fchmod() that operate on file descriptors
  (so use open() instead of fopen() to open the file)
*/
char *file_name;
int fd;
/* Initialize file_name */
fd = open( file_name,  O_WRONLY | O_CREAT | O_EXCL, S_IRWXU);
if (fd == -1) {
/* Handle error */
}
/* ... more code ... */
/* Fixed, permissions changed on previously opened file */
if (fchmod(fd, S_IRUSR) == -1) {
  /* Handle error */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/676.html,https://cwe.mitre.org/data/definitions/367.html,https://wiki.sei.cmu.edu/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO01,CWE:367,CWE:676]]></security>
    </normatives>
    <properties>
      <property name="filenameFunctions" descname="Comma-separated list of functions that use filename (in first argument)" value="rename, remove, unlink, chmod, stat, lstat, chown, access, utime, utimes, open, creat, fopen, freopen, mknod, tmpnam"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.FIO30" message="FIO30: Exclude unsanitized user input from format strings" class="com.optimyth.cpp.rules.certc.fio.FIO30ExcludeUserInputFromFormatStrings" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.4.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Input / Output]]></tags>
    <description><![CDATA[Never call any formatted I/O function with a format string containing user input.

An attacker who can fully or partially control the contents of a format string can crash a vulnerable process, view the contents of the stack, view memory content, or write to an arbitrary memory location and consequently execute arbitrary code with the permissions of the vulnerable process.

Formatted output functions are particularly dangerous because many programmers are unaware of their capabilities (for example, they can write an integer value to a specified address using the %n conversion specifier).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid format-string vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#define MSG_FORMAT "%s cannot be authenticated.\n"
void incorrect_password(const char *user) { /* user is untrusted */
  /* user names are restricted to 256 characters or less */
  static const char *msg_format = MSG_FORMAT;
  size_t len = strlen(user) + sizeof(MSG_FORMAT);
  char *msg = (char *)malloc(len);
  if (!msg) {
    /* Handle error condition */
  }
  int ret = snprintf(msg, len, msg_format, user);
  if (ret < 0 || ret >= len) {
    /* Handle error */
  }
  fprintf(stderr, msg); /* Non Compliant, user -snprintf-> msg (msg is format string) */
  syslog(LOG_INFO, msg); /* Non Compliant, same as above (msg is format string) */
  free(msg);
  msg = NULL;
}]]></example>
    <repair><![CDATA[#define MSG_FORMAT "%s cannot be authenticated.\n"
void incorrect_password(char const *user) {
  fprintf(stderr, MSG_FORMAT, user); /* Fixed, format string does not depend on untrusted sources */
  syslog(LOG_INFO, MSG_FORMAT, msg); /* Fixed, format string does not depend on untrusted sources */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/134.html,https://wiki.sei.cmu.edu/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO30,CWE:134,CWETOP25:2011:23,OWASP:2004:A5,PCI-DSS:6.5.1,WASC:10]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.FIO33" message="FIO33: Detect and handle input/output errors resulting in undefined behavior" class="com.optimyth.cpp.rules.certc.fio.FIO33CheckErrorsInIOFunctions" technology="C" active="true">
    <tags><![CDATA[Input / Output]]></tags>
    <description><![CDATA[Detect and handle input output errors resulting in undefined behavior.

Always check the status of input/output functions that can fail and leave variables improperly initialized.
Failure to detect and properly handle these errors can lead to undefined program behavior.

This rule checks common I/O functions that return a value that shall be checked for errors. Failure to perform error checking before using the element produced by the function (e.g. a memory buffer, a file descriptor, etc.) will result in a violation.

Functions checked are: * fopen - Pointer returned must be checked for null.
* fgets - Pointer returned must be checked for null.
* gets - Must be replaced by equivalent fgets call.
* printf and similar functions - Returned size value must be checked for negative values.
Checked functions are printf, vprintf, fprintf, vfprintf, sprintf, vsprintf, snprintf and vsnprintf.
Note: If allowUnsecurePrintf=false, printf and sprintf are forbidden unconditionally.

See code examples for details.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Error handling and fault isolation</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid undefined behaviour or buffer overflow vulnerabilities, due to failure to handle errors in I/O functions.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* fgets example */
char buf[BUFSIZ];
fgets(buf, sizeof(buf), stdin); /* Non compliant, does not check for errors */
buf[strlen(buf) - 1] = '\0';

/* fopen example */
FILE *fptr = fopen(file_name, "w"); /* Non compliant, fptr is not checked for NULL (which signals error) */
/* process file */
fputs(text, fptr);
fclose(fptr);

/* snprintf example */
j = snprintf(buffer, sizeof(buffer)," String: %s\n", s); /* Non compliant, return is not checked */
j += snprintf(buffer + j, sizeof(buffer) - j, " Character: %c\n", c); /* j could be negative in case of error, or could exceed buffer size */]]></example>
    <repair><![CDATA[/* fgets example */
char buf[BUFSIZ];
char *p;
if (fgets(buf, sizeof(buf), stdin)) {
  /* Process read data in buf. See FIO37 */
} else {
  /* fgets failed, handle error */
}

/* fopen example */
FILE * fptr = fopen(file_name, "w"); /* Fixed, fptr checked for fopen error */
if (fptr == NULL) {
  /* Handle error */
} else {
  /* process file */
  /* For fputs, check for errors (return == EOF or ferror(fptr)) */
  /* For fclose(), check that return is negative in case of error */
}

/* snprintf example */
rc = snprintf(buffer, sizeof(buffer)," String: %s\n", s); /* compliant, return is checked */
if(rc == -1 || rc >= sizeof(buffer)) { /* Handle error */
} else j += rc;
rc snprintf(buffer + j, sizeof(buffer) - j, " Character: %c\n", c);
if(rc == -1 || rc >= sizeof(buffer) - j) { /* Handle error */
} else j += rc;]]></repair>
    <reference><![CDATA[]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO33]]></security>
    </normatives>
    <properties>
      <property name="allowUnsecurePrintf" descname="If false, printf and sprintf are not allowed and violation is emitted recommending snprintf; if true, allowed but returned value must be checked." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.FIO34" message="FIO34: Use int to capture the return value of character I/O functions" class="com.optimyth.cpp.rules.certc.fio.FIO34UseIntForCharFunctionReturn" technology="C" active="true">
    <tags><![CDATA[Input / Output]]></tags>
    <description><![CDATA[Use int to capture the return value of character I/O functions.

The character input/output functions fgetc(), getc(), and getchar() all read a character from a stream and return it as an int.
If the stream is at end-of-file, the end-of-file indicator for the stream is set and the function returns EOF.
If a read error occurs, the error indicator for the stream is set and the function returns EOF.
The character input/output functions fputc(), putc(), putchar(), and ungetc() also return a character or EOF.
Do not convert the value returned by a character input/output function to char if that value will be compared to EOF.
Once the return value of these functions has been converted to a char type, character values may be indistinguishable from EOF.

See STR00-C, "Represent characters using an appropriate type", for more information on the proper use of character types.
This rule applies to the use of all character input/output functions.

Historically, using a char type to capture the return value of character input/output functions has resulted in significant vulnerabilities, including command injection attacks (see the CA-1996-22 advisory on www.cert.org). As a result, the severity of this error is high.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid logical errors that could result in security vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char buf[BUFSIZ];
char c;
int i = 0;
/* Non compliant, char var returned by character I/O function compared against EOF */
while ( (c = getchar()) != '\n' && c != EOF ) {
  if (i < BUFSIZ-1) {
    buf[i++] = c;
  }
}
buf[i] = '\0';]]></example>
    <repair><![CDATA[/*
In this compliant solution, the c variable is declared as an int.
Additionally, feof() is used to test for end-of-file and ferror() is used to test for errors.
*/
char buf[BUFSIZ];
int c;
int i = 0;
while ( ((c = getchar()) != '\n') && !feof(stdin) && !ferror(stdin))
{
  if (i < BUFSIZ-1) {
    buf[i++] = c;
  }
}
buf[i] = '\0';

/*
Note: while ( ((c = getchar()) != '\n') && c != EOF) is enough to check for EOF according to this rule,
but FIO35-C demands checks on ferror() and feof()
*/]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/FIO34-C.+Distinguish+between+characters+read+from+a+file+and+EOF+or+WEOF]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO34]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.FIO36" message="FIO36: Do not assume a new-line character is read when using fgets()" class="com.optimyth.cpp.rules.certc.fio.FIO36DoNotAssumeNewlineReadWithFgets" technology="C" active="true">
    <tags><![CDATA[Input / Output]]></tags>
    <description><![CDATA[The fgets() function is typically used to read a new-line-terminated line of input from a stream.
The fgets() function takes a size parameter for the destination buffer and copies, at most, size-1 characters from a stream to a string. Truncation errors can occur if the programmer assumes that the last character in the destination string is a new-line.

The fgetws() function is similarly affected.

NOTE: Rule FIO37 looks for similar issue, but FIO37 is interested in buffer underflow, while FIO36 is interested in truncation errors. If truncation is what it was intended, you may add suppressions on the violations where truncation behaviour is allowed.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Error handling and fault isolation</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended truncation on strings read with fgets(), when last character read is not a new line.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char buf[BUFSIZ + 1];
/* Read a line, removing the new-line character at the end (fgets return it) */
if (fgets(buf, sizeof(buf), stdin)) {
  if (*buf) { /* this check avoids buffer underflow, see FIO37-C */
    /* Violation, potential string truncation: char at strlen(buf) - 1 is not necessarily new-line */
    buf[strlen(buf) - 1] = '\0';
  }
}
else {
  /* Handle error condition */
}]]></example>
    <repair><![CDATA[char buf[BUFSIZ + 1];
char *p;
if (fgets(buf, sizeof(buf), stdin)) {
  p = strchr(buf, '\n'); /* Find new-line */
  if (p) {
    *p = '\0';
  }
}
else {
  /* Handle error condition */
}]]></repair>
    <reference><![CDATA[]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO36]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.FIO37" message="FIO37: Do not assume character data has been read" class="com.optimyth.cpp.rules.certc.fio.FIO37DoNotAssumeCharactersRead" technology="C" active="true">
    <tags><![CDATA[Input / Output]]></tags>
    <description><![CDATA[When using character-oriented input function calls (e.g. fgets()), do not assume any character data has been read.
Errors can occur when assumptions are made about the type of data being read.
These assumptions may be violated, for example, when binary data has been read from a file instead of text from a users terminal (see FIO14-C, "Understand the difference between text mode and binary mode with file streams"). On some systems, it may also be possible to input a null byte (as well as other binary codes) from the keyboard.

This rule checks that a buffer is loaded by calls to fgets() and then a position in the buffer is read using the character length of the buffer (extracted using strlen), which could be 0. See examples for full details.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid out-of-bounds conditions when it is not assumed that a non-zero character is read by fgets()]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char buf[BUFSIZ + 1];
if (fgets(buf, sizeof(buf), stdin) == NULL) {
/* Handle error */
}
/* Non Compliant, strlen(buf) could be 0, producing an array out of bounds condition. */
buf[strlen(buf) - 1] = '\0';]]></example>
    <repair><![CDATA[/* Do not assume that buffer is filled with at least one non-zero character */
char buf[BUFSIZ + 1];
char *p;
if (fgets(buf, sizeof(buf), stdin)) {
  p = strchr(buf, '\n'); /* Fixed */
  if (p) {
    *p = '\0';
  }
} else {
  /* Handle error condition */
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/FIO37-C.+Do+not+assume+that+fgets%28%29+or+fgetws%28%29+returns+a+nonempty+string+when+successful]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO37]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.FIO43" message="FIO43: Creation of Temporary File in Directory with Incorrect Permissions" class="com.optimyth.cpp.rules.certc.fio.FIO43DontCreateTempFilesInSharedDirectories" technology="C" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,Input / Output]]></tags>
    <description><![CDATA[Programmers frequently create temporary files in directories that are writable by everyone (examples are /tmp and /var/tmp on UNIX and C:\TEMP on Windows), when temporary data cannot reside in memory or as a inter-process communication (IPC) mechanism.

This is a dangerous practice, because well-known file in a shared directory could be easily highjacked or manipulated by an attacker.

To avoid the issue, programmer may use other IPC mechanism (sockets, shared memory, remote procedure calls...), or use a secure directory (or a chroot jail) that can only be accessed by application instances.

Please note that POSIX mmap() function may use temporary files in shared directories.

Why using temporary files is a dangerous practice? Priviledged programs can be exploited if attacker can overwrite protected (system or user) files (e.g. attacker simply replace temporary file with a link to the file the attacker is interested to, for example /etc/passwd). Additionally, if sensitive information is stored in temporary files, an attacker may have access to it.

To be secure, temporary files must be: 1) created with unique and unpredicatable file names, 2) opened with exclusive access, 3) removed before the program exits, 4) opened with appropiate permissions.

This is so difficult to be done properly, that this rule emits a violation for each usage of temporary file functions, with names in the tempfileFunctions property, without any further check (the standard admits some usages as compliant, but this implementation simply ban any usage of temporary files).
If after review a temporary file usage is considered safe, add a suppression on such save usages.
See CERT FIO34-C rule in the CERT Secure Coding Standard book for full details.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Insecure temporary file creation can lead to a program accessing unintended files and permission escalation on local systems.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char file_name[L_tmpnam];
FILE* fp;
/* VIOLATION, does not ensure unique or unpredictable file names, and only in shared temp directory */
if (!tmpnam(file_name)) {
  /* Handle error */
}

/* A TOCTOU race condition exists here, see FIO01 */
fp = fopen(file_name, "wb+");

if (fp == NULL) {
  /* Handle error */
}]]></example>
    <repair><![CDATA[Do not use temporary files; and if they are really needed, check section FIO34 of CERT Secure Coding Standard and create a suppression for usages that are deemed correct.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/379.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO43,CWE:379]]></security>
    </normatives>
    <properties>
      <property name="tempfileFunctions" descname="Forbiddden functions related to temporary files creation" value="tmpnam, tmpnam_s, tmpfile, tmpfile_s, mktemp, mkstemp"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.INT13" message="INT13: Use bitwise operators only on unsigned operands" class="com.optimyth.cpp.rules.misra.expressions.UnsignedBitwiseOperands" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Integers]]></tags>
    <description><![CDATA[Bitwise operations (~, <<,  >>, &, ^ and |) and their combinations with assign operator (<<=, >>=, &=, ^= and |=)
are not normally meaningful on signed integers. Problems can arise if, for example, a right shift moves the sign bit into the number,
or a left shift moves a numeric bit into the sign bit (or a shift by a negative number).

Bitwise operators should be used only with unsigned integer operands, as the result of bitwise operations on signed integers are implementation-defined.
The C11 standard, section 6.5 paragraph 4, states: "Some operators (the unary operator ~ , and the binary operators <<, >>, &, ^, and |,
collectively described as bitwise operators) shall have operands that have integral type. These operators return values that depend
on the internal representations of integers, and thus have implementation-defined and undefined aspects for signed types."

The Microsoft C compiler states, for example: "Bitwise operations on signed integers work the same as bitwise operations on unsigned integers."
The GCC compiler says about the implementation of bitwise operations on signed integers: "Bitwise operators act on the representation of the value
including both the sign and value bits, where the sign bit is considered immediately above the highest-value value bit."

This rule checks that operands of bitwise operators are unsigned.

Note: The type of an integer literal depends on multiple factors including the magnitude of the literal,
the implementation sizes of the integer types, the presence of suffixes like u, and the number base in which the value is expressed
(i.e. decimal, octal or hexadecimal). The rule will report a defect for integer literals without the 'u' suffix when they are operands
of a bitwise expression, except when at right-hand side of a shift operation (so expr << 2 is considered equivalent to expr << 2U).

Note: This rule uses same implementation as MISRA-C 12.7 rule (OPT.MISRAC.UnsignedBitwiseOperands).]]></description>
    <priority>4</priority>
    <effort>2</effort>
    <vulntype>Number handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Performing bitwise operations on signed numbers can lead to buffer overflows and the execution of arbitrary code
    by an attacker in some cases, unexpected or implementation defined behavior in others.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[int rc = 0;
int stringify = 0x80000000; /* -1 in 32 bit platform */
char buf[sizeof("256")];
/* Non compliant: stringify >> 24 evaluates to 0xFFFFFF80 or 4,294,967,168 */
rc = snprintf(buf, sizeof(buf), "%u", stringify >> 24);
/* snprintf truncates (but result is incorrect); with sprinf() a buffer overflow occurs */
if (rc == -1 || rc >= sizeof(buf)) /* handle error */;]]></example>
    <repair><![CDATA[int rc = 0;
unsigned int stringify = 0x80000000; /* FIXED */
char buf[sizeof("256")];
/* stringify >> 24 evaluates to 0x00000080 or 128 */
rc = snprintf(buf, sizeof(buf), "%u", stringify >> 24);
if (rc == -1 || rc >= sizeof(buf)) /* handle error */ ;]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/INT13-C.+Use+bitwise+operators+only+on+unsigned+operands,https://cwe.mitre.org/data/definitions/682.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:INT13,CWE:682]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.INT34" message="INT34: In shift operations, do not shift a negative number of bits or more bits than exist in the left operand" class="com.optimyth.cpp.rules.certc.integer.INT34ShiftProperRightOperand" technology="C" active="true">
    <tags><![CDATA[Integers]]></tags>
    <description><![CDATA[Bitwise shifts include left-shift operations of the form shift-expression << additive-expression and right-shift operations of the form shift-expression >> additive-expression.
The integer promotions are performed on the operands, each of which has an integer type.
The type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.

In almost every case, an attempt to shift by a negative number of bits or by more bits than exist in the operand indicates a bug (logic error). This is different from overflow, where there is simply a representational deficiency (see INT32-C, "Ensure that operations on signed integers do not result in overflow").]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Number handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid undefined behaviour that could end in security vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[uint32_t f(uint32_t number, int32_t bits) {
  /* Non compliant, bits could be negative or higher than 32 */
  return number >> bits;
}]]></example>
    <repair><![CDATA[uint32_t f(uint32_t number, int32_t bits) {
  if ( (bits >= sizeof(uint32_t) * 8) && (bits >= 0) { /* FIXED */
    /* handle error condition */
  } else {
    return number >> bits;
  }
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/INT34-C.+Do+not+shift+an+expression+by+a+negative+number+of+bits+or+by+greater+than+or+equal+to+the+number+of+bits+that+exist+in+the+operand]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:INT34]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM00" message="MEM00: Allocate and free memory in the same module at the same level of abstraction" class="com.optimyth.cpp.rules.certc.mem.MEM00AllocateFreeInSameAbstractionLevel" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[Allocating and freeing memory in different modules and levels of abstraction may make it difficult to determine when and if a block of memory has been freed, leading to programming defects such as double-free vulnerabilities, accessing freed memory, or writing to freed or unallocated memory.

To avoid these situations, memory should be allocated and freed at the same level of abstraction and ideally in the same code module.
This includes the use memory allocation (malloc, calloc, realloc) and deallocation functions (free).

Failing to follow this recommendation has led to real-world vulnerabilities. For example, freeing memory in different modules resulted in a vulnerability in MIT Kerberos 5.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[The mismanagement of memory can lead to freeing memory multiple times or writing to already freed memory.
Both of these coding errors can result in an attacker executing arbitrary code with the permissions of the vulnerable process.
Memory management errors can also lead to resource depletion and denial-of-service attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[enum { MIN_SIZE_ALLOWED = 32 };

int verify_size(char *list, size_t size) {
  if (size < MIN_SIZE_ALLOWED) {
    /* Handle error condition */
    free(list); /* Non compliant, free does not match allocation in same unit */
    return -1;
  }
  return 0;
}

void process_list(size_t number) {
  char *list = (char *)malloc(number);

  if (list == NULL) {
    /* Handle allocation error */
  }
  if (verify_size(list, number) == -1) {
    free(list); /* double-free problem */
    return;
  }
  /* Continue processing list */
  free(list);
}]]></example>
    <repair><![CDATA[enum { MIN_SIZE_ALLOWED = 32 };

int verify_size(char *list, size_t size) {
  if (size < MIN_SIZE_ALLOWED) {
    /* Handle error condition */
    /* Fixed, free() not called, caller must allocate and deallocate memory */
    return -1;
  }
  return 0;
}

void process_list(size_t number) {
  char *list = (char *)malloc(number);

  if (list == NULL) {
    /* Handle allocation error */
  }
  if (verify_size(list, number) == -1) {
    free(list);
    return;
  }
  /* Continue processing list */
  free(list);
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/MEM00-C.+Allocate+and+free+memory+in+the+same+module%2C+at+the+same+level+of+abstraction,https://cwe.mitre.org/data/definitions/415.html,https://cwe.mitre.org/data/definitions/416.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM00,CWE:415,CWE:416,CWETOP25:2020:38,CWETOP25:2021:7]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM08" message="MEM08: Use realloc() only to resize dynamically allocated arrays" class="com.optimyth.cpp.rules.certc.mem.MEM08AvoidReallocWithDifferentTypes" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control,Memory management]]></tags>
    <description><![CDATA[Use realloc() only to resize dynamically allocated arrays.

Resizing storage for objects other that dynamically allocated arrays may result in silently converting data to an incompatible type.
The rule checks that types for the pointer used as argument and for the return pointer (casted or assigned without cast to another pointer variable) have the same type.

According to the C standard, calling realloc(ptr, size) deallocates the old object pointed to by ptr and returns a pointer to a new object that has the size specified by size. The contents of the new object shall be the same as that of the old object prior to deallocation, up to the lesser of the new and old sizes. Any bytes in the new object beyond the size of the old object have indeterminate values.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended conversions that could happen when realloc() uses source and target pointers to different types.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <stdlib.h>
typedef struct gadget gadget;
struct gadget {
  int i;
  double d;
  char *p;
};
typedef struct widget widget;
struct widget {
  char *q;
  int j;
  double e;
};
/* ... later ... */
gadget *gp;
widget *wp;
/* ... */
wp = (widget *)realloc(gp, sizeof(widget)); /* Non compliant */]]></example>
    <repair><![CDATA[#include <stdlib.h>
typedef struct widget widget;
struct widget {
  char *q;
  int j;
  double e;
};
/* ... later ... */
widget *wp;
widget *wq;
/* ... */
wp = (widget *)malloc(10 * sizeof(widget));
/* ... */
wq = (widget *)realloc(wp, 20 * sizeof(widget)); /* Fixed, realloc source and target have same types */
/* ... */
wp = (widget *)realloc(wq, 15 * sizeof(widget));]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/628.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM08,CWE:628]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM30" message="MEM30: Do not access freed memory (Use after free)" class="com.optimyth.cpp.rules.certc.mem.MEM30DoNotAccessFreedMemory" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[Accessing memory once it is freed may corrupt the data structures used to manage the heap.
References to memory that has been deallocated are referred to as dangling pointers.
Accessing a dangling pointer can result in exploitable vulnerabilities.

When memory is freed, its contents may remain intact and accessible because it is at the memory manager's discretion when to reallocate or recycle the freed chunk. The data at the freed location may appear valid. However, this can change unexpectedly, leading to unintended program behavior. As a result, it is necessary to guarantee that memory is not written to or read from once it is freed.

Note: Reading memory that has already been freed can lead to abnormal program termination and denial-of-service attacks.
Writing memory that has already been freed can lead to the execution of arbitrary code with the permissions of the vulnerable process.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid abnormal program termination and denial-of-service issues due to detected dangling pointers.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Classical example, in Kernighan & Ritchie book */
for (p = head; p != NULL; p = p->next)
  free(p); /* p->next after, p was already freed: dangling pointer */
head = NULL;

int main(int argc, const char *argv[]) {
  char *buff;
  buff = (char *)malloc(BUFSIZ);
  if (!buff) {
    /* Handle error condition */
  }
  /* ... */
  free(buff);
  strncpy(buff, argv[1], BUFSIZ-1); /* Non compliant, buff reference is on a dangling pointer */
}]]></example>
    <repair><![CDATA[for (p = head; p != NULL; p = q) { /* Fixed: ref to q is OK */
  q = p->next;
  free(p);
}
head = NULL;

int main(int argc, const char *argv[]) {
  char *buff;
  buff = (char *)malloc(BUFSIZ);
  if (!buff) {
    /* Handle error condition */
  }
  /* ... */
  strncpy(buff, argv[1], BUFSIZ-1); /* Fixed, free() after usage */
  free(buff);
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/416.html,https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM30,CWE:416,CWETOP25:2021:7]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM31" message="MEM31: Free dynamically allocated memory exactly once (Double Free)" class="com.optimyth.cpp.rules.certc.mem.MEM31AvoidDoubleFree" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[Freeing memory multiple times has similar consequences to accessing memory after it is freed ("dangling pointers").
The underlying data structures that manage the heap can become corrupted in a way that can introduce security vulnerabilities into a program.
These types of issues are referred to as double-free vulnerabilities. In practice, double-free vulnerabilities can be exploited to execute arbitrary code.

To eliminate double-free vulnerabilities, it is necessary to guarantee that dynamic memory is freed exactly one time.
Programmers should be wary when freeing memory in a loop or conditional statement; if coded incorrectly, these constructs can lead to double-free vulnerabilities.
It is also a common error to misuse the realloc() function in a manner that results in double-free vulnerabilities (see MEM04-C, "Do not perform zero-length allocations").]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Reduce possibility of double-free errors. Freeing memory multiple times can result in an attacker executing arbitrary code with the permissions of the vulnerable process.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[size_t num_elem = /* some initial value */;
int error_condition = 0;
int *x = (int *)malloc(num_elem * sizeof(int));
if (x == NULL) {
  /* handle allocation error */
}
else {
  /* ... */
  if (error_condition == 1) {
    /* handle error condition*/
    free(x);
  }
  /* ... */
  free(x); /* Non compliant, previous potential free() may cause double-free condition */
}]]></example>
    <repair><![CDATA[size_t num_elem = /* some initial value */;
int error_condition = 0;
int *x = (int *)malloc(num_elem * sizeof(int));
if (x == NULL) {
  /* handle allocation error */
}
else {
  /* ... */
  if (error_condition == 1) {
    /* handle error condition*/
  }
  /* ... */
  free(x); /* Fixed, free() when error_condition == 1 was removed */
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/MEM31-C.+Free+dynamically+allocated+memory+when+no+longer+needed,https://cwe.mitre.org/data/definitions/415.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM31,CWE:415,CWETOP25:2020:38]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM32" message="MEM32: Detect and handle memory allocation errors" class="com.optimyth.cpp.rules.certc.mem.MEM32CheckMemoryAllocationErrors" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[The return values for memory allocation routines indicate the failure or success of the allocation.

According to the C standard, calloc(), malloc(), and realloc() return null pointers if the requested memory allocation fails.
Failure to detect and properly handle memory management errors can lead to unpredictable and unintended program behavior.
As a result, it is necessary to check the final status of memory management routines and handle errors appropriately.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid runtime errors: Failing to check return values from memory allocation functions may cause null pointer dereference.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *input_string = /* initialize from untrusted data */;
size_t size = strlen(input_string) + 1;
char *str = (char *)malloc(size); /* Non compliant, return value is not checked for NULL */
strcpy(str, input_string);
/* ... */
free(str);
str = NULL;]]></example>
    <repair><![CDATA[char *input_string = /* initialize from untrusted data */;
size_t size = strlen(input_string) + 1;
char *str = (char *)malloc(size);
if (str == NULL) {
  /* Handle allocation error */
}
else {
  strcpy(str, input_string);
  /* ... */
  free(str);
  str = NULL;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/476.html,https://cwe.mitre.org/data/definitions/252.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM32,CWE:252,CWE:476,CWETOP25:2021:15]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM34" message="MEM34: Free of Memory not on the Heap" class="com.optimyth.cpp.rules.certc.mem.MEM34OnlyFreeDynamicAllocatedMemory" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[Freeing memory that is not allocated dynamically can lead to serious errors. The specific consequences of this error depend on the compiler, but they range from nothing to abnormal program termination. Regardless of the compiler, avoid calling free() on anything other than a pointer returned by a dynamic-memory allocation function, such as malloc(), calloc(), or realloc().

A similar situation arises when realloc() is supplied a pointer to nondynamically allocated memory.
The realloc() function is used to resize a block of dynamic memory. If realloc() is supplied a pointer to memory not allocated by a memory allocation function, such as malloc(), the program may terminate abnormally.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid fatal runtime errors, and potential security vulnerabilities: freeing or reallocating memory that was not dynamically allocated can lead to arbitrary code execution.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[enum { MAX_ALLOCATION = 1000 };
int main(int argc, const char *argv[]) {
  char *str = NULL;
  size_t len;
  if (argc == 2) {
    len = strlen(argv[1])+1;
    if (len > MAX_ALLOCATION) {
      /* Handle error */
    }
    str = (char *)malloc(len);
    if (str == NULL) {
      /* Handle allocation error */
    }
    strcpy(str, argv[1]);
  }
  else {
    str = "usage: $>a.exe [string]";
    printf("%s\n", str);
  }
  /* ... other code ... */
  /* Non compliant: str = "usage: $>a.exe [string]"; reaches this, is not allocated memory */
  free(str);
  return 0;
}]]></example>
    <repair><![CDATA[enum { MAX_ALLOCATION = 1000 };
int main(int argc, const char *argv[]) {
  char *str = NULL;
  size_t len;
  if (argc == 2) {
    len = strlen(argv[1])+1;
    if (len > MAX_ALLOCATION) {
      /* Handle error */
    }
    str = (char *)malloc(len);
    if (str == NULL) {
      /* Handle allocation error */
    }
    strcpy(str, argv[1]);
  }
  else {
    printf("%s\n", "usage: $>a.exe [string]"); /* Fixed, str is not reused */
    return -1;
  }
  /* ... other code ... */
  free(str);
  return 0;
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/MEM34-C.+Only+free+memory+allocated+dynamically,https://cwe.mitre.org/data/definitions/590.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM34,CWE:590]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.MEM35" message="MEM35: Incorrect Calculation of Buffer Size." class="com.optimyth.cpp.rules.certc.mem.MEM35BadAllocSize" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Memory management]]></tags>
    <description><![CDATA[The types of integer expressions used as size arguments to malloc(), calloc(), realloc(), or aligned_alloc() must have
sufficient range to represent the size of the objects to be stored.

If size arguments are incorrect or can be manipulated by an attacker, then a buffer overflow may occur.
Incorrect size arguments, inadequate range checking, integer overflow, or truncation can result in the allocation
of an inadequately sized buffer.

Typically, the amount of memory to allocate will be the size of the type of object to allocate.
When allocating space for an array, the size of thearray entry type will be multiplied by the bounds of the array.
When allocating space for a structure containing a flexible array member, the size of the array member must be added to the size of the structure.
Use the correct type of the object when computing the size of memory to allocate.

Please note that there are many patterns for improper computation of buffer size. For example:
- when the size comes from untrusted input and it is not validated,
- When the size may get out of range due to integer overflow, and no validation check for that.
- when signed integer used, but no check for positive values. Remember that allocation functions typically use unsigned values for size
  (example: size_t type), and attackers may force a negative value that will be converted to a huge positive value (so allocation fails),
  or a too-small positive number, which may lead to buffer overflow.
- when a pointer type is used as argument of sizeof (see EXP01 rule).
- When the data to be written to the buffer expands or shrinks due to encoding and other transformations, and size computation does not match that.
- when an buffer holds an array-like object but the entry type or the array size are not properly computed or passed to allocation function.
  For example, malloc(sz) requires sz to be the total number of bytes for the buffer, while calloc(arrsz, entrysz) allocates a buffer
  with arrsz * entrysz bytes.

STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator is a specific instance of this rule.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Providing invalid size arguments to memory allocation functions can lead to buffer overflows and the execution of arbitrary code with the permissions of the vulnerable process.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <stdlib.h>
#include <time.h>

struct tm *make_tm(int year, int mon, int day, int hour,
                   int min, int sec) {
  struct tm *tmb;
  /* VIOLATION - inadequate space allocated for a struct tm object, because
     pointer size is being used to determine the size of the object */
  tmb = (struct tm *) malloc(sizeof(tmb));
  if (tmb == NULL) {
    return NULL;
  }
  *tmb = (struct tm) {
    .tm_sec = sec, .tm_min = min, .tm_hour = hour,
    .tm_mday = day, .tm_mon = mon, .tm_year = year
  };
  return tmb;
}]]></example>
    <repair><![CDATA[#include <stdlib.h>
#include <time.h>

struct tm *make_tm(int year, int mon, int day, int hour,
                   int min, int sec) {
  struct tm *tmb;
  /* FIXED - correct size of struct tm object
     (compiler will infer the type of the *tmb expr) */
  tmb = (struct tm *) malloc(sizeof(*tmb));
  if (tmb == NULL) {
    return NULL;
  }
  *tmb = (struct tm) {
    .tm_sec = sec, .tm_min = min, .tm_hour = hour,
    .tm_mday = day, .tm_mon = mon, .tm_year = year
  };
  return tmb;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,https://wiki.sei.cmu.edu/confluence/display/c/MEM35-C.+Allocate+sufficient+memory+for+an+object]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MEM35,CWE:131]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.POS30" message="POS30: Use the readlink() function properly" class="com.optimyth.cpp.rules.certc.pos.POS30ProperReadlink" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Posix]]></tags>
    <description><![CDATA[The readlink() function reads where a link points to. It makes no effort to null-terminate its second argument, buffer. Instead, it just returns the number of characters it has written.

The rule checks that the buffer is null-terminated at the proper position and that the returned length is checked for -1, which readlink() returns in case of error.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid abnormal program termination and buffer-overflow vulnerabilities due to improper readlink() usage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <unistd.h>
...
char buf[1024];
ssize_t len = readlink(filename, buf, sizeof(buf)-1); /* Violation, len is not checked for -1 */
buf[len] = '\0';]]></example>
    <repair><![CDATA[#include <unistd.h>
...
char buf[1024];
ssize_t len = readlink(filename, buf, sizeof(buf)-1);
if(len != -1) { /* FIXED */
  buf[len] = '\0';
  ...
}
else {
  /* Handle error condition */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/170.html,https://wiki.sei.cmu.edu/confluence/display/c/POS30-C.+Use+the+readlink%28%29+function+properly]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:POS30,CWE:170]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.POS33" message="POS33: Do not use vfork()" class="com.optimyth.cpp.rules.certc.pos.POS33AvoidVfork" technology="C" active="true">
    <tags><![CDATA[Posix]]></tags>
    <description><![CDATA[Using the vfork function introduces many portability and security issues. There are many cases in which undefined and implementation-specific behavior can occur, leading to a denial-of-service vulnerability.

According to the vfork man page: "The vfork() function has the same effect as fork(), except that the behavior is undefined if the process created by vfork() either modifies any data other than a variable of type pid_t used to store the return value from vfork(), or returns from the function in which vfork() was called, or calls any other function before successfully calling _exit() or one of the exec family of functions".

Furthermore, older versions of Linux are vulnerable to a race condition, occurring when a privileged process calls vfork(), and then the child process lowers its privileges and calls execve().
The child process is executing with the unprivileged users UID before it calls execve().

Due to the implementation of the vfork() function, the parent process is suspended while the child process executes. If a user sends a signal to the child process, delaying its execution, the parent process (which is privileged) is also blocked. This means that an unprivileged process can cause a privileged process to halt, a privilege inversion resulting in a denial of service.

The rule emits a violation for each call to vfork() found. Use fork() instead of vfork() in all circumstances.]]></description>
    <priority>4</priority>
    <effort>1</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Not using vfork() reduces the possibility of a denial of service condition.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *filename = ... /* file name */;

pid_t pid = vfork(); /* VIOLATION */

if (pid == 0 ) /* child */ {
  if (execve(filename, NULL, NULL) == -1) {
    /* Handle error */
  }
  _exit(1); /* in case execve() fails */
}]]></example>
    <repair><![CDATA[char *filename = ... /* file name */;

pid_t pid = fork(); /* FIXED */

if (pid == 0 ) /* child */ {
  if (execve(filename, NULL, NULL) == -1) {
    /* Handle error */
  }
  _exit(1); /* in case execve() fails */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/242.html,https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152373]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:POS33,CWE:242]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.POS35" message="POS35: Race Condition Enabling Link Following" class="com.optimyth.cpp.rules.certc.pos.POS35AvoidRaceConditionsCheckingSymlink" technology="C" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity,Posix]]></tags>
    <description><![CDATA[Many common operating systems such as Windows and UNIX support symbolic (soft) links.
If not properly performed, checking for the existence of symbolic links can lead to race conditions.

Typically POSIX lstat() function is used to collect information about a file, to check if it is a symbolic link.
If it is determined from returned that file is not a symbolic link, and file is opened, a race condition may occur if the file with same filename is changed. The recommended way is to open the file, then call fstat() on the file descriptor to recheck that the file node is the same as the one returned by lstat(). See repair example for full details.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid TOCTOU race condition vulenerabilities that could be exploited to gain elevated privileges.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <sys/stat.h>

void f(char *filename, char *userbuf, unsigned int userlen) {
  struct stat lstat_info;
  struct stat fstat_info;
  int fd;
  /* ... */
  if (lstat(filename, &lstat_info) == -1) { /* VIOLATION, lstat() followed by open() */
    /* handle error */
  }
  /* ... Some check on lstat_info ... */

  fd = open(filename, O_RDWR); /* Potential race condition, fd may not correspond to file checked by lstat */
  if (fd == -1) {
    /* handle error */
  }
  if (write(fd, userbuf, userlen) < userlen) {
    /* Handle error */
  }
}]]></example>
    <repair><![CDATA[#include <sys/stat.h>

/*
This compliant solution eliminates the race condition by
  1. calling lstat() on the file name.
  2. calling open() to open the file.
  3. calling fstat() on the file descriptor returned by open().
  4. comparing the file information returned by the calls to lstat() and fstat()
     to ensure that the files are the same.
*/
void f(char *filename, char *userbuf, unsigned int userlen) {
  struct stat lstat_info;
  struct stat fstat_info;
  int fd;
  /* ... */
  if (lstat(filename, &lstat_info) == -1) {
    /* handle error */
  }
  /* ... Some check on lstat_info ... */

  fd = open(filename, O_RDWR);
  if (fd == -1) {
    /* handle error */
  }
  /* FIXED, check with fstat() that the opened file is the same as the one processed by lstat() */
  if (fstat(fd, &fstat_info) == -1) {
    /* handle error */
  }
  if (lstat_info.st_mode == fstat_info.st_mode &&
      lstat_info.st_ino == fstat_info.st_ino &&
      lstat_info.st_dev == fstat_info.st_dev) {
    /* The file operation, no race condition */
    if (write(fd, userbuf, userlen) < userlen) {
      /* Handle error */
    }
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/363.html,https://wiki.sei.cmu.edu/confluence/display/c/POS35-C.+Avoid+race+conditions+while+checking+for+the+existence+of+a+symbolic+link]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:POS35,CWE:363]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.POS36" message="POS36: Observe correct revocation order while relinquishing privileges" class="com.optimyth.cpp.rules.certc.pos.POS36CorrectOrderRevocatingPrivileges" technology="C" active="true">
    <tags><![CDATA[CWEScope:Integrity,Posix]]></tags>
    <description><![CDATA[In case of set-user-ID and set-group-ID programs (typically owned by superuser), when the effective user-ID and group-ID are different from those of the real user, it is important to drop not only the user-level privileges but also the group privileges.
While doing so, the order of revocation must be correct.

POSIX defines setgid() to have the following behavior: "If the process has appropriate privileges, setgid() shall set the real group ID, effective group ID, and the saved set-group-ID of the calling process to gid. If the process does not have appropriate privileges, but gid is equal to the real group ID or the saved set-group-ID, setgid() shall set the effective group ID to gid; the real group ID and saved set-group-ID shall REMAIN UNCHANGED".

Rule checks that if setuid() is called, that call should be preceded by a call to setgid() (if any) so all group privileges are correctly revocated. If setuid() is called before setgid(), the process may not have then privileges for setgid() to change all group IDs.

To ensure that both are executed in proper sequence, rule checks that they must be placed in same statements block.
See rule POS37 "Ensure that privilege relinquishment is successful" for an additional rule that mandates to check permissions granted by setuid().]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Failing to observe the correct revocation order while relinquishing privileges may allow an attacker to regain elevated privileges]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Drop privileges in incorrect order */
if (setuid(getuid()) == -1) { /* VIOLATION, setgid() called after setuid() */
  /* handle error condition */
}
if (setgid(getgid()) == -1) {
  /* handle error condition */
}
/*
 * It is still possible to regain group privileges due to
 * incorrect relinquishment order
 */]]></example>
    <repair><![CDATA[/* Drop privileges in correct order */
if (setgid(getgid()) == -1) {
  /* handle error condition */
}
if (setuid(getuid()) == -1) { /* FIXED */
  /* handle error condition */
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/POS36-C.+Observe+correct+revocation+order+while+relinquishing+privileges,https://cwe.mitre.org/data/definitions/696.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:POS36,CWE:696]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.POS37" message="POS37: Improper Check for Dropped Privileges" class="com.optimyth.cpp.rules.certc.pos.POS37EnsureSuccessfulPrivilegeRevocation" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Non-Repudiation,Posix]]></tags>
    <description><![CDATA[The POSIX setuid() function has complex semantics and platform-specific behavior:

"If the process has appropriate privileges, setuid() shall set the real user ID, effective user ID, and the saved set-user-ID of the calling process to uid.
If the process does not have appropriate privileges, but uid is equal to the real user ID or the saved set-user-ID, setuid() shall set the effective user ID to uid; the real user ID and saved set-user-ID shall remain unchanged".

The meaning of "appropriate privileges" varies from platform to platform. Because of this complex behavior, there may be cases where the desired privilege drops are unsuccessful. Explicit checks should be made to ensure that privilege relinquishment has succeeded.

NOTE: The rule checks that after dropping privileges (via setuid(getuid()) or similar code), a later check that elevated privileges were successfully dropped (e.g. a check setuid(0) != -1) is performed. This ensures that dropping privileges actually succeded, as setuid to 0 (superuser) will fail if the uid does not have elevated privileges.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[If privilege relinquishment conditions are left unchecked, any flaw in the program may lead to unintended
    system compromise corresponding to the more privileged user or group account.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Code intended to run with elevated privileges */

/* Temporarily drop privileges */
if (seteuid(getuid()) != 0) {
  /* Handle error */
}

/* Code intended to run with lower privileges */

if (need_more_privileges) {
  /* Restore privileges */
  if (seteuid(0) != 0) {
    /* Handle error */
  }
  /* Code intended to run with elevated privileges */
}

/* ... */

/* Permanently drop privileges */
  if (setuid(getuid()) != 0) {
    /* Handle error */
  }
/*
 * Code intended to run with lower privileges,
 * but if privilege relinquishment failed,
 * attacker can regain elevated privileges!
 */]]></example>
    <repair><![CDATA[/* Store the privileged ID for later verification */
uid_t privid = geteuid();

/* Code intended to run with elevated privileges */

/* Temporarily drop privileges */
if (seteuid(getuid()) != 0) {
  /* Handle error */
}

/* Code intended to run with lower privileges */
if (need_more_privileges) {
  /* Restore Privileges */
  if (seteuid(privid) != 0) {
    /* Handle error */
  }
  /* Code intended to run with elevated privileges */
}
/* ... */
/* Restore privileges if needed */
if (geteuid() != privid) {
  if (seteuid(privid) != 0) {
    /* Handle error */
  }
}
/* Permanently drop privileges */
if (setuid(getuid()) != 0) {
  /* Handle error */
}

/* FIXED: This checks if privileges were successfully dropped */
if (setuid(0) != -1) {
  /* Privileges were not dropped, handle error */
}
/*
 * Code intended to run with lower privileges;
 * attacker cannot regain elevated privileges
 */]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/POS37-C.+Ensure+that+privilege+relinquishment+is+successful,https://cwe.mitre.org/data/definitions/273.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:POS37,CWE:273]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.PRE01" message="PRE01: Use parentheses within macros around parameter names" class="com.optimyth.cpp.rules.misra.preprocessor.EncloseInParanthesesMacroArgs" technology="C" active="true">
    <tags><![CDATA[Preprocessor]]></tags>
    <description><![CDATA[Parenthesize all parameter names found in macro definitions. This practice avoid unexpected results.
When parameter names are surrounded by commans in replacement text, or for operands with # and ## macro operators, macro parameters do not need to be parenthesized.

See also PRE00-C, "Prefer inline or static functions to function-like macros", and PRE02-C, "Macro replacement lists should be parenthesized."

NOTE: This rule uses the same implementation as MISRA-C 19.10 rule "In the definition of a function-like macro, each parameter shall be enclosed in parentheses".]]></description>
    <priority>3</priority>
    <effort>1</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Failing to parenthesize the parameter names in a macro can result in unintended program behavior.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Non compliant */
#define CUBE(I) (I * I * I)
int a = 81 / CUBE(2 + 1);
/* Expands to int a = 81 / (2 + 1 * 2 + 1 * 2 + 1); i.e. 11, not the expected (3) */]]></example>
    <repair><![CDATA[/* Compliant */
#define CUBE(I) ((I) * (I) * (I))
int a = 81 / CUBE(2 + 1);
/* Expands to int a = 81 / ((2 + 1) * (2 + 1) * (2 + 1)); i.e. 3 */]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/PRE01-C.+Use+parentheses+within+macros+around+parameter+names?src=contextnavpagetreemode]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:PRE01,MISRA-C:19.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.PRE02" message="PRE02: Macro replacement lists should be parenthesized" class="com.optimyth.cpp.rules.certc.pre.PRE02ParenthesizeMacroReplacement" technology="C" active="true">
    <tags><![CDATA[Preprocessor]]></tags>
    <description><![CDATA[Macro replacement lists (containing an expression) should be parenthesized to protect any lower-precedence operators from the surrounding expression. See also PRE00-C, "Prefer inline or static functions to function-like macros", and PRE01-C, "Use parentheses within macros around parameter names".

NOTE: When no confusion may exist (e.g. single identifiers, simple function calls, function-like macros with no argument replaced) no enclosing parentheses are required. For example, #define MY_LOG(FMT, ...) printf(FMT, __VA_ARGS__) is permitted, as function call protects macro replacement against misinterpretation.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid logical errors due to operator precedence when macro replacement list is not enclosed between parentheses.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Non compliant */
#define CUBE(X) (X) * (X) * (X)
int i = 3;
/* expands to 81 / i * i * i, that is, (81/i)*i*i, which was not intended */
int a = 81 / CUBE(i);

/* Non compliant */
#define EOF -1
/* Programmed forgot != operator, expands to if(getchar() - 1), which is not intended */
if (getchar() EOF) {
  /* ... */
}

/* Compliant, rule only consider macro containing an expression, see rule PRE10 */
#define SWAP(x, y, t) \
  do { \
    (t) = (x); \
    (x) = (y); \
    (y) = (t); \
  } while (0)]]></example>
    <repair><![CDATA[/* Compliant */
#define CUBE(X) ((X) * (X) * (X))
int i = 3;
/* expands to 81 / ((i) * (i) * (i)), which was intended */
int a = 81 / CUBE(i);

/* Compliant */
#define EOF (-1)
/*
"if (getchar() EOF)" does not compile,
as unary - sign cannot be confused with arithmetic - operator
*/]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/PRE02-C.+Macro+replacement+lists+should+be+parenthesized]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:PRE02]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.PRE09" message="PRE09: Do not replace secure functions with less secure functions" class="com.optimyth.cpp.rules.certc.pre.PRE09ReplaceWithLessSecureFunc" technology="C" active="true">
    <tags><![CDATA[Preprocessor]]></tags>
    <description><![CDATA[Macros are frequently used in the remediation of existing code to globally replace one identifier with another, for example, when an existing API changes.

While there is always some risk involved, this practice becomes particularly dangerous if a function name is replaced with a less secure function. Replacing secure functions with less secure functions is a very risky practice, because developers can be easily fooled into trusting the function to perform a security check that is absent.

The property 'secureFunctions' contains the list of functions that should not be replaced by function-like macros.]]></description>
    <priority>1</priority>
    <effort>4</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid issues (like buffer overrun) due to the risky function replacement.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Non compliant: vsprintf does not check bounds */
#define vsnprintf(buf, size, fmt, list) \
        vsprintf(buf, fmt, list)]]></example>
    <repair><![CDATA[Do not replace via #define secure functions with less secure functions.
If necessary, include an implementation of the missing function (vsnprintf() in the example), to eliminate the dependency
on external library functions when they are not available.

For example, vnsprintf() is included in ISO C99 standard. You may include an alternate implementation if not under C99:
#include <stdio.h>
#ifndef __USE_ISOC99
  /* reimplements vsnprintf() */
  #include "my_stdio.h"
#endif]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/PRE09-C.+Do+not+replace+secure+functions+with+deprecated+or+obsolescent+functions,https://cwe.mitre.org/data/definitions/684.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:PRE09,CWE:684]]></security>
    </normatives>
    <properties>
      <property name="secureFunctions" descname="Comma-separated list of functions that should not be replaced in macro #define">
        <value><![CDATA[fgets, strlcat, strlcpy, snprintf, asprintf, vsnprintf, vasprintf, tmpfile_s, tmpnam_s, fopen_s, freopen_s, fprintf_s,
fscanf_s, printf_s, scanf_s, snprintf_s, sprintf_s, sscanf_s, vfprintf_s, vfscanf_s, vprintf_s, vscanf_s, vsnprintf_s,
vsprintf_s, vsscanf_s, gets_s, getenv_s, bsearch_s, qsort_s, wctomb_s, mbstowcs_s, wcstombs_s, memcpy_s, memmove_s,
strcpy_s, strncpy_s, strcat_s, strncat_s, strtok_s, strerror_s, strerrorlen_s, strnlen_s, asctime_s, ctime_s, gmtime_s,
localtime_s, fwprintf_s, fwscanf_s, snwprintf_s, swprintf_s, swscanf_s, vfwprintf_s, vfwscanf_s, vsnwprintf_s,
vswprintf_s, vswscanf_s, vwprintf_s, vwscanf_s, wprintf_s, wscanf_s, wcscpy_s, wcsncpy_s, wmemcpy_s, wmemmove_s,
wcscat_s, wcsncat_s, wcstok_s, wcsnlen_s, wcrtomb_s, mbsrtowcs_s, wcsrtombs_s]]></value>
      </property>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.PRE10" message="PRE10: Wrap multistatement macros in a do-while loop" class="com.optimyth.cpp.rules.certc.pre.PRE10WrapMacroStatementsInDoWhileLoop" technology="C" active="true">
    <tags><![CDATA[Preprocessor]]></tags>
    <description><![CDATA[Macros are often used to execute a sequence of multiple statements as a group.

While inline functions are, in general, more suitable for this task (see PRE00-C, "Prefer inline or static functions to function-like macros"), occasionally they are not feasible (when macros are expected to operate on variables of different types, for example).

When multiple statements are used in a macro, they should be bound together in a loop syntactically, so the macro can appear safely inside if clauses or other places that expect a single statement or a statement block.

NOTE: A single statement in macro body is allowed, but it should be either a straight function call statement, or a "do ... while(0)" statement. If macro definition contains multiple statements, or a single statement none of the two cases allowed, a violation is emitted.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid improper wrapped statement macros that can result in unexpected behaviour.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Non compliant */
/* Swap x and y, using t as temporary swap var. x, y and t should be lvalues */
#define SWAP(x, y, t) \
(t) = (x); \
(x) = (y); \
(y) = (t)
...
int *ptrX, *ptrY, z, tmp;
...
if (z == 0)
  SWAP(*ptrX, *ptrY, tmp);

Code above expanded to the following, which does not operate as expected
(second and third assignments execute unconditionally, out of if statement without braces):
int *ptrX, *ptrY, z, tmp;
...
if (z == 0)
  (tmp) = (*ptrX);
(*ptrX) = (*ptrY);
(*ptrY) = (tmp);]]></example>
    <repair><![CDATA[/* Compliant */
#define SWAP(x, y, t) \
  do { \
    (t) = (x); \
    (x) = (y); \
    (y) = (t); \
  } while (0)
...
int *ptrX, *ptrY, z, tmp;
...
if (z == 0)
  SWAP(*ptrX, *ptrY, tmp);

Code above expanded to this, which operates as expected:
int *ptrX, *ptrY, z, tmp;
...
if (z == 0)
  do {
    (tmp) = (*ptrX);
    (*ptrX) = (*ptrY);
    (*ptrY) = (tmp);
  while(0);

Of course, no problem if the original macro was used like this:
if (z == 0) {
  SWAP(*ptrX, *ptrY, tmp);
}
But regarding preprocessor, it is better to be safe than to be sorry,
and not to expect that caller used braces.]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/PRE10-C.+Wrap+multistatement+macros+in+a+do-while+loop]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:PRE10]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.SIG02" message="SIG02: Avoid using signals to implement normal functionality" class="com.optimyth.cpp.rules.certc.sig.SIG02AvoidSignalsImplementNormalFunctionality" technology="C" active="true">
    <tags><![CDATA[Signals]]></tags>
    <description><![CDATA[Avoid using signals to implement normal functionality. Signal handlers are severely limited in the actions they can perform in a portably secure manner.

For example, do not use signals as a means to pass state changes around in a multithreaded environment.

A signal is a limited form of inter-process communication used in Unix, Unix-like, and other POSIX-compliant operating systems. It is an asynchronous notification sent to a process or to a specific thread within the same process in order to notify it of an event that occurred. When a signal is sent, the operating system interrupts the target process's normal flow of execution. Execution can be interrupted during any non-atomic instruction.
If the process has previously registered a signal handler, that routine is executed. Otherwise the default signal handler is executed.

Signal handling is vulnerable to race conditions. Because signals are asynchronous, another signal (even of the same type) can be delivered to the process during execution of the signal handling routine. The sigprocmask() call can be used to block and unblock delivery of signals.
Signals can cause the interruption of a system call in progress, leaving it to the application to manage a non-transparent restart.
Signal handlers should be written in a way that doesn't result in any unwanted side-effects, e.g. errno alteration, signal mask alteration, signal disposition change, and other global process attribute changes.
Use of non-reentrant functions, e.g. malloc or printf, inside signal handlers is also unsafe.

NOTE: As defining what constitutes "normal functionality" in signal handling is not possible, the rule implementation simply checks that certain signal identifiers, typically used for inter-process communication or other behaviour not related with async notifications from the environment (considered proper usage), are passed to kill() or signal() functions.
The list of not allowed signal identifiers is given in the 'forbiddenSignals' property.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Reduce violations of one or more secure coding rules for signal handling, that should be limited and strictly controlled
    (no race conditions, no side-effects in handlers, calls to reentrant functions, etc.).]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* Bad usage: one thread use SIGUSR1 to wake up a second thread */
/* THREAD 1 */
int do_work(void) {
  /* ... */
  kill(THR2_PID, SIGUSR1); /* Violation */
}

/* THREAD 2 */
volatile sig_atomic_t flag;
void sigusr1_handler(int signum) {
  flag = 1;
}

int wait_and_work(void) {
flag = 0;
while (!flag) {}
  /* ... */
}]]></example>
    <repair><![CDATA[/* Use condition variables from POSIX pthread library (or Win32 API) */
#include <pthread.h>
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
/* THREAD 1 */
int do_work(void) {
  /* ... */
  pthread_mutex_lock(&mut);
  pthread_cond_signal(&cond, &mut);
  pthread_mutex_unlock(&mut);
}

/* THREAD 2 */
int wait_and_work(void) {
  pthread_mutex_lock(&mut);
  pthread_mutex_wait(&cond, &mut);
  pthread_mutex_unlock(&mut);
  /* ... */
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/SIG02-C.+Avoid+using+signals+to+implement+normal+functionality]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:SIG02]]></security>
    </normatives>
    <properties>
      <property name="forbiddenSignals" descname="Comma-separated list of signals to be avoided in signal handling" value="SIGUSR1, SIGUSR2, SIGPIPE, SIGURG, SIGXFSZ, SIGRTMIN, SIGRTMAX"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.SIG30" message="SIG30: Signal Handler Use of a Non-reentrant Function" class="com.optimyth.cpp.rules.certc.sig.SIG30AsyncSafeCallsInSignalHandler" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Signals]]></tags>
    <description><![CDATA[Call only asynchronous-safe functions within signal handlers. This restriction applies to library functions as well as application-defined functions.

When a signal occurs, the normal flow of control of a program is interrupted. If a signal occurs that is being trapped by a signal handler, that handler is invoked. When it is finished, execution continues at the point at which the signal occurred.
This arrangement could cause problems if the signal handler is invoked again when an unsafe function is being called.

Only certain system functions known as 'asynchronous-safe' should be called (directly or from other user functions) in signal handlers.
The list of asynchronous-safe functions (e.g. Posix or platform-specific) could be provided in the asyncSignalSafeFunctions property.

Signal handlers should be as concise as possible, ideally unconditionally setting a volatile sig_atomic_t flag and returning.
They may also call the _Exit() function. Finally, they may call other functions provided that all implementations to which the code is ported guarantee that these functions are asynchronous-safe.]]></description>
    <priority>1</priority>
    <effort>4</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid security vulnerabilities due to improper signal handling.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
enum { MAXLINE = 1024 };
char *info = NULL;

extern void unknownReportFunc(void);

void log_message(void) {
  fprintf(stderr, info);
}

void terminate(void) {
  _Exit(1); /* async-signal safe */
}

void handler(int signum) {
  log_message(); /* Non compliant, non async-signal-safe */
  free(info); /* Non compliant, non async-signal-safe (and other problems...) */
  info = NULL;
  unknownReportFunc(); /* Non compliant, cannot check */
  terminate(); /* Compliant */
}

int main(void) {
  if (signal(SIGINT, handler) == SIG_ERR) {
    /* Handle error */
  }
  info = (char*)malloc(MAXLINE);
  if (info == NULL) {
    /* Handle error */
  }
  while (1) {
    /* Main loop program code */
    log_message();
    /* More program code */
  }
  return 0;
}]]></example>
    <repair><![CDATA[Simplify signal handler, if possibly to setting a flag.
Move code, if possible, out of signal handler. For example:

volatile sig_atomic_t eflag = 0;

void handler(int signum) {
  eflag = 1;
}
...
int main(void) {
  ...
  while (!eflag) {
    /* Main loop program code */
    log_message();
    /* More program code */
  }
  /* Moved out of signal handler */
  log_message();
  free(info);
  info = NULL;
  unknownReportFunc();
  terminate();
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/STR30-C.+Do+not+attempt+to+modify+string+literals,https://cwe.mitre.org/data/definitions/479.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:SIG30,CWE:479]]></security>
    </normatives>
    <properties>
      <property name="asyncSignalSafeFunctions" descname="Comma-separated list of async signal safe functions">
        <value><![CDATA[_Exit, _exit, abort, accept, access, aio_error, aio_return, aio_suspend, alarm, bind, cfgetispeed, cfgetospeed,
cfsetispeed, cfsetospeed, chdir, chmod, chown, clock_gettime, close, connect, creat, dup, dup2, execle, execve,
fchmod, fchown, fcntl, fdatasync, fork, fpathconf, fstat, fsync, ftruncate, getegid, geteuid, getgid, getgroups,
getperrname, getpgrp, getpid, getppid, getsockname, getsockopt, getuid, kill, link, listen, lseek, lstat, mkdir,
mkfifo, open, pathconf, pause, pipe, poll, posix_trace_event, pselect, raise, read, readlink, recv, recvfrom, recvmsg,
rename, rmdir, select, sem_post, send, sendmsg, sendto, setgid, setpgid, setsid, setsockopt, setuid, shutdown, sigaction,
sigaddset, sigdelset, sigemptyset, sigfillset, sigismember, sleep, signal, sigpause, sigpending, sigprocmask, sigqueue,
sigset, sigsuspend, sockatmark, socket, socketpair, stat, symlink, sysconf, tcdrain, tcflow, tcflush, tcgetattr, tcgetpgrp,
tcsendbreak, tcsetattr, tcsetpgrp, time, timer_getoverrun, timer_gettime, timer_settime, times, umask, uname, unlink,
utime, wait, waitpid, write]]></value>
      </property>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.SIG32" message="SIG32: Signal Handler Use of a Non-reentrant Function" class="com.optimyth.cpp.rules.certc.sig.SIG32LongjmpInSignalHandler" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Signals]]></tags>
    <description><![CDATA[Invoking the longjmp() or siglongjmp() functions from within a signal handler can lead to undefined behavior if it results in the invocation of any non-asynchronous-safe functions, likely compromising the integrity of the program.
Consequently, neither longjmp() nor the POSIX siglongjmp() should ever be called from within a signal handler.

Invoking longjmp() or siglongjmp() from a signal handler causes the code after the setjmp() to be called under the same conditions as the signal handler itself. That is, the code must be called while global data may be in an inconsistent state and must be able to interrupt itself (in case it is itself interrupted by a second signal).
So the risks in calling longjmp() or siglongjmp() from a signal handler are the same as the risks in a signal handler calling non-asynchronous-safe functions.

Invoking functions that are not asynchronous-safe from within a signal handler may result in privilege escalation and other attacks.

This rule is closely related to SIG30-C, "Call only asynchronous-safe functions within signal handlers".]]></description>
    <priority>1</priority>
    <effort>4</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid well-known serious security vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <setjmp.h>
#include <signal.h>
#include <stdlib.h>

enum { MAXLINE = 1024 };
static jmp_buf env;

void handler(int signum) {
  longjmp(env, 1); /* Non Compliant */
}

void log_message(char *info1, char *info2) {
  static char *buf = NULL;
  static size_t bufsize;
  char buf0[MAXLINE];

  if (buf == NULL) {
    buf = buf0;
    bufsize = sizeof(buf0);
  }
  /*
   * Try to fit a message into buf, else re-allocate
   * it on the heap and then log the message.
   */
  /*** NO VULNERABILITY IF SIGINT RAISED HERE ***/
  if (buf == buf0) {
    buf = NULL;
  }
}

int main(void) {
  if (signal(SIGINT, handler) == SIG_ERR) {
    /* Handle error */
  }

  char *info1;
  char *info2;
  /* info1 and info2 are set by user input here */
  if (setjmp(env) == 0) {
    while (1) {
      /* Main loop program code */
      log_message(info1, info2);
      /* More program code */
    }
  } else {
    log_message(info1, info2);
  }
  return 0;
}]]></example>
    <repair><![CDATA[#include <setjmp.h>
#include <signal.h>
#include <stdlib.h>

enum { MAXLINE = 1024 };
static jmp_buf env;
/*
  In this compliant solution, the call to longjmp() is removed;
  the signal handler sets an error flag of type volatile sig_atomic_t instead.
*/
volatile sig_atomic_t eflag = 0;
void handler(int signum) {
  eflag = 1; /* Fixed */
}

/* ... log_message() as before ... */

int main(void) {
  if (signal(SIGINT, handler) == SIG_ERR) {
    /* Handle error */
  }

  char *info1;
  char *info2;
  /* info1 and info2 are set by user input here */
  /* Fixed: simply checks if eflag was set in handler to exit main loop */
  while (!eflag) {
    /* Main loop program code */
    log_message(info1, info2);
    /* More program code */
  }
  log_message(info1, info2);

  return 0;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/479.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:SIG32,CWE:479,MISRA-C:20.7]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR02" message="STR02: Sanitize data passed to sensitive subsystems" class="com.optimyth.cpp.rules.certc.str.STR02SanitizeDataForComplexSubsystems" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,Characters and strings]]></tags>
    <description><![CDATA[String data passed to sensitive subsystems may contain special characters that can trigger commands or actions, resulting in a software vulnerability. It is therefore necessary to sanitize all string data passed to sensitive subsystems so that the resulting string is innocuous in the context in which it is interpreted.

These are some examples of sensitive subsystems: - command processor via a call to system() or similar function (see ENV03-C, "Sanitize the environment when invoking external programs").
- external programs.
- relational databases.
- third-party commercial off-the-shelf components (e.g., an enterprise resource planning subsystem).

You may specify the kinds of target complex subsystems to check in the 'sinkResources' property. You may add custom sources (input that need to be neutralized before reaching a controlled resource), sinks (API for access to sensitive resources), and neutralization functions (considered that 'untaints' a potentially malicious input and makes it save to reach a sink/sensitive resource). For adding your custom sources, sinks and neutralization functions, create an XML library descriptor and register it for analysis, as described un the manuals.

It is necessary to ensure that all valid data is accepted, while potentially dangerous data is rejected or sanitized.
This can be difficult when valid characters or sequences of characters also have special meaning to the subsystem and may involve validating the data against a grammar. In cases where there is no overlap, white listing can be used to eliminate dangerous characters from the data.

The white listing approach to data sanitization is to define a list of acceptable characters and remove any character that is not acceptable. The list of valid input values is typically a predictable, well-defined set of manageable size.

API for some subsytems may allow to pass input data as data, not as part of the command (e.g. parameters in an parameterized SQL statement). If possible, use white-listing validation plus such more secure API alternatives.]]></description>
    <priority>1</priority>
    <effort>4</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *addr = argv[0]; /* addr is user-controlled */
sprintf(buffer, "/bin/mail %s < /tmp/email", addr); /* Care with buffer overflow... */
/* VIOLATION: trivial command injection, no neutralization between source (program args) and sink (operating system shell) */
system(buffer);]]></example>
    <repair><![CDATA[Use a sanity-check function between source (argv[0]) and sink (buffer arg in system() call).]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/88.html,https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems,https://cwe.mitre.org/data/definitions/78.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR02,CWE:77,CWE:78,CWE:88,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:31]]></security>
    </normatives>
    <properties>
      <property name="sinkResources" descname="Comma-separated list of resource types to consider as sinks (filesystem, environment, other)" value="environment, filesystem, other"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR06" message="STR06: Do not assume that strtok() leaves the parse string unchanged" class="com.optimyth.cpp.rules.certc.str.STR06StrtokModifiesParseString" technology="C" active="true">
    <tags><![CDATA[Characters and strings]]></tags>
    <description><![CDATA[strtok() is a string tokenization function that takes two arguments: an initial string to be parsed, and a const-qualified character delimiter.

The first time strtok() is called, the function parses the string up to the first instance of the delimiter character, replaces the character in place with a null byte ('\0'), and returns the starting address of the first token. Subsequent calls to strtok() begin parsing immediately after the most recently placed null character.

The alternate POSIX strtok_r() also modifies its input string.

Because strtok() / strtok_r() modify its argument, the string is subsequently unsafe and cannot be used in its original form. If you need to use the original string, copy it into a buffer and pass the address of the buffer to strtok() instead of the original string.
For example, you may use malloc + strcpy, or POSIX strdup() function, for this.

It is better to avoid strtok() and provide your own tokenizer implementation.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[The improper use of strtok() is likely to result in truncated data, producing unexpected results
    later in program execution.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *token;
char *path = getenv("PATH");
token = strtok(path, ":"); /* VIOLATION, parse string is used later */
puts(token);
while (token = strtok(0, ":")) {
  puts(token);
}
printf("PATH: %s\n", path); /* bad usage. PATH is now just "/usr/bin" */]]></example>
    <repair><![CDATA[  char *token;
  char *path = getenv("PATH");
  char *copy = (char *)malloc(strlen(path) + 1);
  if (copy == NULL) {
    /* handle error */
  }
  strcpy(copy, path);
  token = strtok(copy, ":"); /* FIXED */
  puts(token);
  while (token = strtok(0, ":")) {
    puts(token);
  }
  printf("PATH: %s\n", path);]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/STR06-C.+Do+not+assume+that+strtok%28%29+leaves+the+parse+string+unchanged]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR06]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR31" message="STR31: Guarantee that storage for strings has sufficient space for character data and the null terminator" class="com.optimyth.cpp.rules.certc.str.STR31SpaceForNullTerminator" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Characters and strings]]></tags>
    <description><![CDATA[Copying data to a buffer that is not large enough to hold that data results in a buffer overflow.

While not limited to null-terminated byte strings (NTBS), buffer overflows often occur when manipulating NTBS data.
To prevent such errors, limit copies either through truncation (see STR03-C, "Do not inadvertently truncate a null-terminated byte string") or, preferably, ensure that the destination is of sufficient size to hold the character data to be copied and the null-termination character.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[void f(char* src) {
  char dest[ARRAY_SIZE];
  size_t i;

  /* ... */
  for (i=0; src[i] && (i < sizeof(dest)); i++) {
    dest[i] = src[i];
  }
  dest[i] = '\0'; /* VIOLATION, possibly i == ARRAY_SIZE, off-by-one error */
  /* ... */
}

int main(int argc, char *argv[]) {
  /* ... */
  char prog_name[128];
  char editor_var[256];
  char *editor = getenv("EDITOR");

  strcpy(prog_name, argv[0]); /* VIOLATION, possible buffer-overflow on prog_name[] */
  /* ... */
  if (editor == NULL) {
    /* EDITOR environment variable not set */
  } else {
    strcpy(editor_var, editor); /* VIOLATION, possible buffer-overflow on editor_var[] */
  }
  /* ... */
}]]></example>
    <repair><![CDATA[void f(char* src) {
  char dest[ARRAY_SIZE];
  size_t i;

  /* ... */
  for (i=0; src[i] && (i < sizeof(dest) - 1); i++) {
    dest[i] = src[i];
  }
  dest[i] = '\0'; /* FIXED, i at most ARRAY_SIZE-1 */
  /* ... */
}

int main(int argc, char *argv[]) {
  const char prog_name = argv[0]; /* FIXED, no need to copy argv[0] input */
  char *editor_var;
  char *editor = getenv("EDITOR");

  /* ... */
  if (editor == NULL) {
    /* EDITOR environment variable not set */
  } else {
    size_t len = strlen(editor)+1;
    editor_var = (char *) malloc(len);
    if(editor_var == NULL) {
      /* Handle malloc() error */
    } else {
      memcpy(editor_var, editor, len); /* FIXED, no buffer overlow */
      editor_var[len-1] = '\0'; /* See rule STR32 */
    }
  }
  /* ... */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,https://cwe.mitre.org/data/definitions/119.html,https://cwe.mitre.org/data/definitions/676.html,https://cwe.mitre.org/data/definitions/193.html,https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+termin]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR31,CWE:119,CWE:131,CWE:193,CWE:676,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR32" message="STR32: Null-terminate byte strings as required" class="com.optimyth.cpp.rules.certc.str.STR32NullTerminateByteStrings" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Characters and strings]]></tags>
    <description><![CDATA[Null-terminated byte strings (NTBS) must contain a null-termination character at or before the address of the last element of the array before they can be safely passed as arguments to standard string-handling functions, such as strcpy() or strlen().

This is because many string-handling functions depend on the existence of a null-termination character to operate properly.

In particular, the standard strncpy() function does not guarantee that the resulting string is null-terminated.
If there is no null character in the first n characters of the source array, the result may not be null-terminated.
So care must be taken to ensure that a null is explictely inserted to terminate the NTBS.

Similarly, null-terminated byte strings must be null-terminated before iterating on a character array where the termination condition of the loop depends on the existence of a null-termination character within the memory allocated for the string.

Failure to properly terminate null-terminated byte strings can result in buffer overflows and other undefined behavior.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Failure to properly null-terminate strings can result in buffer overflows and the execution of arbitrary code with the
    permissions of the vulnerable process. Null-termination errors can also result in unintended information disclosure.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char ntbs[NTBS_SIZE];
ntbs[sizeof(ntbs)-1] = '\0';
strncpy(ntbs, source, sizeof(ntbs)); /* Violation, null may be overwritten */]]></example>
    <repair><![CDATA[char ntbs[NTBS_SIZE];
strncpy(ntbs, source, sizeof(ntbs)-1); /* FIXED, with truncation */
ntbs[sizeof(ntbs)-1] = '\0';

/* Alternatively, if possible use strncpy_s() and control errors */
char ntbs[NTBS_SIZE];
if(source) {
  /* FIXED, strncpy_s guarantees that ntbs is null-terminated and not truncated */
  errno_t err strncpy_s(ntbs, sizeof(ntbs), source, size_source);
  if(err != 0) {
    /* Handle copy errors */
  }
} else {
  /* handle NULL source */
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/STR32-C.+Do+not+pass+a+non-null-terminated+character+sequence+to+a+library+function+that+expects+a+string,https://cwe.mitre.org/data/definitions/170.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR32,CWE:170]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR33" message="STR33: Size wide character strings correctly" class="com.optimyth.cpp.rules.certc.str.STR33ProperSizeWideCharacterStr" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Characters and strings]]></tags>
    <description><![CDATA[Wide character strings may be improperly sized when they are mistaken for narrow strings or for multibyte character strings. Incorrect string sizes can lead to buffer overflows when used, for example, to allocate an inadequately sized buffer.

Improper string size calculations may include: using strlen() or other string length function that is not prepared for wide character strings; or not multiplying string length by the bytes per wchar_t (obtained with sizeof(wchar_t)). Remember to leave one extra wchar_t element for null string terminator.

For example, using strlen() on a wide-character string could return a number lower than the real characters in a wide character string, as a 0 byte could be present in non-null characters, but strlen() will confuse it with the zero termination character. Use wcslen() or other variants for getting the length of a wide character string.

NOTE: C/C++ 2011 added char16_t (for UTF-16) and char32_t (for UTF-32) for more portable wide character types, because the size in bytes of wchar_t is implementation-dependent.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid buffer overflow conditions due to improper computation of wide character strings.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[wchar_t wide_str1[] = L"0123456789";
wchar_t *wide_str2 = (wchar_t *)malloc( strlen(wide_str1) + 1 ); /* VIOLATION */
if (wide_str2 == NULL) {
/* Handle error */
}
/* ... */
free(wide_str2);
wide_str2 = NULL;]]></example>
    <repair><![CDATA[wchar_t wide_str1[] = L"0123456789";
wchar_t *wide_str2 = (wchar_t *) malloc(
  (wcslen(wide_str1) + 1) * sizeof(wchar_t) /* Proper calculation */
);
if (wide_str2 == NULL) {
  /* Handle error */
}
/* ... */
free(wide_str2);
wide_str2 = NULL;]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/131.html,,https://cwe.mitre.org/data/definitions/135.html,https://cwe.mitre.org/data/definitions/119.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR33,CWE:119,CWE:131,CWE:135,CWETOP25:2021:17]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR35" message="STR35: Do not copy data from an unbounded source to a fixed-length array" class="com.optimyth.cpp.rules.certc.str.STR35CopyUnboundedSourceToFixedLengthArray" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.1.2,ASVS-v4.0.2:5.4.1,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Characters and strings]]></tags>
    <description><![CDATA[Functions that perform unbounded copies often rely on external input to be a reasonable size.
Such assumptions may prove to be false, causing a buffer overflow to occur. For this reason, care must be taken when using functions that may perform unbounded copies.

For example, the gets() function is inherently unsafe and should never be used because it provides no way to control how much data is read into a buffer from stdin.

fgets() is frequenty used as a replacement for gets(), but it has some differences: fgets() return new-line character (not included in gets() returned string), and may return a partial line if the line exceeds its size parameter. Aternatively, gets_s() function (TR 24731) behaves like gets() but with size limit and a NULL return value that could be used to detect if line was truncated or an I/O error was found.

Formatted input (scanf() and variants) are another cause of buffer-overflow vulnerabilities. Unbounded string reads, like %s, read as much non-whitespace chars as available from input, which could produce a buffer overflow.

Rule also checks how arrays are filled in loops with functions like getchar(), or if a bounded %Ns format specifier is used with formatted input functions (like scanf).]]></description>
    <priority>1</priority>
    <effort>4</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid buffer overflow issues when input is not bounded.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[void badGets(void) {
  char buf[BUFSIZ];

  if (gets(buf) == NULL) { /* VIOLATION, gets() is totally unsafe */
    /* Handle error */
  }
}

void badGetchar(void) {
  char buf[BUFSIZ], *p;
  int ch;

  p = buf;
  while ( ((ch = getchar()) != '\n')
   && !feof(stdin)
   && !ferror(stdin))
  {
    *p++ = ch; /* VIOLATION, buf may overflow */
  }
  *p++ = 0;
}

void badScanf(void) {
  enum { CHARS_TO_READ = 9 };
  char buf[CHARS_TO_READ + 1];

  scanf("%s", buf); /* VIOLATION, buf may overflow */
  /* ... */
}]]></example>
    <repair><![CDATA[/*
  Alternatively, use fgets() on stdin.
  Remember, there are differences with gets()
 */
void getsReplacement(void) {
  char buf[BUFSIZ];

  /* FIXED, but only if TR 24731 available */
  if (gets_s(buf, sizeof(buf)) == NULL) {
    /* handle error */
  }
}

void properGetchar(void) {
  unsigned char buf[BUFSIZ];
  int ch;
  int index = 0;
  int chars_read = 0;

  while ( ( (ch = getchar()) != '\n')
    && !feof(stdin)
    && !ferror(stderr) )
  {
    if (index < BUFSIZ-1) { /* FIXED, overflow controlled */
      buf[index++] = (unsigned char)ch;
    }
    chars_read++;
  }
  buf[index] = '\0'; /* terminate NTBS */
  if (feof(stdin)) {
    /* handle EOF */
  }
  if (ferror(stdin)) {
    /* handle error */
  }
  if (chars_read > index) {
    /* handle truncation */
  }
}

/* Suggested by Kernighan and Pike */
void properScanf(void) {
  enum { CHARS_TO_READ = 9 };
  char buf[CHARS_TO_READ + 1];
  char format[32];

  /* Generates %Ns format */
  snprintf(format, sizeof(format), "%%%ds", CHARS_TO_READ);
  scanf(format, buf); /* FIXED */
  /* ... */
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/120.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR35,CWE:120]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CERTC.STR36" message="STR36: Do not specify the bound of a character array initialized with a string literal" class="com.optimyth.cpp.rules.certc.str.STR36UnboundedCharArrayWithStringLiteral" technology="C" active="true">
    <tags><![CDATA[Characters and strings]]></tags>
    <description><![CDATA[Do not specify the bound of a character array initialized with a string literal.

The C standard allows an array variable to be declared both with a bound and with an initialization literal.
The initialization literal also implies an array size in the number of elements specified.
For strings, the size specified by a string literal is the number of characters in the literal plus one for the terminating null character.

It is common for an array variable to be initialized by a string literal and declared with an explicit bound that matches the number of characters in the string literal. This is one too few characters to hold the string, because it does not account for the terminating null character. Such a sequence of characters has limited utility and has the potential to cause vulnerabilities if a null-terminated byte string is assumed.

A better approach is to not specify the bound of a string initialized with a string literal, as the compiler will automatically allocate sufficient space for the entire string literal, including the terminating null character.
This is the preferred approach, because the size of the array can always be derived even if the size of the string literal changes.

NOTE: Two exceptions to this rule are allowed: character arrays explictly initialized to character array (not string literal), or arrays with explicit limit whose contents are modified (e.g. with strcat() or other functions).

This rule is a specific exception to ARR02-C, "Explicitly specify array bounds, even if implicitly defined by an initializer".
Note: Initializing a character array using a string literal to fit exactly without a null byte is not allowed in C++.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Incorrectly specifying the bound of a character array initialized with a string literal may result in the declaration
    of a character array instead of a null-terminated byte string.
    This may result in a vulnerability if this character array is subsequently used as a null-terminated byte string.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char global[10] = "abc";

void f(void) {
  const char s[10] = "abc"; /* Compliant, as other characters will be added after initial ones */

  /* Non compliant, array with size limit for zero-terminated string, not modified */
  const char s2[10] = "abc" "def";

  const char s3[] = "abc"; /* Compliant, no size limit */
  char chArray[3] = { 'a', 'b', 'c' }; /* Compliant, a character array, NOT a zero-ended string */

  strcat(s[3], "other");  /* s is accepted, as it should accomodate extra characters */
}

void f2(void) {
  memcat(global[3], "other");  /* global is accepted, it could accomodate extra characters */
  ...
}]]></example>
    <repair><![CDATA[  /* Rest of code is the same */
  const char s2[] = "abc" "def";]]></repair>
    <reference><![CDATA[]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:STR36]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.CorrectUseMemoryLeaks" message="CorrectUseMemoryLeaks: Allocated memory must be released in same scope" class="com.optimyth.cpp.rules.gen.GEN_CorrectUseMemoryLeaks" technology="C" active="true">
    <description><![CDATA[The memory allocated for an object (in the heap) must always be released in same scope where it was allocated.

Scope could range from a loop body block, to function or class or file. Unpaired allocation/deallocation in same scope increase the possibility of memory leaks.

Memory allocated using standard heap functions (malloc, calloc, realloc) shall be released with the free function.
For C++, allocated memory via new operator shall be released with the delete statement.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Pointer and reference handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Reduces the risk of memory leaks at runtime that might lead to the depletion of memory.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  int GCD(int a, int b){
    int *buffer1 = (int*) malloc (100*sizeof(int)); /* VIOLATION, a trivial (and non-sense) memory leak */

    while( 1 ) {
      a = a % b;
      if( a == 0 )
        return b;
      b = b % a;
      if( b == 0 )
        return a;
    }
  }]]></example>
    <repair><![CDATA[  int GCD(int a, int b){
    int *buffer1 = (int *) malloc (100*sizeof(int));

    while( 1 ){
      a = a % b;
      if( a == 0 )
        return b;
      b = b % a;
      if( b == 0 )
        return a;
    }

    free (buffer1); /* FIXED */
  }]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/401.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:401,CWETOP25:2021:32]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.PotentialInfiniteLoop" message="PotentialInfiniteLoop: Loop with Unreachable Exit Condition ('Infinite Loop')" class="com.optimyth.cpp.rules.sec.PotentialInfiniteLoop" technology="C" active="true">
    <tags><![CDATA[CWEScope:AccessControl,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The program contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.
Such infinite loop conditions are due typically to logical errors in the loop exit conditions and/or loop variables update,
where the loop exit condition is never reached.

An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory, and might compromise software availability.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[T arr[ROWS][COLS] = fetchArray();

size_t i=0, j=0;
for (i=0; i < ROWS; i++) {
  T row[] = arr[i];
  // VIOLATION: infinite loop
  // a typo after copy+paste external loop, inner loop var j not updated
  for (j=0; j < COLS; i++) {
     doSomething(row[j]);
  }
}]]></example>
    <repair><![CDATA[T arr[ROWS][COLS] = fetchArray();

size_t i=0, j=0;
for (i=0; i < ROWS; i++) {
  T row[] = arr[i];
  // FIXED, j++ instead of i++
  for (j=0; j < COLS; j++) {
     doSomething(row[j]);
  }
}]]></repair>
    <reference><![CDATA[https://en.wikipedia.org/wiki/Infinite_loop]]></reference>
    <normatives>
      <security><![CDATA[CWE:835,CWETOP25:2020:36]]></security>
    </normatives>
    <properties>
      <property name="allowExplicitInfiniteLoops" descname="Intentional non-empty infinite loops, coded as while(true)  for(;;), are allowed." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.AnonymousLdapBind" message="AnonymousLdapBind: Access Control - Anonymous LDAP Bind" class="com.kiuwan.qaking.cpp.rules.security.AnonymousLdapBind" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Without proper access control, executing an LDAP statement that contains a user-controlled value can allow an attacker
to access unauthorized records.

Executing LDAP queries under an anonymous bind, effectively without authentication, can allow an attacker to abuse a
poorly configured LDAP environment.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <ldap.h>

// Example of anonymous LDAP bind with OpenLDAP
LDAP *bind_anonymous() {
  LDAP *ld = ldap_init(ldap_host, LDAP_PORT);
  ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &desired_version);

  // VIOLATION - anonymous bind (empty string also works)
  ldap_bind_s(ld, NULL, NULL, LDAP_AUTH_SIMPLE);

  return ld;
}]]></example>
    <repair><![CDATA[#include <ldap.h>

// Example of non-anonymous LDAP bind with OpenLDAP
LDAP *bind_as_user(char *user, char *pass) {
  LDAP *ld = ldap_init(ldap_host, LDAP_PORT);
  ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &desired_version);

  // Validation to make sure that anonymous bind is avoided
  if(isNonNullEmpty(user, pass)) {
    // FIXED - non-anonymous bind to LDAP server
    ldap_bind_s(ld, user, pass, LDAP_AUTH_SIMPLE);

  } else {
    // handle error
  }
  return ld;
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/285.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:285,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.ConnectionStringParameterPollution" message="ConnectionStringParameterPollution: Connection string polluted with untrusted input" class="com.kiuwan.qaking.cpp.rules.security.ConnectionStringParameterPollution" technology="C" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[When the connection string for an application resource (like database, remote server, persistence entity manager...) could
be affected by an untrusted source, not properly neutralized, the application is vulnerable to a Connection String Parameter Pollution attack.

An attack targeted at this vulnerability may use special characters (like ';' or ':') to add unexpected parts to the connection string,
for example to gain extra privileges, or to deactivate security features.

"Untrusted input" means, in this context, a user-controlled application input, an environment variable, or data fetched
from an external web source.

It should be suspicious that a connection string depends on untrusted input. Normally the application configuration uses
a fixed connection string, but other attacks, depending on where the connection string is stored (like an SQL injection or
path traversal attack) may affect the configuration item. This rule only checks for connection strings that are constructed
programmatically with untrusted input.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Example for SQLAPI++ library
#include <SQLAPI.h>

int main(int argc, char *argv[]) {
  SAConnection con;
  // VIOLATION - Connection string taken from unstrusted source
  con.Connect(argv[0], argv[1], argv[2], SA_SQLServer_Client);
  // ...
}]]></example>
    <repair><![CDATA[// Validate (white-list approach) the untrusted input combined into the connection string.
// Alternatively, fetch connection string from a trusted source, like a configuration system.

// And remember that connection strings may contain sensitive information that may need to be
// protected cryptographically.]]></repair>
    <reference><![CDATA[https://www.blackhat.com/presentations/bh-dc-10/Alonso_Chema/Blackhat-DC-2010-Alonso-Connection-String-Parameter-Pollution-wp.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:15,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.DoSRegexp" message="DoSRegexp: Prevent denial of service attack through malicious regular expression ('Regex Injection')" class="com.kiuwan.qaking.cpp.rules.security.DoSRegexp" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.1.1,CWEScope:Access-Control,ReDoS,denial-of-service]]></tags>
    <description><![CDATA[Regular expressions are a formal language for identifying strings of text, parsing, and matching them.

Most regular expressions engines are built over a non-deterministic Finite Automaton (NFA). They use backtracking and,
while these regular expression engines can quickly confirm a positive match, confirming a negative match can take much more longer.

There are lots of well-known regular expression patterns that, using selected inputs, take a time exponentially related to input size.

An attacker with total or partial control over a regular expression may carry out a denial-of-service attacks.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <bits/stdc++.h>

// Vulnerable regexp, leading to catastrophic backtracking
// Problem in second capture group, (([\\-.]|[_]+)?([a-zA-Z0-9]+))*
const char* emailValidation =
  "^([a-zA-Z0-9])"
  "(([\\-.]|[_]+)?([a-zA-Z0-9]+))*"
  "(@){1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$";

bool checkEmail(char* userInput) {
  std::regex redos(emailValidation); // VIOLATION
  std::cmatch m;
  return std::regex_match(userInput, m, redos);
}]]></example>
    <repair><![CDATA[// Rewrite regular expression so to avoid catastrophic backtracking.
// In the example, use an atomic group ?> quantifier:
const char* emailValidation =
  "^([a-zA-Z0-9])"
  "(?>([\\-.]|[_]+)?([a-zA-Z0-9]+))*"
  "(@){1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$";]]></repair>
    <reference><![CDATA[https://cpp.cs.cloud.vt.edu/docs-lecture14-lecture-14#redos,https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS,https://www.regular-expressions.info/boost.html,https://www.regular-expressions.info/stdregex.html,https://cwe.mitre.org/data/definitions/400.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:400,CWETOP25:2021:27]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.HardcodedCryptoKey" message="HardcodedCryptoKey: Hardcoded cryptographic keys" class="com.kiuwan.qaking.cpp.rules.security.HardcodedCryptoKey" technology="C" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,crypto,essential]]></tags>
    <description><![CDATA[Never hard-code cryptographic keys (or passwords used to generate them) in your program.

Crypto keys are used for encryption/decryption, for generation of message authentication codes (MAC), during generation
of password-based encryption keys (the password is the "crypto key" that generates key material for the cipher), and other usages.
Source code is the worst place for key storage, as any change in keys needs recompilation, and it is easy to reverse-engineer
an application binary to learn any keys or secrets that may be embedded in it.

Some data used in cryptographic operations (like initial vector for block ciphers, salt for password hashes, etc.)
are not "private", and it is recommended to generate a good random instance at the origin, and add it to the message
in plaintext, so the destination may use it. The security depends on properly protecting the "secret" thing
(private key in a public/private keypair, encryption key in a symmetric cipher, key in an HMAC, etc.).

Long-term cryptographic keys (in contrast with ephemeral ones), are better stored in a safe key storage.
Private keys in a public/private keypair should NEVER be unprotected (in raw form) and they should be stored in an even
safer key storage (the impact for a compromise of a private key is typically huge and brutal).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <string.h>

/* Example: C code using openssl */
void encrypt(const unsigned char *plaintext, unsigned char *cipherText, size_t *cipherLen) {
    /* Set up the key and iv. Do I need to say to not hard code these in a real application? :-) */

    /* A 256 bit key */
    unsigned char *key = (unsigned char *)"01234567890123456789012345678901";
    /* A 128 bit IV */
    unsigned char *iv = (unsigned char *)"0123456789012345";

    int len, ciphertext_len;
    int plaintext_len = strlen ((char *)plaintext);

    // error handling omitted, for simplicity
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv); // VIOLATION
    EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len);
    EVP_EncryptFinal_ex(ctx, ciphertext + len, &len);
    EVP_CIPHER_CTX_free(ctx);

    *cipherLen = ciphertext_len;
}]]></example>
    <repair><![CDATA[//... rest of code
    /* A 256 bit key */
    unsigned char *key = loadCryptoKey(); // FIXED
    /* A 128 bit IV */
    unsigned char *iv = generateRandomIV();
//... rest of code]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/321.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:321,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.3.1,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.HardcodedSalt" message="HardcodedSalt: Use of hardcoded salt" class="com.kiuwan.qaking.cpp.rules.security.HardcodedSalt" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[The software uses a one-way cryptographic hash against an input that should not be reversible, such as a password,
but the software uses a predictable salt as part of the input.

A hardcoded, fixed salt makes easier for attackers to pre-compute a dictionary of common passwords and their hash values,
effectively disabling the protection that an unpredictable salt would provide.

The rule will report any usage of a password hashing function that expects a salt, when the salt is hardcoded.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid compromising hashed values.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <Poco/PBKDF2Engine.h>

using std::string;
using Poco::DigestEngine;
using Poco::DigestEngine::Digest;
using Poco::PBKDF2Engine;
using Poco::HMACEngine;
using Poco::SHA1Engine;

string hash_password(const string& password) {
  // VIOLATION, hardcoded salt
  PBKDF2Engine<HMACEngine<SHA1Engine>> pbkdf2("hardcoded_salt", 4096, 256);
  pbkdf2.update(passphrase);
  Digest d = pbkdf2.digest();
  return DigestEngine::digestToHex(d);
}]]></example>
    <repair><![CDATA[// same include and using

// Random salt, needs to be stored with the password hash so it is returned with the hash
tuple<string, string> hash_password(const string& password) {
  string salt = create_random_salt(); // for example, 64 bits salt
  PBKDF2Engine<HMACEngine<SHA1Engine>> pbkdf2(salt, 4096, 256); // FIXED
  pbkdf2.update(passphrase);
  Digest d = pbkdf2.digest();
  return make_tuple(DigestEngine::digestToHex(d), salt);
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/760.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:760,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.HardcodedUsernamePassword" message="HardcodedUsernamePassword: Use of Hard-coded Credentials" class="com.kiuwan.qaking.cpp.rules.security.HardcodedUsernamePassword" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.4,ASVS-v4.0.2:3.5.2,ASVS-v4.0.2:6.4.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,credentials,essential]]></tags>
    <description><![CDATA[Hardcoded credentials (username / password) are visible to any person reading the source code.
If the resource protected by such hardcoded credentials is important, this may compromise system security.

With hardcoded credentials, change is difficult. If the target account is compromised, and the software
is deployed in production, a code change is needed, which forces a redeployment.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid credential leakage.
If an account is compromised, changing credentials in an external repository does not need changes in code plus software deployment.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <SQLAPI.h>

const char *u = "sa";
const char *p = "r00tp4zz?!";

SAConnection con;
// VIOLATION, hardcoded database username and password
con.Connect(connStr, u, p, SA_SQLServer_Client);]]></example>
    <repair><![CDATA[// Don't hard-code credentials. Load them from external configuration
// And, when possible, protect them wth encryption]]></repair>
    <reference><![CDATA[https://www.kiuwan.com/docs/display/K5/Avoid+hard-coded+or+in-comment+passwords+in+code,http://cwe.mitre.org/data/definitions/798.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:798,CWETOP25:2021:16,OWASP-M:2016:M2,OWASP:2021:A7,PCI-DSS:6.5.3,WASC:01]]></security>
    </normatives>
    <properties>
      <property name="passwordPattern" descname="Regular expression for matching field names containing passwords." value=""/>
      <property name="usernamePattern" descname="Regular expression for matching field names containing user ids." value=".*(user|username).*|(^|.*_)id(_.*|$)"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.InsecureRandomness" message="InsecureRandomness: Standard pseudo-random number generators cannot withstand cryptographic attacks" class="com.kiuwan.qaking.cpp.rules.security.InsecureRandomness" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.3.1,ASVS-v4.0.2:2.6.2,ASVS-v4.0.2:2.9.2,ASVS-v4.0.2:6.3.1,ASVS-v4.0.2:6.3.2,ASVS-v4.0.2:6.3.3,CWEScope:Access-Control,CWEScope:Confidentiality,crypto,prng]]></tags>
    <description><![CDATA[Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness
in security-sensitive context.

Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators
(PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.

There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties,
but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use in cases
where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating
output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly
improbable for an attacker to distinguish between it and a truly random value. In general, if a PRNG algorithm is not
advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in
security-sensitive contexts, where its use can lead to serious vulnerabilities such as easy-to-guess temporary passwords,
predictable cryptographic keys, session hijacking, and DNS spoofing.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Using non predictable keys improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Remember Knuth: "Random numbers should not be generated with a method chosen at random"

void createCSRFToken(const char *prefix, char **token) {
  char randBytes[32];
  srand(time(NULL)); // really bad seed, but...
  // returning 42 is probably as much "random" as this ;)
  for(int i=0; i<32; i++) {
    int rng = rand(); // VIOLATION, poor randomness
    randBytes[i] = (char)rng;
  }
  // deterministically work with randBytes
  // (convert to hex and concat with prefix into token, etc,)
  concat(prefix, randBytes, 32, token);
}]]></example>
    <repair><![CDATA[// Remember Von Neumann: "Any one who considers arithmetical methods
   of producing random digits is, of course, in a state of sin."

#include "sodium.h"
void createCSRFToken(const char *prefix, char **token) {
  char randBytes[32];
  // FIXED - better quality pseudo-random number for CSRF token,
  // libsodium's randombytes_buf() is crypto-quality PRNG
  // (and PRNG is automatically initialized from system entropy sources)
  randombytes_buf(randBytes, 32);
  concat(prefix, randBytes, token);
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/338.html,http://cwe.mitre.org/data/definitions/330.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:MSC30,CWE:330,CWE:338,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="pattern" descname="Regular expression for detecting when a non-cryptographic PRNG is used in a security context.
When blank and checkInSecurityContext=true, no violations are emitted." value="password|passwd|receipt|session|user|key|csrf|token|hash|mac|digest|uuid|guid|crypto|encrypt|decrypt"/>
      <property name="checkInSecurityContext" descname="When set to true, PRNGs usages are only reported when they are used in a security context." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.InsecureSSL" message="InsecureSSL: Insecure SSL configuration" class="com.kiuwan.qaking.cpp.rules.security.InsecureSSL" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:9.2.4,CWEScope:Access-Control,CWEScope:Authentication,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,essential,ssl]]></tags>
    <description><![CDATA[The SSL / TLS standard provides guidelines on how to perform proper SSL validation checks on the client side.
They are not part of the standard, anyway. The implementation of the validation logic is left to the application developer,
that should setup SSL-related classes adequately.

Configuration for the SSL/TLS context in libraries is difficult, because the protocol evolutioned along time (from SSLv2 to the current TLSv1.3),
when certain attacks were discovered. The suite of allowed ciphers and modes for key exchange, encryption and authentication
allowed combinations that nowadays are considered unsafe. To support legacy systems (at client- or server- side)
often old protocol versions are allowed

Creating or configuring proper SSL validation checks is complex, and developers may fail providing a secure
SSL configuration. No certificate validity checks, no certificate chain signature verification, no or improper
server hostname validation (with respect to the identity contained in the server certificate) are common flaws.

Often, developers provide trust managers for accepting self-signed certificates, or even ignore certificate
state to allow expired or revoked certificates. Alternatively, the hostname validation is disabled to avoid
errors when the name in the certificate does not match the target hostname.

The problem with flawed SSL configuration is that it may allow man-in-the-middle attacks and other issues,
see references for full details.

The rule checks for SSL flaw patterns: forbidden SSL versions, or too-permissive certificate chain verification strategies.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid main-in-the-middle and other attacks that proper SSL configuration should block.]]></benefits>
    <inconvenients><![CDATA[Closing the gaps opened by a flawed SSL configuration may produce connection errors with certain legacy hosts.]]></inconvenients>
    <example><![CDATA[ #include <openssl/ssl.h>

 SSL_CTX *configure_tls(bool server) {
   SSL_METHOD* method;

   // version-flexible, do not fix any version (limited later)
   if (server) {
      method = (SSL_METHOD*) TLS_server_method();
   } else {
     method = (SSL_METHOD*) TLS_client_method();
   }

   SSL_CTX *ctx = SSL_CTX_new(method); // VIOLATION, SSLv3 and TLSv1_1 are allowed (but forbidden)

   SSL_CTX_set_min_proto_version(ctx, SSL3_VERSION); // SSLv2 not allowed (but POODLE breaks SSLv3)
   SSL_CTX_set_max_proto_version(ctx, TLS1_1_VERSION); // remove TLSv1_2 and TLSv1_3 (why ?)
   // drop TLSv1.0 support (leaving a "hole" in the list of allowed protocol version, which is discouraged)
   SSL_CTX_set_options(ctx, SSL_OP_NO_TLSv1); // remove TLS 1.0, vulnerable to BEAST
   // allowd are SSLv3 (broken!) and TLSv1_1 (not recommended)

   // in adition, accept any cert:

   SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL); // VIOLATION
   // or
   SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE, verify_nothing_callback);  // VIOLATION

   return ctx;
}

// Accept any certificates from the other side ;)
static int verify_nothing_callback(int preverify_ok, X509_STORE_CTX *certCtx) {
  log_chain(certCtx);
  return 1;
}]]></example>
    <repair><![CDATA[ SSL_CTX *configure_tls(bool server) {
   SSL_METHOD* method;

   // version-flexible, do not fix any version (limited later)
   if (server) {
      method = (SSL_METHOD*) TLS_server_method();
   } else {
     method = (SSL_METHOD*) TLS_client_method();
   }

   SSL_CTX *ctx = SSL_CTX_new(method);

   // FIXED: only TLSv1.2 and TLSv1.3 allowed
   // (TLSv1.2, released in 2008 is retained because TLS1.3 is too new as of today)
   SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);

   SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE, verify_callback); // FIXED

   return ctx;
}

// If provided, it should be programmed carefully:
// it should detect invalid certificate chain (incl. revocation status via OCSP) and hostname checks

static int verify_callback(int preverify_ok, X509_STORE_CTX *certCtx) {
  if( isInvalidChain(certCtx, preverify_ok) ) return 0;
  return preverify_ok;
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/296.html,https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/,https://cwe.mitre.org/data/definitions/297.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:296,CWE:297,CWE:298,CWE:299,OWASP-M:2016:M3,OWASP:2021:A2,OWASP:2021:A7,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="forbiddenVersions" descname="Comma-separated list of forbidden protocol versions, including any of: SSLv2, SSLv3, TLSv1, TLSv1_1, TLSv1_2, TLSv1_3, DTLSv1, DTLSv1_2." value="SSLv2, SSLv3, TLSv1, TLSv1_1, DTLSv1"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.InsufficientKeySize" message="InsufficientKeySize: Weak cryptography, insufficient key length" class="com.kiuwan.qaking.cpp.rules.security.InsufficientKeySize" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.8.3,ASVS-v4.0.2:6.2.3,ASVS-v4.0.2:6.2.4,ASVS-v4.0.2:6.2.5,ASVS-v4.0.2:6.2.6,ASVS-v4.0.2:6.2.7,ASVS-v4.0.2:9.1.2,ASVS-v4.0.2:9.1.3,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[A robust cryptographic algorithm (like RSA or AES) with a small key length could be vulnerable to brute-force type attacks.

For symmetric ciphers, AES-CBC (FIPS 197) is the most often recommended algorithm nowadays, with a block size of at least
64 bits (128 bits for the better). Recommended minimum key length for AES is 128 bits for most usages, but for long-range
security, 192 bits or even 256 bits are often recommended.

DES and DESede (or "triple-DES") are, nowadays, not robust enough for most applications. Many algorithms used in the past,
like Blowfish or RC2, are now deemed insecure.

For asymetric cryptography ("public key"), the algorithm most often used is RSA. Most experts consider 2048 as the
most adequate key length for common needs, as its usage in digital signature and other applications demand cryptographic
robustness for a long period of time. Experts now consider 1024 bits for RSA keys (modulus) not enough secure.

Algoritms based on elliptic curves cryptography (like EC-DSA) typically require smaller key sizes, around 200 bits.

See http://www.keylength.com for an interactive site showing current recommendations in cryptographic algorithms,
key length and other issues to take into account.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Example: AES using openssl
// with AES/256 configured in minKeySize:
// Key with 16 byts = 128 bits, too small for long-term protection
EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv); // VIOLATION]]></example>
    <repair><![CDATA[// key should be modified to hold 32 bytes = 256 bits.
EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv); // FIXED]]></repair>
    <reference><![CDATA[http://www.keylength.com/,http://cwe.mitre.org/data/definitions/326.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:326,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Comma-separated list of allowed ciphers." value="Salsa20, XSalsa20, ChaCha20"/>
      <property name="minKeySize" descname="Comma-separated list of minimum key size per algorithm. For example, if AES should use 256 bit keys, use AES/256." value="RSA/2048, DSA/2048, EC/256, AES/128, DH/2048"/>
      <property name="forbiddenAlgorithms" descname="Comma-separated list of ciphers that should NOT be used." value="des, desx, gost, loki, blowfish, enigma, rc2, rc4, arc4, arcfour, rc4drop, threeway, kasumi, panama, skipjack, crypt"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.LdapInjection" message="LdapInjection: Avoid non-neutralized user-controlled input in LDAP search filters" class="com.kiuwan.qaking.cpp.rules.security.LdapInjection" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.7,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software constructs all or part of an LDAP query or search filter using externally-influenced input,
but it does not neutralize or incorrectly neutralizes special elements that could modify the intended LDAP query when sent to LDAP server.

Please note that RFC 4513 (which defines simple authentication method for bind operation in LDAP) specifies
that a null or empty password means either an anonymous authentication (when the dn is also empty or null),
or an authenticated authentication (when the dn is not null/empty). The rule considers both cases as anonymous binding.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[It improves the safety.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#include <ldap.h>

int main( int argc, char *argv[]) {
  int desired_version = LDAP_VERSION3;
  char *ldap_host = "localhost";
  char *root_dn = "cn=Manager, dc=example, dc=com";
  char *root_pw = "secret";

  char* base = "dc=example,dc=com";

  strings ss;
  ss.append("(&(objectClass=person)(cn=").append(argv[1]).append("))"); // concatenation
  char* filter = ss.c_str();

  LDAP *ld = ldap_init(ldap_host, LDAP_PORT);
  ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &desired_version);
  ldap_bind_s(ld, root_dn, root_pw, LDAP_AUTH_SIMPLE);
  ldap_search_s(ld, base, LDAP_SCOPE_SUBTREE, filter, NULL, 0, &msg); // VIOLATION

  for(LDAPMessage *entry = ldap_first_entry(ld, msg); entry != NULL; entry = ldap_next_entry(ld, entry)) {
    // ...
  }
}]]></example>
    <repair><![CDATA[// Do not concatenate untrusted input without validation into ldap search filters.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/90.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:90,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:29]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.NoSQLInjection" message="NoSQLInjection: Improper neutralization of special elements in data query logic (NoSQL injection)" class="com.kiuwan.qaking.cpp.rules.security.NoSQLInjection" technology="C" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,NoSQL]]></tags>
    <description><![CDATA[The application generates a query intended to access or manipulate data in a data store such as a NoSQL database,
but it does not neutralize or incorrectly neutralizes special elements that can modify the intended logic of the query.

Depending on the capabilities of the query language, an attacker could inject additional login into the query to:
- Modify the intended selection criteria, thus changing which data entities (e.g., records) are returned, modified, or otherwise manipulated.
- Append additional commands to the query.
- Return more or fewer entities than intended.
- Cause entities to be sorted in an unexpected way.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent NoSQL injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// MongoDB C driver (libmongoc)
// Similar with C++ driver (mongocxx)

#include <mongoc/mongoc.h>

// do not hardcode this...
const char *MONGO_CONN_STR = "mongodb+srv://<username>:<password>@<cluster-url>/test?...";

int main(int argc, char *argv[]) {
    mongoc_client_t *client;
    mongoc_database_t *database;
    mongoc_collection_t *collection;
    bson_t query;
    char *query_str[1024];
    mongoc_cursor_t *cursor;

    mongoc_init();
    client = mongoc_client_new(MONGO_CONN_STR);
    database = mongoc_client_get_database(client, "test");
    collection = mongoc_database_get_collection(database, "mydocs");

    // The query is made by concatenating untrusted input, non validated/sanitized
    bson_init();

    strcat_s(query_str, sizeof query_str, "{\"product\" : ");
    // concat this way opens the door to NoSQL injection ;)
    strcat_s(query_str, sizeof query_str, argv[1]);
    strcat_s(query_str, sizeof query_str, "}");

    bson_init_from_json(&query, argv[0], -1, NULL);

    // VIOLATION, noSQL injection
    cursor = mongoc_collection_find_with_opts( collection, &query, NULL, NULL );
    // ... do something with the cursor ...

   bson_destroy (&query);
   mongoc_cursor_destroy (cursor);
   mongoc_collection_destroy(collection);
   mongoc_database_destroy(database);
   mongoc_client_destroy(client);
   mongoc_cleanup();
}]]></example>
    <repair><![CDATA[    // Same code as before
    long productId = strtol( argv[1], (char **)NULL, 10);
    query = BCON_NEW ( "product", BCON_INT64(productId) ); // FIXED

    cursor = mongoc_collection_find_with_opts( collection, &query, NULL, NULL );]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/943.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:943,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.PathTraversal" message="PathTraversal: Avoid non-neutralized user-controlled input composed in a pathname to a resource" class="com.kiuwan.qaking.cpp.rules.security.PathTraversal" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.1,ASVS-v4.0.2:12.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software uses external input to construct a pathname that is intended to identify a file or directory
that is located underneath a restricted parent directory, but the software does not properly neutralize
special elements within the pathname that can cause the pathname to resolve to a location outside the
restricted directory.

Under an application server, if the application server configuration does not restrict access to files outside
certain restricted directories, the attacker may fetch sensitive files, and if the file is written with contents
controlled by user input, the attacker may change configuration files (like web.xml among others), web contents
('web defacement'), or libraries (for more insidious code injection attacks). Access to system files
(the customary /etc/password in Unix/Linux systems) could also allowed with the app server account permissions.

It is recommended, besides ensuring that files depending on user-controlled input do not exit the intended directories,
that the OS account does have the minimal permissions, to reduce the impact of a successful path traversal attack.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Filesystem paths should not be controlled by user-controlled inputs.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[char *fname = getUntrustedInput();
// VIOLATION, user-controlled path opened without validation
FILE *file = fopen(fname, "w");
// ... write into f ...]]></example>
    <repair><![CDATA[char *fname = getUntrustedInput();

// Step#1: Canonicalize
// alternatives: realpath() or GetFullPathName
char *cfname = canonicalize_file_name(fname);

// Step#2: Ensure that path is inside allowed area
if(verify_file(cfname)) {
  FILE *f = fopen(cfname, "w"); // FIXED
  // ... write into f ...
}
free(cfname);]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources,http://cwe.mitre.org/data/definitions/22.html,http://cwe.mitre.org/data/definitions/73.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-C:FIO01,CWE:22,CWE:73,CWETOP25:2021:8,OWASP:2021:A4,OWASP:2021:A5,PCI-DSS:6.5.8,WASC:33]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.ProcessControl" message="ProcessControl: Do not load executables or libraries from untrusted sources" class="com.kiuwan.qaking.cpp.rules.security.ProcessControl" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.14.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,code-injection,scripting]]></tags>
    <description><![CDATA[Loading libraries or executables from an untrusted source or in an untrusted environment can cause an application
to execute malicious code on behalf of an attacker.

Sometimes a developed or third-party library needs to be be run during application execution. For example, System.AppDomain type provides
methods for running libraries or for loading types from a library. If the path to the library depends on external untrusted input,
for example configuration entries, an attacker that could modify the external input could manage to execute uninteded code,
with the privileges of the application.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid code injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[void doSomething(const char *loadPath, const char *libname) {
  // ...

  // VIOLATION - if loadPath influenced by untrusted input,
  // an attacker may force loading libraries from unexpected locations
  SetDllDirectory(loadPath);

  // VIOLATION - if libname influenced by untrusted input
  // an attacker may force loading an unexpected library, including malicious code
  LoadLibrary(libname); // VIOLATION

  // ...
}]]></example>
    <repair><![CDATA[// Validate library path and library search directories, to avoid executing code from an unintended library.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/114.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:114,CWE:494,CWETOP25:2021:4,OWASP:2021:A1,OWASP:2021:A8,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="allowSystemConfiguration" descname="If false, any kind of input is considered untrusted; if true, only user input is considered untrusted" value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.ResourceInjection" message="ResourceInjection: Improper control of resource identifiers (&quot;Resource Injection&quot;)" class="com.kiuwan.qaking.cpp.rules.security.ResourceInjection" technology="C" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software takes from an untrusted source the identifier for a system resource (like a port number),
and allows access to a non-expected resource. Attackers may use the flaw for malicious behaviour,
for example a port scan, change software configuration, transmit sensitive information to a third-party server,
etc.

This vulnerability is also known as "Insecure Direct Object Reference" instead of "Resource Injection".

Note: Please note that other rules may check injection flaws for specific resources (like Path Traversal rule for
filesystem resources, or SSRF for network addresses). This rule reports injection flaws on resource identifiers not
covered by other rules.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[#import <hiredis.h>

int main(int argc, char *argv[]) {

  char *host = argv[1];
  int port = (int) strtol(argv[2], (char **)NULL, 10);

  redisContext *ctx = redisConnect(host, port); // VIOLATION
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Resource_Injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:99,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.SqlInjection" message="SqlInjection: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" class="com.kiuwan.qaking.cpp.rules.security.SqlInjection" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The software constructs all or part of an SQL command using externally-controlled input, but it does not neutralize properly
that input that could modify the intended SQL command when it is sent to a database interaction method.

The rule detects a path in code between an input statement (source) and a database call (sink),
with SQL sentence depending on non neutralized input.

It must be known that if SQL does not depend on user-controlled input (e.g. Parametrized SQL, see repair example),
there is no possibility for an SQL injection.

Note: Using stored procedures in database operations does NOT prevent SQL injection if, for example, the SQL to send to
the database for execution of the stored procedure is composed by concatenating non properly neutralized user input.
The ways to avoid SQL injection are:
1) Use parametrized SQL, so SQL code and parameters are not mixed (no parameter could change semantics of the SQL).
2) If SQL code must depend on user input (e.g. to build 'dynamic' WHERE clauses), even with prepared statements,
   all user-controlled inputs used to compose such "dynamic" SQL should be neutralized.

A neutralization function either validates inputs and report an (neutral) error without allowing SQL execution,
or replaces sensitive SQL characters in the input to avoid that the resulting SQL has different semantics.

It is recommended to use parametrized SQL (when possible).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// vulnerable code using SQLAPI++
#include <SQLAPI.h>

// assume that username is externally-controlled
string username = getUserParameter();

// concatenation instead of parameterized query
string sql("select user, pass from users where username = '");
sql.append(username);
sql.append("'");

SAConnection con; // create connection object
con.Connect(dbname, dbuser, dbpass, SA_SQLServer_Client);
SACommand cmd(&con, sql.c_str()); // VIOLATION
cmd.Execute();
// ...]]></example>
    <repair><![CDATA[#include <SQLAPI.h>

// assume that username is externally-controlled
string username = getUserParameter();

// FIXED, parameterized query
char* sql = "select user, pass from users where username = :1";

SAConnection con; // create connection object
con.Connect(dbname, dbuser, dbpass, SA_SQLServer_Client);
SACommand cmd;
cmd.setCommandText(sql);
cmd << username; // binds username to parameter in prepared statement
cmd.Execute();
// ...]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.StaticDatabaseConnection" message="StaticDatabaseConnection: Static database connection / session" class="com.kiuwan.qaking.cpp.rules.security.StaticDatabaseConnection" technology="C" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Design]]></tags>
    <description><![CDATA[A (transactional) resource object, like a database connection or a persistence framework session, should not be a static field.
Static fields have application scope, and are typically shared between multiple user sessions and threads.

Transactional resource objects should not be stored in static fields. Such objects can only be associated with one transaction at a time.
Storing them in static fields would make it easy to erroneously share them between threads in different transactions.

Sharing a transactional resource object is a design flaw. Concurrent database operations based on the shared connection/session
may interfere with each other, with potential security issues. Resource leaking is another problem (database may close
an opened connection after idle timeout).

As a general recommendation, always acquire and close connection/session and intermediate objects (statement, resultset...)
in the shortest possible scope, preferably inside using block.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Example with SOCI, cases for other database libraries are similar
#include <soci.h>
using namespace soci;

class DatabaseAccess {
  private:
    static session sql; // VIOLATION, shared database connection

  public:
    // ...
}]]></example>
    <repair><![CDATA[class DatabaseAccess {
  private:
    session sql; // FIXED, either one db connection per instance, or...
    static connection_pool pool; // ...a connection pool, which is thread-safe

  public:
    // ...
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/567.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:567,PCI-DSS:6.5.6]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.UnsafeChroot" message="UnsafeChroot: Unsafe chroot call." class="com.kiuwan.qaking.cpp.rules.security.UnsafeChroot" technology="C" active="true">
    <tags><![CDATA[CERT-D:POS05,CWEScope:AccessControl]]></tags>
    <description><![CDATA[The chroot system call changes the root directory for the current process. Root directory is typically "/", but chroot() modifies it.
The call itself does not change the process current working directory, so attackers may escape the "chroot jail" (a misnomer term anyway),
simply using relative paths that might still refer to file system resources outside of the new chroot directory.

In addition, as chroot() demands superuser ("root") privileges or or CAP_SYS_CHROOT capability, it is recommended to relinquish
privileges to those of a non-privileged user, immediatly after the chroot call, typically by using setXXuid / setXXgid system calls.

The rule checks for two calls in the same function where the chroot() call is found:

(1) A call to chdir() or equivalent function, to change the current working directory, so access to files outside the chroot directory is prevented.
    Either chdir("/") after chroot, or chdir(chroot_dir) before chroot are needed.

(2) As calling chroot() needs superuser privileges, chroot call should be followed by a call to setXXuid()
    (the proper one depends on the underlying operating system), to change the effective user-id (EUID) to an non-privileged one.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended access to filesystem resources outside the chroot directory.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const char *CHROOT_DIR = "/home/myhttpdaemon/webroot";

void create_file_jail() {
  int err;
  /* ensure that we are superuser */
  err = setuid(0);
  if(err != 0) { /* fail with error */ }

  err = chroot(CHROOT_DIR); // VIOLATION
  if(err != 0) { /* fail with error */ }

  /* do your things here... */
}]]></example>
    <repair><![CDATA[const char *CHROOT_DIR = "/home/myhttpdaemon/webroot";

/*
  alternative: chdir(CHROOT_DIR) followed by chroot(".")
*/
void create_file_jail() {
  int err;
  /* ensure that we are superuser */
  err = setuid(0);
  if(err != 0) { /* fail with error */ }

  err = chroot(CHROOT_DIR);
  if(err != 0) { /* fail with error */ }

  err = chdir("/"); // fix -
  if(err != 0) { /* fail with error */ }

  err = seteuid(getuid()); // drop privileges
  if(err != 0) { /* fail with error */ }

  /* do your things here... */
}]]></repair>
    <reference><![CDATA[https://wiki.sei.cmu.edu/confluence/display/c/POS05-C.+Limit+access+to+files+by+creating+a+jail,http://www.unixwiz.net/techtips/chroot-practices.html,https://cwe.mitre.org/data/definitions/243.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:243]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.WeakCryptographicHash" message="WeakCryptographicHash: Weak cryptographic hash" class="com.kiuwan.qaking.cpp.rules.security.WeakCryptographicHash" technology="C" active="true">
    <tags><![CDATA[CWEScope:Accountability,CWEScope:Integrity,CWEScope:Non-Repudiation,crypto,hash]]></tags>
    <description><![CDATA[Use of weak cryptographic hash does not guarantee data integrity.

A (cryptographic) hash function maps data of arbitrary size ("the message") to a bit string of a fixed size ("the digest"),
designed to be a 'one-way' function, infeasible to invert. Ideally, a brute-force search of possible inputs to check
for a match on the expected digest (or a 'rainbow' table of precomputed message/hash pairs) should be the unique way
to recreate an input for a given digest.

Hash functions are the "workhorses" of modern cryptography, with many usages in digital signatures, message authentication codes (MACs),
symmetric key generation, indexing in hash tables, duplicate data detection, checksum against accidental data corruption...

A hash function hash() should have resistance against certain attacks:
* pre-image resistance: given hash value h, it should be difficult to find m such that h = hash(m).
* second pre-image resistance: given m1, it should be difficult to find another m2 such that hash(m1) = hash(m2).
* collision resistance ("birthday attack"): it should be difficult to find m1, m2 such that hash(m1) = hash(m2).
* length-extension resistance: given hash(m) and len(m) but not m, by choosing a suitable m' an attacker can calculate hash(m | m')
  (| denotes concatenation).

Resources needed for brute-force attacks obviously vary exponentially with hash size in bits, while for other attacks
could be half the bits in time or pre-image space (or much lower, if the algorithm has weaknesses).

MD5, SHA1 and SHA2 are often used to verify the integrity of data but last advances in cryptanalysis have discovered weaknesses in both algorithms.
In particular, they use the Merkle-Damgard construction, which are vulnerable to length-extension attacks against naive MAC generation
like hash(K | M).

Note: Modern crypto libraries may include the latest NIST standarized hash algorithm SHA-3 (Keccak),
which is a variable-size hash function (actually, a "cryptographic sponge") under sha3-224 ... sha3-512. When available
their usage is recommended in new code.

The rule looks for usages of crypto primitives (hash or hmac) using a weak algorithm.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid weak algorithms when verifying data integrity.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// The following example uses Microsoft CryptoAPI
// The rule would apply to any modern crypto library, like libcrypt, libsodium, openssl, crypto++...
#include <bcrypt.h>

void do_hash(const char *message) {
  BCRYPT_ALG_HANDLE hAlg = NULL;
  BCRYPT_HASH_HANDLE hHash = NULL;
  BCryptOpenAlgorithmProvider(&hAlg, BCRYPT_SHA1_ALGORITHM, NULL, 0);
  // VIOLATION - SHA-1 is now considered weak
  BCryptCreateHash(hAlg, &hHash, pbHashObject, cbHashObject, NULL, 0, 0);
  // ...
}]]></example>
    <repair><![CDATA[#include <bcrypt.h>

void do_hash(const char *message) {
  BCRYPT_ALG_HANDLE hAlg = NULL;
  BCRYPT_HASH_HANDLE hHash = NULL;
  // FIXED - Use SHA-2 (256 bits) hash, considered robust for most cryptographic usages
  BCryptOpenAlgorithmProvider(&hAlg, BCRYPT_SHA256_ALGORITHM, NULL, 0);
  BCryptCreateHash(hAlg, &hHash, pbHashObject, cbHashObject, NULL, 0, 0);
  // ...
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/328.html,https://en.wikipedia.org/wiki/Hash_function_security_summary,https://crackstation.net/hashing-security.htm]]></reference>
    <normatives>
      <security><![CDATA[CWE:328,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:50]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="List of robust hash functions">
        <value><![CDATA[
sha224, sha256, sha384, sha512, sha3, sha3-224, sha3-256, sha3-384, sha3-512, blake2b, blake2s, keccak, ripemd160, rmd160, ripemd256, ripemd320, whirlpool, dss1, bcrypt, pbkdf2
        ]]></value>
      </property>
      <property name="forbiddenAlgorithms" descname="List of weak hash functions">
        <value><![CDATA[
md2, md4, md5, sha1, gost, gost-crypto, tiger128, tiger160, tiger192, panama, haval128, snefru, ripemd128, adler32, crc32, crc32b, fnv132, fnv1a32, fnv164, fnv1a64, joaat, plaintext
        ]]></value>
      </property>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.WeakEncryption" message="WeakEncryption: Weak symmetric encryption algorithm" class="com.kiuwan.qaking.cpp.rules.security.WeakEncryption" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.9.3,ASVS-v4.0.2:6.2.2,ASVS-v4.0.2:8.3.7,CWEScope:Confidentiality,crypto]]></tags>
    <description><![CDATA[Using a weak encryption algorithms does not guarantee the confidentiality of sensitive data.

Home-grown ciphers, or standard algorithms that were proven flawed or weak, compromise the confidentiality of data.

Encryption algorithms like DES, Triple-DES and RC2 are nowadays too weak for cryptographic usage,
in particular for ensuring information confidentiality.

DES is currently broken, as an small key size renders it unsafe against brute-force attacks.

RC2 is currently broken, as a related-key attack, where an attacker finds mathematical relationships
between key values, renders it unsafe as well.

Triple-DES (or 3DES) is weak, and should be migrated to a more robust standard cipher.

The AES standard algorithm, with an adequate key length and proper setup (initial vector, mode, padding)
should be used instead, for cryptographic operations.

The rule checks usages of weak ciphers in cryptographic primitives, not registred in the allowed list, and registed in the forbidden list.
The rule does not check if the cipher operation is coded properly (key length, initial vector and feedback mode, padding).]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid compromising sensitive data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Encryption using openSSL
#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/err.h>

// iv and key must be in sync with the cipher chosen
int encrypt_failed(unsigned char *plaintext, int plaintext_len, unsigned char *key,
               unsigned char *iv, unsigned char *ciphertext) {
    EVP_CIPHER_CTX *ctx;
    int len;
    int ciphertext_len;

    if(!(ctx = EVP_CIPHER_CTX_new())) {
      handleErrors();
    }

    // VIOLATION, DES is weak encryption (old, keys with 56 bits, 8-byte blocks)
    if(1 != EVP_EncryptInit_ex(ctx, EVP_des_cbc(), NULL, key, iv)) {
      handleErrors();
    }

    if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) handleErrors();
    ciphertext_len = len;

    if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();
    ciphertext_len += len;

    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);

    return ciphertext_len;
}]]></example>
    <repair><![CDATA[// Encryption using openSSL
#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/err.h>

// iv and key must be in sync with the cipher chosen
int encrypt_failed(unsigned char *plaintext, int plaintext_len, unsigned char *key,
               unsigned char *iv, unsigned char *ciphertext) {
    EVP_CIPHER_CTX *ctx;
    int len;
    int ciphertext_len;

    if(!(ctx = EVP_CIPHER_CTX_new())) {
      handleErrors();
    }

    // FIXED - AES-256 is strong, keylen = 128 bits, block is 32 bytes
    if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) {
      handleErrors();
    }

    if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) handleErrors();
    ciphertext_len = len;

    if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();
    ciphertext_len += len;

    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);

    return ciphertext_len;
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/327.html,https://blog.cryptographyengineering.com/2012/05/19/how-to-choose-authenticated-encryption/]]></reference>
    <normatives>
      <security><![CDATA[CWE:327,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Comma-separated list of allowed ciphers." value="aes, rijndael, camellia, cast, cast5, tripledes, 3des, des3, des-ede, des-ede3, mars, twofish, saferplus, seed, serpent, idea, rc5, rc6, rabbit, trivium, salsa20, xsalsa20, chacha20"/>
      <property name="forbiddenAlgorithms" descname="Comma-separated list of ciphers that should NOT be used." value="des, desx, gost, loki, blowfish, enigma, rc2, rc4, arc4, arcfour, rc4drop, threeway, kasumi, panama, skipjack, crypt"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.C.SEC.XmlEntityInjection" message="XmlEntityInjection: XML entity injection" class="com.kiuwan.qaking.cpp.rules.security.XmlEntityInjection" technology="C" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.5.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[In XML parsers, when XML document to parse could be altered by untrusted input, and the untrusted input may
alter the Document Type Definition (DTD, embedded or external), the parser should be configured to avoid
two kinds of potential attacks:

* XML entity expansion DoS (XEE, XML bomb or "billion laughs attack"), CWE-776, where well-formed DTD with
  internal entities are expanded exponentially until they exhaust memory.

* XML external entity injection (XXE), CWE-611, where an external entity controlled by the attacker refers to the URL
  of a resource that gives unauthorized access to sensitive files on the server machine, or to a resource
  like /dev/random in Unix systems that, when entity is expanded, leads to a denial-of-service condition.
  A variant of this attack is the server-side request forgery (SSRF), where the URL for external DTD or XML-Schema
  is processed by the URL handler used by the XML parser, allowing the attacker access to an unexpected
  network resource (for cross-site request forgery attacks or port-scanning enumeration).

A particular parser might be vulnerable to XML entity injection attacks when their default settings have both entity expansion
and external entity resolution enabled. Disabling validations does not help, as entity expansion / external entity loading is done,
even when validation is disabled.

DTD is not the unique element that an attacker could use for injection: XML-Schema attributes could be specified
on any tag, so SSRF injection may happen at any place in the XML document, not only at the start where DTD should
be placed, but fortunately common parsers do not seem to fetch schema URLs by default.

XML parsing could be hidden in other frameworks and libraries. For example, with REST, when a resource has an XML
representation, the REST framework typically use an underlying XML parser for processing the request message, which
obviusly is fully under control of a potential attacker.

To be safe during XML processing coming from untrusted sources, a number of XML features should be disabled
when configuring the parser:
* DTD interpretation - Ensure DOCTYPE tags are ignored, or documents containing them are rejected.
* Ignore or reject external entities.
* schemaLocation and noNamespaceSchemaLocation should not fetch URLs.
* XIncludes - Should be disabled or left disabled.

The rule checks that there is a path between an untrusted input and the XML document to parse,
then verifies that the XML parser is configured to avoid both external entity and entity expansion attacks.

Some of the common XML parsers available in the C/C++ ecosystem, like expat or libxml2,
may allow bad configuration leading to XXE or entity expansion attacks.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XML entity attacks that could cause denial-of-service and information leakage.]]></benefits>
    <inconvenients><![CDATA[Dependencies on certain features related to DTD or entity expansion may render runtime errors.]]></inconvenients>
    <example><![CDATA[// Vulnerable XML parser using libxml2:
char *input = getUserInput();
// XML_PARSE_NOENT allows expansion of entities
// XML_PARSE_DTDLOAD allows external DTD loading
xmlDocPtr doc = xmlReadMemory(input, strlen(input), "noname.xml", NULL, XML_PARSE_DTDLOAD | XML_PARSE_NOENT);

This code is vulnerable to well-known XML attack vectors like:

* "billion laughs" attack, 1K payload expands to 3GB!:
<?xml version="1.0"?>
<!DOCTYPE lolz [
 <!ENTITY lol "lol">
 <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
 <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
 <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
 <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
 <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
 <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
 <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
 <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>

* XXE (external entity attack), for sensitive file disclosure:
<!DOCTYPE roottag [
 <!ENTITY windowsfile SYSTEM "file:///c:/boot.ini">
]>
<roottag>
 <sometag>&windowsfile;</sometag>
</roottag>

* XXE, for denial-of-service under Unix servers:
<!DOCTYPE foo [
  <!ELEMENT root ANY >
  <!ENTITY unixfile SYSTEM "file:///dev/random" >
]>
<root>&unixfile;</root>]]></example>
    <repair><![CDATA[// FIXED, the default configuration is safe against XEE and XXE attacks
xmlDocPtr doc = xmlReadMemory(input, strlen(input), "noname.xml", NULL, 0);]]></repair>
    <reference><![CDATA[OWASP XML External Entity Processing: https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing,XML Schema, DTD, and Entity Attacks: http://www.vsecurity.com/download/papers/XMLDTDEntityAttacks.pdf,http://cwe.mitre.org/data/definitions/611.html,http://cwe.mitre.org/data/definitions/776.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:611,CWE:776,CWETOP25:2021:23,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:43,WASC:44]]></security>
    </normatives>
    <properties>
      <property name="parametersAsSources" descname="Assume that method parameters are untrusted inputs" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <categories>
    <category name="C" technology="C" active="true" weight="1.0">
      <description><![CDATA[C rules]]></description>
      <children>
        <category name="OPT.CRITERIUM_VALUE.CQM.EFFICIENCY" technology="C" active="true" weight="0.0">
          <description><![CDATA[Efficiency]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.MAINTAINABILITY" technology="C" active="true" weight="0.0">
          <description><![CDATA[Maintainability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.PORTABILITY" technology="C" active="true" weight="0.0">
          <description><![CDATA[Portability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.RELIABILITY" technology="C" active="true" weight="0.0">
          <description><![CDATA[Reliability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.SECURITY" technology="C" active="true" weight="10.0">
          <description><![CDATA[Security]]></description>
        </category>
      </children>
    </category>
  </categories>
</ruleset>
