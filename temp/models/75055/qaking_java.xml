<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="qaking_java" updated="">
  <description>EDCAST_MOBILE</description>
  <rule name="OPT.HIBERNATE.BindParametersInQueries" message="BindParametersInQueries: Use bind (or named) parameters in HQL and native SQL queries" class="com.optimyth.qaking.hibernate.rules.BindParametersInQueries" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Hibernate]]></tags>
    <description><![CDATA[It is commonly thought that ORM layers, like Hibernate, are automatically immune to SQL injection.
This is FALSE, as Hibernate includes a subset of SQL called HQL, and allows "native" SQL queries.
Often the ORM layer only minimally manipulates the inbound query before handing it off to the database for processing.

HQL, as well as native SQL, could also produce SQL injection conditions, when potentially tainted values (values that could be controlled by user inputs) are concatenated to the query string.

The rule checks that the first argument in Session.executeQuery (for HQL) and Session.executeSQLQuery (for native SQL) methods is composed by concatenating potentially user-controlled variables. The static analysis performed by the rule is not very precise, so false positives (and false negatives) could happen.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid potential SQL injection issues.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// trivial SQL injection case. tainted and tainted2 could be affected by user input
public List bad(String tainted, String tainted2, Session session) {
  String sql = "from DomesticCat cat where cat.name = " + tainted + " and cat.type = :type"; // NEVER DO THIS !
  Query q = session.createQuery(sql);
  q.setString("type", tainted2); // safe, but damage was already done
  return q.list();
}]]></example>
    <repair><![CDATA[public List ok(String tainted, String tainted2, Session session) {
  Query q = session.createQuery("from DomesticCat cat where cat.name = :name and cat.type = :type");
  // Secure, under most database drivers (where bound parameters in prepared statements are NOT part of the SQL)
  q.setString("name", tainted);
  q.setString("type", tainted2);
  return q.list();
}]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Hibernate-Guidelines,https://cwe.mitre.org/data/definitions/564.html,https://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:564,CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="searchInMappings" descname="If true, process hibernate mapping descriptors; if false, ignore mapping descriptors" value="true"/>
      <property name="searchInEntityCode" descname="If true, process JPA-annotated (@Entity) classes; if false, ignore JPA entities" value="true"/>
      <property name="searchInClientCode" descname="If true, process client Java code (non JPA-annotated entities); if false, ignore client code" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.HIBERNATE.DeclarePrivateIdentifierSetter" message="DeclarePrivateIdentifierSetter: The setter method for an identifier property (id or composite-id) should be private" class="com.optimyth.qaking.hibernate.rules.DeclarePrivateIdentifierSetter" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Hibernate]]></tags>
    <description><![CDATA[This rule looks for non-private methods used to set the value of an identifier field. The identifier field should only be assigned a value by Hibernate when the object is saved. By making the method private you ensure that other code cannot change the object's identity.
For composite ID, it also checks that the composite ID class is serializable and overrides equals() and hashCode().]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[By making the method private you ensure that other code (apart from Hibernate) cannot change the object's identity.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// eg.PersistentClass is an Hibernate persistent class
package eg;

public class PersistentClass {
  private Long id;

  public void setId(Long id) { this.id = id; } // VIOLATION
  public Long getId() { return this.id; }

  ...
}

// MyKey is a composite-id class, must be serializable and provide equals() and hashCode()
public class MyKey { // VIOLATION, not serializable, not equals() / hashCode()
  private String employeeNumber;
  private String department;

  private void setEmployeeNumber(Long id) { this.employeeNumber = employeeNumber; }
  public Long getEmployeeNumber() { return this.employeeNumber; }

  private void setDepartment(String department) { this.department = department; }
  public String getDepartment() { return this.department; }
}]]></example>
    <repair><![CDATA[// eg.PersistentClass is an Hibernate persistent class
package eg;

public class PersistentClass {
  private Long id;

  private void setId(Long id) { this.id = id; } // OK
  public Long getId() { return this.id; }

  ...
}

public class MyKey implements Serializable { // OK
  private String employeeNumber;
  private String department;

  private void setEmployeeNumber(Long id) { this.employeeNumber = employeeNumber; }
  public Long getEmployeeNumber() { return this.employeeNumber; }

  private void setDepartment(String department) { this.department = department; }
  public String getDepartment() { return this.department; }

  public boolean equals(Object o) { ... }
  public int hashCode() { ... }
}]]></repair>
    <reference><![CDATA[]]></reference>
    <properties>
      <property name="searchInMappings" descname="If true, process hibernate mapping descriptors; if false, ignore mapping descriptors" value="true"/>
      <property name="searchInEntityCode" descname="If true, process JPA-annotated (@Entity) classes; if false, ignore JPA entities" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.AlwaysCanonicalizeURLReceivedByContentProvider" message="AlwaysCanonicalizeURLReceivedByContentProvider: Avoid improper access to application data" class="com.optimyth.qaking.android.rules.security.ContentProviderPathTraversal" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[When ContentProvider.openFile() method is used, access to our application data can be granted to another application.

If the URI path provided to the openFile() method contains a static path to the directory, then it would be possible to access to the directory, and all files contained on it.

To avoid that, a proper input data validation must be done.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unauthorized access to sensible data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import android.content.ContentProvider;
import android.os.ParcelFileDescriptor;
import java.io.File;
import android.net.Uri;

public class MyProvider extends ContentProvider {
  public ParcelFileDescriptor openFile(Uri paramUri, String paramString) throws FileNotFoundException {
      File file = new File(paramUri);
      return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);    // Violacion
  }
}]]></example>
    <repair><![CDATA[import android.content.ContentProvider;
import android.os.ParcelFileDescriptor;
import java.io.File;
import android.net.Uri;

public class MyProvider extends ContentProvider {
  public ParcelFileDescriptor openFile(Uri paramUri, String paramString) throws FileNotFoundException {
        paramUri = doSomething(paramUri);    // Ok
      File file = new File(paramUri);
      return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/android/DRD08-J.+Always+canonicalize+a+URL+received+by+a+content+provider]]></reference>
    <properties>
      <property name="parametersAsSources" descname="Allow to consider method parameters as sources." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.AndroidSQLInjection" message="AndroidSQLInjection: Avoid SQL code formed with non neutralized user input" class="com.optimyth.qaking.android.rules.security.AndroidSQLInjection" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android,essential]]></tags>
    <description><![CDATA[The software constructs all or part of an SQL command using externally-controlled input, but it does not neutralize
properly that input that could modify the intended SQL command when it is sent to a database interaction class
(e.g. Android SQLiteDatabase).

The rule detects a path in code between an user-input statement (source) and a database call (sink), with SQL sentence depending on
non neutralized input.

It must be known that if SQL does not depend on user-controlled input (e.g. Parametrized SQL), there is no possibility for an SQL injection.

Note: Using stored procedures in database operations does NOT prevent SQL injection if, for example, the SQL to send
to the database for execution of the stored procedure is composed by concatenating non properly neutralized user input.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;

public class Test {

  public void test1(String username, String password){
    String sql = "select * from user where username='" + username +"' and password='" + password + "'";

    SQLiteDatabase mDatabase = this.getWritableDatabase();

    SQLiteStatement sqlstmt = mDatabase.compileStatement(sql);
    sqlstmt.execute();    // Violation
  }
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[]]></reference>
    <properties>
      <property name="parametersAsSources" descname="Allow to consider method parameters as sources." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.AndroidStickyBroadcast" message="AndroidStickyBroadcast: Avoid Sticky Broadcasts" class="com.optimyth.qaking.android.rules.security.AndroidStickyBroadcast" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android,essential,infoleak]]></tags>
    <description><![CDATA[Sticky broadcasts are usually informational and designed to tell other processes some fact about
the system state (like "battery low"). Sticky broadcasts receipt cannot be secured with a permission,
and therefore are accessible to any receiver.

A normal broacasted Intent reaches receiver(s) configured for that intents, and ends. With sticky broadcasts,
the Intent continues in system (so other apps could be notified if they need the same information). Additionally,
a malicious app could overwrite sticky Intent data.

If these broadcasts contain sensitive data or reach a malicious receiver, an information leakage may happend.

Note: Sticky broadcasts are deprecated since API level 21 ("lollipop").

The rule looks for any call of the deprecated methods related to sticky broadcasts, and any <uses-permission> element
in AndroidManifest.xml requesting android.permission.BROADCAST_STICKY permission to send or remove such broadcast type.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid potential security issues, like sensitive information disclosure.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class MyActivity extends Activity {

  public void sendBroadcast() {
    AccountManager am = AccountManager.get(this);
    Account[] accounts = am.getAccountsByType("com.google");
    String googleMail = accounts[0].name;

    Intent intent = new Intent();
    intent.setAction("com.example.service.UserExists");
    intent.putExtra("Username", googleMail);

    sendStickyBroadcast(intent); // VIOLATION
  }
}

In AndroidManifest.xml, app must request the BROADCAST_STICKY
to send sticky broadcasts:
<!-- VIOLATION -->
<uses-permission android:name="android.permission.BROADCAST_STICKY"/>]]></example>
    <repair><![CDATA[Always avoid deprecated 'sticky' broadcasts.]]></repair>
    <reference><![CDATA[http://www.jssec.org/dl/android_securecoding_en.pdf,https://cwe.mitre.org/data/definitions/927.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:927,OWASP:2021:A4,PCI-DSS:7.1.2]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.ContentProviderUriInjection" message="ContentProviderUriInjection: Content Provider URI Injection" class="com.optimyth.qaking.android.rules.security.ContentProviderUriInjection" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android]]></tags>
    <description><![CDATA[Android content providers is a data access abstraction that uses URIs as query strings. Implementation of a content
provider translates the URI request to data operations on the backend data repository (e.g. an SQL database).

Accesses to content providers in app code are based on calls to a ContentResolver or ContentProviderClient.
Calls are typically insert / query / update / delete, with an URI argument used by the content provider
to perform the operation.

When untrusted input, without validation, is concatenated to compose an URI argument to such content provider methods,
an attacker may change the operation intended by the Android app, using typically .. and / characters, and perform
unexpected operations in the targeted content provider.

Depending on the implementation of the target content provider, this flaw could also allow path traversal or SQL injection
attacks against the target content provider via the vulnerable app, if the content provider contains such vulnerabilities.

This vulnerability is similar to the more traditional SQL Injection, where the URI semantics (playing similar role to SQL)
is changed when uncontrolled concatenation from untrusted data is performed.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import android.net.Uri;

// msgId is untrusted input, and the query arguments are encoded in the URI
// an attacker may pass "123/delete" instead or "123", changing the intended operation
Uri dataUri = Uri.parse(MyProvider.BASE_URI + "/" + msgId);

Cursor wCursor1 = getContentResolver().query(dataUri, null, null, null, null); // VIOLATION]]></example>
    <repair><![CDATA[// Add a proper validation to msgId:
if( isValidMsgId( msgId ) ) { // FIXED
  Uri dataUri = Uri.parse(MyProvider.BASE_URI + "/" + msgId);
  Cursor wCursor1 = getContentResolver().query(dataUri, null, null, null, null);
  // ...
}]]></repair>
    <reference><![CDATA[https://solidgeargroup.com/sql-injection-in-content-providers-of-android-and-how-to-be-protected/,https://oldbam.github.io/android/security/android-vulnerabilities-insecurebank-content-providers,https://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:89,CWETOP25:2021:6,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.ContextSensitiveDataIsKeptSecure" message="ContextSensitiveDataIsKeptSecure: Avoid improper access to data created by the context" class="com.optimyth.qaking.android.rules.security.ContextSensitiveDataIsKeptSecure" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android,essential,infoleak]]></tags>
    <description><![CDATA[In Android Apps, data can be communicated by Intents, stored in files, shared using shared preferences, or stored in databases.

The security, except in cases where there are Intents involved, it can be get creating a file, a shared preference or
a database with the mode MODE_PRIVATE in internal storage, or using encryption in external storage.

MODE_PRIVATE is a constant defined by the class android.content.Context.  It may be used as parameter in the methods
openFileOutput(), getSharedPreferences(), and openOrCreateDatabase().]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unauthorized access to sensible data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class TestClass {

  private Context context;

  public TestClass(Context context) {
    this.context = context;
  }

  public Context getApplicationContext(){
    return this.context;
  }

  public void method1KO (){
    Context c = new Context();
    FileOutputStream fos = c.openFileOutput( title+".html", Context.MODE_WORLD_READABLE);  // Violation
  }

  public void method2KO (){
    FileOutputStream fos = context.openFileOutput( title+".html", Context.MODE_WORLD_READABLE);  // Violation
  }

  public void method3KO (){
    FileOutputStream fos = this.context.openFileOutput( title+".html", Context.MODE_WORLD_READABLE);  // Violation
  }

  public void method4KO (Context c){
    FileOutputStream fos = c.openFileOutput( title+".html", Context.MODE_WORLD_READABLE);  // Violation
  }
}]]></example>
    <repair><![CDATA[public class TestClass {

  private Context context;

  public TestClass (Context context) {
    this.context = context;
  }

  public Context getApplicationContext(){
    return this.context;
  }

  public void method1OK (){
    Context c = new Context();
    FileOutputStream fos = c.openFileOutput( title+".html", Context.MODE_PRIVATE);  // Ok
  }

  public void method2OK(){
    FileOutputStream fos = context.openFileOutput( title+".html", Context.MODE_PRIVATE);  // Ok
  }

  public void method3OK(){
    FileOutputStream fos = this.context.openFileOutput( title+".html", Context.MODE_PRIVATE);  // Ok
  }

  public void method4OK(Context c){
    FileOutputStream fos = c.openFileOutput( title+".html", Context.MODE_PRIVATE);  // Ok
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/android/DRD11.+Ensure+that+sensitive+data+is+kept+secure]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.DoNotLogSensitiveInformation" message="DoNotLogSensitiveInformation: Avoid unsafe log access" class="com.optimyth.qaking.android.rules.security.DoNotLogSensitiveInformation" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[App with android.permission.READ_LOGS can output logging information and also access to log output, using android.util.Log
class and the logcat command, respectively.

Before Android API LEVEL 16 (Jelly Bean), any app with READ_LOGS permission could access any other app output logs.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Error handling and fault isolation</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unauthorized access to sensible data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <uses-sdk
    android:minSdkVersion="8"
    android:targetSdkVersion="16" />

  <!-- VIOLATION -->
  <uses-permission android:name="android.permission.READ_LOGS"/>

  <application
    android:name=".app"
    android:icon="@drawable/icon"
    android:label="@string/app_name"
    android:debuggable="true">

    <provider
      android:name="MyProvider2"
      android:authorities="com.example.MyProvider2" />

  </application>
</manifest>]]></example>
    <repair><![CDATA[<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <uses-sdk
    android:minSdkVersion="8"
    android:targetSdkVersion="16" />

  <application
    android:name=".app"
    android:icon="@drawable/icon"
    android:label="@string/app_name"
    android:debuggable="true">

    <provider
      android:exported="false"
      android:name="MyProvider2"
      android:authorities="com.example.MyProvider2" />

  </application>

</manifest>]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/android/DRD04-J.+Do+not+log+sensitive+information]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.DoNotReleaseDebuggableApps" message="DoNotReleaseDebuggableApps: Do not release debuggable apps" class="com.optimyth.qaking.android.rules.security.DoNotReleaseDebuggableApps" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[Android allows to debug apps if the attribute android:debuggable is set to true in the AndroidManifest.xml.
By default its value is false.

If an application is published with this attribute active, users can access to the details of the application
which should be kept in a secure way, because it's allowing to debug the application without the source code.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unauthorized access to sensible data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.android.package"
    android:versionCode="102"
    android:versionName="1.1" >

    <application
        android:name=".app"
        android:icon="@drawable/icon"
        android:label="@string/app_name"
        android:debuggable="true"> <!-- Violation -->

    </application>
</manifest>]]></example>
    <repair><![CDATA[<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.android.package"
    android:versionCode="102"
    android:versionName="1.1" >

    <application
        android:name=".app"
        android:icon="@drawable/icon"
        android:label="@string/app_name"
        android:debuggable="false"> <!-- FIXED -->

    </application>
</manifest>]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/android/DRD10-X.+Do+not+release+apps+that+are+debuggable]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.DynamicallyLoadingCode" message="DynamicallyLoadingCode: Discourage dynamically loading code" class="com.optimyth.qaking.android.rules.DynamicallyLoadingCode" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android,code-injection]]></tags>
    <description><![CDATA[It is strongly discouraged to load code outside of the application APK. Doing so significantly increases the likelihood
of application compromise due to code injection or code tampering.

It also adds complexity around version management and application testing.
Finally, it can make it impossible to verify the behavior of an application, so it may be prohibited in some environments.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[String packageName = "android.myapp";
String apkName = getPackageManager().getApplicationInfo(packageName, 0).sourceDir;
DexClassLoader dexClassLoader = new DexClassLoader(apkName, "/dynamicClasses", null, getClass().getClassLoader());

Class myClass = Class.forName("android.myapp.DynClass", true, dexClassLoader);]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[Android Developers - http://developer.android.com/intl/es/training/articles/security-tips.html#DynamicCode,http://www.symantec.com/connect/blogs/android-class-loading-hijacking]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SEC03,CWE:114,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.ExportedActivity" message="ExportedActivity: Exported activity must require permissions" class="com.optimyth.qaking.android.rules.security.ExportedActivity" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[Activity can be exported by setting its attribute exported=true, or adding an intent-filter not setting attribute exported=false.
To receive or bind them a permission have to be required, otherwise any apps can access the activity.

The rule checks for exported activities without explicit permissions required.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <application>

    <!-- VIOLATION -->
    <activity
        android:name=".BlankShoppingList">
      <intent-filter>
        <action
            android:name="com.isecpartners.shopping.CLEAR_LIST" />
      </intent-filter>
     <!-- VIOLATION -->
    </activity>
        <activity
        android:name=".BlankShoppingList"
        android:exported="true">
    </activity>

  </application>

</manifest>]]></example>
    <repair><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <permission
    android:name="com.mypkg.permission.YOUR_PERMISSION"
    android:protectionLevel="normal" />

  <uses-permission android:name="com.mypkg.permission.YOUR_PERMISSION" />

  <application>

    <!-- OK. Permission is set -->
    <activity
        android:name=".BlankShoppingList"
        android:permission="com.isecpartners.ACCESS_SHOPPING_LIST">
      <intent-filter>
        <action
            android:name="com.isecpartners.shopping.CLEAR_LIST" />
      </intent-filter>
    </activity>

    <activity
        android:name=".BlankShoppingList">
    </activity> <!-- OK. Default value without intents is false -->

  </application>

</manifest>]]></repair>
    <reference><![CDATA[https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/isec_securing_android_apps.pdf,https://developer.android.com/guide/topics/manifest/manifest-intro.html,https://developer.android.com/training/articles/security-tips.html,https://developer.android.com/guide/topics/manifest/activity-element.html]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.ExportedPreferenceActivity" message="ExportedPreferenceActivity: Activities extending PreferenceActivity should not be exported" class="com.optimyth.qaking.android.rules.security.ExportedPreferenceActivity" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android]]></tags>
    <description><![CDATA[Fragment injection gives anyone who can send your PreferenceActivity an intent
        the ability to load any fragment, with any arguments, in your process.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <uses-sdk
      android:minSdkVersion="8"
      android:targetSdkVersion="16" />

  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.GET_ACCOUNTS" />
  <uses-permission android:name="android.permission.MANAGE_ACCOUNTS" />
  <uses-permission android:name="android.permission.AUTHENTICATE_ACCOUNTS" />
  <uses-permission android:name="android.permission.USE_CREDENTIALS" />

  <application
      android:allowBackup="true"
      android:icon="@drawable/ic_launcher"
      android:label="@string/app_name"
      android:theme="@style/AppTheme" >
      <!-- Violation -->
      <activity
          android:name="MainActivity"
          android:label="@string/app_name" >
          <intent-filter>
              <action android:name="android.intent.action.MAIN" />
              <category android:name="android.intent.category.LAUNCHER" />
          </intent-filter>
      </activity>
      <activity
          android:name="OtherActivity">
      </activity>
  </application>
</manifest>]]></example>
    <repair><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <uses-sdk
      android:minSdkVersion="8"
      android:targetSdkVersion="16" />

  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.GET_ACCOUNTS" />
  <uses-permission android:name="android.permission.MANAGE_ACCOUNTS" />
  <uses-permission android:name="android.permission.AUTHENTICATE_ACCOUNTS" />
  <uses-permission android:name="android.permission.USE_CREDENTIALS" />

  <application
      android:allowBackup="true"
      android:icon="@drawable/ic_launcher"
      android:label="@string/app_name"
      android:theme="@style/AppTheme" >
      <!-- FIXED -->
      <activity
              android:name="MainActivity"
              android:label="@string/app_name" >
      </activity>
      <activity
              android:name="OtherActivity">
      </activity>
  </application>
</manifest>]]></repair>
    <reference><![CDATA[https://securityintelligence.com/new-vulnerability-android-framework-fragment-injection/]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SEC03-J,CWE:470]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.ExportedProvider" message="ExportedProvider: Exported providers must require permissions" class="com.optimyth.qaking.android.rules.security.ExportedProvider" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[Providers can be exported by setting its attribute exported=true.
To receive or bind them a permission have to be required, otherwise any apps can access the service.

The rule checks for exported providers without explicit permissions required.
The implicit value of exported attributed is false by default in API level 17 or higher.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <application>
    <!-- VIOLATION when android:targetSdkVersion or android:minSdkVersion set to 16 or lower  -->
    <provider
      android:name="com.android.tools.fd.runtime.InstantRunContentProvider"
      android:authorities="com.kiuwan.InstantRunContentProvider"
      android:multiprocess="true" />

    <!-- VIOLATION -->
    <provider
        android:name="com.android.tools.fd.runtime.InstantRunContentProvider"
        android:authorities="com.kiuwan.InstantRunContentProvider"
        android:multiprocess="true"
        android:exported="true"/>

  </application>

</manifest>]]></example>
    <repair><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <permission
    android:name="com.mypkg.permission.YOUR_PERMISSION"
    android:protectionLevel="normal" />

  <uses-permission android:name="com.mypkg.permission.YOUR_PERMISSION" />

  <application>
    <!-- Ok when android:targetSdkVersion and android:minSdkVersion set to 17 or higher-->
    <provider
        android:name="com.android.tools.fd.runtime.InstantRunContentProvider"
        android:authorities="com.kiuwan.InstantRunContentProvider"
        android:multiprocess="true"/>
    <!-- Ok -->
    <provider
        android:name="com.android.tools.fd.runtime.InstantRunContentProvider"
        android:authorities="com.kiuwan.InstantRunContentProvider"
        android:multiprocess="true"
        android:exported="false"/>

    <!-- Ok -->
    <provider
        android:name="com.android.tools.fd.runtime.InstantRunContentProvider"
        android:authorities="com.kiuwan.InstantRunContentProvider"
        android:multiprocess="true"
        android:exported="true"
        android:permission="com.mypkg.permission.YOUR_PERMISSION"/>

    <!-- Ok -->
    <provider
        android:name="com.android.tools.fd.runtime.InstantRunContentProvider"
        android:authorities="com.kiuwan.InstantRunContentProvider"
        android:multiprocess="true"
        android:permission="com.mypkg.permission.YOUR_PERMISSION"/>

  </application>

</manifest>]]></repair>
    <reference><![CDATA[https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/isec_securing_android_apps.pdf,https://developer.android.com/training/articles/security-tips.html,https://developer.android.com/guide/topics/manifest/provider-element.html,https://developer.android.com/guide/topics/manifest/manifest-intro.html]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.ExportedReceiver" message="ExportedReceiver: Exported receivers must require permissions" class="com.optimyth.qaking.android.rules.security.ExportedReceiver" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[A malicious app installed on the device may send an Intent that could be captured by an exported receiver that was
not intended to be exported. This attack is known as "Intent Spoofing".

Exported receivers (receivers which either set exported=true or contain an intent-filter and do not specify exported=false)
should define a permission that en entity must have in order to launch the receiver or bind to it.
Without this, any application can use this receiver.

The rule checks for exported receivers (explictly, or implicitly with intent filter) that do not require permissions.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <application>
    <!-- VIOLATION, exported -->
    <receiver android:name="MyBroadcastReceiver" android:exported="true" />

    <!-- VIOLATION, implicitly exported -->
    <receiver android:name="MyBroadcastReceiverWithIntentFilter">
      <intent-filter>
        <action android:name="MyAction" />
      </intent-filter>
    </receiver>
  </application>

</manifest>]]></example>
    <repair><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <permission
    android:name="com.mypkg.permission.YOUR_PERMISSION"
    android:protectionLevel="normal" />

  <uses-permission android:name="com.mypkg.permission.YOUR_PERMISSION" />

  <application>
    <!-- FIXED, not exported -->
    <receiver android:name="MyBroadcastReceiver" android:exported="false" />

    <!-- FIXED, exported but demands permission -->
    <receiver
      android:name="MyBroadcastReceiverWithIntentFilter"
      android:permission="com.mypkg.permission.YOUR_PERMISSION"
      >
      <intent-filter>
        <action android:name="MyAction" />
      </intent-filter>
    </receiver>
  </application>

</manifest>]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.ExportedService" message="ExportedService: Exported services must require permissions" class="com.optimyth.qaking.android.rules.security.ExportedService" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[Services can be exported by setting its attribute exported=true, or adding an intent-filter not setting attribute exported=false.
To receive or bind them a permission have to be required, otherwise any apps can access the service.

The rule checks for exported services without explicit permissions required.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <application>
    <!-- VIOLATION, exported without demanding permissions -->
    <service android:name="MyBroadcastService" android:exported="true" />

    <!-- VIOLATION, exported without demanding permissions -->
    <service
      android:name="MyBroadcastServiceWithIntentFilter"
    >
      <intent-filter>
        <action android:name="MyAction" />
      </intent-filter>
    </service>

  </application>

</manifest>]]></example>
    <repair><![CDATA[[AndroidManifest.xml]
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.android.package"
  android:versionCode="102"
  android:versionName="1.1" >

  <permission
    android:name="com.mypkg.permission.YOUR_PERMISSION"
    android:protectionLevel="normal" />

  <uses-permission android:name="com.mypkg.permission.YOUR_PERMISSION" />

  <application>
    <!-- FIXED, service not exported -->
    <service android:name="MyBroadcastService" android:exported="false" />

    <!-- FIXED, service exported but needs permission granted -->
    <service
      android:name="MyBroadcastServiceWithIntentFilter"
      android:permission="com.mypkg.permission.YOUR_PERMISSION"
    >
        <intent-filter>
          <action android:name="MyAction" />
        </intent-filter>
    </service>

  </application>

</manifest>]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.GrantAllUris" message="GrantAllUris: Avoid sharing root path" class="com.optimyth.qaking.android.rules.security.GrantAllUris" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[<grant-uri-permission> element allows sharing especific paths.

        If shared path is '/', app would be sharing the root path, which is possibly not the desired effect.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[            <?xml version="1.0" encoding="UTF-8"?>

            <manifest xmlns:android="http://schemas.android.com/apk/res/android"
                package="foo.bar2"
                android:versionCode="1"
                android:versionName="1.0" >
                <uses-sdk android:minSdkVersion="14" />
                <application
                    android:icon="@drawable/ic_launcher"
                    android:label="@string/app_name" >

                    <!-- Violation -->
                    <grant-uri-permission android:path="/"/>
                </application>
            </manifest>]]></example>
    <repair><![CDATA[            <?xml version="1.0" encoding="UTF-8"?>

            <manifest xmlns:android="http://schemas.android.com/apk/res/android"
                package="foo.bar2"
                android:versionCode="1"
                android:versionName="1.0" >
                <uses-sdk android:minSdkVersion="14" />
                <application
                    android:icon="@drawable/ic_launcher"
                    android:label="@string/app_name" >

                    <!-- Ok -->
                    <grant-uri-permission android:pathPrefix="/all_downloads/"/>
                </application>
            </manifest>]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.IntentManipulation" message="IntentManipulation: Intent Manipulation" class="com.optimyth.qaking.android.rules.security.IntentManipulation" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android]]></tags>
    <description><![CDATA[If untrusted input is inserted into certain parts of an Android Intent, without proper sanitization, a malicious user or app
could force, via the tainted Intent, the execution of unintended code or inject malicious data in the vulnerable app.

Certain Intent properties could change the expected semantics of the Intent, like setAction(), setClass(), setClassName(),
or setComponent(). If the Intent is used to start an Activity or Service, for example, the attacker may change the
expected element launched, with potential nefarious consequences.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid Intent Manipulation attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;

public class IntentManipulation extends Activity {
  protected void onCreate(Bundle savedInstanceState) {
    // ...
    Intent request = getIntent(); // possibly coming from a malicious app
    String action = request.getAction();
    String type = request.getType();
    ComponentName component = request.getComponent();

    Intent targetService = new Intent();
    targetService.setAction(action); // VIOLATION
    targetService.setComponent(component); // VIOLATION
    targetService.setType(type);

    startService(targetService); // probably not the intended service !
  }
}]]></example>
    <repair><![CDATA[// Perform a white-list validation
protected void onCreate(Bundle savedInstanceState) {
  Intent request = getIntent(); // possibly coming from a malicious app
  String action = request.getAction();
  String type = request.getType();
  ComponentName component = request.getComponent();

  if( isValidAction(action) && isValidComponent(component) ) { // FIXED
    // ... rest of logic
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/99.html,http://oasam.org/en/oasam/oasam-dv-data-validation/oasam-dv-007-intent-injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:99,OWASP-M:2016:M7,OWASP:2021:A3,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.JavascriptEnabled" message="JavascriptEnabled: Enabling JavaScript is not recommended" class="com.optimyth.qaking.android.rules.JavascriptEnabled" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.1.1,ASVS-v4.0.2:14.5.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android]]></tags>
    <description><![CDATA[Use of setJavaScriptEnabled() or addJavaScriptInterface() on webView is not recommended.

Because WebView consumes web content that can include HTML and JavaScript from an external URL,
improper use can introduce common web security issues such as cross-site-scripting (XSS, or JavaScript injection).

Android includes a number of mechanisms to reduce the scope of these potential issues by limiting the capability
of WebView to the minimum functionality required by your application.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid cross-site scripting vulnerabilities.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[     WebView webView = (WebView)findViewById(R.id.webView);
     webView.getSettings().setJavaScriptEnabled(true); // VIOLATION, potential XSS]]></example>
    <repair><![CDATA[     WebView webView = (WebView)findViewById(R.id.webView);
     webView.getSettings().setJavaScriptEnabled(false); // FIXED, is the default value]]></repair>
    <reference><![CDATA[Android Developers - http://developer.android.com/intl/es/training/articles/security-tips.html#WebView]]></reference>
    <normatives>
      <security><![CDATA[CWE:749]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.JavascriptInterfaceAnnotation" message="JavascriptInterfaceAnnotation: Potential code injection via WebView.addJavaScriptInterface()" class="com.optimyth.qaking.android.rules.security.JavascriptInterfaceAnnotation" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.1.1,ASVS-v4.0.2:14.5.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android]]></tags>
    <description><![CDATA[Android apps often use the WebView class to display online content. An app can inject Java objects into a WebView via the
WebView.addJavascriptInterface() method, which allows JavaScript code in the loaded page to call public methods
of the injected Java object (this is called "JavaScript bridge").

Exposing Java objects to JavaScript could have negative security implications, such as code injection (allowing access
to native phone functionality like sending SMS to premium numbers, accessing account information and sensitive data, etc.)
Such code injection may, for example, do something like this (to launch a system command):

exposedObj.getClass().forName('java.lang.Runtime').getMethod('getRuntime', null).invoke(null, null).exec(cmd)

Note: For applications built for API levels >= 17 (JellyBean MR1), only public methods annotated with @JavascriptInterface
(on objects registered with addJavascriptInterface) could be called; for example, getClass() above is not allowed.

This rule emits a violation on any WebView.addJavaScript() call, when the app's API level is below 17. Please note that
it is not possible for the rule to decide if the content rendered by WebView should be considered trusted.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class Test extends Activity {
  private WebView appView;
  private JS js;

  @Override public void onCreate(Bundle savedInstanceState) {
    appView = new WebView(this);
    bindBrowser(appView);
  }

  private void bindBrowser(WebView appView) {
    js = new JS(this, appView);
    appView.addJavascriptInterface(js, "JS"); // VIOLATION
  }

  private static class JS {
    public void exposed() {...}
  }
}]]></example>
    <repair><![CDATA[/*
  Either (1) remove the JavaScript/Java bridge (addJavascriptInterface).
  or (2) make sure that the content loaded by WebView is really trusted
  (and place a suppression for violations when needed), or (3) upgrade
  to API level 17 or higher and place a @JavascriptInterface annotation
  on allowed public methods, as in the following code
*/

// update minSdkVersion to 17 or higher in AndroidManifest.xml

public class Test extends Activity {
  private WebView appView;
  private JS js;

  @Override public void onCreate(Bundle savedInstanceState) {
    appView = new WebView(this);
    bindBrowser(appView);
  }

  private void bindBrowser(WebView appView) {
    js = new JS(this, appView);
    appView.addJavascriptInterface(js, "JS");
  }

  private static class JS {
    @JavascriptInterface // FIXED
    public void exposed() {...}
  }
}]]></repair>
    <reference><![CDATA[WebView addJavascriptInterface Remote Code Execution - https://labs.mwrinfosecurity.com/blog/2013/09/24/webview-addjavascriptinterface-remote-code-execution/,CERT-Android DRD13 - https://www.securecoding.cert.org/confluence/x/HoC9Bw]]></reference>
    <normatives>
      <security><![CDATA[CWE:749]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.LimitAccessibilityOfSensitiveContentProvider" message="LimitAccessibilityOfSensitiveContentProvider: Limit the accessibility of a app's sensitive ContentProvider" class="com.optimyth.qaking.android.rules.security.LimitAccessibilityOfSensitiveContentProvider" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[The ContentProvider class provides a mechanism for managing and sharing data with other applications.

When sharing a providers data with other apps, access control should be carefully implemented to prohibit unauthorized
access to sensitive data. So, if ContentProvider provides access to sensible data, it must be protected using exported=false,
or with a permission which control which other apps could access such data.

Note: From API level 17 (JellyBean) the export default is false, whereas in previous versions it is true.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unauthorized access to sensible data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.myorg.pkg"
  android:versionCode="102"
  android:versionName="1.1" >

  <uses-sdk
    android:minSdkVersion="8"
    android:targetSdkVersion="16" />

  <application
    android:name=".app"
    android:icon="@drawable/icon"
    android:label="@string/app_name">

    <!-- VIOLATION -->
    <provider
      android:exported="true"
      android:name="MyProvider"
      android:authorities="com.example.MyProvider" />

    <!-- VIOLATION, exported by default (API level <= 16) -->
    <provider
      android:name="MyProvider2"
      android:authorities="com.example.MyProvider2" />

  </application>

</manifest>]]></example>
    <repair><![CDATA[<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.myorg.pkg"
  android:versionCode="102"
  android:versionName="1.1" >

  <uses-sdk
    android:minSdkVersion="8"
    android:targetSdkVersion="16" />

  <application
    android:name=".app"
    android:icon="@drawable/icon"
    android:label="@string/app_name">

    <!-- FIXED, not exported -->
    <provider
      android:exported="false"
      android:name="MyProvider"
      android:authorities="com.example.MyProvider" />

    <!-- FIXED, explicit read/write permissions -->
    <provider
      android:exported="true"
      android:readPermission="com.myorg.MyProvider.readAllowed"
      android:writePermission="com.myorg.MyProvider.writeAllowed"
      android:name="MyProvider2"
      android:authorities="com.example.MyProvider2"/>

  </application>

</manifest>]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/android/DRD01-X.+Limit+the+accessibility+of+an+app%27s+sensitive+content+provider]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.PackagedPrivateKey" message="PackagedPrivateKey: Avoid package private key files" class="com.optimyth.qaking.android.rules.security.PackagedPrivateKey" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[Avoid package private key files.

Rule considers .pem and .key formats as potential key containers.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[[private_key.pem]
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: DES-EDE3-CBC,77F426A58B274623
6f2ba5d6064e58f5aca354afa04e6dad1b91ea1bd7d5e194e59bcdca39e4ac3a
93e92aef23a0cfebcd7641d806977bd509009e41e3ed19440b8cc38df240ee92
e6933af5888da26cb8000f41fc0510bd14bfaa56dc5004df1b60c13975f680b8
63c7aa02234b17882fbe9cd94d37af27ab6d495f83dc39027abb58afa7f5d525
-----END RSA PRIVATE KEY-----]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.PackageManagerGetSignatures" message="PackageManagerGetSignatures: Potential Multiple Certificate Exploit" class="com.optimyth.qaking.android.rules.security.PackageManagerGetSignatures" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[Improper validation of app signatures can cause security issues when a malicious app
submits itself to the PlayStore with its real certificate and other fake certificate.

If the certificates signatures are recovered into the code, a malicious app can use them to sign itself, turning into a
trustable application. Recovering certificates signatures into the code must be avoided because it is insecure.

This rule is only applied to versions from 2.1 to 4.4, both included.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding certificate exploit improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class Test extends Activity {
  public void check() {
    getPackageManager().getPackageInfo("pkg.pkg", PackageManager.GET_SIGNATURES);   // Violation
  }
}]]></example>
    <repair><![CDATA[Certificates signatures are not being recovered into the source code.]]></repair>
    <reference><![CDATA[http://www.androidcentral.com/fake-id-and-android-security-updated]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.PreventBackupVulnerability" message="PreventBackupVulnerability: Inadecuate backup configuration" class="com.optimyth.qaking.android.rules.security.PreventBackupVulnerability" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.2.1,ASVS-v4.0.2:10.3.1,ASVS-v4.0.2:14.1.3,ASVS-v4.0.2:2.5.4,ASVS-v4.0.2:3.4.3,ASVS-v4.0.2:3.4.4,ASVS-v4.0.2:3.4.5,CWEScope:Confidentiality,Framework:Android,infoleak]]></tags>
    <description><![CDATA[The android:allowBackup attribute determines if an application's data can be backed-up and restored.

If the attribute is not specified, backup is enabled by default; if developer forgets to write this attribute,
sensitive app data may be leaked.

Note: Backup may have security consequences for an application. End-users may copy app data off of the device.
Once backed up, all application data can be read by the user. As backup services may use the cloud for storage,
backup for sensitive data threatens information confidentiality.

A malicious user may also change the data so after restore, unintended data, configurations and permissions could
be enabled, with data integrity loss.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unauthorized access to sensitive application data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- VIOLACION, active backup without fullBackupContent
     (when permitBackup=true) -->
<application
  android:name=".app"
  android:icon="@drawable/icon"
  android:label="@string/app_name"
  android:allowBackup="true">
  ...
</application>]]></example>
    <repair><![CDATA[<!-- FIXED, data to backup made explicit -->
<application
  android:name=".app"
  android:icon="@drawable/icon"
  android:label="@string/app_name"
  android:allowBackup="true" android:fullBackupContent="@xml/backupscheme">
  ...
</application>]]></repair>
    <reference><![CDATA[http://developer.android.com/training/backup/autosyncapi.html#configuring,https://cwe.mitre.org/data/definitions/16.html,https://cwe.mitre.org/data/definitions/359.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:FIO52-J,CWE:16,CWE:359,OWASP-M:2016:M2,OWASP:2021:A5,WASC:13]]></security>
    </normatives>
    <properties>
      <property name="permitBackup" descname="When true, allowBackup=true is permitted. When false, a violation is reported when backup is active." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.PrivilegeEscalationAttack" message="PrivilegeEscalationAttack: Don't allow applications to execute code using other applications privileges" class="com.optimyth.qaking.android.rules.security.PrivilegeEscalationAttack" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.4.5,Framework:Android]]></tags>
    <description><![CDATA[Android allows checking application permissions in several ways. Two from these ways are using the calls
checkCallingOrSelfPermission y checkCallingOrSelfUriPermission.

If an application A restricts the execution of a block of code by using one of these checks, and other application B tries
to execute that code, then even when the B application doesn't have enough privileges to execute it, it will be executed
anyway if the A application is allowed to do it, producing an privilege escalation attack.

In example if the checkCallingPermission function is used, then the execution of the code only will be performed when the
B application has enough privileges to do it.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid privileges escalation attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import android.content.Context;

public class MainActivity extends Activity {

    private void doSomething(Context context) {
        if (!context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE") == 0) {     // VIOLATION
            return;
        }

        if (!context.checkCallingOrSelfUriPermission(uri, 1) == 0) {     // VIOLATION
            return;
        }
    }
}]]></example>
    <repair><![CDATA[import android.content.Context;

public class MainActivity extends Activity {

    private void doSomething(Context context) {
        if (!context.checkCallingPermission("android.permission.ACCESS_NETWORK_STATE") == 0) {     // Ok
            return;
        }
    }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/275.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:275]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.ReceiverWithoutPermission" message="ReceiverWithoutPermission: Missing broadcaster permission when register a receiver" class="com.optimyth.qaking.android.rules.security.ReceiverWithoutPermission" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android,essential,infoleak]]></tags>
    <description><![CDATA[To avoid any broadcaster sends messages when you register a receiver, it's important specify the broadcaster permission
where registerReceiver method is invoked.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Specify permissions avoids the application may be compromised by messages containing malicious data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import android.app.Activity;
import android.os.Environment;
import java.io.*;

public class MainActivity extends Activity {

    IntentFilter filter1;

    @Override
    public void onCreate() {
        filter1 = new IntentFilter("android.bluetooth.BluetoothDevice.ACTION_ACL_CONNECTED");
        registerReceiver(myReceiver, filter1);  //VIOLATION
    }
}]]></example>
    <repair><![CDATA[import android.app.Activity;
import android.os.Environment;
import java.io.*;

public class MainActivity extends Activity {

    IntentFilter filter1;

    @Override
    public void onCreate() {
        filter1 = new IntentFilter("android.bluetooth.BluetoothDevice.ACTION_ACL_CONNECTED");
        registerReceiver(myReceiver, filter1, PERMISSION_STRING_PRIVATE_BROADCASTER, null);  //OK
    }
}]]></repair>
    <reference><![CDATA[https://developer.android.com/training/articles/security-tips.html#permissions,http://siis.cse.psu.edu/slides/android-sec-tutorial.pdf,https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/isec_securing_android_apps.pdf]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.SMSMonitoring" message="SMSMonitoring: Don't use SMS for data input or command" class="com.optimyth.qaking.android.rules.SMSMonitoring" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.1.1,ASVS-v4.0.2:14.5.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Android]]></tags>
    <description><![CDATA[The SMS protocol was primarily designed for user-to-user communication and is not well-suited for apps that want to transfer data.
Beware that SMS is neither encrypted nor strongly authenticated on either the network or the device. In particular, any SMS receiver should expect that a malicious user may have sent the SMS to your applicationDo not rely on unauthenticated SMS data to perform sensitive commands. Also, you should be aware that SMS may be subject to spoofing and/or interception on the network.

As the rule cannot know if SMS is used for user notification or inter-application communications, two properties
(allowSendSMS and allowReceiveSMS) could be set to configure if sending / receiving of SMS/MMS messages is allowed,
so for example application is allowed to send SMS messages, but not to capture received messages.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    // If allowReceiveSMS=false this is a rule violation
    public static final String SMS_EXTRA_NAME = "pdus";
     
    Object[] smsExtra = (Object[]) extras.get( SMS_EXTRA_NAME ); // VIOLATION, with allowReceiveSMS=false

    // Another way to process received SMS messages from broadcast intent
    public static SmsMessage[] getMessagesFromIntent(Intent intent) {
        Object[] messages = (Object[]) intent.getSerializableExtra("pdus"); // VIOLATION
        byte[][] pduObjs = new byte[messages.length][];

        for (int i = 0; i < messages.length; i++) {
            pduObjs[i] = (byte[]) messages[i];
        }
        byte[][] pdus = new byte[pduObjs.length][];
        int pduCount = pdus.length;
        SmsMessage[] msgs = new SmsMessage[pduCount];
        for (int i = 0; i < pduCount; i++) {
            pdus[i] = pduObjs[i];
            msgs[i] = SmsMessage.createFromPdu(pdus[i]);
        }
        return msgs;
    }

    // If allowSendSMS=false this is a rule violation
    SmsManager smsManager = SmsManager.getDefault();
    smsManager.sendTextMessage(phoneNumber, null, message, piSent, piDelivered); // VIOLATION, with allowSendSMS=false]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[Android Developers - http://developer.android.com/training/articles/security-tips.html#Networking]]></reference>
    <normatives>
      <security><![CDATA[CWE:749]]></security>
    </normatives>
    <properties>
      <property name="allowSendSMS" descname="Allow sending SMS/MMS messages (via SmsManager)" value="true"/>
      <property name="allowReceiveSMS" descname="Allow receiving SMS/MMS messages" value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.UseASafeCipher" message="UseASafeCipher: Avoid using cipher in ECB mode, or without specifying the mode" class="com.optimyth.qaking.android.rules.security.UseASafeCipher" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[getInstance() method from Cipher class (javax.crypto.Cipher) should not be called specifying the ECB mode, or without
specifying a mode. If cipher mode is not specified, Android implementations typically use ECB mode by default, which
is not considered secure for general usage. It is recommended to make explicit the mode (and padding) always,
and avoid using ECB mode whenever possible.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[Cipher c = Cipher.getInstance("AES"); // VIOLATION, ECB by default
Cipher c2 = Cipher.getInstance("AES/ECB/PKCS5Padding"); // VIOLATION]]></example>
    <repair><![CDATA[Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); // FIXED]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.ANDROID.UseCheckPermission" message="UseCheckPermission: Use the result of a permission check" class="com.optimyth.qaking.android.rules.security.UseCheckPermission" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Android]]></tags>
    <description><![CDATA[When a method which checks permissions is called, such as checkCallingPermission(), it returns the permission status.
If no check is done on the returned value, no permission check is done.

An alternate path is to call an enfoce*Permission() method, such as enforceCallingPermission(), which throws a SecurityException
if permission is not granted, so code to protect is not executed.

Valid uses considered by this rule are:
- Using permission check call in a conditional sentence.
- Using permission check call as return value, or as argument for other call.
- Assigning the result of the permission check to a var, and then using the var in any of the valid uses described before.

A call to enforce*Permission() is considered not valid if SecurityException is caught in an empty catch block, so
permission check is ignored.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import android.app.Fragment;

public class MyFragment extends Fragment {
  public void method() {
    String permission = "android.permission.WRITE_EXTERNAL_STORAGE";
    try {
      getContext().enforceCallingPermission(permission); // VIOLATION

    } catch(SecurityException se) {}

    // ... code to protect by permission check ...
  }
}]]></example>
    <repair><![CDATA[import android.app.Fragment;

public class MyFragment extends Fragment {
  public void method() {
    String permission = "android.permission.WRITE_EXTERNAL_STORAGE";
    try {
      // FIXED, code to protect is moved into try block
      getContext().enforceCallingPermission(permission);
      // ... code to protect by permission check ...

    } catch(SecurityException se) {
      // ... error handling (not empty) ...
    }
  }
}]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.EJB.AvoidReturnThisClassEjb" message="AvoidReturnThisClassEjb: Avoid returning 'this' from the methods of the Enterprise JavaBean classes" class="com.als.clases.rational.AvoidReturnThisClassEJB" technology="JAVA" active="true">
    <description><![CDATA[The application of this rule prevents the possibility that a client directly accesses the reference of the Enterprise JavaBean. All invocations performed by a client must go through the Enterprise JavaBean container, not the bean itself.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Increased code security and reliability.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[      public class BeanClass implements javax.ejb.EntityBean {
        public Object returningMethod() {
          return this; // VIOLATION
        }
      }]]></example>
    <repair><![CDATA[      public class BeanClass implements javax.ejb.EntityBean {
        public Object returningMethod() {
          return this.getEJBObject(); //OK
        }
      }]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.EJB.DontModifyAccessSecurity" message="DontModifyAccessSecurity: Do not access or modify java.security configuration objects (Policy, Security, Provider, Principal, KeyStore)" class="com.als.clases.rational.DontModifyAccessSecurity" technology="JAVA" active="true">
    <description><![CDATA[Accessing or modifying java.security configuration objects (Policy, Security, Provider, Principal, KeyStore) is forbidden. They can cause security problems,
and sometimes could signal a backdoor to skip certain security controls.]]></description>
    <priority>5</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improves security and reliability, avoids potential backdoors.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[import java.security.Policy; //VIOLATION

public class BeanClass implements javax.ejb.EntityBean {
  private static Policy p; //VIOLATION
  private static Policy p2; //VIOLATION

  public void manageSecurity() {
    // ..
    p = p2.getPolicy();//VIOLATION
    p2 = p;//VIOLATION
    Policy p3 = p;//VIOLATION
  }
}]]></example>
    <repair><![CDATA[Do not access or modify java.security.* objects (Policy, Security, Provider, Principal, KeyStore).]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidCheckPermission" message="AvoidCheckPermission: Avoid calling java.security.AccessController.checkPermission()" class="com.als.clases.rational.AvoidCheckPermission" technology="JAVA" active="true">
    <description><![CDATA[Write the program so that it uses the existing security mechanism and does not need to check permissions.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improvements in security and reliability of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[public class AccessControllerCheck {
  public AccessControllerCheck(String name) {
    super();
    this .resourceName = name;
  }

  public File getFileResource() throws AccessControlException {
    FilePermission perm = new FilePermission(resourceName, r_permission);
    AccessController.checkPermission(perm); //VIOLATION
    return new File(resourceName);
  }

  private static final String r_permission = "read";
  private String resourceName = null;

}]]></example>
    <repair><![CDATA[public class AccessControllerCheck {
  public AccessControllerCheck(String name) {
    super();
    this.resourceName = name;
  }

  public File getFileResource() {
    return new File(resourceName); // implicit security check
  }

  private String resourceName = null;
}]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidDoAs" message="AvoidDoAs: Avoid calling javax.security.auth.Subject.doAs()" class="com.als.clases.rational.AvoidDoAs" technology="JAVA" active="true">
    <description><![CDATA[When a block is marked as privileged code, you can call services based on the permissions even though some of the callers do not have such permissions. Minimize privileges of the application.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improvements in security and reliability of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[public class Loader {
  public void loadLibrary(Execution exec) {
    exec.execute(new PrivilegedAction() {
      public Object run() {
        System.loadLibrary("lib");
        return null;
      }
    });
  }
}

public abstract class Execution {

  public Execution(Subject sub) {
    this.sub = sub;
  }

  private Subject sub;

  public void execute(PrivilegedAction action) {
    Subject.doAs(sub, action); //VIOLATION
  }

}]]></example>
    <repair><![CDATA[public class Loader {
  public void loadLibrary() {
    System.loadLibrary("lib"); //OK
  }
}]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidDoAsPrivileged" message="AvoidDoAsPrivileged: Avoid calling javax.security.auth.Subject.doAsPrivileged()" class="com.als.clases.rational.AvoidDoAsPrivileged" technology="JAVA" active="true">
    <description><![CDATA[When a block of code is set to privileged it can call services even if they dont have permission to do so.
Minimize the usage of operations that require a different identity in your application.]]></description>
    <priority>3</priority>
    <effort>5</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[It increases the security and the reliability of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[public class ExampleClass {
  private Subject sub;
  private AccessControlContext ctx;

  public ExampleClass(Subject sub) {
    this.sub = sub;
  }

  public void execute(PrivilegedAction action) {
    Subject.doAsPrivileged(sub, action, ctx); // VIOLATION
  }

  public class Loader {

    public void loadLibrary(ExampleClass exec) {
      exec.execute(new PrivilegedAction() {
        public Object run() {
          System.loadLibrary("lib");
          return null;
        }
      });
    }
  }
}]]></example>
    <repair><![CDATA[public class ExampleClass {
  private Subject sub;
  private AccessControlContext ctx;

  public ExampleClass(Subject sub) {
    this.sub = sub;
  }

  public void execute(PrivilegedAction action) {
    System.loadLibrary("lib"); // Note: forbidden by other rules
  }
}]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidDoPriviliged" message="AvoidDoPriviliged: Avoid calling java.security.AccessController.doPrivileged()" class="com.als.clases.rational.AvoidDoPrivileged" technology="JAVA" active="true">
    <description><![CDATA[When a block is marked as privileged code, you can call services based on the permissions even though some of the callers do not have such permissions. Minimise the privileges of the application.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class Initializer {
  public Initializer() {
  super();
  }

  public void initialize() throws AccessControlException {
    AccessController.doPrivileged(new PrivilegedAction() {
      public Object run() {
        System.loadLibrary("library");//$NON-NLS-1$
        return null;
      }
    });
  }
}]]></example>
    <repair><![CDATA[Do not use privileged blocks unless absolutely necessary.]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/SEC00-J.+Do+not+allow+privileged+blocks+to+leak+sensitive+information+across+a+trust+boundary]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SEC00-J]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidExtendPermission" message="AvoidExtendPermission: Avoid extending java.security.Permission" class="com.als.clases.rational.NamesAllowedRule" technology="JAVA" active="true">
    <description><![CDATA[Use an existing implementation. You can add new permissions to Java that are tailored to specific needs.
However, you should always minimise the application privileges. Write the program so you do not need more than the basic set of privilege.]]></description>
    <priority>3</priority>
    <effort>5</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improves the reliability and maintainence of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[      
      public class Action {
        public Action(Permission perm) {
          this .rootPermission = perm;
        }
        private Permission rootPermission;
        public void execute(CustomPermission permission) {
          if (rootPermission.implies(permission)) {
            //...
          }
        }
      }

      public final class CustomPermission extends BasicPermission {
        public CustomPermission(String name,List properties) {
          super(name);
          this .properties = properties;
        }
        public boolean implies(Permission permission) {
          CustomPermission perm = (CustomPermission) permission;
          return perm.properties.containsAll(properties);
        }
        private List properties;
      }]]></example>
    <repair><![CDATA[      
     // Try to avoid creating new permission types.

      public class Action {
        public Action() {
        }
        public void execute() {
          //...
        }
      }]]></repair>
    <reference><![CDATA[]]></reference>
    <properties>
      <property name="NOT_ALLOWED_INPUT_TYPE" descname="NOT_ALLOWED_INPUT_TYPE" value="CLASSES"/>
      <property name="NOT_ALLOWED" descname="NOT_ALLOWED" value="java.security.Permission"/>
      <property name="SEARCH_SCOPE" descname="SEARCH_SCOPE" value="EXTENDS_ONLY"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidGetContext" message="AvoidGetContext: Avoid calling java.security.AccessController.getContext()" class="com.als.clases.rational.AvoidGetContext" technology="JAVA" active="true">
    <description><![CDATA[The code should use this through the existing API. Avoid direct use of AccessController context.]]></description>
    <priority>5</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improves the reliability of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[public class AccessControllergetContext {
  public AccessControllergetContext(Permission permission) {
    super();
    this.context = AccessController.getContext(); // VIOLATION
    this.permission = permission;
  }

  public void getFileResource() throws AccessControlException {
    AccessController.doPrivileged(new PrivilegedAction() {
      public Object run() {
        context.checkPermission(permission);
        System.loadLibrary("library");
        return null;
      }
    });
  }

  private AccessControlContext context = null;
  private Permission permission = null;

}]]></example>
    <repair><![CDATA[public class AccessControllergetContext {
  public AccessControllergetContext() {
    super();
  }

  public void getFileResource() throws AccessControlException {
    AccessController.doPrivileged(new PrivilegedAction() {
      public Object run() {
        System.loadLibrary("library");
        return null;
      }
    });
  }
}]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidGetProperty" message="AvoidGetProperty: Avoid calling java.security.Security.getProperty()" class="com.als.clases.rational.AvoidGetProperty" technology="JAVA" active="true">
    <description><![CDATA[The code should always use the default security implementation. Do not customise the code for security reasons.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improvements in security and reliability of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[public abstract class SecurityGetProperty {

  public SecurityGetProperty() {
  }

  public void readResource() {
    AccessController.doPrivileged(new PrivilegedAction() {
      public Object run() {
        String value = Security.getProperty(PROVIDER); //VIOLATION
        if (canDo(value)) {
          executionWithCondition();
        } else {
          usualExecution();
        }
        return null;
      }
    });
  }

  private final String PROVIDER = "policy.provider";
  protected abstract boolean canDo(String valueProperty);
  private abstract void executionWithCondition();
  private abstract void usualExecution();
}]]></example>
    <repair><![CDATA[public abstract class SecurityGetProperty { //OK

  public SecurityGetProperty() {
  }

  public void readResource() {
    AccessController.doPrivileged(new PrivilegedAction() {
      public Object run() {
        usualExecution();
        return null;
      }
    });
  }

  private abstract void usualExecution();
}]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidPermissionInstance" message="AvoidPermissionInstance: Avoid creating an instance of java.security.Permission" class="com.als.clases.rational.NamesAllowedRule" technology="JAVA" active="true">
    <description><![CDATA[Minimise the privileges of the application by writing the program so that it uses the existing security mechanism and does not need to instantiate permissions.]]></description>
    <priority>3</priority>
    <effort>5</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improved efficiency and performance.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[      public abstract class UserHomeAction {
        public void execute() {
          try {
            AccessController.checkPermission(new java.util.PropertyPermission("user.home", "read"));
            executeActionGranted();
          } catch (Exception e) {
            executeDefaultAction();
          }
        }

        protected abstract void executeDefaultAction();
        protected abstract void executeActionGranted();
      }]]></example>
    <repair><![CDATA[      Do not create permissions.

      public abstract class UserHomeAction {
        public void execute() {
          executeAction();
        }
        protected abstract void executeAction();
      }]]></repair>
    <reference><![CDATA[]]></reference>
    <properties>
      <property name="NOT_ALLOWED_INPUT_TYPE" descname="NOT_ALLOWED_INPUT_TYPE" value="CLASSES"/>
      <property name="NOT_ALLOWED" descname="NOT_ALLOWED" value="java.util.PropertyPermission,java.security.Permission"/>
      <property name="SEARCH_SCOPE" descname="SEARCH_SCOPE" value="NEW_ONLY"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidSecurityManager" message="AvoidSecurityManager: Avoid using java.lang.SecurityManager" class="com.als.clases.rational.AvoidSecurityManager" technology="JAVA" active="true">
    <description><![CDATA[The security manager is part of the API standard J2EE Container. It is required that the code should follow the standard and avoid the direct use of security manager. Minimise changes in the standard behaviour of the system. Instead, change the policy file.]]></description>
    <priority>2</priority>
    <effort>5</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Increase the security and reliability of the application.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[public abstract class ChangeProperties {

  public ChangeProperties() {
    manager = System.getSecurityManager(); //VIOLATION
  }

  public void execute() {
    if (manager != null) { //VIOLATION
      manager.checkPropertiesAccess(); //VIOLATION
      changeProperties();
    }
    else {
      throw new UnsupportedOperationException();
    }
  }

  protected abstract void changeProperties();

  private SecurityManager manager = null; //VIOLATION
}]]></example>
    <repair><![CDATA[public abstract class ChangeProperties {

  public ChangeProperties() {
  }

  public void execute() {
    changeProperties();
  }

  protected abstract void changeProperties();
}]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidSetProperty" message="AvoidSetProperty: Avoid calling java.security.Security.setProperty()" class="com.als.clases.rational.AvoidSetProperty" technology="JAVA" active="true">
    <description><![CDATA[Minimise the dynamic modification of application security.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improvements in security and reliability of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[public abstract class SecurityPropertySetter {
  public SecurityPropertySetter(String val) {
    this.val = val;
  }

  private String val;

  public void activeProperty() {
    Security.setProperty("policy.provider", val); //VIOLATION
  }

}

public abstract class Execution {

  public abstract void execute();

  public static final void executeWithProperty(
      SecurityPropertySetter property, Execution exec) {
    property.activeProperty();
    exec.execute();
  }
}]]></example>
    <repair><![CDATA[// Remove calls to Security.setProperty()
public abstract class Execution {
  public abstract void execute();

  public static void executeObject(Execution exec) {
    exec.execute();
  }
}]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2EE.AvoidSetSecurityManager" message="AvoidSetSecurityManager: Avoid calling java.lang.System.setSecurityManager()" class="com.als.clases.rational.AvoidSetSecurityManager" technology="JAVA" active="true">
    <description><![CDATA[System.setSecurityManager() installs the system SecurityManager to be used by the JVM when checking permissions
on resources controlled by security policy. System.setSecurityManager() call could be the footprint for a backdoor
The initial policy must allow setting the security manager:
permission java.lang.RuntimePermission "setSecurityManager"

The security manager is set in certain contexts (like J2EE Containers). Minimize changes to the standard behaviour of the system.
Instead change the existing policy with the SecurityManager.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Increase the security and reliability of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[// VIOLATION, removes installed SecurityManager
// Needs "setSecurityManager" permission on security policy
System.setSecurityManager(null);
// ... out of sandbox ...]]></example>
    <repair><![CDATA[If your environment need a security policy above "permission java.security.AllPermission",
remove System.setSecurityManager() calls and do not activate "setSecurityManager" permission in the policy.]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2SE.AvoidProtectedNativeMethods" message="AvoidProtectedNativeMethods: Avoid protected native methods" class="com.als.clases.rational.AvoidProtectedNativeMethodsRule" technology="JAVA" active="true">
    <description><![CDATA[The native methods are outside Java security system. Neither security manager nor any other mechanism is designed to control the behavior of native code. Native code can cause serious problems to the system since they are not being controlled by anybody. Examine the input and output parameters of native methods and make sure you apply the correct visibility to it.]]></description>
    <priority>1</priority>
    <effort>4</effort>
    <vulntype>Other</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[It increases the security and the reliability of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[      public class NativeClass {

        public NativeClass() {
        }

        protected native int getQuantity();

        protected native Object getExternalValue(int index); // VIOLATION

        public List getResult() {
          List list = new ArrayList(5);
          for (int index = 0; index < getQuantity(); index++) {
            list.add(getExternalValue(index));
          }
          return list;
        }
      }]]></example>
    <repair><![CDATA[      public class NativeClass {

        public NativeClass() {
        }

        private native int getQuantity();

        private native Object getExternalValue(int index); //OK

        public List getResult() {
          List list = new ArrayList(5);
          for (int index = 0; index < getQuantity(); index++) {
            list.add(getExternalValue(index));
          }
          return list;
        }
      }]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.J2SE.AvoidPublicNativeMethods" message="AvoidPublicNativeMethods: Avoid public native methods" class="com.als.clases.rational.AvoidPublicNativeMethodsRule" technology="JAVA" active="true">
    <description><![CDATA[The native methods are outside Java security system. Neither security manager nor any other mechanism is designed to control the behavior of native code. Native code can cause serious problems to the system since they are not being controlled by anybody. Examine the input and output parameters of native methods and make sure you apply the correct visibility to it.]]></description>
    <priority>1</priority>
    <effort>4</effort>
    <vulntype>Other</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[It increases the reliability of the code.]]></benefits>
    <inconvenients><![CDATA[None.]]></inconvenients>
    <example><![CDATA[      public class NativeClass {
        public NativeClass() {
        }
        public native int getQuantity();
        public native Object getExternalValue(int index);
        public List getResult() {
          List list = new ArrayList(5);
          for (int index = 0; index < getQuantity();index++){
            list.add(getExternalValue(index));
          }
          return list;
        }
      }]]></example>
    <repair><![CDATA[      public class NativeClass {
        public NativeClass() {
        }
        private native int getQuantity();
        private native Object getExternalValue(int index);
        public List getResult() {
          List list = new ArrayList(5);
          for (int index = 0; index < getQuantity();index++){
            list.add(getExternalValue(index));
          }
          return list;
        }
      }]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.JAX.AvoidExposingAllEndpointlPublicMethods" message="AvoidExposingAllEndpointlPublicMethods: Specify an endpoint interface to avoid exposing all the public methods" class="com.optimyth.qaking.jax.rules.AvoidExposingAllEndpointlPublicMethods" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality,Framework:JAX,Framework:JAX-WS]]></tags>
    <description><![CDATA[A JAX-WS can be developed following a bottom-up or a top-down approach.

Following the bottom-up strategy, the endpoint implementation classes must be annotated either with @WebService
(javax.jws.WebService), to define the service as a SEI-based endpoint, or with @WebServiceProvider
(javax.xml.ws.Provider), to define it as a provider-based endpoint.

A SEI-based endpoint define a service endpoint interface, either explicitly by specifying the endpointInterface
attribute into the @WebService, or implicitly by exposing the implementation class as an interface.

Possibly when exposing the implementation class, some methods would need to be restricted from the fact of being
exposed, and this can be performed by annotating these methods with @WebMethod(exclude=true).

Not using an endpoint interface or the @WebMethod annotation can cause to incorrectly exposing all the public
endpoint implementation class methods, which probably is an undesired effect.

This situation can lead to a security flaw, allowing an user to perform unwanted actions or to obtain private data.

This rule reports the endpoint class implementations not having defined neither an endpoint interface nor @WebMethod
annotations, that make clear that just the intended public methods are exposed.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid accessing to unwanted data or operations, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[package helloservice.endpoint;

import javax.jws.WebService;

// VIOLATION: When no explicit SEI interface,
// all normal public methods are exposed as web service operations
@WebService
public class MyWebService {
    private String message = "Hello, ";

    public String sayHello(String name) {
        return message + name + ".";
    }

    // this is probably unintentionally exposed
    public String forTestingShouldNotBeExposed() { /* ... */ }
}]]></example>
    <repair><![CDATA[package helloservice.endpoint;

import javax.jws.WebService;
import javax.jws.WebMethod;

// FIXED, using a SEI explicit interface
@WebService(endpointInterface = "helloservice.endpoint.MyWebServiceInterface")
public class MyWebService implements MyWebServiceInterface {
    private String message = "Hello, ";

    public String sayHello(String name) {
        return message + name + ".";
    }

    // do not include this in MyWebServiceInterface
    public String forTestingShouldNotBeExposed() { /* ... */ }
}

// Alternative fix, using @WebService(exclude = true)
@WebService
public class MyWebService {
    private String message = "Hello, ";

    public String sayHello(String name) {
        return message + name + ".";
    }

    @WebService(exclude = true)
    public String forTestingShouldNotBeExposed() { /* ... */ }
}]]></repair>
    <reference><![CDATA[https://axis.apache.org/axis2/java/core/docs/jaxws-guide.html#JAXWSIntro,https://cwe.mitre.org/data/definitions/200.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:200,CWETOP25:2021:20,OWASP:2021:A5,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.JAX.CheckHTTPMethods" message="CheckHTTPMethods: Check the HTTP method used to send the request" class="com.optimyth.qaking.jax.rules.CheckHTTPMethods" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality,Framework:JAX,Framework:JAX-WS]]></tags>
    <description><![CDATA[Usually SOAP services use HTTP Post method because the XML structure is too complex to be
especified into an HTTP GET query. However, it is possible to use it when complex types are not being used.

When an endpoint receives a request, the invoke() method is executed, regardless of the HTTP method used, so if no
action is taken, the same code is executed for all the HTTP methods.

It is a good practice to differentiate between the HTTP methods, so different actions can be performed. Also, if this
filtering is not performed, maybe a malicious attacker can send a unexpected petition to be processed by the server,
allowing him to access private sensible data.

This rule reports violation when the HTTP method is not checked into the endpoint invoke() method. This rule only
applies for the endpoints annotated with @WebServiceProvider.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unwanted accesses to private sensible data, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[package helloservice.endpoint;

import javax.jws.WebServiceProvider;
import javax.jws.WebMethod;

@WebServiceProvider
public class Hello3 {        // Violation
    public Source invoke(Source source)  {

    throw new HTTPException(500);
  }
}]]></example>
    <repair><![CDATA[package helloservice.endpoint;

import javax.jws.WebServiceProvider;
import javax.jws.WebMethod;

import javax.xml.ws.handler.MessageContext;

@WebServiceProvider
public class Hello {		// Ok
    public Source invoke(Source source)  {
    try {
        MessageContext messageContext = wsContext.getMessageContext();
        String httpMethod = (String)messageContext.get(MessageContext.HTTP_REQUEST_METHOD);
        // place here the proper logic to handle each of the possible HTTP methods
         if ("POST".equalsIgnoreCase(httpMethod)) {
           // ...
        }
        if ("GET".equalsIgnoreCase(httpMethod)) {
           // ...
        }

    } catch(Exception e) {
        e.printStackTrace();
    }
    throw new HTTPException(500);
  }
}]]></repair>
    <reference><![CDATA[http://www.oracle.com/technetwork/articles/take-a-rest-085683.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:200,CWETOP25:2021:20,OWASP:2021:A5,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.JAX.SecureResourcesProperly" message="SecureResourcesProperly: Use annotations to secure resources properly" class="com.optimyth.qaking.jax.rules.SecureResourcesProperly" technology="JAVA" active="true">
    <tags><![CDATA[Framework:JAX,Framework:JAX-RS]]></tags>
    <description><![CDATA[JAX-RS allows to create REST web services by using annotations, so the endpoint
development and deployment is simplified.

JAX offers annotations to secure the JAX-RS resources, so they can be only be accessed by the explicitly allowed roles.
This is a good programming practice, as it avoids unauthorized users from accessing private and sensible data.

The supported security annotations are:
  - @PermitAll.
  - @DenyAll.
  - @RolesAllowed, used along with a comma separated list of the allowed rules.

Keep in mind that annotations at class level don't have any effect on subclasses, while annotations at method level do.

This rule reports violation when a method doesn't have security annotations (at class level, at super class level, or at
method level).]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Having a role policy improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[package com.jax.project;

import javax.ws.rs.GET;
import com.jax.project.MyResource;

@Path("/myResource")
public class SomeResource extends MyResource{       // Violation

   	@POST
    @Path("/persona/add")
 	public String get1(String referer) {      // Never annotated

		// do something
 	}
}]]></example>
    <repair><![CDATA[package com.jax.project;

import javax.ws.rs.GET;
import com.jax.project.MyResource;

@Path("/myResource")
public class SomeResource extends MyResource{       // Ok

    @GET
    @Produces("text/html")
    @DenyAll
    public String get4(String referer) {     // Annotated

        // do something
    }
}]]></repair>
    <reference><![CDATA[http://blog.dejavu.sk/2014/02/04/filtering-jax-rs-entities-with-standard-security-annotations]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.JAX.UseHTTPMethodAnnotation" message="UseHTTPMethodAnnotation: Use a proper annotation to indicate the HTTP request methods accepted" class="com.optimyth.qaking.jax.rules.UseHTTPMethodAnnotation" technology="JAVA" active="true">
    <tags><![CDATA[Framework:JAX,Framework:JAX-RS]]></tags>
    <description><![CDATA[JAX-RS allows to create REST web services by using annotations, so the endpoint
development and deployment is simplified.

It is possible to annotate methods to indicate the accepted HTTP request methods. This way a method will only send a
respond if the request HTTP method matches the annotation, avoiding that a method process a request using a unexpected
HTTP method.

The available annotations are:
 - @GET
 - @POST
 - @PUT
 - @DELETE

This improves reliability and security, as the program flow will kept private and sensible data safe from unexpected and
unwanted accesses.

This rule reports violation when a method is not annotated to indicate the expected HTTP method.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Performing a filtering of the HTTP methods expected from the request, improves reliability and security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[@Path("/myResource")
@Produces("text/plain")
public class SomeResource {

    @Produces("text/html")
    public String get(@HeaderParam("Referer") String referer,       // Violation
    					@DefaultValue("value") @HeaderParam("Referer") String referer) {

    	// do something
    }
}]]></example>
    <repair><![CDATA[@Path("/myResource")
@Produces("text/plain")
public class SomeResource {

    @Path("smooth")
	@GET        // Ok
	public Response processRequest (
    @DefaultValue("2") @QueryParam("step") int step) {
    	// do something
	}

	@PUT        // Ok
	@Path("{id}")
	public Response getUserById(@PathParam("id") String id,
								 @DefaultValue("myID") @PathParam("id") String id) {

	   return Response.status(200).entity("getUserById is called, id : " + id).build();
	}
}]]></repair>
    <reference><![CDATA[http://www.techferry.com/articles/RESTful-web-services-JAX-RS-annotations.html]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.RGS.CLONE" message="CLONE: Make your clone() method final for security" class="com.als.clases.segur.rgs.Clone" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Integrity,object-hijack]]></tags>
    <description><![CDATA[All classes implementing the Cloneable interface must have a final clone() method.

A class with a clone() method that is not declared final allows an object to be created without calling the constructor.
This can cause the object to be in an unexpected state.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[     public class CLONE implements Cloneable {
       public Object clone () throws CloneNotSupportedException { // VIOLATION
         CLONE cl = (CLONE) super.clone ();
         cl._field = _field; return cl;
          }
        private int _field = 0;
     }]]></example>
    <repair><![CDATA[      Declare as final either the entire class or just the clone () method.

       public class CLONEFIXED implements Cloneable {
         public final Object clone () throws CloneNotSupportedException { // OK
           CLONEFIXED cl = (CLONEFIXED) super.clone ();
           cl._field = _field; return cl;
            }
         private int _field = 0;

       }]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/OBJ07-J.+Sensitive+classes+must+not+let+themselves+be+copied,http://cwe.mitre.org/data/definitions/491.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:OBJ07-J,CWE:491]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.RGS.CMP" message="CMP: Do not compare class objects with getName() or getSimpleName() methods" class="com.als.clases.segur.rgs.Cmp" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Do not compare class objects using the getName() or getSimpleName() method.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[It's possible that more than one class into the JVM have the same name, so using the class name
to compare classes it's not reliable at all.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class CMP {
  public boolean sameClass (Object o) {
    Class thisClass = this.getClass();
    Class otherClass = o.getClass();
    return (thisClass.getName() == otherClass.getName()); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[Compare Class objects directly to equality.
 public class CMPFIXED {
  public boolean sameClass (Object o) { Class thisClass = this.getClass();
    class otherClass = o.getClass();
    return (thisClass == otherClass); // OK
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/OBJ09-J.+Compare+classes+and+not+class+names,https://cwe.mitre.org/data/definitions/486.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:OBJ09-J,CWE:486]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.RGS.NUA" message="NUA: Do not use applets in an application client layer" class="com.als.clases.segur.rgs.Nua" technology="JAVA" active="true">
    <description><![CDATA[Do not use applets in an application client layer.]]></description>
    <priority>2</priority>
    <effort>5</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[       import java.awt.*;
       import java.applet.*;

       public class MyApplet extends Applet //VIOLATION
       {
           static private MyConsole c;
           // The init() method for the applet.
           public void init()
           {
             super.init();
             setLayout(null);
             resize(6,6);

             c = new MyConsole (getParameter(string));
             c.show();
           }
           public boolean handleEvent(Event event)
           {
              return super.handleEvent(event);
           }
      }]]></example>
    <repair><![CDATA[Do not use applets in the client layer of your application.]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.RGS.SER2" message="SER2: Do not use interfaces that extends the java.io.Serializable interface" class="com.als.clases.segur.rgs.Ser2" technology="JAVA" active="true">
    <description><![CDATA[Do not use interfaces that extends the java.io.Serializable interface.]]></description>
    <priority>4</priority>
    <effort>5</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[      public interface SER2 extends java.io.Serializable { // VIOLATION

        public void method();
        static final int MAX = 10;
      }]]></example>
    <repair><![CDATA[      public interface SER2FIXED { // FIXED

        public void method();
        static final int MAX = 10;
      }]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AccessibilitySubversionRule" message="AccessibilitySubversionRule: Java access restriction subverted (Reflection)" class="com.optimyth.qaking.security.rules.java.AccessibilitySubversionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.10.1,ASVS-v4.0.2:1.4.2,ASVS-v4.0.2:1.4.4,essential]]></tags>
    <description><![CDATA[Java imposes access restrictions for code in one class to access fields, methods and constructors in objects of
different classes (the access level specifiers with public, protected and private keywords enforce in code such restrictions).

Using reflection, Java allows a programmer to get around the access control checks provided by these specifiers.
For example, a programmer may use setAccessible(true) on a reflected field, method or constructor and bypass
the access limitations (if the SecurityManager allows it), so a private field could be read or changed, and
a private method or constructor could be called, from any class.

The rule emits a security flaw when setAccessible(true) is used on any java.lang.reflect.AccessibleObject subtype,
like Field, Method or Constructor.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended accesses to elements that should be protected.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[Field fields[] = SomeClass.class.getDeclaredFields();
for (Field field : fields) {
  if ( !Modifier.isPublic(field.getModifiers())) {
    field.setAccessible(true); /* VIOLATION */
  }
  System.out.print("Field: " + field.getName());
  System.out.println(", value: " + field.get(someObject));
}]]></example>
    <repair><![CDATA[Do not use reflection to increase accessibility of methods, constructors or fields.
Avoid any abuse of setAccessible(). For example, have you been told that Java Strings
are immutable?

import java.lang.reflect.*;

public class MutableStrings {
   static void mutate(String s) throws Exception {
      // value is private in java.lang.String, but who cares?
      Field value = String.class.getDeclaredField("value");
      value.setAccessible(true);
      value.set(s, s.toUpperCase().toCharArray());
   }
   public static void main(String args[]) throws Exception {
      final String s = "Hello world!";
      System.out.println(s); // "Hello world!"
      mutate(s);
      System.out.println(s); // "HELLO WORLD!"
   }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/SEC05-J.+Do+not+use+reflection+to+increase+accessibility+of+classes%2C+methods%2C+or+fields,http://cwe.mitre.org/data/definitions/284.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SEC05-J,CWE:284,CWETOP25:2020:30,OWASP:2021:A1,PCI-DSS:6.5.8,WASC:02]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AcegiInsecureChannelMixingRule" message="AcegiInsecureChannelMixingRule: Acegi Misconfiguration - Insecure Channel Mixing" class="com.optimyth.qaking.security.rules.java.AcegiInsecureChannelMixingRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Allowing transport protocol to switch between HTTP and HTTPS makes application vulnerable to session hijacking.

Many applications use cookies to communicate a user's session identifier. When the application is accessed over HTTPS,
cookies are protected (attackers are unable to sniff them). But if developers allow HTTP access to non-sensitive parts
of the application, the session identifier can be stolen.

When a user browses to an unprotected part of the site, the cookie containing the session ID is sent without encryption.
If attackers sniff the traffic, they can see the session ID and could take control of the user's session.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<bean class="org.acegisecurity.intercept.web.FilterSecurityInterceptor">
  <property name="filterInvocationDefinitionSource">
    <value>
      CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
      \A/secure/.*\Z=REQUIRES_SECURE_CHANNEL
      \A/acegilogin.jsp.*\Z=REQUIRES_SECURE_CHANNEL
      \A/j_acegi_security_check.*\Z=REQUIRES_SECURE_CHANNEL
      \A.*\Z=REQUIRES_INSECURE_CHANNEL
    </value>
  </property>
<bean>]]></example>
    <repair><![CDATA[<bean class="org.acegisecurity.intercept.web.FilterSecurityInterceptor">
  <property name="filterInvocationDefinitionSource">
    <value>
      CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
      \A.*\Z=REQUIRES_SECURE_CHANNEL
    </value>
  </property>
<bean>]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/5.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:5,OWASP:2021:A2,PCI-DSS:6.5.10,PCI-DSS:6.5.8,WASC:04]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AcegiRunAsAuthenticationReplacementRule" message="AcegiRunAsAuthenticationReplacementRule: Acegi Misconfiguration - Run-As Authentication Replacement" class="com.optimyth.qaking.security.rules.java.AcegiRunAsAuthenticationReplacementRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.1,ASVS-v4.0.2:2.3.3,ASVS-v4.0.2:2.7.1,ASVS-v4.0.2:2.7.2,ASVS-v4.0.2:2.7.3,ASVS-v4.0.2:2.8.4,ASVS-v4.0.2:2.8.5,ASVS-v4.0.2:9.2.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Using the Run-As authentication replacement feature in Acegi can lead to a privilege escalation vulnerability.

Acegi Security allows for temporarily replacing the Authentication object in the SecurityContext during the secure object callback phase.
This only occurs if the original Authentication object was successfully processed by the AuthenticationManager and AccessDecisionManager.
The RunAsManager creates this Authentication object. Typically developers use RunAsManager to configure one or more additional roles
for an authenticated user for the duration of a method invocation. This is useful for a secure bean that needs to access a remote application.
Since the remote application might demand different credentials, this allows translating between calling roles and those needed
by the remote application so that the remote access can succeed.

The new Authentication object (called RunAsUserToken) will be simply accepted as a valid Authentication object without
any further authentication or authorization check. Adding new roles or privileges to the new Authentication object
has the potential to temporarily elevate the user's privileges, allowing the user to take an unauthorized action.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!--
The following configuration shows using RunAsManager to add the role "UBER_BOSS" to a user who has the role "ROLE_PEON",
thus temporarily granting this user manager privileges, which enables him to get data from PrivateCatalog service.
-->
<bean id="bankManagerSecurity" class="org.acegisecurity.intercept.method.aopalliance.MethodSecurityInterceptor">
  ...
  <property name="objectDefinitionSource">
    <value>
      com.example.service.PrivateCatalog.getData=ROLE_PEON,RUN_AS_UBER_BOSS
      ...
    </value>
  </property>
</bean>]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/724.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:287,CWETOP25:2021:14,OWASP:2021:A7,PCI-DSS:6.5.10,PCI-DSS:6.5.8,WASC:01]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AnonymousLdapBindRule" message="AnonymousLdapBindRule: Access Control - Anonymous LDAP Bind" class="com.optimyth.qaking.security.rules.java.AnonymousLdapBindRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Without proper access control, executing an LDAP statement that contains a user-controlled value can allow an attacker to access unauthorized records.
Executing LDAP queries under an anonymous bind, effectively without authentication, can allow an attacker to abuse a poorly configured LDAP environment.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    The following code creates the DirContext ctx using an anonymous bind.
      ...
      env.put(Context.SECURITY_AUTHENTICATION, "none");
      DirContext ctx = new InitialDirContext(env);
      ...
    All LDAP queries executed against ctx will be performed without authentication and access control. An attacker might be able to manipulate one of these
    queries in an unexpected way to gain access to records that would otherwise be protected by the directory's access control mechanism.]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/285.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:285,OWASP:2021:A1,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties>
      <property name="ldapContextClasses" descname="ldapContextClasses" value="javax.naming.InitialContext, InitialContext, javax.naming.directory.InitialDirContext,InitialDirContext,javax.naming.ldap.InitialLdapContext,InitialLdapContext"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidEJBAWTSwing" message="AvoidEJBAWTSwing: EJB Bad Practices: Use of AWT Swing" class="com.optimyth.qaking.security.rules.java.AvoidCommonEJBBadPracticesRule" technology="JAVA" active="true">
    <description><![CDATA[An enterprise bean should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security. This rule checks the usage of AWT / Swing (CWE-575).

An enterprise bean must not use the AWT functionality to attempt to output information to a display, or to input
information from a keyboard. Most servers do not allow direct interaction between an application program and a
keyboard/display attached to the server system.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.ejb.Stateless;

import java.awt.Panel;
import java.awt.Button;

@Singleton
@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class BeanClass {

	public void method (){
      Panel panel = new Panel();
      Button btn = new Button("Press");
      panel.add(btn);	  // VIOLATION

	}
}]]></example>
    <repair><![CDATA[Avoid usage of AWT / Swing in EJB.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/575.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:575]]></security>
    </normatives>
    <properties>
      <property name="checkAwtSwing" descname="Check AWT/SWING" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidEJBExplicitServerSocket" message="AvoidEJBExplicitServerSocket: EJB Bad Practices: Use of Sockets" class="com.optimyth.qaking.security.rules.java.AvoidCommonEJBBadPracticesRule" technology="JAVA" active="true">
    <description><![CDATA[An enterprise bean should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security. This rule checks explicit (server) socket usage (CWE-577).

EJB standard permits the use of client-side sockets only for the purpose of communication with legacy systems when no
higher-level API is available. An enterprise bean must not attempt to listen on a socket, accept connections on a
socket, or use a socket for multicast.

The EJB architecture allows an enterprise bean instance to be a network socket client, but it does not allow it to be a
network server.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.ejb.Stateless;

import java.net.ServerSocket;

@Singleton
@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class BeanClass {

// ...
    ServerSocket serverSocket = new ServerSocket(4444);   // VIOLATION

// ...
}]]></example>
    <repair><![CDATA[Avoid explicit (server) socket usage.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/577.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:577]]></security>
    </normatives>
    <properties>
      <property name="checkServerSocket" descname="Check ServerSocket" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidEJBExplicitThreadManagement" message="AvoidEJBExplicitThreadManagement: Avoid explicit thread management in EJB" class="com.optimyth.qaking.security.rules.java.AvoidCommonEJBBadPracticesRule" technology="JAVA" active="true">
    <description><![CDATA[An enterprise bean should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security. This rule checks that there is not explicit thread management (CWE-383).

Thread management in a web application is forbidden by the J2EE standard in some circumstances, is error prone. Managing
threads is difficult and is likely to interfere in unpredictable ways with the behaviour of the application server.

Thread management leads to bugs that are hard to detect and diagnose like deadlock, race conditions, and other
synchronization errors that could be exploited to produce illegal access to information or denial of service conditions.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.ejb.Stateless;

@Singleton
@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class BeanClass {

  public void method (){
        new Thread(new Runnable() {   // VIOLATION CWE-383
          public void run(){}
        }).start();
  }
}]]></example>
    <repair><![CDATA[Avoid explicit thread management in EJB.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/383.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:383]]></security>
    </normatives>
    <properties>
      <property name="checkThread" descname="Check Thread" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidEJBJavaIo" message="AvoidEJBJavaIo: EJB Bad Practices: Use of Java I/O" class="com.optimyth.qaking.security.rules.java.AvoidCommonEJBBadPracticesRule" technology="JAVA" active="true">
    <description><![CDATA[An enterprise bean should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security. This rule checks if there is any use of java.io (CWE-576).

An enterprise bean must not use the java.io package to attempt to access files and directories in the file system. The
file system APIs are not well-suited for business components to access data. Business components should use a resource
manager API, such as JDBC, to store data.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.ejb.Stateless;

import java.io.PrintStream;
import java.io.File;

@Singleton
@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class PropertyRegistry {

    public void method() {

      PrintStream ps = new PrintStream("FileName");
      System.setErr(ps);    // VIOLATION
      System.setOut(ps);    // VIOLATION

    }
}]]></example>
    <repair><![CDATA[Avoid usage of java.io in EJB.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/576.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:576]]></security>
    </normatives>
    <properties>
      <property name="checkJavaIo" descname="Check java.io API use" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidEJBJVMShutdown" message="AvoidEJBJVMShutdown: J2EE Bad Practices: Use of System.exit()" class="com.optimyth.qaking.security.rules.java.AvoidCommonEJBBadPracticesRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability]]></tags>
    <description><![CDATA[An enterprise bean should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security. This rule checks that there is not JVM shutdown code (CWE-382)

It is never a good idea for a web application to attempt to shut down the application container.

A call to System.exit() is probably part of leftover debug code or code imported from a non-J2EE application.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Initialization and shutdown</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.ejb.Stateless;

@Singleton
@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class PropertyRegistry {
    public void method() {

      System.exit(1);   // VIOLATION
      Runtime.getRuntime().halt(1);   // VIOLATION
      Runtime.getRuntime().exit(1);   // VIOLATION
      Runtime.exit(1);   // VIOLATION
    }
}]]></example>
    <repair><![CDATA[Avoid JVM shutdown code in EJB.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/382.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:ERR09-J,CWE:382]]></security>
    </normatives>
    <properties>
      <property name="checkJvmExit" descname="Check JVM Exit" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidEJBRedirectStreams" message="AvoidEJBRedirectStreams: Avoid changing the input, output, and error streams in EJB" class="com.optimyth.qaking.security.rules.java.AvoidCommonEJBBadPracticesRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[An enterprise bean should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security.

This rule checks if there is any change of the input, output, and error streams (System.setErr|setIn|setOut).]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.ejb.Stateless;

import java.io.PrintStream;

@Singleton
@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class BeanClass {

	public void method() {

      PrintStream ps = new PrintStream("FileName");
      System.setErr(ps);    // VIOLACIN
	}
}]]></example>
    <repair><![CDATA[Avoid changing the input, output, and error streams in EJB.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/578.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:578]]></security>
    </normatives>
    <properties>
      <property name="checkRedirectStreams" descname="Check streams redirection" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidEJBSetClassLoader" message="AvoidEJBSetClassLoader: Avoid setting context ClassLoader in EJB" class="com.optimyth.qaking.security.rules.java.AvoidCommonEJBBadPracticesRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[An enterprise bean should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security.

This rule checks use of ClassLoader (CWE-578).

The enterprise bean must not attempt to set the context class loader.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.ejb.Stateless;

@Singleton
@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class BeanClass {

   Thread t;

	public void method (){
    t.setContextClassLoader(c);   // VIOLATION
	}
}]]></example>
    <repair><![CDATA[Avoid setting context ClassLoader in EJB.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/578.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:578]]></security>
    </normatives>
    <properties>
      <property name="checkSetClassLoader" descname="Check 'setContextClassLoader'" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidEJBSetSecurityManager" message="AvoidEJBSetSecurityManager: Avoid setting system SecurityManager in EJB" class="com.optimyth.qaking.security.rules.java.AvoidCommonEJBBadPracticesRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[An enterprise bean should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security.

This rule checks that system's SecurityManager is not set.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.ejb.Stateless;

@Singleton
@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class BeanClass {

	public void method (){
      SecurityManager ss = new SecurityManager();
      System.setSecurityManager(ss);    // VIOLATION
	}
}]]></example>
    <repair><![CDATA[Avoid setting system SecurityManager in EJB.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/578.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:578]]></security>
    </normatives>
    <properties>
      <property name="checkSecurityManager" descname="Check 'setSecurityManager'" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidEJBSynchronizationPrimitives" message="AvoidEJBSynchronizationPrimitives: Avoid use of synchronization primitives in EJB" class="com.optimyth.qaking.security.rules.java.AvoidCommonEJBBadPracticesRule" technology="JAVA" active="true">
    <description><![CDATA[An enterprise bean should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security. This rule checks that there is not use of synchronization primitives
(CWE-574).

An enterprise bean must not use thread synchronization primitives to synchronize execution of multiple instances. Thread
synchronization is provided by the container. Only the EJB 3.1 @Singleton beans are allowed to use synchronization
primitives.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.ejb.ConcurrencyManagement;
import javax.ejb.Startup;
import javax.ejb.Stateless;

import java.io.PrintStream;
import java.io.File;
// ...

import static javax.ejb.ConcurrencyManagementType.BEAN;

@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class BeanClass {

// ...
    public synchronized void setValue(String value) {   // VIOLATION
        // ...
    }
// ...
}]]></example>
    <repair><![CDATA[Avoid use of synchronization primitives in EJB.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/574.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:574]]></security>
    </normatives>
    <properties>
      <property name="checkSynchronization" descname="Check synchronization" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidHostNameChecksRule" message="AvoidHostNameChecksRule: Avoid checks on client-side hostname, that are not reliable due to DNS poisoning" class="com.optimyth.qaking.security.rules.java.AvoidHostNameChecksRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.3.3,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Many DNS servers are susceptible to DNS poisoning attacks, so you should assume that your software will someday run
    in an environment with a compromised DNS server. If attackers are allowed to make DNS updates (sometimes called DNS
    cache poisoning), they can route your network traffic through their machines or make it appear
    as if their IP addresses are part of your domain. Do not base the security of your system on DNS names.

    The rule detects the following code signature:
    String ip = request.getRemoteAddr();
    InetAddress inet = InetAddress.getByName(ip);
    if(isTrustedClient(inet.getHostName())) {
      ... sensitive operation ...
    }

    Note: If client hostname check is the unique possibility, perform proper forward and reverse DNS lookups to detect DNS spoofing.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    
    String ip = request.getRemoteAddr();
    InetAddress inet = InetAddress.getByName(ip);
    if(isTrustedClient(inet.getHostName())) {
      ... sensitive operation ...
    }]]></example>
    <repair><![CDATA[Do not use client hostname for any access control decision.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/350.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:350,OWASP:2021:A4,PCI-DSS:6.5.8,WASC:24]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidJ2EEDirectDatabaseConnection" message="AvoidJ2EEDirectDatabaseConnection: J2EE Bad Practices: Direct Management of Connections" class="com.optimyth.qaking.security.rules.java.AvoidCommonJ2EEBadPracticesRule" technology="JAVA" active="true">
    <description><![CDATA[A J2EE application should avoid bad practices discouraged by the J2EE blueprints, that could introduce weaknesses compromising security. This rule checks if exists any direct database connection without getting DataSource (CWE-245).

    The J2EE standard requires that applications use the container's
    resource management facilities to obtain connections to resources (typically a javax.sql.DataSource fetched via JNDI).
    Rule looks for non recommended ways of getting a connection, e.g. using JDBC DriverManager.getConnection().]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    public class AvoidJ2EEDirectDatabaseConnection {

      public void m(HttpServletRequest req) throws Exception {

        Connection con = DriverManager.getConnection(JDBC_URL); // CWE-245

      }

    }]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/245.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:245]]></security>
    </normatives>
    <properties>
      <property name="checkDriverManager" descname="Check DriverManager" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidJ2EEExplicitSocket" message="AvoidJ2EEExplicitSocket: J2EE Bad Practices: Direct Use of Sockets" class="com.optimyth.qaking.security.rules.java.AvoidCommonJ2EEBadPracticesRule" technology="JAVA" active="true">
    <description><![CDATA[A J2EE application should avoid bad practices discouraged by the J2EE blueprints, that
could introduce weaknesses compromising security. This rule checks that there is not explicit socket usage (CWE-246).

The J2EE standard permits the use of sockets only for the purpose of communication with legacy systems when no
higher-level protocol is available. Authoring your own communication protocol requires wrestling with difficult security
issues (in-band versus out-of-band signaling, channel security, error handling, network constraints like firewalls,
authentication and session management).

Without significant scrutiny by a security expert, it is better to avoid socket communications.

 The rule looks for operations on java.net.Socket, java.net.ServerSocket and java.net.DatagramSocket.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Following the well known good practices for a J2EE application improves Security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.ejb.Stateless;
import java.io.InputStream;
import java.net.ServerSocket;

@Stateless
@Startup
@ConcurrencyManagement(BEAN)
public class PropertyRegistry {

    public void method() {

      ServerSocket s = new ServerSocket("host", 23);    // VIOLATION (checkServerSocket=true) CWE-246
      InputStream is = s.getInputStream();    // VIOLATION (checkServerSocket=true)
    }
}]]></example>
    <repair><![CDATA[Avoid explicit socket usage in J2EE applications.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/246.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:246]]></security>
    </normatives>
    <properties>
      <property name="checkServerSocket" descname="Check server Socket" value="true"/>
      <property name="checkClientSocket" descname="Check client Socket" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidJ2EEExplicitThreadManagement" message="AvoidJ2EEExplicitThreadManagement: J2EE Bad Practices: Direct Use of Threads" class="com.optimyth.qaking.security.rules.java.AvoidCommonJ2EEBadPracticesRule" technology="JAVA" active="true">
    <description><![CDATA[A J2EE application should avoid bad practices discouraged by the J2EE blueprints, that could introduce weaknesses compromising security. This rule checks that thre is not explicit thread management (CWE-383).

    Thread management in a web application is forbidden by the J2EE standard in some circumstances,
    is error prone. Managing threads is difficult and is likely to interfere in unpredictable ways with the behavior of the application server.
    Thread management leads to bugs that are hard to detect and diagnose like deadlock, race conditions, and other synchronization errors
    that could be exploited to produce illegal access to information or denial of service conditions.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    public class AvoidJ2EEExplicitThreadManagement {

      public void m(HttpServletRequest req) throws Exception {

        new Thread(new Runnable() { // CWE-383
          public void run(){}
        }).start();

      }

    }]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/383.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:383]]></security>
    </normatives>
    <properties>
      <property name="checkThread" descname="Check Thread" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidJ2EEJvmExit" message="AvoidJ2EEJvmExit: Avoid JVM shutdown code in J2EE applications" class="com.optimyth.qaking.security.rules.java.AvoidCommonJ2EEBadPracticesRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability]]></tags>
    <description><![CDATA[A J2EE application should avoid bad practices discouraged by the J2EE blueprints, that could introduce weaknesses compromising security. This rule checks if exists JVM shutdown code (CWE-382).

    It is never a good idea for a web application to attempt to shut down the application container.
    A call to System.exit() is probably part of leftover debug code or code imported from a non-J2EE application.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    public class AvoidJ2EEJvmExit {

      public void m(HttpServletRequest req) throws Exception {
        System.exit(1); // CWE-382
        Runtime.getRuntime().halt(1); // CWE-382
        Runtime.getRuntime().exit(1); // CWE-382

      }

    }]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/382.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:382]]></security>
    </normatives>
    <properties>
      <property name="checkJvmExit" descname="Check JVM Exit" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidJ2EELeftoverDebugCode" message="AvoidJ2EELeftoverDebugCode: Leftover Debug Code in J2EE applications" class="com.optimyth.qaking.security.rules.java.AvoidCommonJ2EEBadPracticesRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[A J2EE application should avoid bad practices discouraged by the J2EE blueprints, that could introduce weaknesses compromising security. This rule checks if exists leftover debug code (CWE-489).

    A common development practice is to add "back door" code specifically designed
    for debugging or testing purposes that is not intended to be shipped or deployed with the application.
    When this sort of debug code is accidentally left in the application, the application is open to unintended modes of interaction.
    These back door entry points create security risks because they are not considered during design or testing and
    fall outside of the expected operating conditions of the application. Rule looks for static main(String[]) method,
    typically used for testing purposes.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Error handling and fault isolation</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class AvoidJ2EELeftoverDebugCode {

      // Interpreted as leftover debug code, CWE-489
      public static void main(String[] args) {
         ...
      }
    }]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/ENV06-J.+Production+code+must+not+contain+debugging+entry+points,https://cwe.mitre.org/data/definitions/489.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:ENV06-J,CWE:489]]></security>
    </normatives>
    <properties>
      <property name="checkLeftoverDebugCode" descname="Check leftover debug code" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.AvoidNativeCallsRule" message="AvoidNativeCallsRule: Avoid calls from Java to native (JNI) code" class="com.optimyth.qaking.security.rules.java.AvoidNativeCallsRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[When a Java application uses the Java Native Interface (JNI) to call code written in
another programming language, it can expose the application to weaknesses in that code, even if those weaknesses
cannot occur in Java.

Native code is developed in C/C++ or equivalent languages, more susceptible to buffer overflows and other
security issues. This rule checks for native methods, their calls and which native libraries are loaded.

In Java memory management is done to a large extent by the JVM, and no "pointer arithmetic" is available.
The implementation of native methods open the possibility to vulnerabilities not present in Java.

Potential mitigations are: do not use JNI libraries in your software systems (remember that some system-dependent
parts of the Java JDK are implemented using native code, but such code at least has been under review for
long time). Replace, if possible, native libraries with equivalent, non-native, Java libraries. If native
code is absolutely necessary, analyze native code for vulnerabilities and ensure that proper error handling,
input verification and other security techniques are in place.

To exclude certain types, you may list (in the allowed property) the types with native code to be accepted
without alerts.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class AvoidNativeCalls {

  static{
    System.loadLibrary("AvoidNativeCalls");
    Runtime.getRuntime().load("/opt/lib/AvoidNativeCalls_base.so");
  }

  private native void print();
  private void noNativePrint();

  public static void main(String[] args) {
    AvoidNativeCalls avnc = new AvoidNativeCalls();
    avnc.print();   // VIOLATION
    avnc.noNativePrint();
  }
}]]></example>
    <repair><![CDATA[// Remove the native methods, replaced by equivalent non-native code in Java
// If native libraries cannot be removed, ensure they are audited for security issues]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/111.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:111]]></security>
    </normatives>
    <properties>
      <property name="allowedNativeCodeTypes" descname="Comma-separated list of classnames (FQCN) with allowed native code" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CodeInjectionRule" message="CodeInjectionRule: Dynamic code injection in scripting API" class="com.optimyth.qaking.security.rules.java.CodeInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.4,ASVS-v4.0.2:5.5.4,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,code-injection,scripting]]></tags>
    <description><![CDATA[Scripting engines in Java allow execution of source code written in different languages.

When the application uses a scripting engine to execute source code that could be altered by an external, untrusted input,
a potential attacker may force the execution of unintended code (local or even remote code injection). Some scripting
engines allow execution of system commands or call Java, which makes this flaw more dangerous, even allowing arbitrary
system command execution.

Code and data in compiled languages are quite different, but under scripting languages this boundary is much more fuzzy.
External untrusted input should be passed to the script in the form of "parameters" or "binding variables" so any
source code injected by a potential attacker will NOT be considered source code by the scripting engine.

This rule supports the standard scripting API (javax.script) and other frameworks like JEXL, Groovy, Mozilla Rhino,
or Jython.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid local / remote code injection attacks on scripting engines.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import groovy.lang.GroovyShell;
...
String code = req.getParameter("hidden_code"); // not so hide...
... JavaScript interpreter in Java scripting API
ScriptEngine se = new ScriptEngineManager().getEngineByExtension("js");
// JavaScript engine allows Java calls, like java.lang.Runtime.getRuntime().exec("rm -rf /")
Object ret = se.eval(code); // VIOLATION
... with Groovy
Object ret2 = new GroovyShell().evaluate(req.getParameter("hidden_code")); // VIOLATION]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import groovy.lang.GroovyShell;
...
String code = getTrustedCode(); // not affected by untrusted input
String param = req.getParameter("hidden_param"); // not so hide...
...
ScriptEngine se = new ScriptEngineManager().getEngineByExtension("js");
se.put("param", param); // FIXED, variable binding at engine scope
Object ret = se.eval(code);
...
Binding variables = new Binding();
GroovyShell shell = new GroovyShell(variables);
variables.setVariable("param", param); // FIXED, separated data and code
Object ret2 = shell.evaluate(code);

// Additionally, create a "sandbox" for execution scripts:
// create an AccessControlContext with limited privileges and run the script
// using AccessController.doPrivileged(PrivilegedAction, AccessControlContext)

private static class RestrictedAccessControlContext {
  private static final AccessControlContext INSTANCE;

  static {
    INSTANCE = new AccessControlContext(
      new ProtectionDomain[] {
        new ProtectionDomain(null, null) // No permissions
      }
    );
  }
}

ScriptEngine engine = new ScriptEngineManager().getEngineByExtension("js");
try {
  AccessController.doPrivileged(
    new PrivilegedExceptionAction<Object>() {
      public Object run() throws ScriptException {
        engine.eval(  ...  ); // in a sandbox with no permissions
        return null;
      }
    }
  )
}]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Code_injection_in_Java,http://cwe.mitre.org/data/definitions/95.html,https://www.securecoding.cert.org/confluence/display/java/IDS52-J.+Prevent+code+injection]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS52-J,CWE:95,OWASP:2021:A3,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CodeInjectionWithDeserializationRule" message="CodeInjectionWithDeserializationRule: Dynamic code injection during XML / JSON deserialization" class="com.optimyth.qaking.security.rules.java.CodeInjectionWithDeserializationRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.5.2,ASVS-v4.0.2:5.5.1,ASVS-v4.0.2:5.5.3,CWEScope:Availability,CWEScope:Integrity,code-injection,serialization]]></tags>
    <description><![CDATA[Certain Java serialization frameworks (like JDKs XmlEncoder/XmlDecoder or XStream library) provide a framework
for arbitrary object persistence (without mapping information), serializing objects to XML documents.
Such frameworks allow to serialize constructor and method calls, to reconstruct object instances properly
(to call the object constructors or setter methods) during deserialization.

If the application deserializes XML documents from untrusted sources (e.g. in a REST framework), and if an attacker
can provide the XML document to be deserialized, he/she may be able to execute arbitrary code on the server, including
opening a reverse shell to launch commands.

If you think that this does not affect you, think twice. A top-level service framework (REST, XML-RPC...) could
transfer Java objects using an underlying XML persistence framework like XmlEncoder or XStream. A REST framework
typically process (HTTP) request messages, and marshals/unmarshals a resource representation (JSON, XML...),
potentially to Java objects. The underlying unmarshalling library could allow code injection if it does not limit
which objects could be unmarshalled and which code could be executed during deserialization.

As XStream is used in other frameworks (for example, XStreamMarshaller class in Spring OXM), the vulnerability could
be found in other places.

In other words, any application that allows a user to pass content that will be deserialized by XMLDecoder or XStream
is exposing a remote code execution flaw.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid code injection thru serialized objects in XML / JSON.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.beans.XMLDecoder;
import com.thoughtworks.xstream.XStream;

public class X {
  /*
  The following xml document will overwrite a sensitive file.
  Similar to new PrintWriter("/myapp/WEB-INF/sensitive.dat").println("hacked!")
  The bad guys could install a JSPShell page, modify configuration files, etc.
  <java>
    <object class="java.io.PrintWriter">
      <string>/myapp/WEB-INF/sensitive.dat</string>
      <void method="println">
        <string>hacked!</string>
      </void>
    </object>
  </java>
  */
  public static X deserialize(HttpServletRequest req) throws Throwable {
    InputSource src = new InputSource(
      new InputStreamReader(req.getInputStream(), "UTF-8")
    );
    XMLDecoder decoder = new XMLDecoder(src); // VIOLATION: untrusted source
    Object object = decoder.readObject();
    decoder.close();
    return (X)object;
  }

  /*
  Similar attack payload for XStream, using dynamic proxy
  Deserialization runs new ProcessBuilder("c:\\windows\\system32\\calc.exe").start()
  <dynamic-proxy>
    <interface>com.myorg.Z</interface>
    <handler class="java.beans.EventHandler">
      <target class="java.lang.ProcessBuilder">
        <command><string>c:\\windows\\system32\\calc.exe</string></command>
      </target>
      <action>start</action>
    </handler>
  </dynamic-proxy>
  */
  public static Z deserialize(HttpServletRequest req) throws Throwable {
    String xml = fetchBody(req.getReader());
    XStream st = new XStream();
    Z object = (Z) st.fromXML(xml); // VIOLATION: untrusted source
    decoder.close();
    return object;
  }
}]]></example>
    <repair><![CDATA[With XMLDecoder, add a custom classloader to limit which classes may be created during deserialization.

With XStream, limit the classes that could be serialized/deserialized.
Note: Do not use the (default) AnyTypePermission.ANY.

XStream xs = new XStream();
xs.addPermission(NoPermissionType.NONE); // clear out existing permissions
// allow some basics
xs.addPermission(NullPermission.NULL);
xs.addPermission(PrimitiveTypePermission.PRIMITIVES);
xs.allowTypeHierarchy(Collection.class);
// allow types from certain package
xs.allowTypesByWildcard(new String[] {
    MyClass.class.getPackage().getName()+".*"
});]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/502.html,https://securityblog.redhat.com/2014/01/23/java-deserialization-flaws-part-2-xml-deserialization/,http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html,https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#hessianburlap-binaryxml,http://x-stream.github.io/securit]]></reference>
    <normatives>
      <security><![CDATA[CWE:502,CWETOP25:2021:13,OWASP:2021:A8,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CommandInjectionRule" message="CommandInjectionRule: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" class="com.optimyth.qaking.security.rules.java.CommandInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[The software constructs all or part of an operating system command using externally-controlled input, but it does not neutralize
properly that input that could modify the intended command when it is sent to a method that executes the command
(e.g. java.lang.Runtime.exec()).

The rule detects a path in code between an user-input statement (source) and a command execution call (sink),
with command depending on non neutralized input. This allows for an attacker to change the intended command to execute
or to add a malicious extra command, executed with the application rights.

A neutralization function either validates inputs and report an (neutral) error without allowing command execution,
or replaces sensitive shell characters in the input to avoid that the resulting command has different semantics.
If possible, use "accept known good" input validation strategy (whitelist).

It is recommended either: to use API calls instead of external commands, when possible; or to ensure that the application (e.g.
deployed in a J2EE container) runs under a non-privileged account with rights for the intended commands.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class Clase{
  public void commandInjection(HttpServletRequest req) throws IOException {
    String btype = req.getParameter("backuptype");
    String cmd = new String("cmd.exe /K \"c:\\util\\rmanDB.bat " + btype+ "&&c:\\utl\\cleanup.bat\"");
    Runtime.exec(cmd); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class Clase{
  public void commandInjection(HttpServletRequest req) throws IOException {
    String input = req.getParameter("input");
    // Neutralized, take care if input ends in a log anyway...
    if(!pattern.match(input)) throw new ValidationException(input); // proper positive validation
    String cmd = new String("cmd.exe /K \"c:\\util\\MyCommand.bat " + input);
    Runtime.exec(cmd);
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method,http://cwe.mitre.org/data/definitions/78.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS07-J,CWE:77,CWE:78,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:31]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ConnectionStringParameterPollution" message="ConnectionStringParameterPollution: Connection string polluted with untrusted input" class="com.optimyth.qaking.security.rules.java.ConnectionStringParameterPollution" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.7,CWEScope:Integrity]]></tags>
    <description><![CDATA[When the connection string for an application resource (like database, remote server, persistence entity manager...) could
be affected by an untrusted source, not properly neutralized, the application is vulnerable to a Connection String Parameter Pollution attack.

An attack targeted at this vulnerability may use special characters (like ';' or ':') to add unexpected parts to the connection string,
for example to gain extra privileges, or to deactivate security features.

"Untrusted input" means, in this context, a user-controlled application input, an environment variable, or data fetched
from an external web source.

It should be suspicious that a connection string depends on untrusted input. Normally the application configuration uses
a fixed connection string, but other attacks, depending on where the connection string is stored (like an SQL injection or
path traversal attack) may affect the configuration item. This rule only checks for connection strings that are constructed
programmatically with untrusted input.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.sql.DriverManager;
import java.sql.Connection;
import java.text.MessageFormat;

public class X {
  private static final String URL = "jdbc:hsqldb:mem:{0}";

  public Connection getConnection(HttpServletRequest req) throws SQLException {
    String uname = req.getParameter("username");
    String jdbcUrl = MessageFormat.format(URL, uname);
    return DriverManager.getConnection(jdbcUrl, userPrefix + "_" + user, password); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[// Validate (white-list approach) the untrusted input combined into the connection string.]]></repair>
    <reference><![CDATA[https://www.blackhat.com/presentations/bh-dc-10/Alonso_Chema/Blackhat-DC-2010-Alonso-Connection-String-Parameter-Pollution-wp.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:15,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CookiesInSecurityDecision" message="CookiesInSecurityDecision: Reliance on Cookies without Validation and Integrity Checking in a Security Decision" class="com.optimyth.qaking.security.rules.java.CookiesInSecurityDecision" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[Using a cookie for security decision is a bad practice. Remember that attackers control most parts of the HTTP message,
including cookies sent to the application. If a security check is based on the value of a cookie field (for example,
the cookie value), a attacker may choose a particular value to pass such security check, without any reliance to
past navigation thru the vulnerable application.

Attackers may exploit this vulnerability to bypass protection mechanisms such as authorization and authentication,
by modifying the cookie to contain an expected value.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid bypass of protection mechanisms, due to flawed security decisions based on cookies.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public void flawedAdminCheck(HttpServletRequest req, HttpServletResponse res) {
  Cookie[] cookies = req.getCookies();
  for(Cookie cookie : cookies) {
    if("role".equals(cookie.getName())) { // VIOLATION
      String role = cookie.getValue();
      if(req.isUserInRole(role) && "admin".equals(role)) { // VIOLATION
        doAdminOperation(req, res);
      }
    }
  }
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/784.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:784,OWASP:2021:A8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CrossSiteHistoryManipulation" message="CrossSiteHistoryManipulation: Cross-Site History Manipulation (XSHM)" class="com.optimyth.qaking.security.rules.java.CrossSiteHistoryManipulation" technology="JAVA" active="true">
    <description><![CDATA[Cross-Site History Manipulation (XSHM) is an attack targeted at end users, that uses browser's history object
to infer information on past navigation on a vulnerable application, violating the browser's enforced Same Origin Policy (SOP).

The logic that creates an XSHM vulnerability, for the Condition leakage variant, is simple:
In PageA: if(CONDITION) Response.Redirect(PageB).

An attacker executes a cross-site request (a request initiated in the victim's browser but controlled by the attacker)
and is able to infer if CONDITION is true or false, using the browser's history object.

A typical XSHM attack could be as follows:
1. Attacker creates an iframe whose src is PageB.
2. The attacker code (JavaScript) saves the current value of history.length.
3. The attacker code changes src of the iframe to PageA.
4. If current history.length is the same as the stored value, CONDITION is true
   (a client-side redirect was done, but URL already exists in history, so it is not added).
   Otherwise, CONDITION is false (no client-side redirect, and PageA is added to the history object).

This attack has the effect of leaking the result of a condition. The impact depends on the sensitivity of CONDITION
for the attacker. A typical case is the user authentication status, inferring parameter values used in CONDITION,
or mounting a Cross-Site Request Forgery (CSRF) attack and be able to detect if attack was successful or not.

Note: Attacker may infer past navigated pages in the site, or even try to infer parameter values for past navigated pages,
by using cross-site requests and using the JavaScript method history.go(URL) (which is allowed cross-domain). This variants
are independent of the XSHM vulnerability documented here.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid user inputs controlling a redirection reduces the risk of occurrence of a XSHM attack.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class RedirectServlet extends HttpServlet {
  @Override
  public void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    String root = req.getContextPath();
    HttpSession session = req.getSession(false);
    boolean isAuthenticated = session != null && session.getAttribute("user") != null;
    if (isAuthenticated) {
      res.sendRedirect(root + "/auth"); // VIOLATION
    } else {
      doNoAuthenticated(req, res);
    }
  }
}]]></example>
    <repair><![CDATA[// Use forward ("server-side redirect") for local URLs, or add a random token to the redirect URL,
// to avoid leaking a sensitive condition.
// Note: such countermeasures may affect application logic

// Option #1: forward instead of sendRedirect
if (isAuthenticated) {
  req.getRequestDispatcher(root + "/auth").forward(req, res); // FIXED
} else {
  doNoAuthenticated(req, res);
}

# Option #2: add a random token to avoid XSHM attack.
# A random token makes the redirected URL different for each request,
# and the attacker cannot mount the XSHM attack.
if (isAuthenticated) {
  String xshmToken = generateRandomToken();
  res.sendRedirect(root + "/auth?xshm=" + xshmToken); // FIXED
} else {
  doNoAuthenticated(req, res);
}]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Cross_Site_History_Manipulation_(XSHM)]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CrossSiteRequestForgeryRule" message="CrossSiteRequestForgeryRule: Cross-site request forgery (CSRF)" class="com.optimyth.qaking.security.rules.java.CrossSiteRequestForgeryRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.3,ASVS-v4.0.2:4.2.2,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,csrf]]></tags>
    <description><![CDATA[A sensitive operation associated with an web URL (servlet, JSP, WebUI, Struts Action ...) may be invoked from
a request coming from a legitimate, authenticated user (with identity typically encoded in a session ID cookie)
but where an attacker was able to force the user agent to submit the request.

For an CSRF attack to succeed, various elements must occur together:
1. Trusted user is logged in the vulnerable webapp
2. Trusted user agent is tricked by the attacker (e.g. in a web app he controls) to send an HTTP request to the
   vulnerable URL
3. The server-side logic under that URL accepts the request as if it was really initiated by the legitimate user,
   without explicit verification that the user really intended to perform the operation, simply because the
   session ID cookie for the logged-in user appears in the HTTP request.

The result is that the vulnerable application accepts the operation (controlled by attacker) as if it was submitted
by the trusted, logged-in, user. This is an abuse of the trust the web application puts on HTTP requests coming from
logged-in users.

A CSRF vulnerability is a design flaw, where certain web operations (sensitive, as an attacker may gain benefit
from the legitimate user) are not protected by a control that avoids this kind of attack to succeed. Essentially,
a CSRF flaw occurs when a web resource performing sensitive operations do not check that the request came from
from same webapp + same user (the application, at server side, needs to explicitely check the request provenance somehow).

NOTE: Other attacks, like Cross-site WebSocket hijacking (https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html)
follow the same path and are prevented along the very same techniques.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid CSRF attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// No "bad code" for CSRF. The lack of anti-CSRF protection
// in web actions performing sensitive operations is the flaw.]]></example>
    <repair><![CDATA[Add a particular anti-CSRF control (sometimes in each action class,
sometimes in webapp configuration.

For example, for OWASP CSRFGuard, In web.xml file:

	Activate the CsrfGuardFilter:
	<filter>
		<filter-name>CSRFGuard</filter-name>
		<filter-class>org.owasp.csrfguard.CsrfGuardFilter</filter-class>
	</filter>

	Configure anti-CSRF filter:
  <listener>
    <listener-class>org.owasp.csrfguard.CsrfGuardServletContextListener</listener-class>
  </listener>
  <listener>
    <listener-class>org.owasp.csrfguard.CsrfGuardHttpSessionListener</listener-class>
  </listener>
  <context-param>
    <param-name>Owasp.CsrfGuard.Config</param-name>
    <param-value>WEB-INF/Owasp.CsrfGuard.properties</param-value>
  </context-param>

	Map the filter to URL patterns for sensitive actions to be protected:
	<filter-mapping>
		<filter-name>CSRFGuard</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/352.html,https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet,https://en.wikipedia.org/wiki/Cross-site_request_forgery]]></reference>
    <normatives>
      <security><![CDATA[CWE:352,CWETOP25:2021:9,OWASP:2013:A8,PCI-DSS:6.5.1,WASC:9]]></security>
    </normatives>
    <properties>
      <property name="checkStateChange" descname="When true, potential vulnerable sources not performing any state-change operation are not reported." value="true"/>
      <property name="patterns" descname="ANT patterns, comma-separated, for source files to process. Try to select sensitive operations that need CSRF protection." value=""/>
      <property name="checkers" descname="Comma-separated names of CSRF protection frameworks (CSRFGuard, ESAPI, JSF, HDIV, Struts1, Struts2 or SpringSecurity; or empty for all of them)." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.CrossSiteScriptingRule" message="CrossSiteScriptingRule: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')" class="com.optimyth.qaking.security.rules.java.CrossSiteScriptingRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,essential]]></tags>
    <description><![CDATA[Software places user-controlled input in page content. An attacker could inject browser script code that is executed
in the client browser. The end-user is the attacked subject, and the software is the vehicle for the attack.
There are two main kinds of XSS:

* Reflected XSS: Attacker causes victim to supply malicious content to a vulnerable web application, which
  renders HTML content embedding a malicious script executed in victim's browser. A variation of this is named
  DOM-based XSS, where the vulnerable software does not generate content depending on user input but include
  script code that use user-controlled input.

* Persisted XSS: Attacker provides malicious content to vulnerable application. When other user access to
  vulnerable pages that embed without proper neutralization the attacker content, script code is executed in the
  victim's browser.

The script executed in the victim's browser could perform malicious activities.

Many browsers could limit the damage via security restrictions (e.g. 'same origin policy'), but user browsers
generally allow scripting languages (e.g. JavaScript) in their browsers (disabling JavaScript severely limits
a web site).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

public class CrossSiteScriptingCode {
  public void directXSS(HttpServletRequest req, HttpServletResponse res) throws IOException {
    PrintWriter w = res.getWriter();
    w.println( req.getParameter("input") ); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import org.owasp.html.*;

public class CrossSiteScriptingCode {
  public void directXSS(HttpServletRequest req, HttpServletResponse res) throws IOException {
    PrintWriter w = res.getWriter();
    // OWASP Java HTML Sanitizer (upgrade to r88 or later)
    // Use your own security library if needed
    PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.LINKS);
    String safeHTML = policy.sanitize( req.getParameter("input") );
    w.println(safeHTML); // OK
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html,https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet,https://www.google.es/about/appsecurity/learning/xss/,https://www.securecoding.cert.org/confluence/display/java/IDS51-J.+Properly+encode+or+escape+output]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS51-J,CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.7,WASC:08]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input, database_input, file_input"/>
      <property name="checkXssProtectionHeaderDisabled" descname="When true rule reports violation if X-XSS-Protection filter is disabled" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.DetailErrorLeakRule" message="DetailErrorLeakRule: Do not send detail error information to client" class="com.optimyth.qaking.security.rules.java.DetailErrorLeakRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.2,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Avoid sending a stack trace to client. Stack trace provides too much information to the user,
that could gather system information to launch other attacks. Stack trace show details about methods called,
that could give an attacker hints about how software works, which libraries are used, etc.

Error messages should be neutral, not revealing system information.

Certain exception types are specially useful for attackers. Some examples and info leaked follows:
* java.io.FileNotFoundException - Filesystem structure.
* java.sql.SqlException - Database structure.
* java.net.BindException - Open ports enumeration, when client may choose server-side port.
* java.util.ConcurrentModificationException - Info about non thread-safe code (prior to a race condition exploit).
* javax.naming.InsufficientResourcesException - Not enouth resources (useful for mounting denial-of-service attacks).
* java.util.MissingResourceException - Resource enumeration.
* java.util.jar.JarException - Filesystem structure.
* java.security.acl.NotOwnerException - Access control lists.
* java.lang.OutOfMemoryError - Useful for mounting denial-of-service attacks.
* java.lang.StackOverflowError - Useful for mounting denial-of-service attacks.

This rule looks for an exception stack trace sent as output to the user.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Error handling and fault isolation</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid showing technical details to a potential attacker.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Writer;

public class sample {
	public void process(HttpServletRequest req, HttpServletResponse res) throws IOException {

	  ServletOutputStream os = res.getOutputStream();
	  PrintWriter w = res.getWriter();
	  try {

	  } catch(Exception e) {
	    e.printStackTrace( new PrintStream(os) );    // VIOLATION
	    e.printStackTrace(w);      // VIOLATION 
	  }
	}
}]]></example>
    <repair><![CDATA[import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Writer;

public class sample {
  public void process(HttpServletRequest req, HttpServletResponse res) throws IOException {
    PrintWriter w = res.getWriter();
    try {

    } catch(Exception e) {
      log.error(e);            // Proper logging is not forbidden
      w.println(NEUTRAL_ERROR_MESSAGE);
    }
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/497.html,ERR01-J: https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:ERR01-J,CWE:497,PCI-DSS:6.5.5,WASC:13]]></security>
    </normatives>
    <properties>
      <property name="stderrDumpNotAllowed" descname="When true, e.printStackTrace() is considered a rule violation" value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.DynamicMethodInvocation" message="DynamicMethodInvocation: Dynamic method invocation in Struts 2" class="com.optimyth.qaking.security.rules.java.struts2.DynamicMethodInvocation" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CVE:2013:4316,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,Framework:struts2]]></tags>
    <description><![CDATA[Struts 2 added a feature (Dynamic Method Invocation, DMI) allowing an Action to expose service methods other than execute()
(or other @Action annotated methods). When DMI is enabled, the ! character could be used in the action URL to invoke
any public method in the action class.

Developers that are not aware of DMI could unexpectedly expose internal business logic to attackers.

The rule reports violation when 'struts.enable.DynamicMethodInvocation' configuration property set to true
(in struts.properties or any Struts .xml configuration file), which enable DMI.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unexpected invocations on public action methods.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[# In struts.properties
struts.enable.DynamicMethodInvocation = true

<!-- In struts.xml configuration file -->
<constant name="struts.enable.DynamicMethodInvocation" value="true" />]]></example>
    <repair><![CDATA[# In struts.properties
struts.enable.DynamicMethodInvocation = false

<!-- In struts.xml configuration file -->
<constant name="struts.enable.DynamicMethodInvocation" value="false" />]]></repair>
    <reference><![CDATA[https://struts.apache.org/docs/s2-019.html,http://cwe.mitre.org/data/definitions/285.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:285,OWASP:2021:A1,PCI-DSS:6.5.8,WASC:02]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ESAPIBannedRule" message="ESAPIBannedRule: Avoid dangerous J2EE API, use replacements from security-focused libraries (like OWASP ESAPI)" class="com.optimyth.qaking.security.rules.java.ESAPIBannedRule" technology="JAVA" active="true">
    <tags><![CDATA[owasp-esapi]]></tags>
    <description><![CDATA[OWASP ESAPI Secure Coding Guidelines (ESAPI SCG) include a set of banned APIs in J2EE framework,
and recommends replacing them by equivalent, more secure replacements.

The list of "banned" APIs and their recommended replacementes in ESAPI are:
* BAN001 - System.out.println(), replace by Logger.*
* BAN002 - Throwable.printStackTrace(), replace by Logger.*
* BAN003 - Runtime.exec(), replace by Executor.safeExec()
* BAN004 - Session.getId(), replace by Randomizer.getRandomString (better not to use at all)
* BAN005 - ServletRequest.getUserPrincipal(), replace by Authenticator.getCurrentUser()
* BAN006 - ServletRequest.isUserInRole(), replace by AccessController.isAuthorized*()
* BAN007 - Session.invalidate(), replace by Authenticator.logout()
* BAN008 - java.util.Randor or Math.random(), replace by Randomizer.*
* BAN009 - File.createTempFile(), replace by Randomizer.getRandomFilename()
* BAN010 - ServletResponse.setContentType(), replace by HTTPUtilities.setContentType()
* BAN011 - ServletResponse.sendRedirect(), replace by HTTPUtilities.safeSendRedirect()
* BAN012 - RequestDispatcher.forward(), replace by HTTPUtilities.safeSendForward()
* BAN013 - ServletResponse.addHeader(), ServletResponse.setHeader(), replace by HTTPUtilities.safeSetHeader()/safeAddHeader()
* BAN014 - ServletResponse.addCookie(), replace by  HTTPUtilities.safeAddCookie()
* BAN015 - ServletRequest.isSecure(), replace by HTTPUtilties.isSecureChannel()
* BAN016 - Properties.*, replace by EncryptedProperties.*
* BAN017 - ServletContext.log(), replace by Logger.*
* BAN018 - java.security.* and javax.crypto.*, replace by Encryptor.*
* BAN019 - java.net.URLEncoder/Decoder, , replace by Encoder.encodeForURL()/decodeForURL()
* BAN020 - java.sql.Statement, replace by java.sql.PreparedStatement
* BAN021 - ServletResponse.encodeURL, replace by HTTPUtilities.safeEncodeURL() (better not to use at all)
* BAN022 - ServletResponse.encodeRedirectURL, replace by HTTPUtilities.safeEncodeRedirectURL() (better not to use at all)

Other rules check for potential security weaknesses, while this rule forbids specific J2EE API usages
unconditionally, and mandates for replacement with secure API calls (using e.g. ESAPI library).

NOTE: Of course many frameworks provide security controls that overlap with libraries like OWASP ESAPI, but
in some areas (output encoding, data validation with canonicalization, CSRF protection, security logging)
ESAPI offers nice capabilities. The rule simply signals usages of problematic APIs and give a ESAPI-based
replacement recommendation. If your organization uses another library(es) as a replacement to potential
trouble sites, map the recommendations to the equivalent calls in your library of choice.

This rule does not check if calls could be affected by user-controlled input. Other rules perform such checks.]]></description>
    <priority>5</priority>
    <effort>2</effort>
    <vulntype>Other</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  File f = File.createTempFile("prefix", "suffix"); // BAN009]]></example>
    <repair><![CDATA[    // Creates a random file, more difficult to guess, and place it in a controlled directory
    // instead of storing in system's temp directory
    File tempFile = new File(DIR, ESAPI.randomizer().getRandomFilename("tmp"));]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/ESAPI_Secure_Coding_Guideline]]></reference>
    <properties>
      <property name="checkWebContext" descname="When this property is enabled only the usages under a web context will be reported. Else every usage will be reported." value="true"/>
      <property name="banned" descname="Comma-separated list with ID of ban rules to apply (if empty, check all banned rules, excluding allowed)" value=""/>
      <property name="allowed" descname="Comma-separated list with ID of ban rules to ignore (if empty, check the ones in allowed or all if not specified)" value="BAN001,BAN002,BAN016,BAN018"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ExecutionAfterRedirect" message="ExecutionAfterRedirect: Execution After Redirect (EAR)" class="com.optimyth.qaking.security.rules.java.ExecutionAfterRedirect" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The web application sends a forward / redirect to another location, but instead of exiting, it executes additional code.

If the redirect is a client redirect (typically, setting the Location HTTP header), the attacker may ignore such redirect
and process the message body, potentially accessing unintended contents rendered to the HTTP response after the redirect.

When the application developer does not terminate the response, but perform additional operations assuming that
the redirect call will not end the flow, then an unauthorized user may be able to access unintended contents.

The rule looks for statements following the forward / redirect call, and reports a defect when a non allowed statement
follows that call. A few kind of statements, like a return, a break (in a switch case), a logging call, or a counter increment,
might be allowed.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[/* ... */
public void bad(HttpServletRequest request, HttpServletResponse response) throws Throwable {
    response.sendRedirect("/test"); //VIOLATION

    /* FLAW: code after the redirect is undefined */
    IO.writeLine("doing some more things here after the redirect");
}
/* ... */]]></example>
    <repair><![CDATA[/* ... */
public void bad(HttpServletRequest request, HttpServletResponse response) throws Throwable {
    response.sendRedirect("/test"); //OK
}
/* ... */]]></repair>
    <reference><![CDATA[http://cs.ucsb.edu/~bboe/public/pubs/fear-the-ear-ccs2011.pdf,https://cwe.mitre.org/data/definitions/698.html,https://www.owasp.org/index.php/Execution_After_Redirect_(EAR)]]></reference>
    <normatives>
      <security><![CDATA[CWE:698]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ExternalControlOfConfigurationSetting" message="ExternalControlOfConfigurationSetting: External Control of System or Configuration Setting" class="com.optimyth.qaking.security.rules.java.ExternalControlOfConfigurationSetting" technology="JAVA" active="true">
    <description><![CDATA[One or more system settings or configuration elements can be externally controlled by a user.

Allowing external control of system settings can disrupt service or cause an application to behave in unexpected,
and potentially malicious ways.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.sql.Connection;

public class X {
  public void doSomething(HttpServletRequest req) {
    Connection conn	= getConnection();
    String hiddenParam = req.getParameter("catalog"); // not hidden at all!
    conn.setCatalog(hiddenParam); // VIOLATION
    // ...
  }
}]]></example>
    <repair><![CDATA[    Connection conn	= getConnection();
    // Configuration taken from a trusted source
    String catalog = getConnectionConfig().getDbCatalog();
    conn.setCatalog(catalog); // OK]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/15.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:15,PCI-DSS:6.5.6]]></security>
    </normatives>
    <properties>
      <property name="sources" descname="Comma-separated list of input kinds considered untrusted for configuration properties (user_input, system_input, environment_input...)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.FormatStringInjectionRule" message="FormatStringInjectionRule: Exclude unsanitized user input from format strings" class="com.optimyth.qaking.security.rules.java.FormatStringInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.4.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Java JDK contains formatting methods, named format() or printf(), that format a sequence of values according to a format string.
Classes with formatting methods: PrintStream/PrintWriter, Formatter, MessageFormat, and String.
Except MessageFormat, format string is loosely similar to C printf() format string.

If the format string is constructed with untrusted input, an attacker may produce unexpected application behaviour.
It may cause an exception such as java.util.MissingFormatArgumentException to be thrown (which, if not catched, may lead
to a denial-of-service condition), or information leak.

Consequently, unsanitized input from untrusted source should never be incorporated into format strings.

Note: The risks here are much lower that the equivalent vulnerability in C/C++ and the %n format modifier, anyway.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid denial of service.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[class X {
  public static void main(String[] args) {
    ...
    if(!isProperExpirationDate(args[0])) {
      // VIOLATION - args[0] may contain format specifiers
      System.out.format(
        args[0] + " not valid. HINT: %s",
        args[1]
      );
    }
  }
}]]></example>
    <repair><![CDATA[class X {
  public static void main(String[] args) {
    ...
    if(!isProperExpirationDate(args[0])) {
      // FIXED - constant format string
      System.out.format(
        "%s not valid. HINT: %s",
        args[0], args[1]
      );
    }
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/IDS06-J.+Exclude+unsanitized+user+input+from+format+strings,http://cwe.mitre.org/data/definitions/134.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS06-J,CWE:134,CWETOP25:2011:23,OWASP:2004:A5,PCI-DSS:6.5.1,WASC:10]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.HardcodedCryptoKey" message="HardcodedCryptoKey: Hardcoded cryptographic keys" class="com.optimyth.qaking.security.rules.java.HardcodedCryptoKey" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,crypto,essential]]></tags>
    <description><![CDATA[Never hard-code cryptographic keys (or passwords used to generate them) in your program.

Crypto keys are used for encryption/decryption, for generation of message authentication codes (MAC), during generation
of password-based encryption keys (the password is the "crypto key" that generates key material for the cipher), and other usages.
Source code is the worst place for key storage, as any change in keys needs recompilation, and it is easy to reverse-engineer
an application binary to learn any keys or secrets that may be embedded in it.

Some data used in cryptographic operations (like initial vector for block ciphers, salt for password hashes, etc.)
are not "private", and it is recommended to generate a good random instance at the origin, and add it to the message
in plaintext, so the destination may use it. The security depends on properly protecting the "secret" thing
(private key in a public/private keypair, encryption key in a symmetric cipher, key in an HMAC, etc.).

Long-term cryptographic keys (in contrast with ephemeral ones), are better stored in a safe key storage.
Private keys in a public/private keypair should NEVER be unprotected (in raw form) and they should be stored in an even
safer key storage (the impact for a compromise of a private key is typically huge and brutal).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public SecretKey hardcodedCryptoKey() throws GeneralSecurityException {
  final String hardcoded = "hardcoded-password"; // hardcoded crypto key
  final byte[] salt = getRandomSalt();
  KeySpec keyspec = new PBEKeySpec(hardcoded.toCharArray(), salt, 65536, 256); // VIOLATION
  SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
  SecretKey tmp = factory.generateSecret(keyspec);
  return new SecretKeySpec(tmp.getEncoded(), "AES");
}]]></example>
    <repair><![CDATA[public SecretKey nonHardcodedCryptoKey() throws GeneralSecurityException {
  final String pass = loadKeyFromSafeInput(); // FIXED
  final byte[] salt = getRandomSalt();
  KeySpec keyspec = new PBEKeySpec(pass.toCharArray(), salt, 65536, 256);
  SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
  SecretKey tmp = factory.generateSecret(keyspec);
  return new SecretKeySpec(tmp.getEncoded(), "AES");
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/321.html,https://wiki.sei.cmu.edu/confluence/display/java/MSC03-J.+Never+hard+code+sensitive+information]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC03-J,CWE:321,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.3.1,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.HardcodedUsernamePassword" message="HardcodedUsernamePassword: Use of Hard-coded Credentials" class="com.optimyth.qaking.security.rules.java.HardcodedUsernamePassword" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.4,ASVS-v4.0.2:3.5.2,ASVS-v4.0.2:6.4.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,credentials,essential]]></tags>
    <description><![CDATA[Hardcoded credentials (username / password) are visible to any person reading the source code.
If the resource protected by such hardcoded credentials is important, this may compromise system security.

With hardcoded credentials, change is difficult. If the target account is compromised, and the software
is deployed in production, a code change is needed, which forces a redeployment.

Please note that source code access is not always necessary: if an attacker has access to the JAR file,
he/she may dis-assembly it to recover the password in clear.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid credential leakage.
If an account is compromised, changing credentials in an external repository does not need changes in code
plus software deployment]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.sql.*;

public class Hardcoded {
  private static final String JDBC_URL = "jdbc:...";
  private static final String USER = "mydbuser";
  private static final String PASS = "notSoSecret!";

  public void connect() {
    Connection conn = DriverManager.getConnection(JDBC_URL, USER, PASS); // VIOLATION
    // ...
  }
}]]></example>
    <repair><![CDATA[import java.sql.*;

public class JdbcConnectionConfig { /* ... */ }

public class Hardcoded {
  public void safeConnect() {
    JdbcConnectionConfig conf = getConnectionConfigFromTrustedSource();
    Connection conn = DriverManager.getConnection(conf.getUrl(), conf.getUser(), conf.getPass()); // FIXED
    // ...
  }
}]]></repair>
    <reference><![CDATA[https://security.web.cern.ch/security/recommendations/en/password_alternatives.shtml,http://cwe.mitre.org/data/definitions/798.html,https://www.kiuwan.com/docs/display/K5/Avoid+hard-coded+or+in-comment+passwords+in+code,https://www.securecoding.cert.org/confluence/display/java/MSC03-J.+Never+hard+code+sensitive+information]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC03-J,CWE:798,CWETOP25:2021:16,OWASP-M:2016:M2,OWASP:2021:A7,PCI-DSS:6.5.3,WASC:01]]></security>
    </normatives>
    <properties>
      <property name="passwordPattern" descname="Regular expression for matching field names containing passwords." value=""/>
      <property name="usernamePattern" descname="Regular expression for matching field names containing user ids." value=".*(user|username).*|(^|.*_)id(_.*|$)"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.HttpParameterPollutionRule" message="HttpParameterPollutionRule: HTTP parameter pollution (HPP)" class="com.optimyth.qaking.security.rules.java.HttpParameterPollutionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.1,CWEScope:Integrity,http-parameter-pollution]]></tags>
    <description><![CDATA[Concatenating untrusted input into path, query string, or parameters for HTTP message (in the URL or in the request body)
may allow an attacker to override/add unexpected request parameters. Attacker may change the intended
HTTP request semantics, and may give him/her access to unauthorized data or bypass web application
firewall validations.

Note: Do not confuse HPP with Server-Side Request Forgery (SSRF), where the attacker has control over the
full request URL, including host and port. For HPP attack, attacker has control over other parts like the query string
part of the URL. Remember the format of an HTTP URL: scheme://user:password@host:port/path?query#fragment
where query is typically param=value&param2=value. HPP is about attackers controlling path, query or fragment,
while SSRF means controlling scheme, user, password, host or port.

Like other injection issues, with HPP attackers play with "&" to inject additional parameter (similar to the quote
in SQL injection), "../" to change the path, ";" (to add matrix parameters to URL at different path segments), or "#"
to remove ending URL characers (like "--" comment delimiter in SQL injection).

Controlling the path typically changes the semantics of the action represented by the HTTP resource.
Some REST services use request parameter like _method for selecting the HTTP method, which may be subverted by an HPP attack
(an HTTP header manipulation flaw could also be leveraged with X-HTTP-Method-Override or similar headers in certain frameworks).

For example, imagine a web application that calls to a remote home-banking REST API. The webapp emits
a (GET) url https://mybank.com/show-balance/account/X/monetaryUnit?date=now to show the balance for the user account X,
where X is taken from a trusted source, but where monetaryUnit is taken from a cookie, and concatenated without
any validation or encoding into the URL. An attacker could pass a Cookie request header set to "../../../transfer/X/to/Y?_method=POST#",
so the vulnerable web application will create https://mybank.com/show-balance/account/X/../../../transfer/X/to/Y?_method=POST#?date=now
which is equivalent to a POST https://mybank.com/transfer/X/to/Y.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unexpected behaviour for HTTP parameter pollution attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[String lang = req.getParameter("lang"); // untrusted input

// Using Apache Commons HttpClient API:
GetMethod get = new GetMethod("http://www.host.com");
get.setQueryString("lang=" + lang + "&poll_id=" + poll_id); /* VIOLATION */
get.execute();

// Using java.net.URLConnection API:
String queryString = "?lang=" + lang + "&poll_id=" + poll_id;
URL url = new URL("http://www.host.com" + queryString); /* VIOLATION */
URLConnection urlConn = url.openConnection();
...
InputStream response = url.getInputStream();]]></example>
    <repair><![CDATA[String lang = req.getParameter("lang"); // untrusted input
validate(lang); // custom validation
// url-encode so special query string chars (&,;?%) in lang are safe
lang = URLEncoder.encode(lang);
... same as before ...]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/235.html,RESTing On Your Laurels will Get YOu Pwned]]></reference>
    <normatives>
      <security><![CDATA[CWE:235,OWASP:2021:A3,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.HttpSplittingRule" message="HttpSplittingRule: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')" class="com.optimyth.qaking.security.rules.java.HttpSplittingRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software places user-controlled input in HTTP headers. An attacker could inject line separators (CR/LF sequences)
    that could split the response message generated by the software into two messages. The second response is completely
    under the control of the attacker (intermediate web proxies may cache it), with could produce multiple conditions
    (web defacement, cache poisoning, cross-site scripting or page hijacking, see CWE-113 for full details).

    If software needs to generate HTTP headers depending on user-controlled input, such input should be properly
    neutralized (a white-list validation excluding CR/LF is recommended). Please note that cookies are received and
    sent in 'Cookie' header in HTTP messages, so if the software generates a Cookie from user input, the input should
    be properly validated as well.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;

public class Sample {

  public void httpSplitting(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String author = req.getParameter("author");
    Cookie cookie = new Cookie("author", author);
    res.addCookie(cookie);    // VIOLATION, cookie is encoded as 'Cookie' header field in HTTP response message
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;

public class Sample {

  public void httpSplitting(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String author = req.getParameter("author");
    // This could emit an exception for white-list validation, or at least remove CR/LF sequences from the input
    //  Neutralize function must be registered into the metadata to be considered by the rule.
    author = neutralize(author);
    Cookie cookie = new Cookie("author", author);
    res.addCookie(cookie); // VIOLATION, cookie is encoded as 'Cookie' header field in HTTP response message
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/113.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:113,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:25]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.IBatisSqlInjectionRule" message="IBatisSqlInjectionRule: Improper Neutralization of Special Elements used in an SQL Command in iBatis ('SQL Injection')" class="com.optimyth.qaking.security.rules.java.IBatisSqlInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[IBatis (or MyBatis for newest versions) is a database persistence framework with support for custom SQL, stored procedures and advanced mappings.
This framework eliminates JDBC code and the manual setting of parameters and retrieval of results, using either XML mapping
descriptors or Java annotations for configuration and declaring the SQL operations and the map between Java objects and
database elements.

Mapping entries in iBatis typically use named parameters that automatically map between input parameters (either map entries
or object fields) and the SQL parameters, and use prepared statements to send SQL to the database. This mode of operation
is largely safe with respect to SQL injection. The #field# or #{field} placeholders in the SQL code are replaced by
prepared parameter placeholders and the field data is injected as parameter in the SQL statement, which is safe against
SQL injection attacks.

But sometimes dynamic SQL is needed, for example to modify part of the SQL according to the values of the input parameters.
iBatis offers a satisfactory way to compose safe dynamic SQL, using XML dynamic elements while avoiding mixing SQL code and
SQL parameters. But it also offers the possibility to concatenate input parameters directly into SQL statements, using the
$field$ or ${field} constructs. They are often used in GROUP BY and ORDER BY clauses, and when certain elements like
column lists or table names need to be modified.

The rule checks for those concatenation constructs, emitting a violation on each SQL operation that uses them, as they could
be potential avenues for SQL injection attacks.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid SQL injection flaws in the iBatis / MyBatis mapping configurations.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- VIOLATION, dynamic concatenation variables $altFilter$ and $orderedFields[]$ -->
<!-- Suppose that altFilter is either empty or contains the fragment AND COL_2 = '...' -->
<select id="mySelect" parameterClass="map" resultMap="myRowMapperVO">
  SELECT * FROM MYTABLE
  WHERE COL_1 = #data.col_1#
  $altFilter$
  <isNotEmpty property="orderBy">
  ORDER BY $orderBy$
  </isNotEmpty>
</select>]]></example>
    <repair><![CDATA[<select id="mySelect" parameterClass="map" resultMap="myRowMapperVO">
  SELECT * FROM MYTABLE
  WHERE COL_1 = #data.col_1#
  <isNotEmpty property="data.col_2">
  AND  COL_2 = #data.col_2#
  </isNotEmpty>
  <dynamic prepend="ORDER BY">
    <isEqual property="orderBy" compareValue="COL_1">COL_1</isEqual>
    <isEqual property="orderBy" compareValue="COL_2">COL_2</isEqual>
    <isEqual property="orderBy" compareValue="COL_3">COL_3</isEqual>
  </dynamic>
</select>]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/89.html,https://www.securecoding.cert.org/confluence/display/java/IDS00-J.+Prevent+SQL+injection]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS00-J,CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InadequatePaddingRule" message="InadequatePaddingRule: Inadequate padding" class="com.optimyth.qaking.security.rules.java.InadequatePaddingRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Accountability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[When used in practice, encryption algorithms are generally combined with some padding scheme. 
The goal of the padding scheme is to prevent a number of attacks that potentially work against the encryption algorithm without padding.

The rule can be parameterized to specified which methods of which classes have to be checked:
- allowedPaddings: comma-separated list of allowed paddings.
- encryptionMethodsSignature: comma-separated list of encryption methods signatures. It should be specified in a certain way: ClassName.methodName/parameterPosition (where 'parameterPosition' is a number that indicates the position that the 'transformation' string parameter occupies between the encryption method arguments: Class1.encryptMethod/2,Class2.otherEncryptMethod/1, ... )

NOTE: do not mistake the position of the 'transformation' string parameter in the method arguments with the 'padding' part of the transformation string for encryption calls such as Cipher.getInstance(). For example:
Cipher.getInstance/1 corresponds to Cipher.getInstance("RSA/NONE/PKCS5Padding", provider) where "RSA/NONE/PKCS5Padding" (first argument) is encoded with the number '1' in the list of signatures although the padding is encoded in the third place of the transformation string.

CGM mode doesn't require a padding.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private static final String TRANSFORMATION = "RSA/NONE/NoPadding";
//...
Cipher c = Cipher.getInstance("RSA/NONE/NoPadding");     //VIOLATION
Cipher c = Cipher.getInstance(TRANSFORMATION);           //VIOLATION

//The rule can lead to some false negatives, for example:
private static final String TRANSFORMATION = "RSA/NONE/NoPadding";
public String getTransformation(){
  return TRANSFORMATION;
}
// ...
Cipher cipher = Cipher.getInstance(getTransformation());  //NOT VIOLATION, BUT FALSE NEGATIVE]]></example>
    <repair><![CDATA[private static final String TRANSFORMATION = "RSA/NONE/PKCS5Padding";
//...
Cipher c = Cipher.getInstance("RSA/NONE/PKCS5Padding");     // OK
Cipher c = Cipher.getInstance(TRANSFORMATION);              // OK]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/325.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:325,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="encryptionMethodsSignature" descname="Comma-separated list of encryption methods signatures" value="Cipher.getInstance/1"/>
      <property name="allowedPaddings" descname="Comma-separated list of allowed algorithms" value="PKCS5Padding,OAEPPadding"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InformationExposureThroughErrorMessage" message="InformationExposureThroughErrorMessage: Avoid sensitive information exposure through error messages" class="com.optimyth.qaking.security.rules.java.InformationExposureThroughErrorMessage" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.1,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[When an error message is generated, care should be taken to ensure that it does not contain
sensitive information about the environment, users or any other information that may be considered sensitive.

Such information may be valuable itself or may be useful for further attacks with a higher impact.

Also attention should not only be paid to information explicitly included into error messages (for example by using System.out.println),
but also to certain functions that may produce an error that unexpectedly shows sensitive information, like when using the
constructor of FileInputStream class. In this situations it is necessary to check that the possible errors are handled somehow.

NOTE: This rule excludes JSPs because auto generated code cay produce several FPs.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid sensitive information leakage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[try {
  doSomething();

} catch (SecurityException e) {
  System.out.println(e.toString()); //VIOLATION
}]]></example>
    <repair><![CDATA[try {
  doSomething();

} catch (SecurityException e) {
  System.out.println("Something was wrong"); //FIXED
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/209.html,http://projects.webappsec.org/w/page/13246936/Information%20Leakage,https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:ERR01-J,CWE:209,OWASP:2021:A4,WASC:13]]></security>
    </normatives>
    <properties>
      <property name="allowThrowingExceptions" descname="When true, throwing an exception will not be reported by this rule." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InputPathNotCanonicalizedRule" message="InputPathNotCanonicalizedRule: Incorrect Behavior Order: Validate Before Canonicalize" class="com.optimyth.qaking.security.rules.java.InputPathNotCanonicalizedRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[A system can accept inputs that contain file path names. That path names
could be contains alias file links such as symbolic (soft) links, hard links, shortcuts, shadows, aliases, and junctions.
Path names should be resolved to a canonical format before to perform any operation with them.
In the lines below we can see some examples about path names:

- C:\temp\file.txt - This is a path, an absolute path, and a canonical path.
- .\file.txt - This is a path. It's neither an absolute path nor a canonical path.
- C:\temp\myapp\bin\..\\..\file.txt - This is a path and an absolute path. It's not a canonical path.

Canonicalization doesn't contribute to security assurance by itself, but it's necessary before perform any validation over a path name.
Doing validations over relative or absolute paths involves a risk.

This rule reports violation when a file path name is used without doing a canonicalization before a validation.

This rule reports violation when an system input is not normalized and then validated.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding malicious file path names improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[package com.demos;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import javax.servlet.http.HttpServletRequest;

public class CanonicalizeDemo {

  public static void main(String[] args) throws IOException {

    File file = new File("/img/" + args[0]);

	// 'equals' method is not a proper neutralization for file object
	// because it doesn't have a previous canonicalization
    if (!file.getPath().equals("/img/java/file1.txt") &&
        !file.getPath().equals("/img/java/file2.txt")) {
       return;
    }

    FileInputStream fis2 = new FileInputStream(file); /* VIOLATION */

	// Canonicalization without validation
	File file2 = new File("/img/" + args[1]);
	String canonicalPath2 = file2.getCanonicalPath();
	FileInputStream fis3 = new FileInputStream(canonicalPath2); /* VIOLATION */

  }
}]]></example>
    <repair><![CDATA[package com.demos;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import javax.servlet.http.HttpServletRequest;

public class CanonicalizeDemo {

  public static void main(String[] args) throws IOException {

    File file = new File("/img/" + args[0]);
    if (!isInSecureDir(file)) {
      throw new IllegalArgumentException();
    }
    String canonicalPath = file.getCanonicalPath();
    if (!canonicalPath.equals("/img/java/file1.txt") &&
        !canonicalPath.equals("/img/java/file2.txt")) {
        return;
    }

	  // Canonicalized and Neutralized
    FileInputStream fis = new FileInputStream(canonicalPath); /* OK */
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/FIO16-J.+Canonicalize+path+names+before+validating+them,http://cwe.mitre.org/data/definitions/171.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:FIO016-J,CERT-J:IDS02-J,CWE:180]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsecureRandomnessRule" message="InsecureRandomnessRule: Standard pseudo-random number generators cannot withstand cryptographic attacks" class="com.optimyth.qaking.security.rules.java.InsecureRandomnessRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.3.1,ASVS-v4.0.2:2.6.2,ASVS-v4.0.2:2.9.2,ASVS-v4.0.2:6.3.1,ASVS-v4.0.2:6.3.2,ASVS-v4.0.2:6.3.3,CWEScope:Access-Control,CWEScope:Confidentiality,crypto,prng]]></tags>
    <description><![CDATA[Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness
in a security-sensitive context: security tokens (like anti-CSRF or password-reset tokens), values used in cryptographic
operations (session key material, initialization vector in block or stream ciphers), or password seeds.

Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators
(PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.

There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties,
but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use
in cases where security depends on generated values being unpredictable.

Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be
cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between it
and a truly random value.

In general, if a PRNG algorithm is not advertised as being cryptographically secure, then it is probably a
statistical PRNG and should not be used in security-sensitive contexts, where its use can lead to serious vulnerabilities
such as easy-to-guess temporary passwords, predictable cryptographic keys, or session hijacking, among others.

The rule also checks that the standard java.security.SecureRandom is initialized properly, which basically means that
its setSeed() method is not called with any seed generated by custom code, except SecureRandom.getSeed(int) or
SecureRandom.generateSeed(int), which are accepted as a proper seed with "adequate entropy".]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// A statistical PRNG used to generate random passwords (security context).

// VIOLATION, seed (and consequently each generated random value) could be predicted
private final Random rand = new Random(System.currentTimeMillis());

public String generateRandomPassword() {
  // used in a security context
  return Integer.toString(rand.nextInt(Integer.MAX_VALUE));
}]]></example>
    <repair><![CDATA[// Instantiate SecureRandom pero do NOT call setSeed().
// The PRNG will be seeded before generating first random value using sources with reasonable entropy.
// Specify at least the algorithm (and provider when possible)
// Periodically discard SecureRandom instance and create a new one
private final SecureRandom rand = SecureRandom.getInstance("SHA1PRNG"); // FIXED

public String generateRandomPassword() {
  return Integer.toString(rand.nextInt(Integer.MAX_VALUE));
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/MSC63-J.+Ensure+that+SecureRandom+is+properly+seeded,http://cwe.mitre.org/data/definitions/338.html,https://www.cigital.com/blog/proper-use-of-javas-securerandom/,https://cwe.mitre.org/data/definitions/330.html/,https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Gene]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC02-J,CERT-J:MSC63-J,CWE:330,CWE:338,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="checkSecurityContext" descname="When this property is enabled only the usages under a security context will be reported. Else every usage will be reported." value="true"/>
      <property name="pattern" descname="Regular expression for sensitive methods where non secure PRNG generation is not allowed" value="password|passwd|session|user|key|csrf|token|hash|digest|uuid|guid"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsecureSSL" message="InsecureSSL: Insecure SSL configuration" class="com.optimyth.qaking.security.rules.java.InsecureSSL" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:9.2.4,CWEScope:Access-Control,CWEScope:Authentication,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,essential,ssl]]></tags>
    <description><![CDATA[The SSL standard provides guidelines on how to perform proper SSL validation checks on the client side.
They are not part of the standard, anyway. The implementation of the validation logic is left to the application developer,
that should setup SSL-related classes adequately.

Creating or configuring proper SSL validation checks is complex, and developers may fail providing a secure
SSL configuration. No certificate validity checks, no certificate chain signature verification, no or improper
server hostname validation (with respect to the identity contained in the server certificate) are common flaws
that this rule tries to discover.

Often, developers provide trust managers for accepting self-signed certificates, or even ignore certificate
state to allow expired or revoked certificates. Alternatively, the hostname validation is disabled to avoid
errors when the name in the certificate does not match the target hostname. Android apps often present such flaws.

The problem with flawed SSL configuration is that it may allow man-in-the-middle attacks and other issues,
see references for full details.

The rule checks for SSL flaw patterns: non-default custom SSL socket factories, and too permissive TrustManagers /
SSLSocketFactories, or HostnameVerifiers with permissive verification strategies.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid main-in-the-middle and other attacks that proper SSL configuration should avoid.]]></benefits>
    <inconvenients><![CDATA[Closing the gaps opened by a flawed SSL configuration may produce connection errors with certain hosts.]]></inconvenients>
    <example><![CDATA[// Any server certificates are accepted
X509TrustManager trustAnything = new X509TrustManager() {
  @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {}
  @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {}
  @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0];}
};

SSLContext ctx = SSLContext.getInstance("SSL");

// VIOLATION, flawed customized SSL verification
ctx.init(null, new TrustManager[]{trustAnything}, SecureRandom.getInstance("SHA1PRNG"));

HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
URL url = new URL("https://spoofable.mybank.com/online-banking");
return url.openConnection().getInputStream();]]></example>
    <repair><![CDATA[SSLContext ctx = SSLContext.getInstance("SSL");

// FIXED, null here means to use the default (with proper validations) implementation
ctx.init(null, null, SecureRandom.getInstance("SHA1PRNG"));

HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
URL url = new URL("https://spoofable.mybank.com/online-banking");
return url.openConnection().getInputStream();]]></repair>
    <reference><![CDATA[An Analysis of Android SSL (In)Security - http://android-ssl.org/files/p50-fahl.pdf,https://cwe.mitre.org/data/definitions/296.html,https://www.securecoding.cert.org/confluence/display/java/MSC00-J.+Use+SSLSocket+rather+than+Socket+for+secure+data+exchange,https://cwe.mitre.org/data/definitions/297.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC00-J,CWE:296,CWE:297,CWE:298,CWE:299,OWASP:2021:A2,OWASP:2021:A7,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsecureTransport" message="InsecureTransport: Insecure transport" class="com.optimyth.qaking.security.rules.java.InsecureTransport" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.1.1,ASVS-v4.0.2:6.1.2,ASVS-v4.0.2:6.1.3,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Communications sent over HTTP (Hypertext Transfer Protocol) protocol are in plain text, so
they are fully exposed to attacks such as man in the middle. This situation is not acceptable when sensible information
is being communicated.

Using HTTPS (Hypertext Transfer Protocol Secure) allows to perform encrypted connections between the user and the server
using SSL (Secure Sockets Layer) or TLS (Transport Layer Security) certificates. These certificates use an asymmetric
public key infrastructure (PKI) system, which consists in two keys, one of them public distributed to the users, and the
other private stored into the server.

When a connection to a web page is started the server sends a SSL/ TSL certificate to the user's browser, and then they
establish a secure connection.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improve security at the transport layer, avoiding interception of potential sensible data.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.net.URL;

String myURL = "http://myorg.com/myapi";
loadPage(new URL(myURL)); // VIOLATION]]></example>
    <repair><![CDATA[import java.net.URL;

// FIXED - Use HTTPS protocol
String myURL = "https://myorg.com/myapi";
loadPage(new URL(myURL));]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/326.html,http://cwe.mitre.org/data/definitions/311.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:311,OWASP:2021:A4,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="checkFtpConn" descname="When true then insecure FTP connections are checked too." value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsufficientKeySizeRule" message="InsufficientKeySizeRule: Weak cryptography, insufficient key length" class="com.optimyth.qaking.security.rules.java.InsufficientKeySizeRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.6.1,ASVS-v4.0.2:1.6.2,ASVS-v4.0.2:1.6.3,ASVS-v4.0.2:1.6.4,ASVS-v4.0.2:2.6.3,ASVS-v4.0.2:2.7.6,ASVS-v4.0.2:2.8.2,ASVS-v4.0.2:2.8.3,ASVS-v4.0.2:2.9.1,ASVS-v4.0.2:6.2.1,ASVS-v4.0.2:6.2.3,ASVS-v4.0.2:6.2.4,ASVS-v4.0.2:6.2.5,ASVS-v4.0.2:6.2.6,ASVS-v4.0.2:6.2.7,ASVS-v4.0.2:6.4.2,ASVS-v4.0.2:9.1.2,ASVS-v4.0.2:9.1.3,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[A robust cryptographic algorithm (like RSA or AES) with a small key length could be vulnerable to brute-force type attacks.

For symmetric ciphers, AES-CBC (FIPS 197) is the most often recommended algorithm nowadays, with a block size of at least
64 bits (128 bits for the better). Recommended minimum key length for AES is 128 bits for most usages, but for long-range
security, 192 bits or even 256 bits are often recommended.

DES and DESede (or "triple-DES") are, nowadays, not robust enough for most applications. Many algorithms used in the past,
like Blowfish or RC2, are now deemed insecure.

For asymetric cryptography ("public key"), the algorithm most often used is RSA. Most experts consider 2048 as the
most adequate key length for common needs, as its usage in digital signature and other applications demand cryptographic
robustness for a long period of time. Experts now consider 1024 bits for RSA keys (modulus) not enough secure.

Algoritms based on elliptic curves cryptography (like EC-DSA) typically require smaller key sizes, around 200 bits.

See http://www.keylength.com for an interactive site showing current recommendations in cryptographic algorithms,
key length and other issues to take into account.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private static final String RSA = "RSA";
private static final int SIZE_MIN = 512;
// ...
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(512); //VIOLATION

KeyPairGenerator kg = KeyPairGenerator.getInstance(RSA);
kg.initialize(SIZE_MIN); //VIOLATION]]></example>
    <repair><![CDATA[private static final String RSA = "RSA";
private static final int SIZE_MIN = 2048;
// ...
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048); //OK

KeyPairGenerator kg = KeyPairGenerator.getInstance(RSA);
kg.initialize(SIZE_MIN); //OK]]></repair>
    <reference><![CDATA[http://www.keylength.com/,http://cwe.mitre.org/data/definitions/320.html,http://cwe.mitre.org/data/definitions/326.html,http://cwe.mitre.org/data/definitions/310.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:310,CWE:320,CWE:326,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="minKeySize" descname="Comma-separated list of minimum key size per algorithms" value="RSA/2048, DSA/2048, EC/256, AES/128, DiffieHellman/2048"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.InsufficientSessionExpirationRule" message="InsufficientSessionExpirationRule: Checks that session expiration interval is positive and does not exceed a limit" class="com.optimyth.qaking.security.rules.java.InsufficientSessionExpirationRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.8.1,ASVS-v4.0.2:2.8.6,ASVS-v4.0.2:3.3.1,ASVS-v4.0.2:3.3.2,ASVS-v4.0.2:3.3.3,ASVS-v4.0.2:3.3.4,ASVS-v4.0.2:3.6.1,ASVS-v4.0.2:3.6.2,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Checks that when setting in code (HttpSession.setMaxInactiveInterval()) a session
expiration interval, interval is not negative or zero (no expiration) and does not exceed a maximum interval.

If a negative interval is set, session never expires. If exceeds the maxExpiration parameter, session lives too much
time and it is considered a security issue.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Controlling session expiration interval improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpSession;

public class InsufficientSessionExpiration {

  public void bad(HttpSession session) {
    session.setMaxInactiveInterval(-1);   // VIOLATION
  }

  public void bad2(HttpSession session) {
    session.setMaxInactiveInterval(4*SECONDS_PER_HOUR);   // VIOLATION
  }

}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpSession;

public class InsufficientSessionExpiration {

  private static final int SECONDS_PER_HOUR = 60*60;

  public void ok(HttpSession session) {
    session.setMaxInactiveInterval(SECONDS_PER_HOUR);   // OK
  }

}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/613.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:613,OWASP:2021:A7]]></security>
    </normatives>
    <properties>
      <property name="maxExpiration" descname="Max time expiration allowed (seconds)" value="7200"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.J2eeFileDisclosureRule" message="J2eeFileDisclosureRule: File disclosure in server-side J2EE forward/include" class="com.optimyth.qaking.security.rules.java.J2eeFileDisclosureRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.12.1,ASVS-v4.0.2:12.5.1,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Constructing a server-side forward/include with user-controlled input could allow an attacker to view arbitrary files
and configuration files, or download application binaries (including application classes or jar files),
within protected directories (e.g. /WEB-INF).

If a user-controlled input (a request parameter, for example) is used as the relative path for a forward/include,
the attacker may force the vulnerable web resource to return the contents of a sensitive file. For example,
using "WEB-INF/web.xml" the attacker may view the J2EE web application configuration file. With "WEB-INF/lib/mySensitiveLibrary.jar"
the attacker may download the code for a library that should not be exposed. The attacker may gain important
information to launch other attacks.

NOTE: Even when the application server denies to serve resources under certain directories (like WEB-INF),
application code should not present this flaw to avoid issues when porting to other application server or
after changes in the configuration.

The rule checks for server-side forward/include using the servlet API, where the target relative URL could be tainted with
user-controlled input.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid attacks directed to accessing sensitive web application resources.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<% String header = request.getParameter("header"); %>
<jsp:include page="<%=header%>" /> <!-- VIOLATION -->]]></example>
    <repair><![CDATA[<%
  String header = (String)request.getAttribute("header"); // set by controller in server-side
  String headerUrl = application.getAttribute("MyUrlMapper").fetch(dest);
  if(headerUrl==null) headerUrl = "/emptyHeader.jsp";
%>
<jsp:include page="<%=headerUrl%>" />]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/552.html,https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet]]></reference>
    <normatives>
      <security><![CDATA[CWE:552,OWASP:2021:A1,PCI-DSS:6.5.1,WASC:38]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.JSONInjection" message="JSONInjection: Avoid using non-neutralized user-controlled input into JSON entities - JSON Injection" class="com.optimyth.qaking.security.rules.java.JSONInjection" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.6,ASVS-v4.0.2:13.3.2,ASVS-v4.0.2:3.5.3,CWEScope:Integrity]]></tags>
    <description><![CDATA[Unvalidated untrusted input is concatenated to a JSON stream, which is sent as request to a potentially service.
This allows an attacker to inject tailored content that change the semantics of the original JSON message.

Depending on how the JSON-formatted data is later used, the attacker could execute unexpected dynamic code, or
escape from authentication or authorization controls. If the resulting JSON string is evaluated in JavaScript
(JavaScript may eval a string and treat it as an array or JavaScript object), the attacker may add additional
code (for example, an attack payload like "'}; while(1); //" that could produce a denial-of-service condition.

Note: Do not confuse this issue with JSON (or JavaScript) hijacking, which is a browser-side vulnerability
where an attacker can steal sensitive information sent as JSON to victim's browser.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid JSON Injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import javax.servlet.http.HttpServletRequest;

public void sendJsonMessage(HttpServletRequest req) throws IOException {
  String username = req.getParameter("username");
  String password = req.getParameter("password");
  String jsonFragment = req.getParameter("jsonFragment");

  StringWriter sw = new StringWriter(1024);
  JsonGenerator gen = new JsonFactory().createGenerator(sw);
  gen.writeStartObject();

  gen.writeFieldName("username");
  gen.writeRawValue("\"" + username + "\""); // VIOLATION

  gen.writeFieldName("password");
  gen.writeRawValue("\"" + password + "\""); // VIOLATION

  gen.writeFieldName("role");
  gen.writeRawValue("\"default\"");

  gen.writeRaw(jsonFragment); // VIOLATION

  gen.writeEndObject();
  gen.close();

  sendJsonToSensitiveSite(sw.toString());
}]]></example>
    <repair><![CDATA[// Do not use writeRawValue() or writeRaw();
// use instead other writeXYZ() methods that escape properly inputs
// so they cannot change the semantics of the JSON elements built.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/345.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:91,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.LdapInjectionRule" message="LdapInjectionRule: Avoid non-neutralized user-controlled input in LDAP search filters" class="com.optimyth.qaking.security.rules.java.LdapInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.7,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software constructs all or part of an LDAP query using externally-influenced input, but it does not neutralize or
    incorrectly neutralizes special elements that could modify the intended LDAP query when sent to LDAP server.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.io.FileFilter;
import java.util.Properties;

public class LdapInjection {

  public NamingEnumeration ldapInjection(HttpServletRequest req, Properties env) throws NamingException {
    String base = "cn=root";
    String address = req.getParameter("input");
    DirContext context = new InitialDirContext(env);
    String query = "MyAttribute=" + address;
    return context.search(base, query, null);   // VIOLATION
  }

}]]></example>
    <repair><![CDATA[// Neutralize external input (e.g. address) before usage in query]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/IDS54-J.+Prevent+LDAP+injection,http://cwe.mitre.org/data/definitions/90.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS54-J,CWE:90,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:29]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.MailCommandInjection" message="MailCommandInjection: Mail Command Injection" class="com.optimyth.qaking.security.rules.java.MailCommandInjection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Integrity]]></tags>
    <description><![CDATA[Mail command injection vulnerabilities occur when an attacker can influence the commands sent to an SMTP, POP3, or IMAP mail server.
If the library or the developer fails to safely encode the line breaks, an attacker controlling any of the arguments for these commands
will be able to inject line breaks and new commands after them.

As line breaks are the usual mechanism that attackers use to change the expected behaviour, this vulnerability
is considered a special CRLF Injection attack.

What the attacker may launch by exploting a Mail Command Injection vulnerability include:
- Generate spam (SMTP). The application acts as a "mail proxy" that attackers may use to create spam messages.
- Read messages from other users (POP3/IMAP).
- Abusing a trusted server to send HTML emails with malicious contents.
- Change authentication or security options, to skip security controls in mail servers.

See "MX Injection: Capturing and Exploiting Hidden Mail Servers", from Vicente Aguilera, for a full description on
the benefits that an attacker may gain.

The rule checks when vulnerable mail libraries are called with untrusted input, without validation, which might be vulnerable
to Mail Command Injection attacks.

Note: Many common java libraries, for example JavaMail, Apache Commons-Net, or Spring Mail support, are still vulnerable.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid Mail Command Injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.mail.*;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
// ...
String subject = request.getParameter("subject"); // untrusted
String message = request.getParameter("message");

Message msg = new MimeMessage(session);
msg.setSentDate(new Date());
msg.setFrom(new InternetAddress(userName));
msg.addRecipient(Message.RecipientType.TO, new InternetAddress(toAddress));
msg.setSubject(subject); // VIOLATION, vulnerable to mail command injection
msg.setText(message);

Transport.send(msg);]]></example>
    <repair><![CDATA[// validate untrusted subject input with a white-list strategy,
// or at least ensure that line breaks (CR/LF) are removed from subject.]]></repair>
    <reference><![CDATA[OWASP Testing for IMAP/SMTP injection: https://www.owasp.org/index.php/Testing_for_IMAP/SMTP_Injection_(OTG-INPVAL-011),http://www.webappsec.org/projects/articles/121106.pdf,http://projects.webappsec.org/w/page/13246948/Mail%20Command%20Injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:93,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:30]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.NonRandomIVWithCBCMode" message="NonRandomIVWithCBCMode: Not using a Random IV with CBC Mode" class="com.optimyth.qaking.security.rules.java.NonRandomIVWithCBCMode" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,crypto,essential]]></tags>
    <description><![CDATA[Not using a random initialization Vector (IV) with Cipher Block Chaining (CBC) Mode causes encryption to be susceptible to dictionary attacks.

CBC mode with predictable IV allows a well-known chosen plaintext attack, and is definitely unsecure.

Note: For other feedback modes, NIST recommends unpredictable IVs for CFB, and unique (non-repeating, like an increasing counter or message number) IVs
for OFB, CTR or PCBC, and for GCM plus other authenticated encryption modes, but certainly the IV should not be eligible by an attacker.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public void encrypt(SecretKey key) throws GeneralSecurityException {
  Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); // CBC mode
  byte[] predictableIV = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; // hardcoded IV, obviously predictable
  cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(predictableIV)); // VIOLATION
  // ...
}]]></example>
    <repair><![CDATA[public void encrypt(SecretKey key) throws GeneralSecurityException {
  Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); // CBC mode
  byte[] randomIV = new byte[16];
  new SecureRandom().nextBytes(randomIV);
  cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(randomIV)); // FIXED, random IV
  byte[] encodedIV = cipher.getParameters().getEncoded(); // needed for decryption, along with ciphertext
  // ...
}]]></repair>
    <reference><![CDATA[https://crypto.stackexchange.com/questions/3515/is-using-a-predictable-iv-with-cfb-mode-safe-or-not,http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:329,OWASP:2021:A2,PCI-DSS:3.6.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.NoSQLInjection" message="NoSQLInjection: Improper neutralization of special elements in data query logic (NoSQL injection)" class="com.optimyth.qaking.security.rules.java.NoSQLInjection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,NoSQL]]></tags>
    <description><![CDATA[The application generates a query intended to access or manipulate data in a data store such as a NoSQL database,
but it does not neutralize or incorrectly neutralizes special elements that can modify the intended logic of the query.

Depending on the capabilities of the query language, an attacker could inject additional login into the query to:
- Modify the intended selection criteria, thus changing which data entities (e.g., records) are returned, modified, or otherwise manipulated.
- Append additional commands to the query.
- Return more or fewer entities than intended.
- Cause entities to be sorted in an unexpected way.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent NoSQL injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import com.mongodb.*;
import com.mongodb.util.JSON;

public class LoginController {
  private DBCollection users = fetchUsersCollection();

  public User authenticate(HttpServletRequest req) {
    String user = req.getParameter("user"); // attacker-controlled
    String pass = req.getParameter("pass"); // attacker-controlled

    // The query object is tainted with non-neutralized untrusted input (user)
    String json = String.format("{ 'username' : '%s', 'password' : '%s' }", user, pass);
    // We parse here whatever JSON the attacker wishes to create...
    // $or operator is a common way to change query semantics
    // Attackers may even encode arbitrary JavaScript code in $where operator, if enabled
    DBObject dbQuery = (DBObject) JSON.parse(json);

    DBObject matched = users.findOne(dbQuery); // VIOLATION, NoSQL injection

    return matched != null ? User.from(matched) : null;
  }
}]]></example>
    <repair><![CDATA[import com.mongodb.*;
import com.mongodb.util.JSON;

public class Login {
  private DBCollection users = fetchUsersCollection();

  public User authenticate(HttpServletRequest req) {
    String user = req.getParameter("user");
    String pass = req.getParameter("pass");
    String passHash = computePasswordHash(user, pass);

    // FIXED, each key/value appended to BasicDBObject are encoded properly
    BasicDBObject dbQuery = new BasicDBObject("username", user).append("password", passHash);

    DBObject matched = users.findOne(dbQuery); // safe

    return matched != null ? User.from(matched) : null;
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/943.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:943,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, system_information, other_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.OpenRedirectRule" message="OpenRedirectRule: URL Redirection to Untrusted Site ('Open Redirect')" class="com.optimyth.qaking.security.rules.java.OpenRedirectRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.5,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a redirect.
This is client-side redirect, either by setting the Location header or by calling HttpServletResponse sendRedirect() method.

If the redirect URL is user-controlled (e.g. fetched from HTTP request parameter), an attacker may force an user to
provide a malicious URL encoded in a link to the vulnerable resource. The browser will redirect to the malicious URL,
and the attacker may deceive the victim user for phising or other malicious activities.

The rule checks for client-side redirections in server-side code, using servlet API. Redirections based on HTTP
headers "Location" and "Refresh" are also checked.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limits phising attacks, and unintended client-side redirections.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<%
  String dest = request.getParameter("dest");
  response.sendRedirect(dest); // VIOLATION
  response.setHeader("Location", dest); // OTHER VIOLATION
  response.setHeader("Refresh", "0;url="+dest); // OTHER VIOLATION
%>]]></example>
    <repair><![CDATA[<%
  String dest = (String)request.getAttribute("dest");
  String url = application.getAttribute("MyUrlMapper").fetch(dest);
  if(url==null) {
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
  } else {
    response.sendRedirect(dest); // FIXED
  }
%>]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet,http://cwe.mitre.org/data/definitions/601.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:601,CWETOP25:2021:37,OWASP:2013:A10,PCI-DSS:6.5.1,WASC:38]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PasswordInCommentRule" message="PasswordInCommentRule: Avoid hard-coded or in-comment passwords in code" class="com.optimyth.qaking.security.rules.java.PasswordInCommentRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Hardcoded passwords can compromise system security in a way that cannot be easily remedied.
It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem 
extremely difficult. Once the code is in production, the password cannot be changed without patching the software.
If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.

The rule checks if there are comments in the code that contain expressions that match with the pattern, so it can lead to several false positives and/or false negatives.

This rule not only applies to Java comments but only to HTML comments included into an HTTP response, however to allow this it's mandatory to enable the processHTMLEmbeddedComments
property.]]></description>
    <priority>5</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// password is: mypazzw0rk                               -> VIOLATION
// password is the first argument                        -> VIOLATION, BUT FALSE POSITIVE
// magic word for connecting to database is: mypazzw0rk  -> NOT VIOLATION, BUT FALSE NEGATIVE

public void bad(HttpServletRequest request, HttpServletResponse response) throws Throwable
{
  response.getWriter().println("<!--DB username = amy, password = cat-->");  // VIOLATION
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/MSC03-J.+Never+hard+code+sensitive+information,http://cwe.mitre.org/data/definitions/615.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC03-J,CWE:615,OWASP:2021:A7,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="processHTMLEmbeddedComments" descname="When enabled HTML comments included into an HTTP response are also analyzed." value="false"/>
      <property name="pattern" descname="Password pattern" value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PasswordInConfigurationFile" message="PasswordInConfigurationFile: Use of credentials into configuration file" class="com.optimyth.qaking.security.rules.java.PasswordInConfigurationFile" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[Passwords written into a configuration file which is distributed along with the code are
visible to any person reading the source code. If the resource protected by such hardcoded credentials is important, this
may compromise system security.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid credential leakage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[[sample.properties]
my.secret.password=abcdefgh]]></example>
    <repair><![CDATA[Properties configuration file should not be distributed along with the project.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/260.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:260,OWASP:2021:A5]]></security>
    </normatives>
    <properties>
      <property name="pattern" descname="Regular expression for matching field names containing credentials." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PasswordInRedirectRule" message="PasswordInRedirectRule: Password Management - Password in Redirect" class="com.optimyth.qaking.security.rules.java.PasswordInRedirectRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.3,ASVS-v4.0.2:3.1.1,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Sending a password as part of an HTTP redirect will cause the password to be displayed, logged, or stored in a cache.
An HTTP redirect causes the user's web browser to issue an HTTP GET request. By convention, the parameters associated with an HTTP GET are not treated as sensitive data, 
so web servers log them, proxies cache them, and web browsers do not make an effort to conceal them.
Sending a password or other sensitive data as part of a redirect will likely cause the data to be mishandled and potentially revealed to an attacker.
The rule checks if there are parts of the redirect chain that contain expressions that match with the pattern, so it can lead to several false positives and/or false negatives.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public void method(HttpServletRequest req, HttpServletResponse res) throws IOException {
  res.sendRedirect("j_security_check?j_username=" + usr + "&j_password=" + pass);   //VIOLATION
  // ...
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/359.html,https://wiki.sei.cmu.edu/confluence/display/java/FIO52-J.+Do+not+store+unencrypted+sensitive+information+on+the+client+side]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:FIO52-J,CWE:598,OWASP:2021:A7,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="sendRedirectInResponseMethods" descname="Comma-separated list of send redirect methods" value="sendRedirect"/>
      <property name="passPattern" descname="Password key words pattern" value="(:|=|&amp;)[\w]*(?:password|passwd|contrase..?a|senha|passwort|mot\s+de\s+passe)\b"/>
      <property name="j_passwordPatter" descname="Password key words pattern" value="\b(j_password)\b"/>
      <property name="responseClasses" descname="Comma-separated list of response classes" value="javax.servlet.ServletResponse, ServletResponse, javax.servlet.http.HttpServletResponse, HttpServletResponse"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PathTraversalRule" message="PathTraversalRule: Avoid non-neutralized user-controlled input composed in a pathname to a resource" class="com.optimyth.qaking.security.rules.java.PathTraversalRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.1,ASVS-v4.0.2:12.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software uses external input to construct a pathname that is intended to identify a file or directory
that is located underneath a restricted parent directory, but the software does not properly neutralize
special elements within the pathname that can cause the pathname to resolve to a location outside the
restricted directory.

Under an application server, if the application server configuration does not restrict access to files outside
certain restricted directories, the attacker may fetch sensitive files, and if the file is written with contents
controlled by user input, the attacker may change configuration files (like web.xml among others), web contents
('web defacement'), or libraries (for more insidious code injection attacks). Access to system files
(the customary /etc/password in Unix/Linux systems) could also allowed with the app server account permissions.

It is recommended, besides ensuring that files depending on user-controlled input do not exit the intended directories,
that the OS account does have the minimal permissions, to reduce the impact of a successful path traversal attack.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;

public class PathTraversalCode {

  public InputStream indirectPathTraversal(HttpServletRequest req) throws IOException {
    String inputFile = req.getParameter("file");
    inputFile = inputFile + ".tmp";
    return new FileInputStream(SAFE_DIR.getAbsoluteFile() + inputFile);   // VIOLATION
  }

}]]></example>
    <repair><![CDATA[import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;

public class PathTraversalCode {

  public InputStream indirectPathTraversal(HttpServletRequest req) throws IOException {
    String inputFile = req.getParameter("file");
    inputFile = inputFile + ".tmp";
    String filename = new File(inputFile).getName();
    return new FileInputStream(new File(SAFE_DIR, filename));   // OK
  }

}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/22.html,http://cwe.mitre.org/data/definitions/73.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:22,CWE:73,CWETOP25:2021:8,OWASP:2021:A4,OWASP:2021:A5,PCI-DSS:6.5.8,WASC:33]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PlaintextStorageInACookieRule" message="PlaintextStorageInACookieRule: Cleartext Storage of Sensitive Information in a Cookie" class="com.optimyth.qaking.security.rules.java.PlaintextStorageInACookieRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Sensitive data stored in a encoded way makes harder to read it than it was stored in plaintext.
        An attacker could use widely-available tools to view cookie content.
        The rule checks whether a cookie with sensitive data is being stored without any kind of encoding.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Encoding data to be stored in a coookie improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class PlaintextStorageInACookie {
  private static final String SECRET = "IKnowWhoKilledKennedy";

  public void sendSensitiveCookie(HttpServletRequest req, HttpServletResponse res) {
    Cookie cookie = new Cookie("username", SECRET); // VIOLATION, sensitive cookie name, value in clear-text
    cookie.setSecure(true); // secure
    cookie.setMaxAge(-1); // non persistent
    cookie.setHttpOnly(true); // httpOnly
    res.addCookie(cookie);
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.security.MessageDigest;
import java.util.Base64;

public class PlaintextStorageInACookie {
  private static final String SECRET = "IKnowWhoKilledKennedy";

  public void sendSensitiveCookie(HttpServletRequest req, HttpServletResponse res) {
    Cookie cookie = new Cookie("username", hash(SECRET)); // OK, sensitive value not in cleartext
    cookie.setSecure(true); // secure
    cookie.setMaxAge(-1); // non persistent
    cookie.setHttpOnly(true); // httpOnly
    res.addCookie(cookie);
  }

  private String hash(String value) {
    MessageDigest digest = MessageDigest.getInstance("SHA-256");
    byte[] hashed = digest.digest(value);
    return Base64.getEncoder().encodeToString(hashed);
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/315.html,https://www.owasp.org/index.php/Plaintext_Storage_in_Cookie,https://cwe.mitre.org/data/definitions/312.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:312,CWE:315]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PlaintextStorageOfPassword" message="PlaintextStorageOfPassword: Plaintext Storage of a Password" class="com.optimyth.qaking.security.rules.java.PlaintextStorageOfPassword" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.7.5,CWEScope:Access-Control,credentials]]></tags>
    <description><![CDATA[Storing a password in plaintext may result in a system compromise.

Password management issues occur when a password is stored in plaintext in an application's properties or configuration file.
Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[FileInputStream is = new FileInputStream(CONFIG_FILE);
Properties config = new Properties();
config.load(is);

String dbHost = config.getProperty("db.host");
String dbUser = config.getProperty("db.user");
String dbPass = config.getProperty("db.pass");

Connection dbConn = DriverManager.getConnection(dbHost, dbUser, dbPass); // VIOLATION]]></example>
    <repair><![CDATA[FileInputStream is = new FileInputStream(CONFIG_FILE);
Properties config = new Properties();
config.load(is);

String dbHost = config.getProperty("db.host");
String dbUser = config.getProperty("db.user");
String encryptedDbPass = config.getProperty("db.pass");
String dbPass = decrypt(encryptedDbPass); // FIXED

Connection dbConn = DriverManager.getConnection(dbHost, dbUser, dbPass);]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/256.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:256,OWASP:2021:A4,PCI-DSS:6.3.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PlaySecurityMisconfiguration" message="PlaySecurityMisconfiguration: Security misconfiguration in Play framework." class="com.optimyth.qaking.security.rules.java.PlaySecurityMisconfiguration" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.9.1,ASVS-v4.0.2:13.2.3,ASVS-v4.0.2:2.2.5,ASVS-v4.0.2:4.2.2,ASVS-v4.0.2:5.3.3,ASVS-v4.0.2:8.3.1,ASVS-v4.0.2:9.1.1,ASVS-v4.0.2:9.2.2,Framework:Play]]></tags>
    <description><![CDATA[Play framework provides several filters that could block/mitigate common attacks in a web application.
These filters are configured in the application configuration files (like application.conf). In recent versions,
many filters are enabled and properly configured by default.

In particular, three filters are enabled by default:
- CSRFFilter, which provide protection against CSRF (cross-site request forgery) attacks, using a CSRF token that
  enables any sensitive action to execute only if the token is passed from another site resource, which avoids CSRF.

- SecurityHeadersFilter, which sets security-related HTTP headers for protection/mitigation of cross-site scripting,
  clickjacking, MIME sniffing, Adobe Flash cross-domain policy hijacking, Referer header leakage, and other security issues.

- AllowedHostsFilter, which sets a whitelist of hosts that can access the application. This is useful to prevent
  cache poisoning attacks.

In addition, a RedirectHttpsFilter (not enabled by default) could be enabled for redirecting all HTTP requests to HTTPS automatically.

Disabling these filters, or misconfiguring them with incorrect or too-permisive values, might open the avenue for security vulnerabilities.
The rule reports any suspicious configuration element.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[play.filters {
  # VIOLATION - CSRF filter disabled (when csrfFilter=true)
  disabled += play.filters.csrf.CSRFFilter
  # SecurityHeadersFilter and AllowedHostsFilter enabled unless disabled explicitly

  # VIOLATION - HTTPS Redirect not explcitly enabled (when redirectHttps=true)
  #enabled += play.filters.https.RedirectHttpsFilter

  # Security headers filter configuration
  headers {

    # VIOLATION - X-Frame-Options header not set.
    frameOptions = null

    # VIOLATION - X-XSS-Protection header disabled.
    xssProtection = "0"

    # VIOLATION - X-Content-Type-Options header not set to "nosniff".
    contentTypeOptions = null

    # VIOLATION - Too-permissive X-Permitted-Cross-Domain-Policies header.
    permittedCrossDomainPolicies = "all"

    # VIOLATION - Content-Security-Policy header not set.
    contentSecurityPolicy = null

    # VIOLATION - unsafe Referrer-Policy header.
    referrerPolicy = "unsafe-url"

    # VIOLATION - Allows an action to use .withHeaders to replace one or more of the above headers
    # (emittd when allowActionSpecificHeaders=true)
    allowActionSpecificHeaders = true
  }

  hosts {
    # VIOLATION - ".other.com" not allowed (when allowedHosts=localhost, .myorg.com)
    allowed = ["localhost", ".myorg.com", ".other.com"]
  }
}]]></example>
    <repair><![CDATA[play.filters {
  # Do not disable default filters, and enable RedirectHttpsFilter
  enabled += play.filters.https.RedirectHttpsFilter

  # Security headers filter configuration. When a value not specified, the default is deemed safe.
  headers {

    frameOptions = "DENY"

    xssProtection = "1"

    contentTypeOptions = "nosniff"

    permittedCrossDomainPolicies = "master-only"

    contentSecurityPolicy = "default-src 'self'"

    referrerPolicy = "origin-when-cross-origin, strict-origin-when-cross-origin"

    allowActionSpecificHeaders = false
  }

  hosts {
    allowed = ["localhost", ".myorg.com"]
  }
}]]></repair>
    <reference><![CDATA[https://nvisium.com/resources/blog/2017/10/04/play-2-6-security-analysis.html,https://www.playframework.com/documentation/2.6.x/resources/confs/filters-helpers/reference.conf,https://www.playframework.com/documentation/2.6.x/Filters]]></reference>
    <normatives>
      <security><![CDATA[CWE:183,CWE:319,CWE:352,CWE:693,CWE:79,CWETOP25:2021:2,CWETOP25:2021:35,CWETOP25:2021:9,OWASP:2021:A1,OWASP:2021:A2,OWASP:2021:A3,OWASP:2021:A4,WASC:47]]></security>
    </normatives>
    <properties>
      <property name="redirectHttps" descname="True if RedirectHttpsFilter should be enabled." value="false"/>
      <property name="allowActionSpecificHeaders" descname="True if it is allowed for actions to change the security headers programmatically." value="false"/>
      <property name="csrfFilter" descname="True if CSRFFilter should be enabled." value="true"/>
      <property name="allowedHosts" descname="Comma-separated list of allowed hosts. Leave empty to ignore the whitelist in app configuration." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.PotentialInfiniteLoop" message="PotentialInfiniteLoop: Loop with Unreachable Exit Condition ('Infinite Loop')" class="com.optimyth.qaking.security.rules.java.PotentialInfiniteLoop" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,essential,potential-bug]]></tags>
    <description><![CDATA[The program contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.
Such infinite loop conditions are due typically to logical errors in the loop exit conditions and/or loop variables update,
where the loop exit condition is never reached.

An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory, and might compromise software availability.

NOTE: Rule OPT.JAVA.SEC_JAVA.UncheckedInputInLoopCondition (CWE-606) checks when an untrusted input, not validated, might influence
loop termination leading to a denial-of-service condition.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[T[][] arr = fetchArray();

for (int i=0; i < arr.length; i++) {
  T[] row = arr[i];
  // VIOLATION: infinite loop
  // a typo after copy+paste external loop, inner loop var j not updated
  for (int j=0; j < row.length; i++) {
     doSomething(row[j]);
  }
}]]></example>
    <repair><![CDATA[T[][] arr = fetchArray();

for (int i=0; i < arr.length; i++) {
  T[] row = arr[i];
  // FIXED
  for (int j=0; j < row.length; j++) {
     doSomething(row[j]);
  }
}]]></repair>
    <reference><![CDATA[https://blog.jooq.org/2015/01/16/infinite-loops-or-anything-that-can-possibly-go-wrong-does/]]></reference>
    <normatives>
      <security><![CDATA[CWE:835,CWETOP25:2020:36]]></security>
    </normatives>
    <properties>
      <property name="allowBooleanMethodsAsNeutralizers" descname="If true the methods defined in &quot;potentialInfiniteLoopNeutralizer&quot; will be considered as potential neutralizers of infinite loops.]" value="false"/>
      <property name="potentialInfiniteLoopNeutralizer" descname="Comma-separated list of methods that could neutralize an infinite loop. The methods must be indicated with the qualified name of the class, e.g., a.b.c.d(). ]" value=""/>
      <property name="allowExplicitInfiniteLoops" descname="Intentional non-empty infinite loops, coded as while(true)  for(;;), are allowed." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ProcessControlRule" message="ProcessControlRule: Library loaded from untrusted source" class="com.optimyth.qaking.security.rules.java.ProcessControlRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.14.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,code-injection,scripting]]></tags>
    <description><![CDATA[Under Java, load() and loadLibrary() methods, in java.lang.System or java.lang.Runtime, load a native library.
For load(), the path to the library is specified, while for loadLibrary() the library name is specified and
a system-dependant search path is used (for example, java.library.path property, or LD_LIBRARY_PATH environmente variable).

If the argument depends on untrusted input (including in this category system environment or Java system properties),
a violation is emitted.

Additionally, any call to loadLibrary() (if rule property 'avoidLoadLibrary' is true) will produce a violation
of the rule, as according to the method documentation:

"Loads the dynamic library with the specified library name. A file containing native code is loaded from the
local file system from a place where library files are conventionally obtained. The details of this process are
implementation-dependent. The mapping from a library name to a specific filename is done in a system-specific manner",

so an attacker could place a malicious library with same name as the loaded library upper in the search path,
which may run with elevated privileges.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid native code injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[  void m() {
    // considered unsafe if avoidLoadLibrary=true
    Runtime.getRuntime().loadLibrary("supposedlySafeLibInSearchPath"); /* VIOLATION */
  }

  // This is considered unsafe if allowSystemConfiguration=false
  private static final String PATH = System.getProperty("my.library.path");
  void m2() {
    File f = new File(PATH, "cannotSpoofMe.dll");
    System.load(f.getAbsolutePath()); /* VIOLATION */
  }]]></example>
    <repair><![CDATA[  void m() {
    // add a suppression or set avoidLoadLibrary=false
    Runtime.getRuntime().loadLibrary("supposedlySafeLibInSearchPath"); /* CONSIDERED SAFE */
  }

  // Set allowSystemConfiguration=true, or set allowSystemConfiguration=true
  private static final String PATH = System.getProperty("my.library.path");
  void m2() {
    File f = new File(PATH, "cannotSpoofMe.dll");
    System.load(f.getAbsolutePath()); /* CONSIDERED SAFE */
  }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/676.html,http://cwe.mitre.org/data/definitions/114.html,http://security.stackexchange.com/questions/35724/security-implications-of-javas-system-load-vs-system-loadlibrary]]></reference>
    <normatives>
      <security><![CDATA[CWE:114,CWE:494,CWE:676,OWASP:2021:A1,OWASP:2021:A8,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="allowSystemConfiguration" descname="If false, any kind of input is considered untrusted; if true, only user input is considered untrusted" value="false"/>
      <property name="avoidLoadLibrary" descname="If true, loadLibrary() method is always considered unsafe" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.RaceConditionFormatFlaw" message="RaceConditionFormatFlaw: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')" class="com.optimyth.qaking.security.rules.java.RaceConditionFormatFlaw" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.11.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,race-condition]]></tags>
    <description><![CDATA[A race condition happened when a code sequence runs concurrently with other code, and the code sequence needs exclusive
access to a shared resource, but a time window exists in which the shared resource can be modified by another code sequence.

In security-critical code, a race condition may have security implications, specially when a security decision is made
on class state affected by a race condition.

The Java language provides a simple primitive, synchronized blocks, for avoiding thread interference and memory consistency errors.
Race conditions typically appear with class state (mutable fields, static or not) is used in methods without synchronization blocks.
Objects of a class are said to be thread-safe when they always maintain a valid state, as observed by other objects,
in multi-threaded environments.

A traditional cause of race conditions in Java are classes in the standard library (JDK), and in particular the java.text.Format
subclasses (like NumberFormat, MessageFormat, DateFormat or SimpleDateFormat), which are not thread-safe.

This rule reports usages of methods in object fields of non thread-safe JDK classes, outside synchronized blocks.
JavaDoc for such classes include a note on synchronization; for example, for java.text.SingleDateFormat:
"Date formats are not synchronized. It is recommended to create separate format instances for each thread.
If multiple threads access a format concurrently, it must be synchronized externally."]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.text.SimpleDateFormat;
import java.util.Date;

public class X {
  private static final SimpleDateFormat DATE_FMT = new SimpleDateFormat("yyyy-MM-dd");

  public String format(Date date) {
    return DATE_FMT.format(date); // VIOLATION
  }
}]]></example>
    <repair><![CDATA[import java.text.SimpleDateFormat;
import java.util.Date;
import org.apache.commons.lang3.time.FastDateFormat;
import java.time.format.DateTimeFormatter;

public class X {
  private static final SimpleDateFormat DATE_FMT = new SimpleDateFormat("yyyy-MM-dd");

  // Option #1 - synchronized block using mutable field as monitor object
  public String format2(Date date) {
    synchronized(DATE_FMT) {
      return DATE_FMT.format(date); // OK
    }
  }

  // Option #2 - add synchronized keyword to access method,
  // equivalent to method body enclosed in synchronized(this) block
  public synchronized String format3(Date date) {
    return sdf.format(date); // OK
  }

  // Option #3: Use a thread-safe date formatter API (like Apache commons-lang FastDateFormat)
  private static final FastDateFormat DATE_FORMATTER =
                       FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT);

  public String format4(Date date) {
    return DATE_FORMATTER.format(date); // OK, thread safe
  }

  // Option #4: Use Java8 DateTimeFormatter (immutable and thread-safe)
  private String format5(Date date) {
    return DateTimeFormatter.ISO_LOCAL_DATE.format(date);
  }
}]]></repair>
    <reference><![CDATA[http://stackoverflow.com/questions/6840803/simpledateformat-thread-safety,https://cwe.mitre.org/data/definitions/362.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:VNA02-J,CWE:362,CWETOP25:2021:33]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.RaceConditionServlet" message="RaceConditionServlet: Race Condition in a Java Servlet" class="com.optimyth.qaking.security.rules.java.RaceConditionServlet" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.11.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,race-condition]]></tags>
    <description><![CDATA[A race condition happened when a code sequence runs concurrently with other code, and the code sequence needs exclusive
access to a shared resource, but a time window exists in which the shared resource can be modified by another code sequence.

In security-critical code, a race condition may have security implications, specially when a security decision is made
on class state affected by a race condition.

HttpServlet is a singleton and so there is a unique instance. This way all threads runs the same instance of the servlet and access
the same fields.

This rule reports field declarations in Java Servelts.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServlet;

public class ExampleServlet extends HttpServlet {

    private Object thisIsNOTThreadSafe; //VIOLATION

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        thisIsNOTThreadSafe = request.getParameter("foo"); // BAD!! Shared among all requests!
    }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServlet;

public class ExampleServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Object thisIsThreadSafe; //OK
        thisIsThreadSafe = request.getParameter("foo"); // OK, this is thread safe.
    }
}]]></repair>
    <reference><![CDATA[https://stackoverflow.com/questions/3106452/how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreadi,https://securingtomorrow.mcafee.com/technical-how-to/testing-race-conditions-web-applications/,https://cwe.mitre.org/data/definitions/362.html,https://www.javaworld.com/article/2072798/java-web-development/write-thread-]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:VNA02-J,CWE:362,CWETOP25:2021:33]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ReflectedFileDownload" message="ReflectedFileDownload: Improper Neutralization of Input leads to Reflected File Download" class="com.optimyth.qaking.security.rules.java.ReflectedFileDownloadRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Reflected File Download (RFD) is a web attack vector that enables attackers to gain complete control over a victims
machine. It happens when the user follows a malicious link to a trusted domain resulting in a file download from that
domain. Once executed the attacker can execute commands on the Operating System level of the clients computer.

In order for an attacker to run a successful RFD attack, the following requirements need to be met:
 - The application reflects user-controllable data.
 - The application allows attackers to treat the server response as a file download.
 - Attackers can prevent the content-disposition header from setting a file name, and at the same time can influence the
 URL in such a way that the browser will derive an attacker-controlled file name.
 - Attackers can control the content-disposition file name and extension.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
public class SampleController {
  @RequestMapping(value = {"/KO"}, method = RequestMethod.GET)
  public ResponseEntity<String> download(@RequestParam("filename") String fileName) {
    HttpHeaders headers = new HttpHeaders();
    headers.setContentDisposition(ContentDisposition.builder("attachment").filename(fileName + ".txt"));  // VIOLATION

    return ResponseEntity.ok()
      .headers(headers)
      .contentType(MediaType.parseMediaType("application/octet-stream"))
      .body(contents);
  }
}]]></example>
    <repair><![CDATA[import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
public class SampleController {
  @RequestMapping(value = {"/OK"}, method = RequestMethod.GET)
  public ResponseEntity<String> download(@RequestParam("filename") String fileName) {
    String safeFileName = org.apache.commons.io.FilenameUtils.getName(fileName);
    ContentDisposition contentDisposition = ContentDisposition.builder("attachment")
      .filename(safeFileName + ".txt") // Secure .txt file
      .build();
    HttpHeaders headers = new HttpHeaders();
    headers.setContentDisposition(contentDisposition);

    return ResponseEntity.ok()
      .headers(headers)
      .contentType(MediaType.parseMediaType("application/octet-stream"))
      .body(contents);
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html,https://securitylab.github.com/research/rfd-spring-mvc-CVE-2020-5398,https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/reflected-file-download-a-new-web-attack-vector/]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP-M:2016:M8,OWASP:2021:A3]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.RegexInjectionRule" message="RegexInjectionRule: Prevent denial of service attack through malicious regular expression ('Regex Injection')" class="com.optimyth.qaking.security.rules.java.RegexInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.1.1,CWEScope:Access-Control,ReDoS]]></tags>
    <description><![CDATA[If the software creates a regular expression ("pattern", "regex") from untrusted input, an attacker may supply
malicious input that produces a denial-of-service (DoS) condition during regular expression matching.

Alternatively, if the regular expression is used for input validation, the attacker-controlled regular expression
may fail to neutralize undesired input, which may bypass the intended restrictions or render useless
a security control.

In Java, the java.util.regex.Pattern class, and a few methods in java.lang.String class, provide
an API to regular expressions. The regular expression engine uses backtracking to match input strings,
and there are certain regular expressions (named "evil regexes") that take exponential time (relative to input size)
to match in the worst case.

If the attacker controls also the input to be matched, he/she could craft an input for the evil regex that
takes an inordinate amount of time to match, consuming resources (like CPU).
Evil regex typically has a group with repetition, and the repeated group has repetition or alternation with overlapping.
For example: "(a+)+", "([a-z]+)*", "(a|aa)+" or "(aa|aab?)*".

For example, a "(a+)+" regex will take long computing time when matching "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!"
takes many seconds to complete, and longer strings (with exponential time increase) may lead to DoS conditions.

Please note that regular expressions are often used for security controls and input validation.
Even OWASP validation regex repository contained some known evil regular expressions.
Note: Attackers may use tools like Google CodeSearch to find evil regex in open-source code ('CodeSearch hacking').

The rule checks for potential injection of untrusted input into regex APIs.

Note: Attacks like ReDoS are named "directed/intelligent/application" DoS, as an attacker with few resources
could render unavailable a web application, in contrast with brute-force DoS.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid DoS conditions produced by regular expression injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.util.regex.*;
import javax.servlet.http.HttpServletRequest;

public class WebValidation {
  public void check(HttpServletRequest req, String field) throws IllegalInputException {
    String regex = req.getParameter("validation_hidden_field"); // not so hidden...
    String input = req.getParameter(field);

    boolean isValid = Pattern.compile(regex) /* VIOLATION: easy path to DoS attack */
      .matcher(input).matches();

    if(!isValid) throw new IllegalInputException("Bad value for " + field);
  }
}]]></example>
    <repair><![CDATA[import java.util.regex.*;
import javax.servlet.http.HttpServletRequest;

public class WebValidation {
  public void check(HttpServletRequest req, String field) throws IllegalInputException {
    // never let regex coming from untrusted source
    String regex = MyRegexRepository.getRegex(field); /* FIXED */
    String input = req.getParameter(field);

    boolean isValid = Pattern.compile(regex)
      .matcher(input).matches();

    if(!isValid) throw new IllegalInputException("Bad value for " + field);
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/400.html,https://www.securecoding.cert.org/confluence/display/java/IDS08-J.+Sanitize+untrusted+data+included+in+a+regular+expression,https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS,https://en.wikipedia.org/wiki/ReDoS]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS08-J,CWE:400,CWETOP25:2021:27,OWASP:2004:A9,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ResourceInjection" message="ResourceInjection: Improper control of resource identifiers (&quot;Resource Injection&quot;)" class="com.optimyth.qaking.security.rules.java.ResourceInjection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software takes from an untrusted source the identifier for a system resource (like a port number),
and allows access to a non-expected resource. Attackers may use the flaw for malicious behaviour,
for example a port scan, change software configuration, transmit sensitive information to a third-party server,
etc.

OWASP project uses the term "Insecure Direct Object Reference" instead of "Resource Injection".

Note: Please note that other rules may check injection flaws for specific resources (like Path Traversal rule for filesytem resources,
or SSRF for network addresses). This rule reports injection flaws on resource identifiers not covered by other rules.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[String remotePort = request.getParameter("remotePort");
int rPort = Integer.parseInt(remotePort);
ServerSocket srvr = new ServerSocket(rPort); // VIOLATION
Socket skt = srvr.accept();]]></example>
    <repair><![CDATA[String remotePort = request.getParameter("remotePort");
Map<String,Integer> allowed = getAllowedPorts();
Integer rPort = allowed.get(remotePort); // FIXED, whitelist
if(rPort == null) rPort = getDefaultPort();

ServerSocket srvr = new ServerSocket(rPort.intValue());
Socket skt = srvr.accept();]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Resource_Injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:99,OWASP:2021:A3,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SameOriginMethodExecution" message="SameOriginMethodExecution: Same Origin Method Execution (SOME)" class="com.optimyth.qaking.security.rules.java.SameOriginMethodExecution" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[SOME is a web application attack which abuses callback endpoints by forcing a victim into
executing arbitrary scripting methods of any page on the endpoints domain.

In example, while JSONP is popular useful technology but it can make a website vulnerable as it uses a callback function
to get data from third-party services. By manipulating the callback parameter, attacker could execute arbitrary methods
on the affected website.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[package com.fwt.coutrollen;

import com.fasterxml.jackson.databind.util.JSONPObject;
import com.fwt.dto.HistogramDto;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import javax.servlet.http.HttpServletRequest;

@Controller
public class EchartsController {

    @CrossOrigin(origins = "*", maxAge = 3600)
    @ResponseBody
    @RequestMapping(value = "getDataJsonp",method = RequestMethod.GET)
    public Object getDataJsonp(HttpServletRequest request){
        String callback = request.getParameter("callback");
        System.out.println("inner getDataJsonp");
        System.out.println(callback);
        HistogramDto dto = new HistogramDto();
        dto.addData("100");
        dto.addData("50");
        dto.addData("120");
        dto.addData("40");
        dto.addData("170");
        // JSONPObject
        JSONPObject jsonpObject = new JSONPObject(callback, dto); // VIOLATION
        System.out.println(jsonpObject+":::");
        return jsonpObject;
    }

}]]></example>
    <repair><![CDATA[// Do not allow user to select the jsonp callback]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html,http://www.benhayak.com/2015/06/same-origin-method-execution-some.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.7,WASC:08]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input, database_input, file_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SecurityCheckInOverridableMethodRule" message="SecurityCheckInOverridableMethodRule: Methods that perform a security check must be declared private or final" class="com.optimyth.qaking.security.rules.java.SecurityCheckInOverridableMethodRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[Nonfinal member methods that perform security checks can be compromised when a malicious subclass overrides the methods
and omits the checks. Consequently, such methods must be declared private or final to prevent overriding.

Failure to declare a class's method private or final affords the opportunity for a malicious subclass
to bypass the security checks performed in the method.

The rule looks for calls to AccessController.checkPermission(), SecurityManager.checkXXX() or using of the classes configured in the parameter <securityClasses>, and
then checks that the containing method cannot be overridden (should be final or private, or belong to
a final class). If method could be overridden, a violation is emitted.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Security checks cannot be bypassed by subclassing and overriding the method with checks.]]></benefits>
    <inconvenients><![CDATA[Need to change class or method access modifiers, which may impact other classes.]]></inconvenients>
    <example><![CDATA[import java.security.AccessController;
import java.io.FilePermision;

public class X {
  public final void sensitiveOperation() {
    readSensitiveFile(FILE1);
    readSensitiveFile2(FILE2);
  }

  public void readSensitiveFile(File file) { /* VIOLATION */
    try {
      SecurityManager sm = System.getSecurityManager();
      if (sm != null) { // Check for permission to read file
        sm.checkRead(file);
      }
      // Access the file
    } catch (SecurityException se) {
      // Log exception
    }
  }

  void readSensitiveFile2(File file) { /* VIOLATION */
    FilePermission perm = new FilePermission(file.getAbsolutePath(), "read");
    AccessController.checkPermission(perm);
    // Access the file
  }
}]]></example>
    <repair><![CDATA[  // sensitive methods are made final
  // alternatively, made container class final
  public final /* FIXED */ void readSensitiveFile(File file) {
    try {
      SecurityManager sm = System.getSecurityManager();
      if (sm != null) { // Check for permission to read file
        sm.checkRead(file);
      }
      // Access the file
    } catch (SecurityException se) {
      // Log exception
    }
  }

  final /* FIXED */ void readSensitiveFile2(File file) {
    FilePermission perm = new FilePermission(file.getAbsolutePath(), "read");
    AccessController.checkPermission(perm);
    // Access the file
  }]]></repair>
    <reference><![CDATA[CERT-J/MET03-J: https://www.securecoding.cert.org/confluence/x/6AAMAg]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MET03-J,CWE:358,OWASP:2021:A1,PCI-DSS:6.5.6]]></security>
    </normatives>
    <properties>
      <property name="securityClasses" descname="Comma-separated list of security custom classes." value="java.lang.SecurityManager, SecurityManager"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SerializableClassContainingSensitiveData" message="SerializableClassContainingSensitiveData: Serializable Class Containing Sensitive Data" class="com.optimyth.qaking.security.rules.java.SerializableClassContainingSensitiveData" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Java provides the java.io.Serializable interface as mechanism to convert an object to a
byte sequence. Once the object has been serialized it can be deserialized and stored into the memory like any other
object. This process is JVM independent.

Classes containing sensitive data can be converted into a sensible object which could be accessed by a malicious attacker
by transforming it into a byte sequence.

This rule reports violation when a serializable class contains sensitive data.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improving sensitive data protection improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.io.Serializable;;

public class Sample implements Serializable {

	private int ccn;		// VIOLATION
	private int uid;		// VIOLATION
	private int ccnLimit;		// VIOLATION
}]]></example>
    <repair><![CDATA[Avoid storing sensible information into a serializable class.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/499.html,https://www.securecoding.cert.org/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SER03-J,CWE:499]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.ServerSideRequestForgeryRule" message="ServerSideRequestForgeryRule: Server-Side Request Forgery (SSRF)" class="com.optimyth.qaking.security.rules.java.ServerSideRequestForgeryRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.6.1,ASVS-v4.0.2:5.2.6,CWEScope:Confidentiality,CWEScope:Integrity,http-parameter-pollution]]></tags>
    <description><![CDATA[The software builds an URL using untrusted input, and retrieves the contents of this URL (e.g. a webservice),
without ensuring that the target (scheme, host, port ...) is the intended one.

This is an instance of the 'confused deputy' weakness, where the vulnerable application acts as a proxy
or relay for connections totally or partially controlled by an attacker.

As the connection originates from the host of the vulnerable application, that may hide the attacker origin,
and bypass network controls.

Attackers may leverage this flaw to use the application as a network proxy to:
* conduct port scanning in internal networks,
* access to local sensitive files using file:// scheme,
* use unintended protocols like tftp to gain unintended connections to internal or external hosts,
* bypass firewalls (the application host may be allowed to perform connections controlled by the attacker),
* attack web applications using injection attacks
and other malicious activity.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[String url = request.getParameter("hidden_url"); // not so hidden...

// Using java.net.URLConnection
URL url = new URL(url); // VIOLATION
InputStream is = url.openConnection().getContent();

// Using Apache Commons HttpComponents
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpget = new HttpGet(url); // VIOLATION
CloseableHttpResponse response = httpclient.execute(httpget);
...]]></example>
    <repair><![CDATA[String _url = request.getParameter("hidden_url"); // not so hidden...

// perform a white-list validation ensuring, for example,
// that the all URL parts are in expected sets
String url = validateUrl(_url);

... same as before ...]]></repair>
    <reference><![CDATA[SSRF bible. Cheat-sheet ONSec Labs,http://cwe.mitre.org/data/definitions/918.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:918,CWETOP25:2021:24,OWASP:2021:A10,PCI-DSS:6.5.8,WASC:42]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SpringNoAntiXssConfiguration" message="SpringNoAntiXssConfiguration: Use defaultHtmlEscape=true with SpringMVC for better cross-site scripting prevention" class="com.optimyth.qaking.spring.rules.SpringNoAntiXssConfiguration" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.3.1,ASVS-v4.0.2:14.1.3,ASVS-v4.0.2:2.5.4,ASVS-v4.0.2:3.4.3,ASVS-v4.0.2:3.4.4,ASVS-v4.0.2:3.4.5,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Spring-MVC,essential]]></tags>
    <description><![CDATA[The rule checks that, for a J2EE web application using Spring MVC, the default cross-site scripting (XSS) control is explicitly enabled.

Please note that defaultHtmlEscape only transforms potential XSS attack payloads during HTTP output construction,
for Spring tags in JSP pages. The default behavior, when no defaultHtmlEscape context parameter is defined, is to apply HTML escaping
to all Spring tags in the form tag library (that render values), but not to the other tags that merely expose values
but dont render the values themselves.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Adds a simple XSS countermeasure to Spring MVC application.]]></benefits>
    <inconvenients><![CDATA[Automatic output encoding may interfere with application's current behaviour.]]></inconvenients>
    <example><![CDATA[<!-- web.xml does not contain defaultHtmlEscape context param, or sets it to false -->
<context-param>
  <param-name>defaultHtmlEscape</param-name>
  <param-value>false</param-value>
</context-param>]]></example>
    <repair><![CDATA[<!-- web.xml with explicit default HTML output-escaping configuration -->
<context-param>
  <param-name>defaultHtmlEscape</param-name>
  <param-value>true</param-value>
</context-param>]]></repair>
    <reference><![CDATA[Java/Spring web app security XSS - https://sgaur.wordpress.com/tag/spring/,OWASP XSS - https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet,Spring Security Cross-site Scripting - https://defensivecode.wordpress.com/2013/09/03/spring-security-xss/]]></reference>
    <normatives>
      <security><![CDATA[CWE:16,CWE:80,OWASP:2021:A5,PCI-DSS:6.5.7,WASC:08]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SpringUnrestrictedRequestMapping" message="SpringUnrestrictedRequestMapping: Spring CSRF unrestricted RequestMapping." class="com.optimyth.qaking.security.rules.java.SpringUnrestrictedRequestMapping" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.3,ASVS-v4.0.2:4.2.2,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,csrf]]></tags>
    <description><![CDATA[Methods annotated with @RequestMapping are, by default, mapped to all the HTTP request methods.

However, Spring Security CSRF protection is not enabled by default for the HTTP request methods GET, HEAD, TRACE, and OPTIONS
(as this could cause the tokens to be leaked). Therefore, state-changing methods annotated with @RequestMapping and not narrowing
the mapping to the HTTP request methods POST, PUT, DELETE, or PATCH are vulnerable to CSRF attacks.

The rule will emit a violation for any Spring MVC controller method that performs any state-change operations,
and is annotated with @RequestMapping (with no methods restriction, or with one  of GET / HEAD / OPTIONS / TRACE), or
@GetMapping.

Note: CSRF = Cross-Site Request Forgery, an attack where an attacker may force a victim to perform an unintended operation
on a vulnerable web resource.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended CSRF vulnerabilities, when an state-changing logic could be invoked by an attacker using GET method,
which is not CSRF-protected (and should not be, to avoid leaking CSRF tokens).]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

@Controller
public class MyController {

    // VIOLATION: GET, HEAD, OPTIONS and TRACE methods could be used by attacker,
    //            circumventing CSRF protection
    @RequestMapping("/path")
    public void writeData(@PathVariable int data) throws IOException {
        // State-changing operations performed within this method.
    }
}]]></example>
    <repair><![CDATA[import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMethod;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

@Controller
public class MyController {

    /**
     * For methods without side-effects specify the method(s) in @RequestMapping.
     * Alternatively, use @GetMapping (String 4.3 or later)
     */
    @RequestMapping(value="/path", method = RequestMethod.GET)
    public String readData() {
        // No state-changing operations performed within this method.
        return "";
    }

    /**
     * State-changing methods. Use explicit RequestMethod.POST or,
     * alternatively, @PostMapping (String 4.3 or later)
     */
    @RequestMapping(value = "/path", method = RequestMethod.POST)
    public void writeData(@PathVariable int data) throws IOException {
        // State-changing operations performed within this method.
    }
}]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet,https://en.wikipedia.org/wiki/Cross-site_request_forgery,https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#csrf-use-proper-verbs,http://cwe.mitre.org/data/definitions/352.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:352,CWETOP25:2021:9,OWASP:2013:A8,PCI-DSS:6.5.1,WASC:9]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SpringViewManipulation" message="SpringViewManipulation: Spring View Manipulation" class="com.optimyth.qaking.spring.rules.SpringViewManipulation" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[An unrestricted view name manipulation in Spring framework (Spring MVC), that uses Thymeleaf as templating engine,
may lead to remote code execution.

As Thymeleaf supports file layouts and fragments, a Spring MVC controller may create a dynamic view fragment name.
At runtime, the Spring ThymeleafView class parses the template name as an expression:

try {
   // By parsing it as a standard expression, we might profit from the expression cache
   fragmentExpression = (FragmentExpression) parser.parseExpression(context, "~{" + viewTemplateName + "}");
}

This is vulnerable to expression language injection attacks: for example, using a payload containing
__${T(java.lang.Runtime).getRuntime().exec("some OS command")}__::.

The __{ ... }__:: exploits the expression preprocessing feature in Spring, and the :: following ensure that
the input is considered as a view fragment that need expression evaluation.

So whenever untrusted data comes to a view name returned from the controller, it could lead to
Expression Language Injection, and therefore to Remote Code Execution.

Please note that the code in ThymeleafView is executed as a Spring expression when the '::' separator appears somewhere
in the view name, which can be forced by the attacker.

This happens even when the controller does not return a string (which Spring interprets as a view name) but with other
return types like void, java.util.Map or org.springframework.ui.Model, and it uses the URI (with parts of it under control
of the attacker) as part of an expression that is executed. See the full details in the references.

Please note that the rule detects if Thymeleaf is configured as the templating engine in the Spring web application.
Spring REST controllers (annotated with @RestController), and static view names are not vulnerable.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Assume that the Thymeleaf templating engine is registered in this Spring web application...

@Controller
public class MyController {

  @RequestMapping("/")
  public String index(@RequestParam String lang) {
    return "user/" + lang + "/index"; // VIOLATION - template path is tainted
  }

  @GetMapping("/fragment")
  public String fragment(@RequestParam String section) {
    return "welcome :: " + section; // VIOLATION
  }
}]]></example>
    <repair><![CDATA[@Controller
public class MyController {

  @RequestMapping("/")
  public String index(@RequestParam String lang) {
    if(isValidLanguage(lang)) { // FIXED
      return "user/" + lang + "/index";

    } else {
      return "user/esperanto/index";
    }
  }

  @GetMapping("/fragment")
  public String fragment(@RequestParam String section) {
    // FIXED, the external input is properly validated
    if(section != null && section.matches("a-zA-Z0-9")) {
      return "welcome :: " + section;

    } else {
      return "index"; // neutral home view
    }
  }
}]]></repair>
    <reference><![CDATA[https://www.veracode.com/blog/secure-development/spring-view-manipulation-vulnerability]]></reference>
    <normatives>
      <security><![CDATA[CWE:917,OWASP:2021:A3]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.SqlInjectionRule" message="SqlInjectionRule: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" class="com.optimyth.qaking.security.rules.java.SqlInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The software constructs all or part of an SQL command using externally-controlled input, but it does not neutralize
properly that input that could modify the intended SQL command when it is sent to a database interaction method
(e.g. JDBC).

The rule detects a path in code between an user-input statement (source) and a database call (sink), with SQL sentence depending on
non neutralized input.

It must be known that if SQL does not depend on user-controlled input (e.g. Parametrized SQL), there is no possibility for an SQL injection.

Note: Using stored procedures in database operations does NOT prevent SQL injection if, for example, the SQL to send
to the database for execution of the stored procedure is composed by concatenating non properly neutralized user input.
The ways to avoid SQL injection are:

1) Use parametrized SQL, so SQL code and parameters are not mixed (no parameter could change the semantic of the SQL)

2) If SQL code must depend on user input (e.g. to build 'dynamic' WHERE clauses), even with prepared statements,
   all user-controlled inputs used to compose such "dynamic" SQL should be neutralized.

A neutralization function either validates inputs and report an (neutral) error without allowing SQL execution, or
replaces sensitive SQL characters in the input to avoid that the resulting SQL has different semantics.

It is recommended to use parametrized SQL (when possible).

The rule supports different database persistence libraries/frameworks, like JDBC, Hibernate, Java Persistence API (JPA),
JDO, or Spring.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.io.IOException;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.sql.Connection;
import java.sql.Statement;
import java.sql.ResultSet;

public class MyServlet extends HttpServlet {
  @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String username = request.getParameter("username");
    String password = request.getParameter("password");
    Connection conn = pool.getConnection();
    String sql = "select * from user where username='" + username +"' and password='" + password + "'";
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(sql);
  }
}]]></example>
    <repair><![CDATA[import java.io.IOException;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.sql.Connection;
import java.sql.Statement;
import java.sql.ResultSet;

public class MyServlet extends HttpServlet {
  @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String username = request.getParameter("username");
    String password = request.getParameter("password");
    Connection conn = pool.getConnection();

    PreparedStatement sqlStatement = conn.prepareStatement("select * from user where username=? and password=?"); //Fixed. Use prepared statements.
    sqlStatement.setString(1, username);
    sqlStatement.setString(2, password);
    ResultSet rs = sqlStatement.executeQuery(sql);
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/IDS00-J.+Prevent+SQL+injection,https://cwe.mitre.org/data/definitions/564.html,http://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS00-J,CWE:564,CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input"/>
      <property name="parametersAsSources" descname="Assume that method parameters are untrusted inputs" value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.StaticDatabaseConnection" message="StaticDatabaseConnection: Static database connection / session" class="com.optimyth.qaking.security.rules.java.StaticDatabaseConnection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Design]]></tags>
    <description><![CDATA[A (transactional) resource object, like a database connection or a persistence framework session, should not be a static field.
Static fields have application scope, and are typically shared between multiple user sessions and threads.

J2EE specification ("Transactions and Threads", section 4.2.3) mandates, to ensure correct operation, that "Transactional
resource objects (for example, JDBC Connection objects) should not be stored in static fields. Such objects can only
be associated with one transaction at a time. Storing them in static fields would make it easy to erroneously share them
between threads in different transactions".

Sharing a transactional resource object is a design flaw. Concurrent database operations based on the shared connection/session
may interfere with each other, with potential security issues. Resource leaking is another problem (database may close
an opened connection after idle timeout).

As a general recommendation, always acquire and close connection/session and intermediate objects (statement, resultset...)
in the shortest possible scope, preferably inside try-with-resources block (Java 7+) or try...finally block.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.sql.Connection;

public class DbUtil {
  private static final Connection jdbcConn = openConnection(); // VIOLATION
  // ...
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://stackoverflow.com/questions/9428573/is-it-safe-to-use-a-static-java-sql-connection-instance-in-a-multithreaded-syste,Java EE Specification, section 4.2.3.]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:VNA02-J,CWE:567,PCI-DSS:6.5.6]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.TooMuchOriginsAllowedRule" message="TooMuchOriginsAllowedRule: CORS policy (Cross-origin resource sharing) too broad" class="com.optimyth.qaking.security.rules.java.TooMuchOriginsAllowedRule" technology="JAVA" active="true">
    <tags><![CDATA[CORS,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Too much allowed origins in HTML5 Access-Control-Allow-Origin header.

Traditionally, web browsers enforced the Same Origin Policy (SOP) to avoid cross-domain JavaScript to access
certain contents in web page. This policy prevents a malicious script on one page from obtaining
access to sensitive data on another web page ("victim") with a different origin. A strict separation between content
from unrelated sites must be maintained on the browser to prevent loss of data confidentiality or integrity.

Cross-Origin Resource Sharing (CORS) relaxes the SOP. To do this, essentially two HTTP headers (Origin, emitted by client,
and Access-Control-Allow-Origin, emitted by server). This allows, for example, to Ajax requests (XMLHttpRequest) for
accessing content from different origin that should be forbidden by the SOP.

With Access-Control-Allow-Origin header, server defines which other domains are allowed to access content in its domain
using cross-origin requests. A too much permissive value (like '*') will allow a malicious application to communicate
with the vulnerable application in unexpected ways, leading to different security problems.

NOTE: CORS is intended to avoid data read from pages coming from other origins, and it is enforced by modern browsers.
Remember that an attacker has full control over an HTTP request message, so do not rely on CORS Origin header for
validating the source of a request, or for CSRF protection.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limits read application data from content coming from hostile origins.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

class CorsExample {
  private static final String CORS_HEADER = "Access-Control-Allow-Origin";
  private static final String CORS_CREDS = "Access-Control-Allow-Credentials";
  private static final String CORS_ORIGINS_ALLOWED = "*";

  public void setCorsOrigins(HttpServletResponse res) {
    //...
    /* VIOLATION, too permisive */
    res.setHeader(CORS_HEADER, CORS_ORIGINS_ALLOWED);
    //...
  }

  // A more flexible alternative is to reflect the Origin header into Access-Control-Allow-Origin
  // but without validation this is dangerous
  public void reflectCorsOrigin(HttpServletRequest req, HttpServletResponse res) {
    String origin = req.getHeader("Origin");
    if(origin != null) {
      res.addHeader(CORS_HEADER, origin); // VIOLATION, no validation
      res.addHeader(CORS_CREDS, "true"); // with this, impact is higher
    }
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.util.Set;
import java.util.regex.Pattern;
import com.google.common.collect.Sets;
import org.springframework.web.util.WebUtils;

class CorsExample {
  private static final String CORS_HEADER = "Access-Control-Allow-Origin";
  private static final String CORS_CREDS = "Access-Control-Allow-Credentials";

  // hardcoded allowed origins, for simplicity
  private Set<String> allowed = Sets.newHashSet(
    "https://affiliate.com", "https://affiliate2.com"
  );
  // subdomains in my domain allowed. TLS always enforced !!!
  private Pattern mySubdomains = Pattern.compile("https://(\\w[\\w\\d\\-_]*)?myorg.com");

  public void setCorsOrigins(HttpServletResponse res) {
    //...
    res.addHeader(CORS_HEADER, "https://www.allowed.com"); // FIXED
    //...
  }

  public void reflectCorsOrigin(HttpServletRequest req, HttpServletResponse res) {
    if(WebUtils.isSameOrigin(req)) return; // same origin, no CORS header needed

    String origin = req.getHeader("Origin");
    // FIXED, white-listed
    if(origin != null && isAllowed(origin, req)) {
      res.addHeader(CORS_HEADER, origin);
      res.addHeader(CORS_CREDS, "true");
    }
  }

  // White-list the origin before reflecting it in the CORS header
  private boolean isAllowed(String origin, HttpServletRequest req) {
    return
      mySubdomains.matcher(origin).matches()) ||
      allowed.contains(origin);
  }
}]]></repair>
    <reference><![CDATA[https://www.baeldung.com/spring-cors,https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties,https://w3c.github.io/webappsec-cors-for-developers,http://cwe.mitre.org/data/definitions/942.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:942,OWASP:2021:A5,PCI-DSS:6.5.10,WASC:15]]></security>
    </normatives>
    <properties>
      <property name="disallowedOriginPattern" descname="Regular expression for CORS origins do not considered valid" value="\*|null"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.TrustBoundaryViolationRule" message="TrustBoundaryViolationRule: Trust boundary violation" class="com.optimyth.qaking.security.rules.java.TrustBoundaryViolationRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,trust-boundary]]></tags>
    <description><![CDATA[The product mixes trusted and untrusted data in the same data structure or structured message.

A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted.
By combining trusted and untrusted data in the same data structure, it becomes easier for programmers
to mistakenly trust unvalidated data. This violation may open attack avenues, like injection attacks,
when the application takes untrusted data from the trusted domain without validation.

When untrusted external input (e.g. input HTTP message contents) is set as session or web application attributes,
without proper validation / neutralization, the check emits a violation.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid security issues when data passed to trusted domain is used without specific validation from other places
in the application.]]></benefits>
    <inconvenients><![CDATA[Need explicit input validation before data movement.]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.owasp.esapi.ESAPI;

public class MyServlet extends HttpServlet {
  public void doPost(HttpServletRequest req, HttpServletResponse res) {
    String param = req.getParameter("input");
    req.getSession().setAttribute("trusted", param); /* VIOLATION */
    res.getWriter().println(ESAPI.encoder().encodeForHTML(param));
  }

  /*
    In other place, session data is considered trusted and not validated,
    allowing cross-site scripting and other security problems.
   */
  public void doGet(HttpServletRequest req, HttpServletResponse res) {
    String trusted = req.getSession().getAttribute("trusted");
    res.getWriter().println("pawned: " + trusted);
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.owasp.esapi.ESAPI;

public class MyServlet extends HttpServlet {
  public void doPost(HttpServletRequest req, HttpServletResponse res) {
    String param = req.getParameter("input");
    if(param != null && param.matches("[a-zA-Z0-9 ]")) { /* FIXED, validation */
      req.getSession().setAttribute("trusted", param);
    }
    res.getWriter().println(ESAPI.encoder().encodeForHTML(param));
  }

  /* Data in trusted domain is validated */
  public void doGet(HttpServletRequest req, HttpServletResponse res) {
    String trusted = req.getSession().getAttribute("trusted");
    res.getWriter().println("pawned: " + trusted);
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/501.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:501,OWASP:2021:A4,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.UnhandledSSLExceptionRule" message="UnhandledSSLExceptionRule: Unhandled SSL exception" class="com.optimyth.qaking.security.rules.java.UnhandledSSLExceptionRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Integrity,error-handling,ssl]]></tags>
    <description><![CDATA[TLS/SSL error handling in Java typically throws an java.net.ssl.SSLException (or subtypes SSLHandshakeException,
SSLKeyException, SSLPeerUnverifiedException or SSLProtocolException) when there is a protocol or security problem
detected by the SSL subsytem, particularly during SSL handshake / negotiation.

If these errors are not explicitly handled, the connection may be left in an unexpected, insecure, state.
This rule demands that for every network operation using TLS/SSL protocol that may throw a SSL exception,
the exceptions are catched (and not ignored) in the same method, to make sure that security-related errors
are processed properly.

Please note that java.net.ssl.SSLException is a subclass of java.io.IOException, so it is recommended that
SSL exceptions should be handled explicitely, before handling IOException.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Error handling and fault isolation</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid using SSL connections in insecure state.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.net.HttpsURLConnection;
import java.net.URL;
import java.io.IOException;

  /* VIOLATION: SSL Exception not handled explicitly */
  public Object m() throws IOException {
    HttpsURLConnection conn = (HttpsURLConnection)new URL("https://host.com/resource").openConnection();
    return conn.getContent();
  }

  /* VIOLATION: SSL Exception ignored */
  public Object m2() throws IOException {
    try {
      HttpsURLConnection conn = new URL("https://host.com/resource").openConnection();
      return conn.getContent();
    } catch(SSLException ssle) {}
  }
}]]></example>
    <repair><![CDATA[  public Object m() throws IOException {
    try {
      HttpsURLConnection conn = new URL("https://host.com/resource").openConnection();
      return conn.getContent();

    } catch(SSLException ssle) {
      logSecurityIssue(ssle); //
      terminateInsecureConnection();
    }
  }]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/391.html,]]></reference>
    <normatives>
      <security><![CDATA[CWE:391,PCI-DSS:6.5.5,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.UnnormalizedInputString" message="UnnormalizedInputString: Always normalize system inputs" class="com.optimyth.qaking.security.rules.java.UnnormalizedInputString" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[When a system accepts external inputs usually uses a filtering or validation technique
to check if the input is safe or a malicious input.

When filtering techniques like blacklisting are used, certain characters whose use can be malicious can skip this
filtering if they are encoded in other different format than the expected.

Therefore, it would be easy for a malicious attacker to bypass, for example, filterings against XSS sending label
<script> as "\ uFE64" + "script" + "\ uFE65".

Therefore, it is necessary normalizing inputs previously to validation, ensuring this way that validation is
performed on strings with the expected format.

This rule reports violation when an system input is not normalized and then validated.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding maliciously formatted chains improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.text.Normalizer;
import java.io.FileInputStream;

public class Sample {

  public void method_KO (HttpServletRequest req) throws IOException {
    String btype = req.getParameter("backuptype");
    String s = "\uFE64" + btype + "\uFE65";

    // Validate
    if (s.matches("")) {
      // Found blacklisted tag
      throw new IllegalStateException();
    } else {
      // ...
    }

    // Normalize
    s = Normalizer.normalize(s, Form.NFKC);

    FileInputStream in = new FileInputStream(s);    // VIOLATION
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.text.Normalizer;
import java.io.FileInputStream;

public class Sample {

  public void method_KO (HttpServletRequest req) throws IOException {
    String btype = req.getParameter("backuptype");
    String s = "\uFE64" + btype + "\uFE65";

    // Normalize
    s = Normalizer.normalize(s, Form.NFKC);

    // Validate
    if (s.matches("")) {
      // Found blacklisted tag
      throw new IllegalStateException();
    } else {
      // ...
    }

    FileInputStream in = new FileInputStream(s);    // OK
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/180.html,https://www.securecoding.cert.org/confluence/display/java/IDS01-J.+Normalize+strings+before+validating+them]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS01-J,CWE:180]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.UnsafeCookieRule" message="UnsafeCookieRule: Generate server-side cookies with adequate security properties" class="com.optimyth.qaking.security.rules.java.UnsafeCookieRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:3.2.3,ASVS-v4.0.2:3.4.1,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Checks that cookies generated in server side have the following security properties:

    * Non persistent - Cookie is not stored persistently by the browser (it is hold in memory)
    * HttpOnly - Cookie is not accessible by client-side scripts (not all browsers support this)
    * Secure - Cookie is sent in HTTP/SSL communications only (more difficult to capture on the net)
    * Path - Path should not match a certain patterns that allow transmission to unintended web applications.
    * Domain - Domain should not be too wide so the cookie is sent to unintended servers.

    HttpOnly, for example, could mitigate some CSRF (cross-site request forgery) issues as it makes
    more difficult for the attacker to capture sensitive cookies from client-side code generated by
    exploiting an XSS vulnerability in a web application.

    Other rules (like SEC_JAVA.HttpSplitting) check other conditions, like HTTP Splitting, that could be
    produced when the cookie value depends on user-controlled input non properly neutralized.

    NOTE: forceHttpOnly property should be set only if Java code uses Java6 (in previous versions, the
    Cookie.setHttpOnly(boolean) method does not exist, and httpOnly flag for cookies can only be set
    by application server configuration, see https://www.owasp.org/index.php/HttpOnly. Under Java5-,
    do not set forceHttpOnly to true as this cannot be set in code.

    NOTE2: Not setting domain or path forces browser to send the cookie to the originator's domain and
    application path, so this is considered secure.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.ServletContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.net.MalformedURLException;

import com.opt.MyOwnCookie;

public class UnsafeCookie {

  private static final String COOKIE_NAME = "SecureCookie";

  public void sendPersistentUnsecureCookie(HttpServletResponse res) {
    Cookie cookie = new Cookie(COOKIE_NAME, "value"); // VIOLATION - no setHttpOnly(true)
    cookie.setMaxAge(24*60*60);          // VIOLATION - 1 day (persistent)

    cookie.setSecure(false);    // VIOLATION

    res.addCookie(cookie);
  }
}]]></example>
    <repair><![CDATA[import javax.servlet.ServletContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.net.MalformedURLException;

import com.opt.MyOwnCookie;

public class UnsafeCookie {

  private static final String COOKIE_NAME = "SecureCookie";

  public void sendPersistentUnsecureCookie(HttpServletResponse res) {
    Cookie cookie = new Cookie("SensibleCookie", "value");

    cookie.setMaxAge(-1); // en memoria - cookie no persistente
    cookie.setSecure(true);
    cookie.setHttpOnly(true);
    cookie.setPath("/allowedPath");
    cookie.setDomain("allowedDomain.es");

    res.addCookie(cookie);
  }
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/200.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:1004,CWE:200,CWE:539,CWE:614,CWETOP25:2021:20]]></security>
    </normatives>
    <properties>
      <property name="domainPatternToAvoid" descname="Domain pattern to avoid" value="\.[^\.]+"/>
      <property name="avoidPersistentCookies" descname="Avoid persistent cookies" value="true"/>
      <property name="avoidUnsecureCookies" descname="Avoid unsecure cookies" value="true"/>
      <property name="pathPatternToAvoid" descname="Path pattern to avoid" value="/"/>
      <property name="forceHttpOnly" descname="Set HttpOnly" value="true"/>
      <property name="checkAllCookieAllocations" descname="Check every Cookie allocation including those not being added to an HTTP response." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.UnsafeReflection" message="UnsafeReflection: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')" class="com.optimyth.qaking.security.rules.java.UnsafeReflection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,reflection]]></tags>
    <description><![CDATA[The software uses external input with reflection to select which classes or code to use, but it does not prevent
the input from selecting improper classes or code.

If the application uses external inputs to determine which class to instantiate or which method to invoke, then an attacker
could supply values to select unexpected classes or methods. If this occurs, then the attacker could execute code that
was not intended by the developer. It may bypass authentication or access control checks, or otherwise cause unexpected behaviour.

It the attacker is able to upload files in a location that appears in the classpath, or add new entries to the classpath,
this flaw could lead to execution of arbitrary code, chosen by the attacker.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limit potential unexpected code execution, or uncontrolled access to sensitive information.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import java.lang.reflect.Method;
// ...

/*
 * Action type and optional initialization method, specified in a "hidden" request parameter
 * Remind that "hidden" parameters are not hidden...
 */
private Action getInstance(HttpServletRequest req) throws Exception {
  String actionClass = req.getParameter("action");
  String init = req.getParameter("init");
  if(init == null) init = "init";

  @SuppressWarnings("unchecked")
  Class<Action> clazz = (Class<Action>) Class.forName(actionClass); // VIOLATION

  Action action = clazz.newInstance();
  Method initMethod = clazz.getMethod(init, HttpServletRequest.class); // VIOLATION
  initMethod.invoke(action, req);

  return action;
}]]></example>
    <repair><![CDATA[// Validate externally-controlled parameters affecting targets of reflexion code]]></repair>
    <reference><![CDATA[OWASP Unsafe Reflection: https://www.owasp.org/index.php/Unsafe_Reflection,Secure Coding Guidelines for the Java Programming Language, guideline 9,https://www.securecoding.cert.org/confluence/display/java/SEC05-J.+Do+not+use+reflection+to+increase+accessibility+of+classes%2C+methods%2C+or+fields,https://cwe.mitre.org/data/definitions/470.h]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SEC05-J,CWE:470,OWASP:2021:A3,PCI-DSS:6.5.8,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.UserControlledSQLPrimaryKey" message="UserControlledSQLPrimaryKey: Avoid using an user controlled Primary Key into a query" class="com.optimyth.qaking.security.rules.java.UserControlledSQLPrimaryKey" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The software constructs all or part of an SQL command using externally-controlled input, but it does not neutralize
properly that input that could modify the intended SQL command when it is sent to a database interaction method
(e.g. JDBC).

Commonly a database table contains information that should not be accessible to all the users. However, if an user can
modify the query to specify a primary key, then it's possible for him to access unauthorized records.
<br/>
The rule detects a path in code between an user-input statement specifying the primary key (source) and a database call
(sink), with SQL sentence depending on non neutralized input.

It must be known that if SQL does not depend on user-controlled input (e.g. Parametrized SQL), there is no possibility
for attacker to view unauthorized records.

The rule supports different database persistence libraries/frameworks, like JDBC, Hibernate, Java Persistence API (JPA),
JDO, or Spring.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding bypassing security authorizations avoids access to sensible information, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import java.io.IOException;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.sql.Connection;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.PreparedStatement;

public class MyServlet extends HttpServlet {

  @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    String pk = request.getParameter("pk");

    Connection conn = pool.getConnection();
    String query = "SELECT employee.userid,first_name,last_name FROM employee,roles where employee.userid=?";

    PreparedStatement pS =  conn.prepareStatement(query);
    pS.setString(1, pk);        // VIOLATION
    ResultSet rs = pS.executeQuery();
  }
}]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/566.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:566]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.WeakCryptographicHashRule" message="WeakCryptographicHashRule: Weak cryptographic hash" class="com.optimyth.qaking.security.rules.java.WeakCryptographicHashRule" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Access-Control,crypto,hash]]></tags>
    <description><![CDATA[Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.
MD5 and SHA-1 are popular cryptographic hash algorithms often used to verify the integrity of messages and other data.

Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5 and SHA-1 should
no longer be used to verify data integrity in security-critical contexts.

Techniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be used
in any security context.

In the case of SHA-1, current techniques still require a significant amount of computational power and
are more difficult to implement. However, attackers have found the Achilles' heel for the algorithm, and techniques
for breaking it will likely lead to the discovery of even faster attacks.

Note: SHA-1 is not a recommended algorithm for password hashing, for digital signature generation/verification, and other uses (NIST).


The rule checks if the cryptographic hash algorithm used is one of the allowed ones; the rule can lead to false negatives
if the algorithm value argument cannot be inferred statically.

In addition, a violation is emitted for every custom implementation of java.security.MessageDigest. Such custom implementations
probably do not have the security level that standard implementations provide.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private final static String SHA_1 = "SHA-1";
// ...
MessageDigest messageDigest = MessageDigest.getInstance("MD5");  // VIOLATION
MessageDigest messageDigest2 = MessageDigest.getInstance(SHA_1); // VIOLATION
// ...
String hashAlgorithm = getHashAlgorithm();
MessageDigest messageDigest3 = MessageDigest.getInstance(hashAlgorithm); // DESCONOCIDO]]></example>
    <repair><![CDATA[private final static String SHA_256 = "SHA-256";
// ...
MessageDigest messageDigest = MessageDigest.getInstance("SHA-384"); // OK
MessageDigest messageDigest2 = MessageDigest.getInstance(SHA_256);  // OK]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/328.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:328,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:50]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Allowed cryptographic hash algorithms" value="SHA224, SHA256, SHA384, SHA512, HashSHA224, HashSHA256, HashSHA384, HashSHA512"/>
      <property name="forbiddenAlgorithms" descname="List of weak hash functions" value="MD2, MD5, SHA1, HashMD5, HashSHA1"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.WeakEncryptionRule" message="WeakEncryptionRule: Weak symmetric encryption algorithm" class="com.optimyth.qaking.security.rules.java.WeakEncryptionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.9.3,ASVS-v4.0.2:6.2.2,ASVS-v4.0.2:8.3.7,CWEScope:Accountability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,cipher,crypto]]></tags>
    <description><![CDATA[The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.

Old encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data.
Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength.
Cryptographic strength is often measured by the time and computational power needed to generate a valid key.
Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time.

For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm
was first developed, but today DES can be cracked in less than a day using commonly available equipment.

Encryption-related classes considered by the rule are Cipher, Mac, KeyGenerator or SecretKeyGenerator in javax.crypto
package.

The rule also considers a violation of this rule any custom implementation of the aforementioned classes (or the
corresponding Spi classes), as correct implementation for encryption/decryption algorithms is difficult,
and need deep analysis from the cryptographic community.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private static final String ALGORITHM = "DES/CBC/PKCS5Padding";

//...
Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding"); //VIOLATION
Cipher cipher = Cipher.getInstance(ALGORITHM);  //VIOLATION

// Probably cannot infer algorithm statically
Cipher cipher = Cipher.getInstance(getAlgorithm());]]></example>
    <repair><![CDATA[private static final String ALGORITHM = "AES/CBC/PKCS5Padding";
//...
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); //OK
Cipher cipher = Cipher.getInstance(ALGORITHM);  //OK]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms,http://cwe.mitre.org/data/definitions/327.html,http://projects.webappsec.org/w/page/13246936/Information%20Leakage]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC61-J,CWE:327,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Comma-separated list of allowed algorithms" value="DESEDE, AES, IDEA"/>
      <property name="forbiddenAlgorithms" descname="Comma-separated list of ciphers that should NOT be used." value="DES, RC2, RC4, RC5"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.WeakPasswordHashing" message="WeakPasswordHashing: Weak Password Hashing" class="com.optimyth.qaking.security.rules.java.WeakPasswordHashing" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.4.1,ASVS-v4.0.2:2.4.2,ASVS-v4.0.2:2.4.3,ASVS-v4.0.2:2.4.4,ASVS-v4.0.2:2.4.5,ASVS-v4.0.2:2.7.5,CWEScope:Access-Control,crypto]]></tags>
    <description><![CDATA[For storage of passwords, the proper way is to apply a one-way hash function that converts the provided password
into a fixed-length "fingerprint" that cannot be reversed. Due to the "avalanche effect" of the hash function,
a one-bit change in the input password results in a large change in the "fingerprint".

Password cracking traditionally used "rainbow tables" where passwords in a dictionary were hashed for a quick search
of plaintext passwords in a long list of hashes. To counteract this, the idea is to add a random salt to each password.

The one-way function is applied both when the password is provided by the end-user during registration (the resulting hash,
along with salt used, is then stored); and at user authentication, when the stored hash for the user is retrieved and compared
against the result of applying the hash function on the provided clean-text password concatenated with the stored salt.

High-end graphics cards (GPUs) and custom hardware can compute billions of hashes per second, so these attacks are still
very effective for brute-force password cracking, in particular when a large list of password hashes is exfiltrated.
To block this attack, "key stretching" (a CPU- and memory- intensive hash function) should be used. Do not try to invent your own;
there are many that passed the scrutiny of the cryptographic community.

The recommended password hashing scheme should, then:
- Use well-designed key stretching / password hashing algorithms, such as PBKDF2, BCrypt, SCrypt, or Argon2.

- Only for legacy reasons, use a common ("fast") hash function like SHA-256, but iterated a large number of times.
  In 2016, NIST recommended 10,000 iterations, but 150,000 is often seen as of 2020.

- Use a long-enough random salt when storing the password, and never reuse it.

- Configure the work factor parameters for the key stretching functions (or iterations in case of a common hash function)
  so its work factor makes brute-force password cracking unfeasible, without too much impact in the authentication process.

- Optionally, add a private and shared "secret key" to the hash (named "pepper"). The key has to be kept secret from an attacker
  even in the event of a breach, otherwise it provides no additional security.

Any non-conformance with the above recommendations will be reported:
- No password hashing at all (CWE-256 or CWE-257).
- Weak hash function (CWE-328).
- No salt or empty (CWE-759).
- Hardcoded or predictable salt (CWE-760).
- Too-small work factor parameters, including number of iterations with legacy "fast" hash functions (CWE-916).

Remember that users often reuse the same password in accounts across multiple systems.

Note: Many libraries automate the generation of random salt with proper length, avoiding errors like hardcoded/reused salt.
If not available, remember to use at least a random salt, generated properly with a Cryptographically Secure
Pseudo-Random Number Generator (CSPRNG), with a size equal to the size of the hash function output (128 bits at minimum).
Never use the username or other non-random information as salt.

Note: During authentication, the comparison between stored and computed hash values should take a length-constant time to avoid
leaking timing information for searches on the passwords space better than brute-force. Most password-hashing libraries
provide verification methods enforcing this.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import org.springframework.security.crypto.password.Pbkdf2PasswordEncoder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.apache.commons.codec.binary.Base64;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import static java.nio.charset.StandardCharsets.UTF_8;

// Spring security automates random salt processing...

public class PasswordAuthentication {

  // Better if this is not hardcoded, shown for illustration purposes
  private final String pepper = "@@:SRDf6BCq]2nf!";

  public String encodePbkdf2(String pwd) {
    // VIOLATION - small iteration count, 1024 is below the pbkdf2 threshold (10000)
    Pbkdf2PasswordEncoder pe = new Pbkdf2PasswordEncoder(pepper, 1024, 256);
    return pe.encode(pwd);
  }

  public static String encodeBCrypt(String pwd) {
    BCryptPasswordEncoder bcrypt = new BCryptPasswordEncoder(4); // VIOLATION - too weak !
    return bcrypt.encode(pwd);
  }

  private final String salt = "hardcodedIsBad";

  public String encodeFastHash(String pwd) throws NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance("SHA-256");
    md.update(pepper.getBytes(UTF_8));
    md.update(salt.getBytes(UTF_8));

    // VIOLATION, hardcoded salt and too-small iteration count (1000 < expected 150000)
    byte[] hash = md.digest(password.getBytes(UTF_8));

    for(int i=0; i < 1000; i++) {
      md.update(salt);
      hash = md.digest(hash);
    }

    return Base64.encodeBase64String(salt) + "$" + Base64.encodeBase64String(hash);
  }

}]]></example>
    <repair><![CDATA[// Identical code omitted...

public class PasswordAuthentication {

  public String encodePbkdf2(String pwd) {
    // Fixed, proper iteration count
    Pbkdf2PasswordEncoder pe = new Pbkdf2PasswordEncoder(pepper, 10000, 256);
    return pe.encode(pwd);
  }

  public static String encodeBCrypt(String pwd) {
    BCryptPasswordEncoder bcrypt = new BCryptPasswordEncoder(12); // FIXED
    return bcrypt.encode(pwd);
  }

  // Only use regular hash functions for legacy systems, never use this for new ones
  private final SecureRandom rand = new SecureRandom();

  public String encodeFastHash(String pwd) throws NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance("SHA-256");
    byte[] salt = rand.generateSeed(32); // 256 bits salt
    md.update(pepper.getBytes(UTF_8));
    md.update(salt.getBytes(UTF_8));

    // Fixed, random salt and adequate iteration count
    byte[] hash = md.digest(password.getBytes(UTF_8));

    for(int i=0; i < 150000; i++) {
      md.update(salt);
      hash = md.digest(hash);
    }

    return Base64.encodeBase64String(salt) + "$" + Base64.encodeBase64String(hash);
  }

}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/759.html,https://cwe.mitre.org/data/definitions/760.html,https://crackstation.net/hashing-security.htm,https://cwe.mitre.org/data/definitions/256.html,https://cwe.mitre.org/data/definitions/916.html,https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords,https://www.baeldung.co]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:MSC03-J,CWE:256,CWE:759,CWE:760,CWE:916,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="thresholds" descname="Comma-separated list of algorithm.workFactor = threshold">
        <value><![CDATA[
pbkdf2 = 10000,
argon2.mem = 12, argon2.iterations = 3, argon2.parallel = 1,
scrypt.cpu = 16384, scrypt.mem = 8, scrypt.parallel = 1,
bcrypt.strength = 10,
fast.hash = 150000
        ]]></value>
      </property>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.WebXmlSecurityMisconfigurationsRule" message="WebXmlSecurityMisconfigurationsRule: Avoid misconfiguring security properties in web.xml descriptor" class="com.optimyth.qaking.security.rules.java.WebXmlSecurityMisconfigurationsRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.3.1,ASVS-v4.0.2:14.1.3,ASVS-v4.0.2:2.5.4,ASVS-v4.0.2:2.8.1,ASVS-v4.0.2:2.8.6,ASVS-v4.0.2:3.2.1,ASVS-v4.0.2:3.3.1,ASVS-v4.0.2:3.3.2,ASVS-v4.0.2:3.3.3,ASVS-v4.0.2:3.3.4,ASVS-v4.0.2:3.4.3,ASVS-v4.0.2:3.4.4,ASVS-v4.0.2:3.4.5,ASVS-v4.0.2:3.6.1,ASVS-v4.0.2:3.6.2,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,essential]]></tags>
    <description><![CDATA[The rule checks 7 common misconfigurations in web.xml descriptors:

    * No default error pages for 404/500 error codes and for uncaught exceptions.
    By default Java web applications display detailed error messages that disclose the server version and detailed stack trace information
    that can, in some situations, wind up displaying snippets of Java code. This information is a boon to hackers who are looking for as much
    information about their victims as possible.

    To avoid, set neutral error pages for 404 and 500 HTTP error codes, and for java.lang.Throwable uncaught exceptions
    (which means ALL uncaught exceptions)

    * No methods in security constraints.
    In security-constraint, do not list any http-method. Any non-listed method will be
    unprotected, so attackers may use an uncommon method (HEAD, TRACE, DELETE...) to access
    the protected resources.

    * Configure SSL for protected areas.
    SSL should be used to protect sensitive data in transit (protected resources)
    This check could be deactivated by setting checkSSLForProtectedAreas to false.

    * Send session ID under SSL only.
    Many web sites use SSL for authentication but then either revert back to non-SSL for subsequent communication
    or have parts of the site that can still be accessed via non-SSL. This leaves the session coookie (i.e. JSESSIONID)
    vulnerable to session hijacking attacks. To prevent this, session cookies can be created with the "Secure" flag,
    which ensures that the browser will never transmit the specified cookie over non-SSL.

    * Send session cookies with the HttpOnly flag set.
    Cookies can be created with the "HttpOnly" flag, which ensures that the cookie cannot be accessed via client side scripts.
    This helps mitigate some of the most common XSS attacks. Must be specified for Servlet 3.0+

    * Use cookies, not URL rewriting, to exchange session IDs with browsers.
    The tracking-mode element in the Servlet 3.0 specification allows you to define whether the JSESSIONID should be
    stored in a cookie or in a URL parameter. If the session id is stored in a URL parameter it could be inadvertently
    saved in a number of locations including the browser history, proxy server logs, referrer logs, web logs, etc.
    Accidental disclosure of the session id makes the application more vulnerable to session hijacking attacks.
    Instead, make sure the JSESSIONID is stored in a cookie (and has the Secure flag set).

    * Expire sessions with no too large timeouts.
    Users like long lived sessions because they are convenient. Hackers like long lived sessions because it gives them
    more time to conduct attacks like session hijacking and CSRF. Security vs usability will always be a dilemma.
    But never specify 0 or negative value, as this makes the session cookie to live forever.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[    <!-- Some of the security properties are not available below Servlet 3.0 -->
    <security-constraint>
      <web-resource-collection>
        <web-resource-name>Protected Area</web-resource-name>
        <url-pattern>/private/*</url-pattern>
        <!-- This means that other HTTP methods can access resources with no protection! -->
        <http-method>GET</http-method>
        <http-method>POST</http-method>
      </web-resource-collection>
      <auth-constraint>...</auth-constraint>
      <!-- No user-data-constraint/transport-guarantee -->
    </security-constraint>

    <session-config>
      <session-timeout>-1</session-timeout>               <!-- VIOLATION: session does not expire -->
      <!-- not secure cookie, no httpOnly, tracking mode not fixed to COOKIE -->
    </session-config>

    <!-- No error pages for 404/500 or java.lang.Throwable -->]]></example>
    <repair><![CDATA[    <security-constraint>
      <web-resource-collection>
        <web-resource-name>Protected Area</web-resource-name>
        <url-pattern>/private/*</url-pattern>
      </web-resource-collection>
      <auth-constraint>...</auth-constraint>
      <!-- No user-data-constraint/transport-guarantee -->
    </security-constraint>

    <session-config>
      <session-timeout>60</session-timeout>
      <cookie-config>
        <http-only>true</http-only>
        <secure>true</secure>
      </cookie-config>
      <tracking-mode>COOKIE</tracking-mode>
    </session-config>

    <!-- Redirect uncaught errors to neutral error message pages -->
    <error-page>
      <error-code>500</error-code>
      <location>/error500.jsp</location>
    </error-page>
    <error-page>
      <exception-type>java.lang.Throwable</exception-type>
      <location>/error500.jsp</location>
    </error-page>
    <error-page>
      <error-code>404</error-code>
      <location>/error404.jsp</location>
    </error-page>]]></repair>
    <reference><![CDATA[http://software-security.sans.org/blog/2010/08/11/security-misconfigurations-java-webxml-files,ERR01-J: https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:ERR01-J,CWE:16,CWE:384,CWE:5,CWE:613,CWE:7,OWASP:2021:A5,OWASP:2021:A7,WASC:47]]></security>
    </normatives>
    <properties>
      <property name="checkSessionTimeoutExists" descname="If true, report violation when &lt;session-timeout&gt; element doesn't exist." value="true"/>
      <property name="checkSessionIdInCookieOnly" descname="If true, configure session ID to be sent only in cookies" value="true"/>
      <property name="checkSessionTimeout" descname="If true, configure a (finite) session timeout" value="true"/>
      <property name="checkErrorPages" descname="If true, default error pages must be configured" value="true"/>
      <property name="checkSSLForProtectedAreas" descname="If true, SSL must be set for protected areas" value="false"/>
      <property name="checkSecureSession" descname="If true, session ID should be configured as secure (sent only under SSL)" value="false"/>
      <property name="checkNoHttpMethodInSecurityContraints" descname="If true, security constraints should NOT specify http methods" value="true"/>
      <property name="checkHttpOnly" descname="If true, session cookie must use httpOnly flag (not accessible from client-side scripts)" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.XmlEntityInjectionRule" message="XmlEntityInjectionRule: XML entity injection" class="com.optimyth.qaking.security.rules.java.XmlEntityInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.5.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[In XML parsers, when XML document to parse could be altered by untrusted input, and the untrusted input may
alter the Document Type Definition (DTD, embedded or external), the parser should be configured to avoid
two kinds of potential attacks:

* XML entity expansion DoS (XML bomb or "billion laughs attack"), CWE-776, where well-formed DTD with
  internal entities are expanded exponentially until they exhaust memory.

* XML external entity injection (XXE), CWE-611, where an external entity controlled by the attacker refers to the URL
  of a resource that gives unauthorized access to sensitive files on the server machine, or to a resource
  like /dev/random in Unix systems that, when entity is expanded, leads to a denial-of-service condition.
  A variant of this attack is the server-side request forgery (SSRF), where the URL for external DTD or XML-Schema
  is processed by the URL handler used by the XML parser, allowing the attacker access to an unexpected
  network resource (for cross-site request forgery attacks or port-scanning enumeration).

Please note that Java parsers are particularly vulnerable to XML entity injection attacks because their
default settings have both entity expansion and external entity resolution enabled. Disabling validations
does not help, as entity expansion / external entity loading is done even when validation is disabled.

DTD is not the unique element that an attacker could use for injection: XML-Schema attributes could be specified
on any tag, so SSRF injection may happen at any place in the XML document, not only at the start where DTD should
be placed, but fortunately common Java XML parsers do not seem to fetch schema URLs by default.

XML parsing could be hidden in other frameworks and libraries. For example, with REST, when a resource has an XML
representation, the REST framework typically use an underlying XML parser for processing the request message, which
obviusly is fully under control of a potential attacker.

To be safe during XML processing coming from untrusted sources, a number of XML features should be disabled
when configuring the parser:
* DTD interpretation - Ensure DOCTYPE tags are ignored, or documents containing them are rejected.
* Ignore or reject external entities.
* schemaLocation and noNamespaceSchemaLocation should not fetch URLs.
* XIncludes - Should be disabled or left disabled.

The rule checks that there is a path between an untrusted input and the XML document to parse,
then verifies that the XML parser is configured to avoid both external entity and entity expansion attacks.

Secure configuration againts entity expansion or external entity injection attacks depends on the API used.
The following libraries are analyzed: JAXP, SAX, StAX, DOM4J, JDOM2, JAXB, TRAX.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XML entity attacks that could cause denial-of-service and information leakage.]]></benefits>
    <inconvenients><![CDATA[Dependencies on certain features related to DTD or entity expansion may render runtime errors.]]></inconvenients>
    <example><![CDATA[// JAXP, unsafe configuration
public Document doc(HttpServletRequest req) {
  DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
  /* VIOLATION, vulnerable to XML entity injection and "billion laughs attack" */
  return dbf.newDocumentBuilder().parse( req.getInputStream() );
}

This code is vulnerable to well-known XML attack vectors like:

* "billion laughs" attack, 1K payload expands to 3GB!:
<?xml version="1.0"?>
<!DOCTYPE lolz [
 <!ENTITY lol "lol">
 <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
 <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
 <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
 <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
 <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
 <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
 <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
 <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>

* XXE (external entity attack), for sensitive file disclosure:
<!DOCTYPE roottag [
 <!ENTITY windowsfile SYSTEM "file:///c:/boot.ini">
]>
<roottag>
 <sometag>&windowsfile;</sometag>
</roottag>

* XXE, for denial-of-service under Unix servers:
<!DOCTYPE foo [
  <!ELEMENT root ANY >
  <!ENTITY unixfile SYSTEM "file:///dev/random" >
]>
<root>&unixfile;</root>]]></example>
    <repair><![CDATA[public Document doc(HttpServletRequest req) {
  DocumentBuilderFactory dbf = getFactory();
  return dbf.newDocumentBuilder().parse( req.getInputStream() );
}

/* FIXED */
private static DocumentBuilderFactory getFactory() {
  DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
  // Use this if the JAXP parser accepts it
  dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
  // AND add the following to enforce limits on what the parser is allowed to do
  dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
  dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
  dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
  dbf.setXIncludeAware(false);
  dbf.setExpandEntityReferences(false);

  return dbf;
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/611.html,http://cwe.mitre.org/data/definitions/776.html,XML Schema, DTD, and Entity Attacks: http://www.vsecurity.com/download/papers/XMLDTDEntityAttacks.pdf,https://www.securecoding.cert.org/confluence/display/java/IDS16-J.+Prevent+XML+Injection,https://github.com/OWASP/CheatSheetSeries/blob/master/ch]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS16-J,CERT-J:IDS17-J,CWE:611,CWE:776,CWETOP25:2021:23,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:43,WASC:44]]></security>
    </normatives>
    <properties>
      <property name="parametersAsSources" descname="Assume that method parameters are untrusted inputs" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.XPathInjectionRule" message="XPathInjectionRule: Improper Neutralization of Data within XPath Expressions ('XPath Injection')" class="com.optimyth.qaking.security.rules.java.XPathInjectionRule" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.10,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[The software uses external input to dynamically construct an XPath expression used to
retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input.
This allows an attacker to control the structure of the query.

Effect: the attacker will have control over the information selected from the XML database and may use that ability
to control application flow, modify logic, retrieve unauthorized data, or bypass important checks (e.g. authentication).

This check looks for calls that create or execute an XPath expression, and detects if an untrusted input could
change the XPath code used at that call.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XPath injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[private boolean doLogin(String loginID, char[] password)
  throws ParserConfigurationException, SAXException, IOException, XPathExpressionException {

  DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
  domFactory.setNamespaceAware(true);
  DocumentBuilder builder = domFactory.newDocumentBuilder();
  Document doc = builder.parse("users.xml");
  String pwd = hashPassword( password);

  XPathFactory factory = XPathFactory.newInstance();
  XPath xpath = factory.newXPath();
  // VIOLATION - xpath code concatenated with untrusted input
  XPathExpression expr = xpath.compile(
    "//users/user[login/text()='" + loginID + "' and password/text()='" + pwd + "' ]"
  );
  Object result = expr.evaluate(doc, XPathConstants.NODESET);
  NodeList nodes = (NodeList) result;

  for (int i = 0; i < nodes.getLength(); i++) {
    Node node = nodes.item(i).getChildNodes().item(1).getChildNodes().item(0);
    System.out.println( "Authenticated: " + node.getNodeValue());
  }

  return (nodes.getLength() >= 1);
}]]></example>
    <repair><![CDATA[// Escape metacharacters in input
loginID = loginID.replace("'", "&apos;");

// Alternatively, use XQuery APIs and avoid concatenating untrusted input
// XPath expression in login.qry
declare variable $loginID as xs:string external;
declare variable $password as xs:string external;
//users/user[@loginID=$loginID and @password=$password]

// Fixed doLogin()
private boolean doLogin(String loginID, String pwd)
  throws ParserConfigurationException, SAXException, IOException, XPathExpressionException {

  DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
  domFactory.setNamespaceAware(true);
  DocumentBuilder builder = domFactory.newDocumentBuilder();
  Document doc = builder.parse("users.xml");

  XQuery xquery = new XQueryFactory().createXQuery(new File("login.xry"));
  Map queryVars = new HashMap();
  queryVars.put("loginid", loginID);
  queryVars.put("password", pwd);
  NodeList nodes = xquery.execute(doc, null, queryVars).toNodes();

  for (int i = 0; i < nodes.getLength(); i++) {
    Node node = nodes.item(i).getChildNodes().item(1).getChildNodes().item(0);
    System.out.println( node.getNodeValue());
  }

  return (nodes.getLength() >= 1);
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/643.html,https://www.securecoding.cert.org/confluence/display/java/IDS53-J.+Prevent+XPath+Injection]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:IDS53-J,CWE:643,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:39]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input)" value="user_input"/>
      <property name="parametersAsSources" descname="Assume that method parameters are untrusted inputs" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SEC_JAVA.XsltInjection" message="XsltInjection: XML Injection (aka Blind XPath Injection)" class="com.optimyth.qaking.security.rules.java.XsltInjection" technology="JAVA" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[If the software allows untrusted inputs to control part or all of an XSLT stylesheet,
an attacker may change the structure and content of resulting XML.

If the resulting XML ends in a browser, the attacker may choose contents to launch cross-site scripting
attacks, or execute operations at server with victim's identity allowed by the browser's same-origin policy
(a variantof the cross-site request forgery attack).

The attacker may also use this flaw to launch attacks targeted at the server, like fetching content
from arbitrary files, running arbitrary Java code, or executing OS commands, when certain XSLT functions
are not disabled.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XSLT Injection flaws allowing server-side and client-side attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.*;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

// A kind of XSLT-based responsive-web output,
// a "hidden" xslt.url parameter chooses which XSLT to use. Dangerous...
public void render(HttpServletRequest req, HttpServletResponse res) throws TransformerException, IOException {
  InputStream xmlUrl = openStream(req.getParameter("xml.url"));
  InputStream xsltUrl = openStream(req.getParameter("xslt.url"));

  Source xmlSource = new StreamSource(xmlUrl); // XML injection here, but this is another story
  Source xsltSource = new StreamSource(xsltUrl);
  Result result = new StreamResult(res.getOutputStream()); // "send to browser"

  TransformerFactory transFact = TransformerFactory.newInstance();
  Transformer trans = transFact.newTransformer(xsltSource); // VIOLATION, XSLT injection
  trans.transform(xmlSource, result);
}

Attackers may use as attack vectors:
* XSS payloads (run in browser rendering the transformation result):
<xsl:template match="/">
  <script>alert('You are XSSed')</script>
</xsl:template>

* Read arbitrary files from server:
<xsl:template match="/">
  <xsl:copy-of select="document('/etc/passwd')"/>
</xsl:template>

* Execute arbitrary Java code (if XSLT functions not disabled):
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:rt="http://xml.apache.org/xalan/java/java.lang.Runtime"
  xmlns:ob="http://xml.apache.org/xalan/java/java.lang.Object">
  <xsl:template match="/">
    <xsl:variable name="rtobj" select="rt:getRuntime()"/>
    <xsl:variable name="process" select="rt:exec($rtobj, 'rm -rf /')"/>
  </xsl:template>
</xsl:stylesheet>]]></example>
    <repair><![CDATA[// Do not allow external input to select the XSLT stylesheet to use.
// Instead, let the external input to choose between a fixed set of
// allowed stylesheets provided by the software.]]></repair>
    <reference><![CDATA[https://blog.csnc.ch/2015/06/xslt-security-and-server-side-request-forgery/]]></reference>
    <normatives>
      <security><![CDATA[CWE:91,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SERI.PrivateReadWriteObjects" message="PrivateReadWriteObjects: Declare optional readObject and writeObject as private in externalizable / serializable classes" class="com.als.clases.rational.ExtSerMustImpReadWriteRule" technology="JAVA" active="true">
    <tags><![CDATA[essential]]></tags>
    <description><![CDATA[In classes that implement the java.io.Externalizable or java.io.Serializable interfaces, when the readObject() / writeObject() methods
are implemented, those methods have to be declared as private.

The declaration of readObject() and writeObject() as private is expected by the Java serialization protocol.
If not, security problems may occur in the application: Such methods should not be available to third parties, and
they should not be overwritten in subclasses. Not making them private breaks these assumptions.

NOTE: The readObjectNoData(), when implemented, must be private as well.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[public class SerializableObject implements Serializable {
  private static final long serialVersionUID = 123;

  // VIOLATION, not private
  public void writeObject(ObjectOutputStream s) throws IOException {
    s.defaultWriteObject();
  }

  // VIOLATION, not private
  public void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    s.defaultReadObject();
  }
}]]></example>
    <repair><![CDATA[// Declare readObject() and writeObject() as private.

public class SerializableObject implements Serializable {
  private static final long serialVersionUID = 123;

  // FIXED
  private void writeObject(ObjectOutputStream s) throws IOException {
    s.defaultWriteObject();
  }

  // FIXED
  private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    s.defaultReadObject();
  }
}]]></repair>
    <reference><![CDATA[https://www.securecoding.cert.org/confluence/display/java/SER01-J.+Do+not+deviate+from+the+proper+signatures+of+serialization+methods]]></reference>
    <normatives>
      <security><![CDATA[CERT-J:SER01-J]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SPRING.AvoidDataSubmissionToNonEditableField" message="AvoidDataSubmissionToNonEditableField: Avoid data submissions to non editable fields" class="com.optimyth.qaking.spring.rules.AvoidDataSubmissionToNonEditableField" technology="JAVA" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.2,CWEScope:Integrity,Framework:Spring,Framework:Spring-MVC]]></tags>
    <description><![CDATA[Usually some model fields should not been edited, or at least its modification is not
expected, i.e. username, id,...

Spring MVC module automatically auto binds the HTML form data into the model by using all the available setters, even a
naive user doesn't expect they are going to be used.

Thus, a malicious attacker can send an infected request containing a value for some of the non editable fields.
Controller would receive this data and bind it to the model, allowing the attacker to perform malicious, unexpected,
activities.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent the modification of sensible data by a malicious user, allowing him to perform malicious activities as session hijacking , improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[@Controller
@RequestMapping(value = "/spring/cities")
public class SpringCityController { // VIOLATION

  @RequestMapping(value = "/{id}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
  public @ResponseBody
  SpringCity getById(@PathVariable("id") Integer id) {
    return new SpringCity("SpringCityById", 1982700, 52);
  }

  @RequestMapping(value = "/{id}", method = RequestMethod.PUT)
  public @ResponseBody
  SpringCity put(@ModelAttribute("customer") Customer customer, @RequestBody SpringCity SpringCity) {
    return SpringCity;
  }
}]]></example>
    <repair><![CDATA[import org.springframework.web.bind.WebDataBinder;

@Controller
@RequestMapping(value = "/spring/cities")
public class SpringCityController {

  @InitBinder
  public void initBinder(WebDataBinder binder) {
      binder.setDisallowedFields("administrator");
  }

  @RequestMapping(value = "/{id}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
  public @ResponseBody
  SpringCity getById(@PathVariable("id") Integer id) {
    return new SpringCity("SpringCityById", 1982700, 52);
  }

  @RequestMapping(value = "/{id}", method = RequestMethod.PUT)
  public @ResponseBody
  SpringCity put(@ModelAttribute("customer") Customer customer, @RequestBody SpringCity SpringCity) {
    return SpringCity;
  }
}]]></repair>
    <reference><![CDATA[http://projects.webappsec.org/w/page/13246913/Abuse%20of%20Functionality,https://cwe.mitre.org/data/definitions/915.html,https://www.owasp.org/index.php/Mass_Assignment_Cheat_Sheet]]></reference>
    <normatives>
      <security><![CDATA[CWE:915,OWASP:2021:A8,WASC:42]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.SPRING.PreventExpositionOfAllRepositories" message="PreventExpositionOfAllRepositories: Avoid exposing all repositories as REST resources" class="com.optimyth.qaking.spring.rules.PreventExpositionOfAllRepositories" technology="JAVA" active="true">
    <tags><![CDATA[Framework:Spring,Framework:Spring-Data,Framework:Spring-Data-REST]]></tags>
    <description><![CDATA[Spring Data module is used to easily access and mine data form Spring applications. Data
can be obtained from SQL or NoSQL databases, REST services,...

When data is going to be obtained from a REST service, a RepositoryDetectionStrategy is used to determine which
repositories will be exported as REST resources. There are several strategies:
  - DEFAULT strategy exposes all public repository interfaces except the ones explicitly annotated with
  @(Repository)RestResource having their exported flag set to false.
  - ALL strategy exposes all repositories independently of type visibility and annotations.
  - ANNOTATION strategy exposes only repositories annotated with @(Repository)RestResource are exposed, unless their
  exported flag is set to false.
  - VISIBILITY strategy exposes only public repositories annotated are exposed.

Using the ALL strategy can lead to security leaks, as maybe some of them were not expected to be shared.

A better option would be using the DEFAULT, ANNOTATION or VISIBILITY strategies, as they only expose previously
annotates repositories, reducing the probabilities of exposing an unwanted repository.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid exposing unwanted repositories, increasing security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.core.mapping.RepositoryDetectionStrategy.RepositoryDetectionStrategies;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurer;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurerAdapter;
import org.springframework.stereotype.Component;

@Configuration
class CustomRestMvcConfiguration {

  @Bean
  public RepositoryRestConfigurer repositoryRestConfigurer() {

    return new RepositoryRestConfigurerAdapter() {

      @Override
      public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
        config.setBasePath("/api");
        config.setRepositoryDetectionStrategy(RepositoryDetectionStrategies.ALL);		// Violation
      }
    };
  }
}]]></example>
    <repair><![CDATA[import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.core.mapping.RepositoryDetectionStrategy.RepositoryDetectionStrategies;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurer;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurerAdapter;
import org.springframework.stereotype.Component;

@Configuration
class CustomRestMvcConfiguration {

  @Bean
  public RepositoryRestConfigurer repositoryRestConfigurer() {

    return new RepositoryRestConfigurerAdapter() {

      @Override
      public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
        config.setBasePath("/api");
        config.setRepositoryDetectionStrategy(RepositoryDetectionStrategies.ANNOTATION);		// Ok
      }
    };
  }
}]]></repair>
    <reference><![CDATA[http://docs.spring.io/spring-data/rest/docs/2.5.1.RELEASE/reference/html/#getting-started.basic-settings]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVA.TRS.AUTG" message="AUTG: Avoid using variables of type java.lang.ThreadGroup" class="com.als.clases.oyr.trs.Autg" technology="JAVA" active="true">
    <description><![CDATA[Do not use java.lang.ThreadGroup variables.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA['ThreadGroup' has security defects and should be avoided. There are other options to simulate its behaviour, such as
    use a references array for the Threads.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[]]></example>
    <repair><![CDATA[Store Thread references in an array or collection.]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <categories>
    <category name="JAVA" technology="JAVA" active="true" weight="1.0">
      <description><![CDATA[JAVA rules]]></description>
      <children>
        <category name="OPT.CRITERIUM_VALUE.CQM.EFFICIENCY" technology="JAVA" active="true" weight="0.0">
          <description><![CDATA[Efficiency]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.MAINTAINABILITY" technology="JAVA" active="true" weight="0.0">
          <description><![CDATA[Maintainability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.PORTABILITY" technology="JAVA" active="true" weight="0.0">
          <description><![CDATA[Portability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.RELIABILITY" technology="JAVA" active="true" weight="0.0">
          <description><![CDATA[Reliability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.SECURITY" technology="JAVA" active="true" weight="10.0">
          <description><![CDATA[Security]]></description>
        </category>
      </children>
    </category>
  </categories>
</ruleset>
