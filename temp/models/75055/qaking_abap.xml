<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="qaking_abap" updated="">
  <description>EDCAST_MOBILE</description>
  <rule name="OPT.ABAP.AGR.CallSysFunction" message="CallSysFunction: Do not call system / kernel functions from ABAP application code" class="com.als.abap.rules.agr.AGR_CallSysFunction" technology="ABAP" active="true">
    <tags><![CDATA[essential]]></tags>
    <description><![CDATA[Avoid calls to system functions (kernel calls, SYSTEM-CALL), because they are reserved for internal use, and they could be modified
by SAP and lead to errors or unexpected behaviour. They are not portable between SAP versions, and add significant security risks.

System functions could be called using SYSTEM-CALL statement, or using kernel function calls (CALL FUNCTION 'cfunc' ID id FIELD fld),
also known as C function calls (because they were implemented typically in the C language).

Calls of system functions whose names or parameters are injected into the program from outside present a serious security risk.
The values from outside must be checked thoroughly before being used. In particular, there are 8 high risk kernel calls: SYSTEM
(OS command exec), C_DB_EXECUTE / C_DB_FUNCTION (native SQL execution), C_GET_TABLE / C_MOD_TABLE (for accessing and modifying
database tables), INTERNET_USER_LOGON (user switch), and XXPASS / XXPASSNET (compute password hash).

Since SAP 6.20, kernel methods replace both kinds of system functions.

Note: The related rule SEC.CommandInjection checks kernel function calls for potential command injection vulnerabilities.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid stability and security issues.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* VIOLATION, ABAP kernel call (to system shell)
CALL 'SYSTEM' ID 'COMMAND' FIELD l_unix_command ID 'ITAB' FIELD itab-*sys*.

* VIOLATION, ABAP kernel call
CALL 'C_DB_EXECUTE' ID 'STATLEN' FIELD lv_len
  ID 'STATTXT' FIELD lv_stmt ID 'SQLERR' FIELD lv_sqlerr.

* VIOLATION, system call
SYSTEM-CALL ICT DID 29
  PARAMETERS
    lv_buff1 lv_buff2 lv_dummy lv_dummy
    lv_dummy lv_dummy lv_dummy lv_dummy.]]></example>
    <repair><![CDATA[" Do not call system / kernel functions from ABAP application code.]]></repair>
    <reference><![CDATA[http://virtualforge.com/tl_files/Theme/Presentations/The%20ABAP%20Underverse%20-%20Slides.pdf,http://help.sap.com/abapdocu_750/en/ABAPSYSTEM-CALL.htm,http://help.sap.com/abapdocu_750/en/ABAPCALL-.htm]]></reference>
    <normatives>
      <security><![CDATA[CWE:676,OWASP:2021:A6,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.AGR.CallTx" message="CallTx: Avoid called transactions corresponding to a certain module" class="com.als.abap.rules.agr.AGR_CallTx" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.1.1,ASVS-v4.0.2:14.5.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Avoid calling transactions corresponding to a certain SAP module.

All transactions for all modules are searched by default.
When callTx* configuration property for matching SAP module is set to false, calls to its transactions are allowed.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid access to predetermined modules.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[CALL TRANSACTION 'SE38' USING BDCDATA  MODE 'N'. "VIOLATION, CALL DEVELOPER MODULE TRANSACTION
CALL TRANSACTION 'FB09' USING BDC_TAB MODE 'A' MESSAGES INTO ERR_BI. "VIOLATION, CALL CO TRANSACTION]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:04,CWE:749]]></security>
    </normatives>
    <properties>
      <property name="callTxHR" descname="CALL HR TRANSACTION" value="true"/>
      <property name="callTxDev" descname="CALL DEVELOPER MODULE TRANSACTION" value="true"/>
      <property name="callTxQM" descname="CALL QM TRANSACTION" value="true"/>
      <property name="callTxFI" descname="CALL FI TRANSACTION" value="true"/>
      <property name="callTxPS" descname="CALL PS TRANSACTION" value="true"/>
      <property name="callTxWF" descname="CALL WF TRANSACTION" value="true"/>
      <property name="callTxPP" descname="CALL PP TRANSACTION" value="true"/>
      <property name="callTxPM" descname="CALL PM TRANSACTION" value="true"/>
      <property name="callTxMM" descname="CALL MM TRANSACTION" value="true"/>
      <property name="callTxSD" descname="CALL SD TRANSACTION" value="true"/>
      <property name="callTxCO" descname="CALL CO TRANSACTION" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.APBR.NoBreakPointStatements" message="NoBreakPointStatements: Remove BREAK-POINT statements from production code" class="com.als.abap.rules.apbr.APBR_NoBreakPointStatements" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,infoleak]]></tags>
    <description><![CDATA[Remove BREAK-POINT statements from production code. These sentences may stop code in production, and provide back-door
access (debugger) into code or sensitive data.]]></description>
    <priority>1</priority>
    <effort>1</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid break-points leaked to code deployed in production.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[START-OF-SELECTION.
  PERFORM get_mard.
  PERFORM get_unit_of_measure.
  PERFORM get_marc.
  PERFORM get_ekpo.
  PERFORM get_lips.
  PERFORM get_vbap.
  PERFORM get_open.
  PERFORM get_price.

END-OF-SELECTION.
	BREAK-POINT. " VIOLATION
	PERFORM build_layout USING layout.
	PERFORM write_output.]]></example>
    <repair><![CDATA[START-OF-SELECTION.
  PERFORM get_mard.
  PERFORM get_unit_of_measure.
  PERFORM get_marc.
  PERFORM get_ekpo.
  PERFORM get_lips.
  PERFORM get_vbap.
  PERFORM get_open.
  PERFORM get_price.

END-OF-SELECTION.
	" FIXED, break-point removed
	PERFORM build_layout USING layout.
	PERFORM write_output.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/489.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:489]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.ASR.ControlFieldsClientTables" message="ControlFieldsClientTables: Include audit fields in custom tables" class="com.als.abap.rules.asr.ASR_ControlFieldsClientTables" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:7.1.3,ASVS-v4.0.2:7.1.4,ASVS-v4.0.2:7.2.1,CWEScope:Non-Repudiation,repository]]></tags>
    <description><![CDATA[Sensitive custom tables in the data dictionary must have specific columns for auditing.
These columns should be at least the client name (like MANDT), the user who realized the last modification, and the modification date & time.

This rule works with the information extracted by SAP Connector.
A single violation will be emitted with all tables matching pattern but not having proper audit fields.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Audit structure for sensitive personalized tables is enforced.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/778.html,http://events.asug.com/2011AC/706_Secure_Programming_ABAP.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:778]]></security>
    </normatives>
    <properties>
      <property name="clientColumns" descname="Comma-separated list of columns allowed for SAP client (MANDT)" value="MANDT,CLIENT"/>
      <property name="pattern" descname="Regular expression for custom tables that should have audit columns" value="Z.*"/>
      <property name="timeColumns" descname="Comma-separated list of columns allowed for modification time" value="AS4TIME,TIME"/>
      <property name="dateColumns" descname="Comma-separated list of columns allowed for modification date" value="AS4DATE,DATE"/>
      <property name="userColumns" descname="Comma-separated list of columns allowed for SAP user" value="AS4USER,USER"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.RELIABILITY.DirectRecursiveCall" message="DirectRecursiveCall: Avoid recursive calls" class="com.optimyth.qaking.abap.rules.reliability.DirectRecursiveCall" technology="ABAP" active="true">
    <tags><![CDATA[essential,potential-bug]]></tags>
    <description><![CDATA[Calling an ABAP procedure unit (function module, subroutine, method, or program) recursively may produce an endless loop,
unless exit from recursion is tightly controlled.

The rule reports any direct recursive call.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Control flow management</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[FORM factorial USING iv_val TYPE i.
  DATA: lv_temp TYPE i.

  " What happens if input is negative?
  IF iv_val = 0.
    iv_val = 1.
  ELSE.
    lv_temp = iv_val - 1.
    " VIOLATION, recursive call
    PERFORM factorial USING lv_temp.
    MULTIPLY iv_val BY lv_temp.
  ENDIF.
ENDFORM.]]></example>
    <repair><![CDATA[FORM factorial USING iv_val TYPE i.
  DATA: lv_res type i value 1.

  " Check for invalid input (not shown)
  DO iv_val TIMES.
    MULTIPLY lv_res BY sy-index.
  ENDDO.

  iv_val = lv_res.
ENDFORM.]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.RELIABILITY.UncaughtExceptionInRfcCall" message="UncaughtExceptionInRfcCall: Uncaught exception in RFC call" class="com.optimyth.qaking.abap.rules.reliability.UncaughtExceptionInRfcCall" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Integrity,essential]]></tags>
    <description><![CDATA[In remote function calls (RFC), the special exceptions COMMUNICATION_FAILURE and SYSTEM_FAILURE may be reported
by SAP when there are problems with the RFC connection to the remote SAP system.

It is necessary to check for these exceptions for every RFC call (CALL FUNCTION ... DESTINATION ...), even
when the called function module uses the modern class-based exceptions.

SYSTEM_FAILURE is triggered if the target server crashes. COMMUNICATION_FAILURE is triggered if there is a connection
or communication problem. In both cases, the optional addition MESSAGE could be used to receive a description of the error.

Unhandled exceptions will likely result in unexpected program state, data inconsistencies and other effects,
as the call failure will not be detected.

Note: If the 'catch-all' OTHERS exception is declared in the call, the violation emitted will be informative,
as this is not the recommended way to handle RFC system errors.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Error handling and fault isolation</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[FORM myform.
  " VIOLATION, uncaught RFC-specific exceptions
  CALL FUNCTION 'Z_MY_RFC_FUNC' DESTINATION lv_rfc
    EXPORTING
      item_id = lv_one
    IMPORTING
      result = lv_two
    EXCEPTIONS
      bizz_error = 1.

  IF sy-subrc NE 0.
    " Exception handling
  ENDIF.
ENDFORM.]]></example>
    <repair><![CDATA[FORM myform.

  CALL FUNCTION 'Z_MY_RFC_FUNC' DESTINATION lv_rfc
    EXPORTING
      item_id = lv_one
    IMPORTING
      result = lv_two
    EXCEPTIONS
      bizz_error = 1
      " FIXED
      communication_failure = 10 MESSAGE com_msg
      system_failure = 11 MESSAGE sys_msg
      " also recommended against future exception interface changes
      OTHERS = 12.

  IF sy-subrc NE 0.
    " Exception handling, com_msg/sys_msg contain details of the RFC error
  ENDIF.
ENDFORM.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/391.html,https://help.sap.com/doc/abapdocu_750_index_htm/7.50/en-US/abenrfc_exception.htm]]></reference>
    <normatives>
      <security><![CDATA[CWE:391,PCI-DSS:6.5.5]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.Backdoors" message="Backdoors: Avoid development/test backdoors in production code" class="com.optimyth.qaking.abap.rules.sec.Backdoors" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,backdoors]]></tags>
    <description><![CDATA[A backdoor in application code provides access paths to functionality designed to "jump" over security
checks, intended to simplify development or testing. If these backdoors are left in production code,
they could be used by an attacker to gain access to confidential data, o manipulate data, in ways that
were not anticipated by the development team. Perpetrators could be developers, testers, or external
hackers as well.

Detecting any backdoor in ABAP code is not possible for all cases, but the rule tries to identify
common constructs that may appear in development-injected backdoors. In particular, it tries to find
comparisons made against sy-uname system variable (in logical conditions that check for a fixed value,
in ranges or matching certain patterns).

Additionally, the 'inputFieldPattern' pattern could be provided to match name of web input fields
(form fields, HTTP header or cookies) that are fetch and later compared in a similar way as the
checks performed on sy-uname variable, which are marked as potential backdoors as well. For example,
it is customary to use an "ADMIN" web field passed to a BSP application to be used as backdoor-controlling
input.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid potential backdoors in production code.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* Typical backdoor in place for functionality to be run as a testing user
if sy-uname = 'TEST_USER'.     " BACKDOOR!
  do_admin_operation().
endif.

* Other potential backdoor, checks list of users in a custom table
* Not reported by the rule
SELECT flag FROM zusers INTO lv_flag WHERE usname = sy-uname.
ENDSELECT.
IF sy-subrc = 0.
  do_admin_operation().
ENDIF.

* Another potential backdoor, if ADMIN_EXEC matched by registered 'inputFieldPattern' property
param = request->get_form_field( 'ADMIN_EXEC' ).
if param = 'Y'.               " BACKDOOR!
  do_admin_operation().
endif.]]></example>
    <repair><![CDATA[Check potential backdoors and remove them from production code, replacing by standard
authorization checks (AUTHORITY-CHECK or alternatives) if necessary.
In case the backdoor reported is considered safe, a supression could be added to ignore the violation.]]></repair>
    <reference><![CDATA[Secure ABAP Programming (Sichere ABAP-Programmierung) section 5.2]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:11,CWE:489,PCI-DSS:6.5.5]]></security>
    </normatives>
    <properties>
      <property name="inputFieldPattern" descname="Regular expression to match web inputs (fields, cookies, headers) that will be considered potential backdoor-controlling input." value="ADMIN.*"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.BadAuthorizationCheck" message="BadAuthorizationCheck: Improper implementation of authorization check" class="com.optimyth.qaking.abap.rules.sec.BadAuthorizationCheck" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Roles and authorizations are a central security topic in SAP environments.
Properly coding explicit SAP authorization checks in ABAP is not trivial.
Not performing or performing incorrectly authorization checks may lead to information exposures and other consequences.

The best authorization concept is rather useless if custom code does not check (correctly) the necessary authorizations.

Security issues arise in the following cases:
- the developer forgets to perform an authorization check in the code.
- The developer uses the wrong authorization object.
- The developer uses proprietary authorization logic.
- The developer does not handle the return value of the authorization check correctly.

Using the standard AUTHORITY-CHECK statement (or an API like function / method that invokes it) is better than using
a propietary authorization scheme, as there are well-known transactions for maintaining the authorization permissions,
and only such checks appear in the SAP authorization trace. Using "custom" authorization controls based on usernames
and/or custom tables is a bad practice.

This rule checks security defect APP-04 in BIZEC APP/11 standard.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[" VIOLATION, sy-subrc not checked
AUTHORITY-CHECK OBJECT 'S_TCODE' ID 'TCD' FIELD 'SE80'.
CALL TRANSACTION 'SE80'.

" VIOLATION, TCD field for S_TCODE should not use DUMMMY
AUTHORITY-CHECK OBJECT 'S_TCODE' ID 'TCD' DUMMY.
IF sy-subrc = 0.
  CALL TRANSACTION 'SE80'.
ENDIF.

" VIOLATION, TCD field for S_TCODE should not use wildcards
AUTHORITY-CHECK OBJECT 'S_TCODE' ID 'TCD' FIELD '*'.
IF sy-subrc = 0.
  CALL TRANSACTION 'SE80'.
ENDIF.

" VIOLATIONS:
" P_GROUP should appear (e.g. as DUMMY),
" DEVCLASS should not be wildcard
" ACTVT should have a proper value
AUTHORITY-CHECK OBJECT 'S_DEVELOP'
  ID 'DEVCLASS' FIELD '*'
  ID 'OBJTYPE'  FIELD 'PROG'
  ID 'OBJNAME'  FIELD lv_prog
  ID 'ACTVT'    DUMMY.

IF sy-subrc = 0.
  READ REPORT lv_prog INTO lt_code.
ENDIF.]]></example>
    <repair><![CDATA[" OK
AUTHORITY-CHECK OBJECT 'S_TCODE' ID 'TCD' FIELD 'SE80'.
IF sy-subrc = 0.
  CALL TRANSACTION 'SE80'.
ENDIF.

" OK
AUTHORITY-CHECK OBJECT 'S_DEVELOP'
  ID 'DEVCLASS' FIELD 'PKG'
  ID 'OBJTYPE'  FIELD 'PROG'
  ID 'OBJNAME'  FIELD lv_prog
  ID 'P_GROUP'  DUMMY " not required in this context
  ID 'ACTVT'    FIELD '03'.

IF sy-subrc = 0.
  READ REPORT lv_prog INTO lt_code.
ENDIF.]]></repair>
    <reference><![CDATA[DSAG - Best Practice Guidelines for Development, section 5.1.1 "Authorization Checks".]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:04,CWE:285,OWASP:2021:A1]]></security>
    </normatives>
    <properties>
      <property name="checkForUser" descname="If true, FOR USER addition is forbidden" value="true"/>
      <property name="checkFields" descname="If true, fields are checked" value="true"/>
      <property name="useAlternateAPI" descname="If true, when alternate API for authorization objects exist, it should be used" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.Calls2CriticalFunctions" message="Calls2CriticalFunctions: Calls to Critical ABAP functions" class="com.optimyth.qaking.abap.rules.sec.informative.Calls2CriticalFunctions" technology="ABAP" active="true">
    <tags><![CDATA[informative]]></tags>
    <description><![CDATA[Some ABAP functions (function modules or class methods) offer a functionality that represents a potential security issue.

For example, calls to RFC_ABAP_INSTALL_AND_RUN create and execute new ABAP reports (which might lead to code injection
security vulnerabilities); calls to RFC_READ_TABLE might extract data from any SAP table, opening the system to
potential information leak issues; and calls to BAPI_USER_GET_DETAIL could be used to extract full details for an user account.

Code using critical ABAP functions can introduce the risk of exposure and/or manipulation of critical business or configuration data
in a SAP system.]]></description>
    <priority>5</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[" VIOLATION, call to critical funcion module
CALL FUNCTION 'RFC_READ_TABLE'
  EXPORTING
    query_table = p_table
  TABLES
    options = lt_option
    data = lt_data
  EXCEPTIONS
    table_not_available = 1
    table_without_data = 2
    OTHERS = 3.]]></example>
    <repair><![CDATA[" Replace code with equivalent logic using non-critical functions.
" If not possible, if the call should be allowed after analysis, you may mute the defect.]]></repair>
    <reference><![CDATA[]]></reference>
    <properties>
      <property name="methods" descname="Comma-separated list of class methods (in the format class-&gt;method) whose calls will be reported." value=""/>
      <property name="functions" descname="Comma-separated list of function modules whose calls will be reported.">
        <value><![CDATA[
BAPI_UPLOAD_DATA, BAPI_USER_ACTGROUPS_ASSIGN, BAPI_USER_ACTGROUPS_DELETE, BAPI_USER_CHANGE,
BAPI_USER_CLONE, BAPI_USER_CREATE, BAPI_USER_CREATE1, BAPI_USER_DELETE, BAPI_USER_GETLIST, BAPI_USER_GET_DETAIL,
BAPI_USER_INTERNET_CREATE, BAPI_USER_LOCACTGROUPS_ASSIGN, BAPI_USER_LOCACTGROUPS_DELETE, BAPI_USER_LOCK,
BAPI_USER_PROFILES_ASSIGN, BAPI_USER_PROFILES_DELETE, BAPI_USER_UNLOCK,
HTTP_ACTIVATE_NODE,
RFC_ABAP_INSTALL_AND_RUN,
RFC_READ_TABLE,
SUSR_AUTH_CREATE, SUSR_BAPI_USER_CHANGE, SUSR_BAPI_USER_CREATE, SUSR_BAPI_USER_LOCK, SUSR_BAPI_USER_UNLOCK,
SUSR_BAPI_USER_PROFILES_ASSIGN, SUSR_BAPI_USER_PROFILES_DELETE, SUSR_CERT_ASSIGN, SUSR_CREATE_USER,
SUSR_GENERATE_PASSWORD, SUSR_INTERNET_PASSWORD_RESET,
SUSR_USER_CHANGE, SUSR_USER_CHANGE_PASSWORD_RFC, SUSR_USER_CREATE, SUSR_USER_LOCK, SUSR_USER_UNLOCK,
SUSR_USER_READ
        ]]></value>
      </property>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.CommandInjection" message="CommandInjection: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" class="com.optimyth.qaking.abap.rules.sec.CommandInjection" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[Executing commands that include unvalidated user input can cause an application to execute malicious commands on behalf of an attacker.
The 'official' way to execute OS commands in SAP is transaction SM49.

There are many ways to execute OS commands in SAP, rule checks the following cases:

* CALL TRANSACTION 'SM49'. If command-line arguments depend on non-neutralized external input, code is vulnerable to OS command injection.
Even if the OS command cannot be altered by the attacker, command arguments may include shell characters (; or | or && are typical options)
so the attacker could feed additional commands.

* SXPG_CALL_SYSTEM/SXPG_COMMAND_EXECUTE: The function modules SXPG_CALL_SYSTEM and SXPG_COMMAND_EXECUTE can be used
to execute a command by providing its alias and optional parameters. Function module SXPG_CALL_SYSTEM executes commands on the SAP system
where it is called, whereas function module SXPG_COMMAND_EXECUTE can execute commands on other/remote SAP systems.
The (called) SAP system finally determines the proper command for the operating system it is running on by resolving
the alias value and executes the command along with any parameters.

This mechanism of the SAP standard allows certain control over the operating system commands that can be executed,
since a white list of allowed commands can be specified. Additionally, execution of the specified commands can be further
restricted with the authorization object S_LOG_COM. But it is possible to perform OS Command Injection attacks even through
the function modules SXPG_CALL_SYSTEM and SXPG_COMMAND_EXECUTE are used. This is possible, if the (optional) additional_parameters
of the called OS command are based on user input. In this case, malicious users can try to "chain" the executed command
with a second command. This can be done by feeding specific command characters (e.g. 'pipe') to the parameters,
so commands executed could be controlled by the external input.

* CALL 'SYSTEM': The ABAP command CALL allows to invoke functionality in the SAP Kernel. Kernel function 'SYSTEM' can be used
to execute arbitrary OS commands. The authorization object S_C_FUNCT allows restricting its execution by means of SAP authorizations.
This can provide a second layer of defense. However, this authorization object only determines IF a user can execute CALL 'SYSTEM',
not which OS commands are actually executed. SAP emphasizes that this call is for internal use only, and should not be used in
application code.

* CALL 'ThWpInfo': This call admits a PROG argument, which should not depend on external input.

* OPEN DATASET ... FILTER: OPEN DATASET (ABAP command that opens files on the SAP application server) can execute arbitrary OS commands
through the option FILTER. This could be restricted with authorization object S_DATASET, but when command could be controlled by
external input, an OS Command Injection attack could succeed.

* RFC_REMOTE_EXEC and RFC_REMOTE_PIPE: Function modules that invoke server program rfcexec, allowing execution of arbitrary OS commands.
A 'command' parameter, when tainted with external input, could be targeted for injection attack.

* Calls to method CL_GUI_FRONTEND_SERVICES->EXECUTE or (obsolete) function modules WS_EXECUTE, GUI_EXECUTE or GUI_RUN,
when arguments related to the command to execute (in client workstation) are potentially tainted with external input.

Remember: Whoever controls the operating system, controls the SAP system as well.

The rule checks for above cases and emits a violation when vulnerable arguments are not clearly constant
(input neutralization is complex for OS commands).

Please note that exposed functionality in SAP systems may be vulnerable to command-injection attacks. For example,
the TH_GREP function module was vulnerable, and was patched in support packages since 2011.

This rule checks security defect APP-02 in BIZEC APP/11 standard.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended OS command execution. Whoever controls the operating system, controls SAP system as well.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[REPORT ZFT.

PARAMETERS lv_opt TYPE string.
PARAMETERS lv_prog TYPE string.

TYPES: BEGIN OF res_type,
         line(255) TYPE c,
       END OF res_type.

DATA res_tab TYPE TABLE OF res_type.
DATA mycmd   TYPE string.

PARAMETERS mycmd TYPE string.

DATA th_opcode(1)        TYPE x.
DATA opcode_wp_exec_prog LIKE th_opcode VALUE 9.
DATA lv_server           TYPE c LENGTH 30.
lv_server = ' '.

* VIOLATION, SYSTEM with command taken from external input
CALL 'SYSTEM' ID 'COMMAND' FIELD lv_prog.

* VIOLATION, ThWpInfo may be vulnerable to OS command injection.
CALL 'ThWpInfo' ID 'OPCODE' FIELD opcode_wp_exec_prog
                ID 'SERVER' FIELD lv_server
                ID 'PROG' FIELD lv_prog
                ID 'ARGC' FIELD 1
                ID 'ARG1' FIELD '/tmp/xu.txt'.

* VIOLATION, FILTER option make this vulnerable to OS command injection.
OPEN DATASET 'c:\\test.dat' FOR INPUT IN BINARY MODE FILTER lv_opt.

* VIOLATION, vulnerable to OS command injection
CALL FUNCTION 'RFC_REMOTE_EXEC' DESTINATION 'SERVER_EXEC'
  EXPORTING
    command  = mycmd
  TABLES
    pipedata = res_tab.]]></example>
    <repair><![CDATA[Using transaction SM69 create a new command alias, and invoke it using SXPG_COMMAND_EXECUTE. Make sure that "additional_parameters"
parameter provided is not based on user input, or at least that input is adequately neutralized.

Never use CALL 'SYSTEM' or CALL 'ThWpInfo'.

Do not use OPEN DATASET ... FILTER prog, or at least make sure that prog is not controlled by external input.

Avoid RFC_REMOTE_EXEC and RFC_REMOTE_PIPE, or at least make sure that 'command' parameter is not controlled by external input.

Avoid passing to method CL_GUI_FRONTEND_SERVICES->EXECUTE or function modules WS_EXECUTE, GUI_EXECUTE or GUI_RUN arguments
for command/program name or command arguments that depend on non-neutralized external inputs.]]></repair>
    <reference><![CDATA[https://blogs.sap.com/2013/10/29/secure-execution-of-os-commands-by-abap-programs/]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:02,CWE:77,CWE:78,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:31]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.CrossClientDatabaseAccess" message="CrossClientDatabaseAccess: Do not bypass SAP client separation mechanism" class="com.optimyth.qaking.abap.rules.sec.CrossClientDatabaseAccess" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Confidentiality]]></tags>
    <description><![CDATA[A single SAP instance can host business data from multiple organizations, also referred to as clients.
The SAP database is designed to completely separate the business data of its clients. This mechanism is called client separation.
All Open SQL access to the database is automatically managed by the SAP framework with regards to client separation.
This way an application can only access data of the respective client where its users logged on to.

Unfortunately the client separation mechanism can be bypassed by insecure ABAP coding practices.
There are three distinct ways of undermining client separation:
1) Explicit Open SQL options
2) Unmanaged SQL (native SQL)
3) Unmanaged SQL (ADBC)

Such practices are dangerous and most likely violates regulatory compliance. The rule checks for OpenSQL statments with
the CLIENT SPECIFIED addition (which bypass client separation), and any uses of native SQL or ADBC API, as they also
bypass client separation.

Please note that even with custom tables (usually named Z* or Y*) client separation could be enforced if table
contains an adequate client field.

This rule checks security defect APP-07 in BIZEC APP/11 standard.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* VIOLATION, bypass client separation in OpenSQL
SELECT * FROM pa0001
  CLIENT SPECIFIED
  INTO TABLE hr_contents.

* VIOLATION, unmanaged (native) SQL
EXEC SQL.
  SELECT BNAME INTO :F1 FROM USR01
ENDEXEC.

* Use of ABAP DataBase Connectivity (ADBC)
DATA:
  lr_con    TYPE REF TO cl_sql_connection,
  lr_stmt   TYPE REF TO cl_sql_statement,
  lv_stmt   TYPE string.

CREATE OBJECT lr_con.

TRY.
  lr_stmt = lr_con->create_statement( ).
  lv_stmt = `insert into ZSALARY( select * from ZNEWSALARY )`.
  " VIOLATION
  lr_stmt->execute_update( statement = lv_stmt ).

CATCH cx_sql_exception.
  RAISE sql_error.
ENDTRY.]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://www.virtualforge.com/en/blog/post/hosting_risks_en.html,http://www.bizec.org/wiki/Client_Separation]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:07,CWE:488]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.CrossSiteScripting" message="CrossSiteScripting: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')" class="com.optimyth.qaking.abap.rules.sec.CrossSiteScripting" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software places user-controlled input in page content. An attacker could inject browser script code that is executed
in the client browser. The end-user is the attacked subject, and the software is the vehicle for the attack.
There are two main kinds of XSS:

* Reflected XSS: Attacker causes victim to supply malicious content to a vulnerable web application, which
renders HTML content embedding a malicious script executed in victim's browser. A variation of this is named
DOM-based XSS, where the vulnerable software does not generate content depending on user input but include
script code that use user-controlled input.

* Persistent XSS: Attacker provides malicious content to vulnerable application. When other user access to
vulnerable pages that embed without proper neutralization the attacker content, script code is executed in the
victim's browser.

The script executed in the victim's browser could perform different malicious activities. When the XSS-injected payload
directs victim's browser to an web application that trusts the victim, the XSS attack is known as "cross-site request
forgery" (CSRF or XSRF in short).

Many browsers could limit the damage via security restrictions (e.g. 'same origin policy'), but user browsers
generally allow scripting languages (e.g. JavaScript) in their browsers (disabling JavaScript severely limits
a web site).

This rule checks security defect APP-10 in BIZEC APP/11 standard.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<%@page language="abap"%>
<%@extension name="htmlb" prefix="htmlb"%>
<% data:
     prod_id type xstring,
     it_ekko table of ekko,
     wa_ekko like line of it_ekko.
%>
<% prod_id = request->get_form_field( 'prod_id' ). %>
<table>
<%
select * up to 10 rows
from ekko
into table it_ekko
where ekko-prod_id = prod_id.

loop at it_ekko into wa_ekko.
%>
<tr>
  <!-- VIOLATION, user input prod_id not neutralized-->
  <td><%=prod_id%></td>
  <!-- VIOLATION (when allowPersistedSources=true), external wa_ekko not neutralized-->
  <td><%=wa_ekko-ebeln%></td>
</tr>
<% endloop. %></table>]]></example>
    <repair><![CDATA[<!-- OK, output encoding of contents so injected script code will be neutralized -->
<%@page language="abap" forceEncode="html"%>
...

<!-- alternative: explicit encoding -->
  escaped = cl_http_utility=>escape_html( prod_id )
  <%html=prod_id%>]]></repair>
    <reference><![CDATA[http://help.sap.com/saphelp_nw70ehp2/helpdata/en/a6/87890ae991441b89bf418d0198ddcc/content.htm]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:10,CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.7]]></security>
    </normatives>
    <properties>
      <property name="allowPersistedSources" descname="When true, external inputs for persisted XSS will be checked." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.DangerousFileDownload" message="DangerousFileDownload: Dangerous file download" class="com.optimyth.qaking.abap.rules.sec.informative.DangerousFileDownload" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.2.1,ASVS-v4.0.2:12.5.2,ASVS-v4.0.2:13.1.5,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,informative]]></tags>
    <description><![CDATA[SAP GUI offers facilities to download files from an SAP Server to a client computer.

Such file downloads are not malicious by itself, but certain cases are problematic:
- Sensitive information may be leaked from SAP servers.
- ABAP code may try to download malicious files to end-user computers, or overwrite sensitive local files,
  without user consent.

Note: Authorization object S_GUI (which controls a user's permission to download files) only restrict file downloads
in general, but the authorization by itself does not offer any security against the cases enumerated above.

This rule checks if the code does not ask consent for the user before download a file to his/her computer.
For example, with hard-coded filenames (which may overwrite sensitive files).

Note: Since SAP GUI 7.20, all file downloads are monitored by SAP GUI, and the user is informed and asked for approval.
By this reason, the flaws emitted by this rule are informative.]]></description>
    <priority>5</priority>
    <effort>2</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[FORM file_download.
  DATA:
    BEGIN OF itab,
      text(255) TYPE c,
    END OF itab.
  DATA file_content TYPE itab OCCURS 0.
  DATA file_len TYPE i.

  " VIOLATION, a potential overwrite of user's computer configuration
  CALL FUNCTION 'GUI_DOWNLOAD'
    EXPORTING
      filetype = 'ASC'
      filename = 'C:\config.sys'
    IMPORTING
      filelength = file_len
    TABLES
      data_tab = file_content
    EXCEPTIONS
      file_write_error = 1
      OTHERS = 2.
ENDFORM.]]></example>
    <repair><![CDATA[FORM file_download.
  " Same data as before
  DATA:
    chosen_filename TYPE string,
    chosen_path TYPE string,
    chosen_fullpath TYPE string,
    rc TYPE i.

  " FIXED, local file to write should be chosen by user
  CALL METHOD cl_gui_frontend_services=>file_save_dialog
    EXPORTING
      window_title = 'Choose CSV filename'
      initial_directory = 'C:\temp'
      file_filter = '*.CSV'
      prompt_on_overwrite = abap_true
    CHANGING
      filename = chosen_filename
      path = chosen_path
      fullpath = chosen_fullpath
      user_action = rc
    EXCEPTIONS
      cntl_error  = 1
      error_no_gui = 2
      not_supported_by_gui = 3
      OTHERS = 4.

  IF sy-subrc = 0 AND rc = cl_gui_frontend_services=>action_ok.
    CALL FUNCTION 'GUI_DOWNLOAD'
      EXPORTING
        filetype = 'ASC'
        filename = chosen_fullpath
    IMPORTING
        filelength = file_len
      TABLES
        data_tab = file_content.
  ENDIF.
ENDFORM.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/434.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:434,CWETOP25:2021:10]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.DangerousFileUpload" message="DangerousFileUpload: Dangerous file upload" class="com.optimyth.qaking.abap.rules.sec.informative.DangerousFileUpload" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.2.1,ASVS-v4.0.2:12.5.2,ASVS-v4.0.2:13.1.5,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,informative]]></tags>
    <description><![CDATA[SAP GUI offers facilities to upload files from a client computer to a SAP Server.

Such file uploads are not malicious by itself, but certain cases are problematic:
- Malicious content may be uploaded and could compromise the server.
- Potentially malicious ABAP code may try to upload files from end-user computers, without user consent.

Note: Authorization object S_GUI (which controls a user's permission to upload files) only restrict file uploads
in general, but without explicit checks on how the file is chosen and which files (by content) are allowed after upload,
the authorization by itself does not offer any security.

This rule checks if the code does not ask consent for the user before uploading a file from his/her computer.
For example, with hard-coded filenames (which may leak sensitive files). This should be avoided, as such practice
may open legal issues in many countries.

Note: Since SAP GUI 7.20, all file uploads are monitored by SAP GUI, and the user is informed and asked for approval.
By this reason, the flaws emitted by this rule are informative.]]></description>
    <priority>5</priority>
    <effort>2</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[FORM file_upload.
  DATA:
    BEGIN OF itab,
      text(255) TYPE c,
    END OF itab.
  DATA file_content TYPE itab OCCURS 0.

  " VIOLATION, a potential leak of user's computer configuration
  CALL FUNCTION 'GUI_UPLOAD'
    EXPORTING
      filetype = 'ASC'
      filename = 'C:\config.sys'
    TABLES
      data_tab = file_content.
ENDFORM.]]></example>
    <repair><![CDATA[FORM file_upload.
  " Same data as before
  DATA:
    chosen_file_table TYPE filetable,
    chosen_file TYPE string,
    rc TYPE i.

  " FIXED, filename to upload should be chosen by user
  CALL METHOD cl_gui_frontend_services=>file_open_dialog
    EXPORTING
      window_title = 'Choose CSV file to upload'
      file_filter = '*.CSV'
      multiselection = 'N'
    CHANGING
      file_table = chosen_file_table
      rc = lv_rc
    EXCEPTIONS
      file_open_dialog_failed = 1
      cntl_error = 2
      error_no_gui = 3
      not_supported_by_gui = 4
      OTHERS = 5.

  IF sy-subrc = 0 AND rc = 1.
    READ TABLE chosen_file_table INDEX 1 INTO chosen_file.
    CALL FUNCTION 'GUI_UPLOAD'
      EXPORTING
        filetype = 'ASC'
        filename = chosen_file
      TABLES
        data_tab = file_content.
  ENDIF.
ENDFORM.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/434.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:434,CWETOP25:2021:10]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.DirectUpdate" message="DirectUpdate: SQL Bad Practices - Direct Update" class="com.optimyth.qaking.abap.rules.sec.DirectUpdate" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Direct SQL Updates (INSERT / UPDATE / MODIFY / DELETE statements) are generally a bad practice.
They undermine the integrity and security of the system, and should not be allowed.
Modifying Standard SAP tables may dramatically change the behaviour of SAP system.

Direct SQL Updates are error-prone, and can cause unexpected system behavior:
- Authorization checks are not part of the Open SQL statement and need to be explicitly performed.
- Easy to miss edit checks and audit trails, automatically generated when using provided SAP transactions or function modules for data modification.
- SAP Locking mechanism must be invoked when using the statement writing on SAP table, to avoid synchronization issues.
- Need to ensure all associated tables and modules are updated alongwith the main table.

The rule emits a violation when any SAP standard table is modified with a DML statement (INSERT / UPDATE / MODIFY / DELETE),
using either Open SQL or native SQL.

This rule checks security defect APP-06 in BIZEC APP/11 standard.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[More robust operations on standard tables.
Prevents flaws and security issues (lack of authorization checks, no audit log leading to poor auditability)]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* OpenSQL
INSERT INTO SKB1 VALUES myrec. "VIOLATION, single line insert into G/L table SKB1
MODIFY SKB1 FROM TABLE itab. "VIOLATION, insert/update rows from internal table into SKB1
UPDATE SKB1 SET A=1 WHERE Z=1. "VIOLATION, update on SKB1
DELETE FROM SKB1 WHERE A=1. "VIOLATION, delete on SKB1

* VIOLATION NativeSQL (INSERT, UPDATE, DELETE on standard table)
EXEC SQL.
  UPDATE SKB1 SET A=B WHERE A=1
ENDEXEC.]]></example>
    <repair><![CDATA[* Replace modification of standard SAP tables by equivalent exposed operations (e.g. BAPIs),
* so data changes are done in a controlled way.

* Following is allowed:
* OpenSQL (update on internal or custom DB table)
INSERT INTO ZTAB VALUES myrec.
MODIFY ztab FROM TABLE itab.
UPDATE Z_2 SET A=1 WHERE Z=1.
UPDATE Z_2 FROM TABLE itab.
UPDATE Z_2 FROM wa.
DELETE FROM ZTAB WHERE A=1.

* NativeSQL (INSERT, UPDATE, DELETE on custom DB table)
EXEC SQL.
  UPDATE ZTAB SET A=B WHERE A=1
ENDEXEC.
* Other statements, not related to standard table update
DELETE DATASET dsname.
DELETE FROM DATABASE mydb(ar) ID mykey.
DELETE FROM SHARED BUFFER myclust(ar) ID mykey.
DELETE TABLE itab FROM wa.
DELETE itab WHERE f=1.
DELETE ADJACENT DUPLICATES FROM itab.]]></repair>
    <reference><![CDATA[https://scn.sap.com/thread/1832136]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:06,CWE:862,CWETOP25:2021:18]]></security>
    </normatives>
    <properties>
      <property name="customTablesPattern" descname="Regular expression for custom tables (where direct updates are allowed)." value="(\/(?:[^\/]+\/)+)?[YZ][_A-Za-z0-9]*"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.DynamicCode" message="DynamicCode: Avoid Dynamic Code constructs" class="com.optimyth.qaking.abap.rules.sec.DynamicCode" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.4,ASVS-v4.0.2:5.5.4,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[ABAP Dynamic Code constructs are potential targets to code injection attacks, particularly when dynamic code generated
could be affected by external inputs.

Such dynamic code constructs cannot be fully tested by QA team, and leaves no traces, as code exists in memory (it is generated at runtime).
Could be used to code a backdoor that may pass security audits.

The rule checks for the following dynamic programming features:
* Extract code to internal table: READ REPORT prog INTO itab.
* Generate program from internal table: INSERT REPORT prog FROM itab.
* Removing a program: DELETE REPORT.
* Loading a program: LOAD REPORT prog PART part INTO itab.
* Edit the program: EDITOR-CALL FOR REPORT prog.
* Generate (temporary) subroutines from internal table: GENERATE SUBROUTINE POOL itab NAME prog.
* Generate program (internal use): GENERATE REPORT prog.
* Generate screen/dynpro (internal use): GENERATE DYNPRO h f e m ID dynpro_id.
* Exporting dynpro: EXPORT DYNPRO h f e m ID dynpro_id.
* Importing dynpro: IMPORT DYNPRO h f e m ID dynpro_id.
* Performing table contents syntax check: SYNTAX-CHECK FOR itab MESSAGE msg LINE l WORD w PROGRAM prog.
* Performing dynpro syntax check: SYNTAX CHECK FOR DYNPRO h f e m.
* Tokenize code and store it into the repository: SCAN ABAP-SOURCE itab1 TOKENS INTO itab2.
* Inserting textpool into repository: INSERT TEXTPOOL prog FROM itab LANGUAGE lang.
* Reading textpool form repository: READ TEXTPOOL prog INTO itab LANGUAGE lang.
* Removing textpool from repository: DELETE TEXTPOOL prog LANGUAGE lg.

* SYNTAX-CHECK FOR DYNPRO.

The generated ABAP code may be invoked later (via SUBMIT or PERFORM).

Note: GENERATE REPORT / GENERATE DYNPRO are intended for internal use only.

This rule checks security defect APP-01 in BIZEC APP/11 standard.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Forbidding dynamic code generation avoids high-impact code injection security flaws.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* VIOLATION, creates subroutine pool from itabCode
GENERATE SUBROUTINE POOL itabCode NAME poolName.

* VIOLATION, generates program from code in reptab
INSERT REPORT lv_dynamic FROM reptab.

* VIOLATION, reads prog code into internal table itab
READ REPORT prog INTO itab.

* VIOLATION, for internal use only
GENERATE REPORT progname.

* VIOLATION, generates dynpro dynamically
GENERATE DYNPRO h f e m ID dynpro_id.

* Classical code injection attack when external input concatenated.
* val is external input variable.
* Imagine that attacker sets val to '3. DELETE FROM USR02. "'
FORM read_data USING val TYPE STRING.
  ...
  APPEND 'REPORT ZREAD_DYNAMIC.' INTO itab.
  APPEND 'DATA: lv_val TYPE STRING.' INTO itab.
  CONCATENATE 'lv_val = ' val '.' INTO l_statement.
  APPEND l_statement INTO itab.
  ...

  ...
  INSERT REPORT lv_dynamic FROM itab. " VIOLATION
  SUBMIT (lv_dynamic) AND RETURN. " dynamic code executed
ENDFORM

* Code executed could be this, if val is '3. DELETE FROM USR02. "'
  REPORT ZREAD_DYNAMIC.
  DATA: lv_val TYPE STRING.
  lv_val = 3. DELETE FROM USR02. ".]]></example>
    <repair><![CDATA[Refactor your program so that you do not have to dynamically generate code. If you are absolutely
confident that dynamic code is not vulnerable to code injection, set a suppression to the rule.]]></repair>
    <reference><![CDATA[https://help.sap.com/abapdocu_731/en/abengeneric_internal.htm,Secure ABAP Programming (Sichere ABAP-Programmierung) section 5.7,http://events.asug.com/2011AC/706_Secure_Programming_ABAP.pdf]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:01,CWE:95,OWASP:2021:A3,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.DynamicConstructs" message="DynamicConstructs: Avoid dynamic constructs controlled by external input" class="com.optimyth.qaking.abap.rules.sec.DynamicConstructs" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.4,ASVS-v4.0.2:5.5.4,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[Setting variables when the name of the variable is evaluated at runtime,
or calling behaviour units where the name of the called unit is known at runtime,
are dangerous if the target item depends on external input. An attacker may
influence the target to modify / execute, producing unexpected behaviour.

Remember that generic code is the enemy of application security, so try to avoid
dynamic constructs if possible, do not make them dependent on external untrusted inputs,
and carefully validate the variables in dynamic construct to avoid security vulnerabilities.

The rule detects dynamic constructs in ABAP code and tries to find an execution path
from an external input (not neutralized by validation functions, like regular expression checks)
to the variable used in the dynamic construct.

The constructs checked for 'taintedness' by the rule are:
1) ASSIGN (var) TO <fs>.
2) WRITE (var) TO dest.
3) SUBMIT (var1).
4) PERFORM (var1) IN PROGRAM zvftest.
5) PERFORM (var1) IN PROGRAM (var2).
6) CALL FUNCTION var1.
7) CALL FUNCTION 'ZFUNCTION' DESTINATION var2.
8) CALL METHOD (var1).
9) CALL METHOD me->(var1).
10) CALL METHOD z_class=>(var1).
11) CALL METHOD (var2)=>method.
12) CALL METHOD (var2)=>(var1).
13) CALL TRANSACTION var.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended data modifications, or unexpected execution of code.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[REPORT Z_DYNAMIC.
  FORM DYNAMIC_FORM.

  DATA: request TYPE REF TO if_http_request.
  DATA: lv_var TYPE string.
  DATA: lv_target TYPE string.
  DATA: lv_dest(80) TYPE c.
  FIELD-SYMBOLS <fs> TYPE string.

  lv_var = request->get_form_field( 'web_param' ).
  lv_target = request->get_form_field( 'web_param' ).

  " VIOLATIONS, think about values for web_param like 'admin_class=>registerUser('DEVIL')'
  ASSIGN (lv_var) TO <fs>.
  WRITE (lv_var) TO lv_dest.

  " VIOLATIONS, the executed item is under control of a potential attacker
  CALL FUNCTION lv_var.
  CALL FUNCTION lv_var DESTINATION lv_dest.
  SUBMIT (lv_var).
  PERFORM (lv_var) IN PROGRAM (lv_target).
  CALL METHOD (lv_var)->mymethod().
  CALL METHOD (lv_var)->(lv_target).

  ENDFORM.]]></example>
    <repair><![CDATA[Do not use dynamic constructs that could be controlled by external input.
At least, carefully validate the variables controlling dynamic constructs, when influenced by external inputs.
For example, regex_whitelist_1 and regex_whitelist_2 could be regular expressions that controls what
are the allowed values for external inputs:

  lv_var = request->get_form_field( 'web_param' ).
  IF cl_abap_matcher=>matches(pattern = regex_whitelist_1 text = lv_var) = abap_false.
    RAISE EXCEPTION TYPE cx_http_ext_exception EXPORTING msg = 'Invalid Input!'.
  ENDIF.

  lv_target = request->get_form_field( 'web_param2' ).
  IF cl_abap_matcher=>matches(pattern = regex_whitelist_2 text = lv_target) = abap_false.
    RAISE EXCEPTION TYPE cx_http_ext_exception EXPORTING msg = 'Invalid Input!'.
  ENDIF.]]></repair>
    <reference><![CDATA[Secure ABAP Programming (Sichere ABAP-Programmierung), sections 5.5 and 5.6]]></reference>
    <normatives>
      <security><![CDATA[CWE:114,CWE:95,OWASP:2021:A3,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.HardcodedClientCheck" message="HardcodedClientCheck: Hardcoded SAP client check (sy-mandt)" class="com.optimyth.qaking.abap.rules.sec.HardcodedClientCheck" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Any check on sy-mandt variable could be used as backdoor or to override client separation enforced in SAP systems.

This rule checks security defect APP-07 in BIZEC APP/11 standard.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid potential violations of client separation in SAP.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[" VIOLATION, check on system variable for client name.
IF sy-mandt = 'XYZ'.
  PERFORM dangerousThingsWhenXYZ.
ENDIF.]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:07,CWE:200,CWE:488,CWETOP25:2021:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.HardcodedDateCheck" message="HardcodedDateCheck: Avoid hardcoding into the code current server date checks (sy-datum)" class="com.optimyth.qaking.abap.rules.sec.HardcodedDateCheck" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[An ABAP program shouldn't have any dependency with the current server date, so sy-datum
checks should be avoided when they lead to a program flow modification.

This rule reports violation when sy-datum checks are found into the code.]]></description>
    <priority>4</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Keeping sensitive information safe avoids inadequate access, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[IF sy-datum = 'XYZ'.   " VIOLATION
  PERFORM bad.
ENDIF.]]></example>
    <repair><![CDATA[Avoid hardcoding into the code current server date checks.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/200.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:200,CWETOP25:2021:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.HardcodedSensitiveData" message="HardcodedSensitiveData: Avoid hardcoding sensitive information" class="com.optimyth.qaking.abap.rules.sec.HardcodedSensitiveData" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Encoding certain sensitive information into the code can be a problem when a malicious
attacker gains access to it. Even it could be worst if the attacker use that information to force the flow of the
program to get the execution of some part of it.

This rule reports violation when an email, ip, or url is found into the code.]]></description>
    <priority>4</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Keeping sensitive information safe avoids inadequate access, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[REPORT test.
gv_email = 'xyz@gmail.com'. " VIOLATION

i_ip = '91.121.140.145'.  " VIOLATION

i_url = 'https://www.google.es/'.  " VIOLATION
i_url = 'http://www.google.es/'.  " VIOLATION
i_url = 'ftp://192.168.1.234/'.  " VIOLATION]]></example>
    <repair><![CDATA[Avoid hardcoding sensitive information.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/200.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:200,CWETOP25:2021:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.HardcodedSystemIdCheck" message="HardcodedSystemIdCheck: Hardcoded System ID check (sy-sysid)" class="com.optimyth.qaking.abap.rules.sec.HardcodedSystemIdCheck" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[The SAP security guidelines advise customers to separate SAP systems into Development, Quality Assurance and Production.

This means that development, tests and productive use of custom business applications can be effectively separated.
Development takes place only on a development system with dummy data. Then the code is transported (by an administrator) to the
corresponding test system, where it is tested by a QA team. If all tests "turn green", the code can be transported
(again by an administrator) to the productive system. This separation is necessary, since development rights on an SAP system
are often equivalent to SAP_ALL access.

A Three-Tier System Landscape ensures several important security goals:
1) Change management: All changes to the business logic are controllable and accountable
2) Segregation of Duties: Only developers write code, only administrators transport code
3) Segregation of Duties: All code is thoroughly tested by an independent QA team
4) Protection of business data: Business data can neither be read nor (accidentally) changed by developers.

Insecure ABAP coding practices can undermine the protection mechanisms of the Three-Tier System Landscape.
There are two types of security violations possible in ABAP that bypass this standard:

1) Non-testable code. ABAP coding can be written in ways that (part of) the application can't be tested.

2) Dynamic code creation. Dynamic creation of ABAP code based on (external) input enable users to write code on the productive
system, breaking system separation. The rule OPT.ABAP.SEC.DynamicCode checks dynamic code creation issues.

The rule checks a common coding pattern that may break the system separation: Code that depends on the particular
SAP system where code is executing.

This rule checks security defect APP-11 in BIZEC APP/11 standard.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[DATA lv_auth TYPE i.

* VIOLATION: Authority check only on the test system
IF sy-sysid = 'T42'.
  AUTHORITY-CHECK OBJECT 'S_TCODE' ID 'TCD' FIELD 'SE16'.
  lv_auth = sy-subrc.
ELSE.
  lv_auth = 0.
ENDIF.

IF lv_auth = 0.
  CALL TRANSACTION 'SE16'.
ENDIF.]]></example>
    <repair><![CDATA[Remove any hardcoded checks on system ID (sy-sysid) system variable.]]></repair>
    <reference><![CDATA[http://www.bizec.org/wiki/Three-Tier_System_Landscape]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:11,CWE:653]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.HardcodedUsernameCheck" message="HardcodedUsernameCheck: Hard-coded user name in check (potential backdoor)" class="com.optimyth.qaking.abap.rules.sec.HardcodedUsernameCheck" technology="ABAP" active="true">
    <tags><![CDATA[backdoors]]></tags>
    <description><![CDATA[Hard-coded user names may bypass access control. They are very likely to violate regulatory compliance.

In outsourced development, where third parties provide development services in SAP environments, a hard-coded
check of a user field against a literal or constant could be a sign of a backdoor (either intentional or left
behind in code as a help for avoiding access controls during testing).

The rule OPT.ABAP.SEC.Backdoors looks for similar potential backdoors, checking sy-uname system variable against
fixed values. This rule extends that logic for any variable or database field with a type/domain representing a user name.
When the variable or database field is checked against a fixed value (in a conditional statement or WHERE clause),
a violation is reported.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[REPORT POT_BACKDOOR.

DATA l_user TYPE USR02.
" ...
SELECT SINGLE bname FROM USR02 INTO l_user WHERE USR02~aname = sy-uname.
" VIOLATION, a potential backdoor (possibly leftover testing code, but who knows...)
IF l_user-bname = 'TEST_USER'.
  " Test operation without access control
ENDIF.]]></example>
    <repair><![CDATA[" Do not write code that performs actions based on the user name
" Remove, when not needed, such code before going into production environments.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/489.html]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:11,CWE:489,PCI-DSS:6.5.5]]></security>
    </normatives>
    <properties>
      <property name="usernameTypes" descname="Comma-separated list of ABAP types representing usernames (like XUBNAME)." value="UBNAME, UNAME, USERNAME, USNAM, XUBNAME"/>
      <property name="databaseTypes" descname="Comma-separated list of table fields representing usernames, in the format TABLE~FIELD (like USR02~BNAME).">
        <value><![CDATA[
USR02~BNAME, PFALV~SUSER,

/VIRSA/ZMITREF~APPROVERID, /VIRSA/ZMITREF_DS~APPROVERID, /VIRSA/MC_LIB_DETAIL_DS~APPROVERID,
/VIRSA/ZNW_SUM_MIT~USERID, /VIRSA/ZNW_SUM_MIT~MONITOR, /VIRSA/ZNW_SUM_MIT~APPROVER, /VIRSA/ZNW_SUM_MIT~MGRID,
/VIRSA/BUAPPVR~APPROVERID, /VIRSA/BUAPPVR_DS~APPROVERID,
/VIRSA/ZFFCNTRL~ZVIRFFID, /VIRSA/ZFFCNTRL~ZVIRFFCONTROLER, /VIRSA/ZFFROLES~ZVIRFFOWNER,
/VIRSA/ZFFUSERS~ZVIRFFID, /VIRSA/ZFFUSERS~ZVIRFIREFIGHTER, /VIRSA/ZFFUSERS~ZVIROWNER,
/VIRSA/ZVIRFFIDT~ZVIRFFID, /VIRSA/ZMITROLE~MONITORID,
/VIRSA/ZVIRFFIDS~ZVIRFFID, /VIRSA/ZVIRFFIDS~ZVIRFFOWNER, /VIRSA/ZVIRFFIDS~ZVIRUSEDBY
        ]]></value>
      </property>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.HttpHeaderManipulation" message="HttpHeaderManipulation: Unvalidated data in HTTP response header" class="com.optimyth.qaking.abap.rules.sec.HttpHeaderManipulation" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Integrity]]></tags>
    <description><![CDATA[Including unvalidated data in an HTTP response header can enable different attacks.

Including unvalidated data in an HTTP response header can enable cache-poisoning, cross-site scripting, cross-user defacement
or page hijacking attacks. A Header Manipulation vulnerability occurs when external input (e.g. from an HTTP request)
is inserted as a header value in a generated HTTP response.

One of common attacks targeted at this vulnerability is HTTP Response Splitting: The application must allow input
that contains CR (carriage return) and LF (line feed) characters into the header. These characters not only give attackers
control of the remaining headers and body of the response the application intends to send, but also allows them to create
additional responses entirely under their control, which may get cached in intermediate web caches.

Of course the attacker may inject another header (e.g. a Set-Cookie or Location header), resulting in impersonation,
cross-user defacement, cross-site scripting, or URL redirect ("page hijacking") attacks.

There are different methods in the IF_HTTP_ENTITY (or subtypes) that modify HTTP header. Some with explicit names (set_header_field),
others not so explicit (set_cookie, set_content_type, set_status ...)

NOTE: Please remember that HTTP-mediated access to ABAP code could be provided by different SAP facilities: ITS,
WebGUI, BSP-based applications, Web Dynpro or exposed Web Services.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<%
data customer type xstring.
customer = request->get_form_field( 'customer' ).
" VIOLATION: Set-Cookie = http header field, not neutralized
response->set_cookie( name = 'customer' value = customer ).
%>]]></example>
    <repair><![CDATA[<%
data customer type xstring.
customer = request->get_form_field( 'customer' ).
" OK, validated against regular expression
if cl_abap_matcher=>matches(pattern = '\w+' text = customer).
  response->set_cookie( name = 'customer' value = customer ).
else.
  RAISE EXCEPTION TYPE cx_http_ext_exception
  EXPORTING msg = 'Invalid Input!'.
endif.
%>]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/113.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:113,OWASP:2021:A3,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.InsecureRandomness" message="InsecureRandomness: Standard pseudo-random number generators cannot withstand cryptographic attacks" class="com.optimyth.qaking.abap.rules.sec.InsecureRandomness" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.3.1,ASVS-v4.0.2:2.6.2,ASVS-v4.0.2:2.9.2,ASVS-v4.0.2:6.3.1,ASVS-v4.0.2:6.3.2,ASVS-v4.0.2:6.3.3,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity,crypto,prng]]></tags>
    <description><![CDATA[Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness
in a security-sensitive context: security tokens (like anti-CSRF or password-reset tokens), values used in cryptographic
operations (session key material, initialization vector in block or stream ciphers), or password seeds.

Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators
(PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.

There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties,
but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use
in cases where security depends on generated values being unpredictable.

Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be
cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between it
and a truly random value.

In general, if a PRNG algorithm is not advertised as being cryptographically secure, then it is probably a
statistical PRNG and should not be used in security-sensitive contexts, where its use can lead to serious vulnerabilities
such as easy-to-guess temporary passwords, predictable cryptographic keys, or session hijacking, among others.

This rule checks for incorrect usages of common pseudo-random generators in ABAP code: Classes cl_abap_random
(in Basis/SABP_RANDOM package) are not adequate for sensitive / cryptographic operations. In addition, it must be
seeded correctly to make it less predictable. The rule will emit a violation when:
- Random numbers are generated in a sensitive context (a procedure with name matching the 'pattern' parameter).
- Seed is not provided in the create() method, or seed is either a fixed constant or an untrusted input (so
  the sequence of numbers is either repeating, or controlled by a potential attacker).]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[FORM genPrng USING p_seed TYPE CHANGING prng TYPE REF TO cl_abap_random.

  CONSTANTS:
    constant_seed TYPE i VALUE 1234.

  " VIOLATION, no seed, default seed which is predictable
  prng = cl_abap_random=>create( ).

  " VIOLATION, constant seed, predictable sequence
  prng = cl_abap_random=>create( seed = constant_seed ).

  " VIOLATION, external seed
  prng = cl_abap_random=>create( seed = p_seed ).

ENDFORM.

FORM genRandomPassword USING prng TYPE REF TO cl_abap_random CHANGING pwd TYPE string.
  DATA: r TYPE n.
  r = prng->int31( ). " VIOLATION, do not use in sensitive security contexts
  CONCATENATE 'PWD' r INTO pwd.
ENDFORM.]]></example>
    <repair><![CDATA[FORM genPrng USING p_seed TYPE CHANGING prng TYPE REF TO cl_abap_random.

  " CORRECT, generate seed (but not strong enough for crypto operations)
  prng = cl_abap_random=>create( seed = cl_abap_random=>seed( ) ).

ENDFORM.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/338.html,https://cwe.mitre.org/data/definitions/330.html/]]></reference>
    <normatives>
      <security><![CDATA[CWE:300,CWE:330,CWE:338,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="pattern" descname="Regular expression for sensitive methods where non secure PRNG generation is not allowed" value="password|passwd|session|user|key|csrf|token|hash|digest|uuid|guid"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.NoAuthorizationCheckCallTransaction" message="NoAuthorizationCheckCallTransaction: Authorization check must be done explicitely before CALL TRANSACTION" class="com.optimyth.qaking.abap.rules.sec.NoAuthorizationCheckCallTransaction" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[CALL TRANSACTION does not check if current user is authorized to execute the transaction. Without proper authorization checks,
the program may allow an unauthorized user to start a restricted transaction. To avoid this, the rule checks if
authorization check (either with AUTHORITY-CHECK sentence or AUTHORITY_CHECK_TCODE function module) immediately preceeds
CALL TRANSACTION, and the result of the authorization check is tested immediately before CALL TRANSACTION.

NOTE: Should I care on this?
SAP was obviously aware of this security flaw, and in recent versions (7.4 and higher) added WITH AUTHORITY-CHECK
to CALL TRANSACTION command for explicit authorization check. In 7.0 with enhancement package 3 (and higher), S_TCODE
authorization object is checked in CALL TRANSACTION, so you probably may deactivate this rule when running on patched versions.

Please note for LEAVE TO TRANSACTION, the ABAP runtime performs implicitely the authorization check,
so there is no need for explicit authorization check.

This rule checks security defect APP-04 in BIZEC APP/11 standard.]]></description>
    <priority>1</priority>
    <effort>1</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Better access control to restricted transactions.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[" VIOLATION: No explicit authorization check
CALL TRANSACTION 'SE38' USING BDCDATA MODE 'N' MESSAGES INTO MESSTAB.
" Starts ABAP editor, where attacker may inject or alter code in SAP system]]></example>
    <repair><![CDATA[" OK, call is immediately preceeded by authorization check
AUTHORITY-CHECK OBJECT 'S_TCODE' ID 'TCD' FIELD 'SE38'.
IF sy-subrc = 0.
  CALL TRANSACTION 'SE38' USING BDCDATA MODE 'N' MESSAGES INTO MESSTAB.
ENDIF.

" OK, other way to go
CALL FUNCTION 'AUTHORITY_CHECK_TCODE' EXPORTING TCODE='SE38'.
CASE sy-subrc.
WHEN 0.
  CALL TRANSACTION 'SE38' USING BDCDATA MODE 'N' MESSAGES INTO MESSTAB.
ENDCASE.]]></repair>
    <reference><![CDATA[https://www.virtualforge.com/tl_files/Theme/Presentations/BIZEC14_ten_golden_rules.pdf,Secure ABAP Programming (Sichere ABAP-Programmierung) section 5.1]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:04,CWE:285,OWASP:2021:A1]]></security>
    </normatives>
    <properties>
      <property name="tcodesToIgnore" descname="Comma-separated list of transaction codes that should be ignored by the rule." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.NoAuthorizationCheckRFC" message="NoAuthorizationCheckRFC: Authorization check must be done explicitly in RFC-enabled functions" class="com.optimyth.qaking.abap.rules.sec.NoAuthorizationCheckRFC" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.1.4,ASVS-v4.0.2:13.4.2,ASVS-v4.0.2:4.1.3,ASVS-v4.0.2:4.1.5,ASVS-v4.0.2:7.2.2,ASVS-v4.0.2:8.3.3,ASVS-v4.0.2:8.3.8,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The RFC (Remote Function Call) interface allows remote execution of business logic in SAP from other systems.
If a function is configured as remotely executable via RFC, the access boundary extends to remote systems.
SAP system usually checks incoming RFC calls, usually using user credentials and S_RFC authorization object.
(in a trusted/trusting scenario, only username and S_RFC authorization object are used).

To reduce risk, RFC-enabled functions should perform additional explicit authorization checks on the resources accessed
in the function implementation body. The rule enforces this by requiring, for each custom function module that is remotely called,
that at least an explicit programmatic authorization check is done (using AUTHORIZATION-CHECK sentence).

NOTE: Should I care on this?
SAP was obviuosly aware of this security flaw. Since 7.0 enhancement package 3, RFC calls perform explicit AUTHORITY-CHECK,
at least when auth/rfc_authority_check parameter set, so you may deactivate the rule.
From SAP documentation:
"When RFC function modules are called over RFC connections, for example, from an RFC client program or from another system,
an authorization check is performed in the called system against the authorization object S_RFC.
In this check, the system checks the name of the function group to which the function module belongs.
If this check fails, the system also checks the authorizations for the name of the function module.

SAP administrators may configure this check with the parameter auth/rfc_authority_check.

This rule checks security defect APP-04 in BIZEC APP/11 standard.]]></description>
    <priority>1</priority>
    <effort>1</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Better access control to restricted transactions.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* Caller
FUNCTION ZRUN IMPORTING filename TYPE string.
  CALL FUNCTION 'ZRFC_FM' DESTINATION target_server
    EXPORTING filename = filename.
ENDFUNCTION.

* RFC-enabled function: VIOLATION, no explicit authorization check
FUNCTION ZRFC_FM IMPORTING filename TYPE string.
  DELETE DATASET filename.
ENDFUNCTION.]]></example>
    <repair><![CDATA[* Caller
FUNCTION ZRUN IMPORTING filename TYPE string.
  CALL FUNCTION 'ZRFC_FM' DESTINATION target_server
    EXPORTING filename = filename.
ENDFUNCTION.

* RFC-enabled function, with explicit authorization check
FUNCTION ZRFC_FM IMPORTING filename TYPE string.
  AUTHORITY-CHECK OBJECT 'ZRFC_FM'   " FIXED
    ID 'FILEGRP' FIELD 'FIN'
    ID 'ACTVT' FIELD '23'.
  IF SY-SUBRC <> 0.
    RAISE EXCEPTION TYPE cx_http_ext_exception EXPORTING msg = 'User not authorized'.
  ENDIF.
  " Sensitive operation
  DELETE DATASET filename.
ENDFUNCTION.]]></repair>
    <reference><![CDATA[Secure ABAP Programming (Sichere ABAP-Programmierung) section 5.3,Securing Remote Function Calls - http://sapassets.edgesuite.net/sapcom/docs/2015/07/e6441a8d-5b7c-0010-82c7-eda71af511fa.pdf]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:04,CWE:285,OWASP:2021:A1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.NoAuthorizationGroup4Table" message="NoAuthorizationGroup4Table: Table without authorization group" class="com.optimyth.qaking.abap.rules.sec.NoAuthorizationGroup4Table" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,repository]]></tags>
    <description><![CDATA[When a database table has no explicit authorization group (maintained with transaction SE11), the coarse-grained
authorization group &NC& ("non-classified") is used. The problem is that there are many tables in this "dummy" group,
so giving this authorization to users give them extensive access rights to database tables (many of them with sensitive
or SAP-internal information).

Multiple tranactions (SE16, SE16N, SM30...) provide direct access to database table contents for authorized users (thru
S_TABU_DIS and related authorization objects). If maintenance (read or read/write) is allowed on a table,
and the user has the privileges defined by the table's authorization group, such transactions will permit reads (or even writes).
Since the SAP standard contains many tables without authorization group (or with the dummy &NC& group),
giving ordinary users access to the &NC& group is considered a bad practice, contrary to the principle of least privilege.

The rule will emit a violation for the first database operation found in code over each table without authorization group,
or with the dummy &NC& authorization group.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[" VIOLATION, when Z_MYTAB has no authorization group, or is &NC&
SELECT SINGLE * FROM Z_MYTAB INTO itab.]]></example>
    <repair><![CDATA[" Set authorization group for reported tables to a proper authorization group
" (transaction SE11); no changes in ABAP code are required.]]></repair>
    <reference><![CDATA[https://www.onapsis.com/blog/dealing-authorization-groups-part-1,https://www.daniel-berlin.de/security/sap-sec/find-tables-without-authorization-group/]]></reference>
    <normatives>
      <security><![CDATA[CWE:266]]></security>
    </normatives>
    <properties>
      <property name="tablesToCheck" descname="Regular expression to match which tables to check for authorization groups." value=".*"/>
      <property name="sourcesToCheck" descname="Regular expression to match which programs to check." value=".*"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.OpenRedirect" message="OpenRedirect: URL Redirection to Untrusted Site ('Open Redirect')" class="com.optimyth.qaking.abap.rules.sec.OpenRedirect" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.5,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Allowing non-validated input to control the URL used in a redirect can point to an attacker-controlled web site
or at least to an unintended site, so attacker may mount different attacks.

Redirects allow web applications to direct users to different pages within the same application or to external sites.
Open redirect vulnerabilities occur when a web application redirects browser to any arbitrary URL that can be controlled by an attacker.
Attackers can utilize open redirects to trick users into visiting a URL to a trusted site and redirecting them to a malicious site
("phising attacks"). By encoding the URL, an attacker can make it more difficult for end-users to notice the malicious destination of the redirect,
even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams,
to harvest sensitive end-user data.

Typical web redirects are calls to cl_http_response->redirect() or different methods in navigation BSP object (of type if_bsp_navigation).

NOTE: Please remember that HTTP-mediated access to ABAP code could be provided by different SAP facilities: ITS,
WebGUI, BSP-based applications, Web Dynpro or exposed Web Services.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid open redirect vulnerabilities that could permit phising and other attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<%
DATA: dest TYPE c.
dest = request->get_form_field( 'dest' ).
response->redirect( dest ). " VIOLATION
%>]]></example>
    <repair><![CDATA[<%
DATA: dest TYPE c.
dest = request->get_form_field( 'dest' ).
cl_http_utility=>check_http_whitelist( dest ).
response->redirect( dest ). "OK, external URL is validated against white-list
%>]]></repair>
    <reference><![CDATA[http://events.asug.com/2011AC/706_Secure_Programming_ABAP.pdf, p. 34]]></reference>
    <normatives>
      <security><![CDATA[CWE:601,CWETOP25:2021:37,OWASP:2013:A10,PCI-DSS:6.5.1,WASC:24]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.OverwriteSystemFields" message="OverwriteSystemFields: Inadequate usage of ABAP System field" class="com.optimyth.qaking.abap.rules.sec.OverwriteSystemFields" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[It is never a good idea to overwrite system fields even though these are accessible as variables.
These fields are used by the runtime environment to communicate the state of the system to the ABAP program.
Overwriting these fields may cause the loss of vital information for normal operation of SAP system,
and may cause service disruption or the ABAP program to behave in unexpected ways.

The rule reports violation on any usage of obsolete or internal system field, or any write for read-only system field.
See http://help.sap.com/saphelp_nw04s/helpdata/en/7b/fb96c8882811d295a90000e8353423/content.htm for full details on
ABAP System Fields and how they could be used.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unexpected program bahaviour due to bad usages of system fields.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[* Invalid
move 0 to sy-INDEX. "sy-INDEX read-only
sy-INDEX = sy-CPAGE = myvar * 2. " sy-INDEX sy-CPAGE read-only
COMPUTE sy-INDEX = myvar * 2. "sy-INDEX
CLEAR sy-INDEX syst-CPAGE sy-LSIND. " sy-INDEX syst-CPAGE read-only
myvar = sy-APPLI * 2. "sy-APPLI obsolete
myvar = sy-CFWAE * 2. "sy-CFWAE internal, should not be used]]></example>
    <repair><![CDATA[* Valid usages (sy-INDEX is read, while sy-LSIND is writable)
move sy-INDEX to myvar.
myvar = sy-LSIND = syst-CPAGE * 2.
COMPUTE myvar = sy-INDEX * 2.]]></repair>
    <reference><![CDATA[https://help.sap.com/saphelp_nw70/helpdata/en/7b/fb96c8882811d295a90000e8353423/content.htm]]></reference>
    <normatives>
      <security><![CDATA[CWE:642]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.PathManipulation" message="PathManipulation: External Control of File Name or Path" class="com.optimyth.qaking.abap.rules.sec.PathManipulation" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.1,ASVS-v4.0.2:12.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Many ABAP applications handle files on SAP application server. File processing has multiple security aspects,
like virus protection or handling sensitive data in datafiles.

Path manipulation flaws occur when an attacker can specify a path used in an operation on the filesystem.
When the application uses the resource specified by that path, the attacker gains a capability that would not otherwise
be permitted. For example, the program may give the attacker the ability to overwrite an unintended file or use
a configuration file controlled by the attacker.

In ABAP, OPEN DATASET / TRANSFER statements use file paths that could depend on external input. Later operations
(READ DATASET, DELETE DATASET, TRANSFER) operate on the server file whose path was controlled by external input.
There are other possibilities (classes and function modules, file upload in Web Dynpro / BSP, etc.) where path
manipulation vulnerabilities may occur. If the path manipulation vulnerability is available in an RFC-enabled function,
the risk is even higher.

An attacker could leverage a path manipulation flaw to see configuration data on the SAP server, see sensitive datafiles,
manipulate or delete critical files on the server, etc.

This rule checks security defect APP-05 in BIZEC APP/11 standard.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[DATA:
  cRoot TYPE string,
  cPath TYPE string,
  cFile TYPE string.

  cRoot = 'c:\www\pub\'.
  cFile = request->get_parameter('filename').
  CONCATENATE cRoot '\' cFile INTO cPath.
  OPEN DATASET FOR OUTPUT cPath IN TEXT MODE ENCODING DEFAULT.
  " File operations go here
  CLOSE DATASET cPath.]]></example>
    <repair><![CDATA[* First possibility: external input may choose one of a sequence of known files
* External input chooses one ID in a allowed sequence of file names in internal table IT_ALLOWED_FILES
  cFileId = request->get_form_field('fileid').
  SELECT SINGLE file_name FROM IT_ALLOWED_FILES INTO cFile WHERE file_id = cFileId.
  CONCATENATE cRoot '\' cFile INTO cPath.

* If the file name needs to depend on external input, use a whitelist validation, for example:
  cFile = request->get_form_field('filename').
  regex_whitelist = '^[a-zA-Z0-9]*$'.
  " Raises exception if invalid input is found
  IF CL_ABAP_MATCHER=>matches (pattern = regex_whitelist text = cFile) = abap_false.
    RAISE EXCEPTION TYPE cx_http_ext_exception EXPORTING msg = 'Invalid Input!'.
  ENDIF.
  CONCATENATE cRoot '\' cFile '.dat' INTO cPath.

* Second possibility: use logical filenames
  cLogicalFile = request->get_form_field('filename').
  CALL FUNCTION 'FILE_VALIDATE_NAME'
    EXPORTING logical_filename = cLogicalFile
    CHANGING physical_filename = cFile
    EXCEPTION OTHERS = 1.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-magno WITH sy-msgv1.
  ELSE
    OPEN DATASET FOR OUTPUT cFile IN TEXT MODE ENCODING DEFAULT.
    " File operations go here
  ENDIF.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/73.html,https://blogs.sap.com/2013/08/05/protecting-abap-code-against-directory-traversal-attacks/,Secure ABAP Programming (Sichere ABAP-Programmierung) section 5.9,http://cwe.mitre.org/data/definitions/22.html]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:05,CWE:22,CWE:73,CWETOP25:2021:8,OWASP:2021:A4,OWASP:2021:A5,PCI-DSS:6.5.8,WASC:33]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.RegexInjection" message="RegexInjection: Prevent denial of service attack through malicious regular expression ('Regex Injection')" class="com.optimyth.qaking.abap.rules.sec.RegexInjection" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.1.1,CWEScope:Access-Control,ReDoS,denial-of-service]]></tags>
    <description><![CDATA[If the software creates a regular expression ("pattern", "regex") from untrusted input, an attacker may supply
malicious input that produces a denial-of-service (DoS) condition during regular expression matching.

Alternatively, if the regular expression is used for input validation, the attacker-controlled regular expression
may fail to neutralize undesired input, which may bypass the intended restrictions or render useless
a security control.

In ABAP, the FIND / REPLACE statements allow a REGEX pattern addition; and many string-based built-in functions allow a regex
parameter for specifying a regular expression argument.

If the attacker controls also the input to be matched, he/she could craft an input for the evil regex that
takes an inordinate amount of time to match, consuming resources (like CPU).
Evil regex typically has a group with repetition, and the repeated group has repetition or alternation with overlapping.
For example: "(a+)+", "([a-z]+)*", "(a|aa)+" or "(aa|aab?)*".

For example, a "(a+)+" regex will take long computing time when matching "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!"
takes many seconds to complete, and longer strings (with exponential time increase) may lead to DoS conditions.

Please note that regular expressions are often used for security controls and input validation.

The rule checks for potential injection of untrusted input into regex APIs.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid DoS conditions produced by regular expression injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[REPORT ZRegexInjection.

PARAMETERS:
  p_regex TYPE c LENGTH 80.

DATA: text TYPE c LENGTH 120
           VALUE `Cathy's cat with the hat sat on Matt's mat.`,
      regx TYPE c LENGTH 120
           VALUE `\<.at\>`.

DATA: result TYPE i,
      substr TYPE string.

result = find( val   = text  " OK, regx constant (trusted)
               regex = regx
               occ   = sy-index ).

result = find( val   = text " VIOLATION, p_regex under attacker control
               regex = p_regex
               occ   = sy-index ).

DATA: result_tab TYPE match_result_tab.

FIND REGEX regx IN text RESULTS result_tab. " OK, regx constant (trusted)
FIND REGEX p_regex IN text RESULTS result_tab. " VIOLATION, p_regex under attacker control]]></example>
    <repair><![CDATA[" Never let untrusted input to be used (or concatenated) into patterns used in ABAP regular expression functions.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/400.html,https://en.wikipedia.org/wiki/ReDoS,https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS]]></reference>
    <normatives>
      <security><![CDATA[CWE:400,CWETOP25:2021:27,OWASP:2004:A9,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.RfcCallbackAttack" message="RfcCallbackAttack: RFC call without callback attack protection" class="com.optimyth.qaking.abap.rules.sec.RfcCallbackAttack" technology="ABAP" active="true">
    <tags><![CDATA[rfc]]></tags>
    <description><![CDATA[In a synchronous RFC call between a client and SAP server, the server can perform an RFC callback to the client.
Such "callback" call uses the open RFC connection to the RFC client, and does not require another user logon.
This is done using the predefined destination BACK. The callback call executes RFC function modules on the client,
in the context of the user that initiated the synchronous RFC communication, so any RFC function modules the
user is authorized to execute on the client might be called by the (possibly malicious) server through RFC callback.

RFC callback can pose risks to business-critical systems when initiating RFC communication using highly privileged users
to other systems with a lower trust level. For example, batch jobs are in many cases executed by highly privileged system users.
These batch jobs could perform RFC communication to remote systems. Malicious remote systems could misuse the high privileges
of the batch user using the RFC callback.

A malicious or compromised remote site may have the RFC-enabled function module (due to a previous code injection attack, for example),
including callback calls to perform unintended modifications on the calling site. See code example for details.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[" In server A, we call an apparently innocuous RFC function (for example, RFC_PING)
CALL FUNCTION 'RFC_PING' DESTINATION serverB.

" But server B is a malicious (or compromised) system with RFC_PING modified:
FUNCTION RFC_PING.
  " ... code ...
  " Attack payload: create, in caller system, a backdoor SAP_ALL user
  lv_username = 'ATTACKER'.
  ls_logondata-ustyp = 'S'.
  ls_password-bapipwd = 'MYPASS'.
  ls_address-lastname = 'Attacker'.

  " VIOLATION (informative) reported here if in analyzed code,
  " potential RFC callback attack when called
  CALL FUNCTION 'BAPI_USER_CREATE1' DESTINATION 'BACK'
    EXPORTING
      username = lv_username
      logondata = ls_logondata
      password = ls_password
      address = ls_address
    TABLES
      return = ls_bapiret.

  ls_profiles-bapiprof = 'SAP_ALL'.
  INSERT ls_profiles INTO TABLE itab_profiles.

  CALL FUNCTION 'BAPI_USER_PROFILES_ASSIGN' DESTINATION 'BACK'
    EXPORTING
      username = lv_username
    TABLES
      profiles = itab_profiles
      return = ls_bapiret.
  " ... code to let caller unaware of the attack ...
ENDFUNCTION.]]></example>
    <repair><![CDATA[" FIXED - Deactivate explicitly every callback calls before RFC sync calls
CALL FUNCTION 'RFC_CALLBACK_REJECTED'.
CALL FUNCTION 'RFC_PING' DESTINATION serverB.]]></repair>
    <reference><![CDATA[https://layersevensecurity.com/how-to-block-rfc-callback-attacks-in-your-sap-systems/,https://www.onapsis.com/blog/unprotected-sap-gateways-evil-twin-and-code-execution-attacks-through-registered-rfc-servers,https://archive.sap.com/documents/docs/DOC-60424]]></reference>
    <properties>
      <property name="unprotectedFunctionsAllowed" descname="Regular expression for RFC-enabled functions that could be called without previous call to RFC_CALLBACK_REJECTED." value=""/>
      <property name="unprotectedFunctionsDenied" descname="Regular expression for RFC-enabled functions that should not be called without previous call to RFC_CALLBACK_REJECTED." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.RfcDestinationInjection" message="RfcDestinationInjection: Destination injection in RFC call" class="com.optimyth.qaking.abap.rules.sec.RfcDestinationInjection" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.6.1,ASVS-v4.0.2:5.2.6]]></tags>
    <description><![CDATA[In ABAP, "CALL FUNCTION fname DESTINATION dest" allows to invoke functions on remote systems via Remote Function Call (RFC).

If the DESTINATION is based on user input, then a malicious user could invoke the given function on a remote server
for which an RFC destination is maintained.

The attacker may then:
- Run code on unintended locations.
- Change business logic: If such function exists in the target system, it may execute completely different code as the intended,
or it may execute the same code, but compute different results due to different system configuration or different database status.

Therefore, allowing untrusted input to affect the destination of RFC call is reported as a security flaw.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[REPORT TEST.
FORM call_rfc.
  DATA request TYPE REF TO if_http_request.
  DATA lv_rfc TYPE string.

  lv_rfc = request->get_form_field( 'rfc_dest' ).
  CALL FUNCTION 'Z_MY_FUNC' DESTINATION lv_rfc. " VIOLATION
ENDFORM.]]></example>
    <repair><![CDATA[REPORT TEST.
FORM call_rfc.
  " If such functionality is required, a whitelist filter was added.
  DATA request TYPE REF TO if_http_request.
  DATA i_dest TYPE i.
  DATA lv_rfc TYPE string.
  " check input against whitelist table
  i_dest = request->get_form_field( 'rfc_dest' ).
  SELECT SINGLE dest FROM zwhitelist INTO lv_rfc WHERE idest = i_dest AND fname = 'Z_MY_FUNC'.
  IF sy-subrc EQ 0.
    CALL FUNCTION 'Z_MY_FUNC' DESTINATION lv_rfc.
  ELSE.
    " error handling : no match in white list
  ENDIF.
ENDFORM.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/941.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:918,CWETOP25:2021:24,OWASP:2021:A10,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.SqlInjection" message="SqlInjection: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" class="com.optimyth.qaking.abap.rules.sec.SqlInjection" technology="ABAP" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[In ABAP, OpenSQL (OSQL) and native SQL are the most usual ways for performing database operations.

OpenSQL is relatively safe against SQL injections, as input parameters to the SQL statement are considered data,
and they are not considered as SQL code (ABAP runtime generates "parameterized SQL" code for the target database,
so each input parameter is considered data).

But OpenSQL statements allow dynamic constructs (in WHERE clauses, in FROM clause, in selected fields clause).
When such dynamic constructs are used, SQL injection is possible, as the SQL that is executed against database
mixes SQL code and parameters to the statement.

Dynamic SQL is possible for OpenSQL statements:
1) INSERT INTO (dyn_tab) VALUES itab.
2) INSERT (dyn_tab) FROM itab.
3) MODIFY (dyn_tab) ...
4) SELECT * FROM (dyn_tab) INTO itab WHERE (dyn_where).
5) DELETE FROM (dyn_tab) WHERE (dyn_where)
6) OPEN CURSOR FOR SELECT * FROM mycur (dyn_tab) WHERE (dyn_where).
8) UPDATE (dyn_tab) SET (dyn_set) WHERE (dyn_where).

Embedded native SQL (EXEC SQL ... ENDEXEC) does not allow dynamic constructs, and all parameters to the statement
are considered data and do not form part of the SQL statement. Please note that EXEC SQL ... ENDEXEC bypasses security features of OpenSQL
(client separation, restrictive access to SQL commands), so it should not be used.
If application code uses embedded native SQL, and executes an stored procedure that launches OS commands (like x_cmdshell
in SQL Server), other attacks (like OS command injection) could success. For a particular case (EXEC SQL EXECUTE IMMEDIATE :sql ENDEXEC)
where dynamic SQL is executed in embedded SQL, a violation is emitted.

Other APIs for executing native SQL statements in ABAP are checked as well (ABAP Database Connectivity, known as ADBC):
1) Methods in CL_SQL_STATEMENT / CL_SQL_PREPARED_STATEMENT classes.
2) DB_EXECUTE_SQL function module.
3) Kernel calls C_DB_EXECUTE / C_DB_FUNCTION (for internal use, should not be used in user ABAP code).

ADBC bypasses security features provided by OpenSQL and should not be used anyway.

The effects of SQL injection exploits in SAP systems could be devastating. Just think about what could be done if the attacker
could alter the REPOSRC table, where source code for standard and custom programs is stored. Backdoors and rootkits could be installed.
See http://www.isaca.org/Groups/Professional-English/sap-applications/GroupDocuments/White%20Paper%20-%20Perfect%20Storm.pdf
for full details.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[REPORT SQL_02.

FORM DYN_SQL USING p_carrid.
  DATA lt_sec TYPE sbook.
  DATA lv_where TYPE string.
  DATA lv_stmt TYPE string.
  DATA lv_len TYPE i.

  " Concatenate WHERE clause with un-neutralized input p_carrid
  CONCATENATE `carrid = '` p_carrid `' AND reserved = ' '` INTO lv_where.

  " VIOLATION, potential SQL injection
  SELECT class passname fldate FROM sbook CLIENT SPECIFIED
  INTO CORRESPONDING FIELDS OF lt_sec
  WHERE (lv_where).
   WRITE : / lt_sec-class, lt_sec-passname, lt_sec-fldate.
  ENDSELECT.

  " OK, NativeSQL is secure
  EXEC SQL.
    SELECT CLASS, PASSNAME, FLDATE INTO :F1, :F2, :F3 FROM SBOOK
    WHERE CARRID = :p_carrid AND RESERVED = ' '
  ENDEXEC.

  " VIOLATION, SAP Kernel call to C_DB_EXECUTE, lv_stmt set using external input
  CALL 'C_DB_EXECUTE'
   ID 'STATTXT' FIELD lv_stmt
   ID 'STATLEN' FIELD lv_len
   ID 'SQLERR' FIELD lv_sqlerr.

  " VIOLATION, SAP Kernel call to C_DB_EXECUTE, lv_stmt set using external input
  CALL FUNCTION 'DB_EXECUTE_SQL'
  EXPORTING
    stmt = lv_stmt
    stmt_ln = lv_len
  IMPORTING
    sql_code = lv_retcode
    sql_msg = lv_retmsg
    row_num = lv_numrows.

ENDFORM.]]></example>
    <repair><![CDATA[...
" Simple neutralization
p_carrid = cl_abap_dyn_prg=>quote_str( p_carrid ).

" Concatenate WHERE with neutralized input p_carrid
CONCATENATE `carrid = '` p_carrid `' AND reserved = ' '` INTO lv_where.
...]]></repair>
    <reference><![CDATA[http://scn.sap.com/community/abap/blog/2013/11/20/how-to-protect-your-abap-code-against-sql-injection-attacks,Secure ABAP Programming (Sichere ABAP-Programmierung) section 5.8]]></reference>
    <normatives>
      <security><![CDATA[BIZEC-APP:08,CWE:89,CWETOP25:2021:6,OWASP:2021:A3,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.ABAP.SEC.WeakHashAlgorithm" message="WeakHashAlgorithm: Weak cryptographic hashes cannot guarantee data integrity" class="com.optimyth.qaking.abap.rules.sec.WeakHashAlgorithm" technology="ABAP" active="true">
    <tags><![CDATA[CWEScope:Access-Control,crypto,hash]]></tags>
    <description><![CDATA[Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.
MD5 and SHA-1 are popular cryptographic hash algorithms often used as primitives for verifying message integrity, and other applications.

Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5 and SHA-1 should
no longer be used to verify the authenticity of data in security-critical contexts.

Techniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be used
in any security context.

In the case of SHA-1, current techniques still require a significant amount of computational power and
are more difficult to implement.
However, attackers have found the Achilles' heel for the algorithm, and techniques for breaking it will likely lead
to the discovery of even faster attacks.

Note: SHA-1 is not a recommended algorithm for password hashes, Hash-based Message Authentication Codes (HMAC),
for digital signature generation/verification, and other uses (NIST).

In ABAP, SAP provides (in Basis/BC-SEC/SECH package) the class CL_ABAP_MESSAGE_DIGEST, which is the recommended API for
cryptographic message digest operations ("crypto hashes"), class CL_ABAP_HMAC for hash-based message authentication codes (HMAC),
and class CL_SEC_SXML_WRITER for XML-Security encryption/MAC.

The rule checks if the cryptographic hash algorithm used is one of the allowed ones; the rule can lead to false negatives
if the algorithm value argument cannot be inferred statically.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[More robust cryptographic message digest (hash) primitives.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[PARAMETERS:
  text TYPE string.

CONSTANTS:
  algo TYPE string VALUE 'MD5'. " Not allowed

DATA:
  o TYPE REF TO cl_abap_message_digest,
  hash TYPE string.

o = cl_abap_message_digest=>get_instance( algo ). " VIOLATION
" ...
" VIOLATION
cl_abap_message_digest=>calculate_hash_for_char(
  EXPORTING if_data = text if_algorithm = algo IMPORTING ef_hashb64string = hash
).
 " VIOLATION, if_algorithm='SHA1' is the default
cl_abap_message_digest=>calculate_hash_for_raw(
  EXPORTING if_data = text IMPORTING ef_hashb64string = hash
).]]></example>
    <repair><![CDATA[CONSTANTS:
  algo TYPE string VALUE 'SHA256'. " FIXED

o = cl_abap_message_digest=>get_instance( algo ).
" ...
cl_abap_message_digest=>calculate_hash_for_char(
  EXPORTING if_data = text if_algorithm = sha256 IMPORTING ef_hashb64string = hash
).
cl_abap_message_digest=>calculate_hash_for_raw(
  EXPORTING if_data = text if_algorithm = sha256 IMPORTING ef_hashb64string = hash
).]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/328.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:328,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Allowed cryptographic hash algorithms" value="SHA224, SHA256, SHA384, SHA512"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <categories>
    <category name="ABAP" technology="ABAP" active="true" weight="1.0">
      <description><![CDATA[ABAP rules]]></description>
      <children>
        <category name="OPT.CRITERIUM_VALUE.CQM.EFFICIENCY" technology="ABAP" active="true" weight="0.0">
          <description><![CDATA[Efficiency]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.MAINTAINABILITY" technology="ABAP" active="true" weight="0.0">
          <description><![CDATA[Maintainability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.PORTABILITY" technology="ABAP" active="true" weight="0.0">
          <description><![CDATA[Portability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.RELIABILITY" technology="ABAP" active="true" weight="0.0">
          <description><![CDATA[Reliability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.SECURITY" technology="ABAP" active="true" weight="10.0">
          <description><![CDATA[Security]]></description>
        </category>
      </children>
    </category>
  </categories>
</ruleset>
