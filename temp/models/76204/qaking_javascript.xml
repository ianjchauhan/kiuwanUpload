<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="qaking_javascript" updated="">
  <description>BridgeWeave Mobile</description>
  <rule name="OPT.JAVASCRIPT.ANGULARJS.AngularCrossSiteScripting" message="AngularCrossSiteScripting: Improper neutralization of input during web content generation (Cross-site Scripting, XSS) - AngularJS" class="com.optimyth.qaking.rules.angularjs.AngularCrossSiteScripting" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:AngularJS]]></tags>
    <description><![CDATA[Angular 1.x (AngularJS) provides automatic output encoding against XSS, context-aware, for most places where external data is inserted
in the HTML page (ng-model, ng-bind, expressions...).

All versions of Angular up to 1.6 executed expressions in a sandbox. But such sandbox was never considered as a security measure, capable
of protecting XSS or code injection attacks. Certainly each version had multiple "sandbox escape" payloads, so the sandbox was removed since Augular 1.6.

This rule detects potential flaws allowing XSS attacks in Angular 1.x, for example using ng-bind-html.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- Angular page -->
<body ng-app='MyApp'>
  <div ng-controller='SearchController'>
    <form>
      <input type='search' ng-model='searchQuery'/>
      <button type='submit' ng-click='search()'>Search</button>
    </form>
  </div>
  <!-- Better in template rendered for the /search?q=... location -->
  <div ng-controller='SearchResultController'>
    <div ng-show='searchQuery'>
      <span ng-bind-html='searchQuery'></span> <!-- VIOLATION, XSS -->
    </div>
    <table>
      <tr><th>product</th><th>prize</th></tr>
      <tr ng-repeat='product in products'>
        <td>{{product.name}}</td><td>{{product.prize}}</td>
      </tr>
    </table>
  </div>
</body>

<!-- JavaScript code -->
var app = angular.module('MyApp');

app.controller('SearchController', ['$scope', '$location', function($scope, $location) {
  $location.path('/search').search({q: $scope.searchQuery || ''});
})]);

app.controller('SearchResultController', ['$scope', '$sce', '$location', 'ProductService',
  function($scope, $sce, $location, productService) {
    $scope.searchQuery = $sce.trustAsHtml($location.search().q); // Reflected XSS allowed here

    productService.search($scope.searchQuery).then(function(products) {
      $scope.products = products;
    });
  }
]);]]></example>
    <repair><![CDATA[// Do not let user-controller input to be rendered without strict context escaping.
// Perform scrict validation e.g. on orderBy expressions in ngRepeat when taken from untrusted input.
// Never bypass SCE with ng-bind-html / $sce.trustAs*() pairs, without careful validation.]]></repair>
    <reference><![CDATA[https://www.synopsys.com/blogs/software-security/angularjs-1-6-0-sandbox/,https://docs.angularjs.org/api/ng/service/$sce,https://www.owasp.org/images/4/46/OWASPLondon20170727_AngularJS.pdf,https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWE:80,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.4,WASC:08]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ANGULARJS.AngularLocalStorageInformationLeak" message="AngularLocalStorageInformationLeak: AngularJS local storage information leakage" class="com.optimyth.qaking.rules.angularjs.AngularLocalStorageInformationLeak" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality,Framework:AngularJS,global]]></tags>
    <description><![CDATA[The angular-storage service in AngularJS allows applications to persist data client-side (browser) in web storage,
without the size restrictions imposed by cookies. However, this service defaults to using local storage,
which persists indefinitely unless it is explicitly cleared. Potential sensitive data will remain on the user's file system
even after the browser is closed, exposing the data to any user with physical access to the system.

This will lead to a security leak, because sensible private data could be improperly accessed by unauthorized agents.

Because any client-side data is inherently insecure, local storage should not be used to persist sensitive data,
such as credentials or credit card numbers. A slightly more secure alternative is to configure the angular-storage service
to use session storage, which is cleared automatically when the browser tab is closed. This can be done with the storeProvider
service within the config block as shown in the code example.

This rule reports violation when data is stored in a angular-storage service, configured to use localStorage (the default).]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding storage of sensitive data in localStorage improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var app = angular.module('MyApp', ['angular-storage']);

app.config(function(storeProvider) {
    // Store defaults to localStorage, but may be set to sessionStorage or cookieStorage
    storeProvider.setStore('localStorage'); // this is the default
});

app.controller('Controller', function(store) {
    var myObj = { /* ... */ };
    store.set('obj', myObj); // VIOLATION
    /* ... */
});]]></example>
    <repair><![CDATA[// FIXED, sessionStorage not kept when browser closes
app.config(function(storeProvider) {
    storeProvider.setStore('sessionStorage'); // cookieStorage also accepted
});]]></repair>
    <reference><![CDATA[https://www.synopsys.com/blogs/software-security/preventing-common-angularjs-vulnerabilities/,http://cwe.mitre.org/data/definitions/200.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:200,CWETOP25:2021:20,OWASP-M:2016:M2,OWASP:2021:A1,PCI-DSS:6.5.1,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ANGULARJS.ContextualEscapingDisabled" message="ContextualEscapingDisabled: Strict Contextual Escaping (SCE) disabled" class="com.optimyth.qaking.rules.angularjs.ContextualEscapingDisabled" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.2,ASVS-v4.0.2:13.3.1,ASVS-v4.0.2:5.1.3,ASVS-v4.0.2:5.1.4,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:AngularJS]]></tags>
    <description><![CDATA[Strict Contextual Escaping (SCE) is disabled in AngularJS application, potentially leading to multiple vulnerabilities.

SCE in AngularJS applications is a mode in which AngularJS constrains bindings to only render trusted values.
Its goal is to assist in writing code in a way that (a) is secure by default, and (b) makes auditing for security vulnerabilities
such as XSS, clickjacking, etc. a lot easier.

To systematically block XSS security bugs, AngularJS treats all values as untrusted by default in HTML or sensitive URL bindings.
When binding untrusted values, AngularJS will automatically run security checks on them (sanitizations, whitelists,
depending on context), or throw when it cannot guarantee the security of the result.
That behavior depends strongly on contexts: HTML can be sanitized, but template URLs cannot, for instance.
See the SCE reference (https://docs.angularjs.org/api/ng/service/$sce) for full details.

As of version 1.2, Angular JS ships with SCE enabled by default.

The rule reports where such protection is specifically disabled.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var app = angular.module('app', []);
app.config(function($sceProvider){
  $sceProvider.enabled(false); // VIOLATION
});]]></example>
    <repair><![CDATA[// Never ever disable SCE explicitly.]]></repair>
    <reference><![CDATA[https://docs.angularjs.org/api/ng/service/$sce,https://cwe.mitre.org/data/definitions/20.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:20,CWETOP25:2021:4,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ANGULARJS.UnsafeResourceUrlWhitelist" message="UnsafeResourceUrlWhitelist: Loading Angular templates insecurely" class="com.optimyth.qaking.rules.angularjs.UnsafeResourceUrlWhitelist" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control,Framework:AngularJS]]></tags>
    <description><![CDATA[In certain places (route definitions, directives, ng-src / ng-include attributes...) a template URL may be specified.
The template resources are restricted by default by AngularJS to the same domain and protocol as the application document.

Often, templates from other domains or protocols need to be loaded; such scenario needs opening the default restriction,
either using a whitelist of patterns, or wrapping them as trusted values. The usual configuration is done via
$sceDelegateProvider.resourceUrlWhitelist() function, with patterns that may be too open to avoid template injection attacks.

This rule ensures that the template URL whitelists are not too permissive:
- A double asterisk wildcard (**) allowing any domain / protocol.
- A wildcard as part of the protocol or domain (wildcards should be restricted to the end of the whitelist pattern).
- Non secure protocols (e.g. allowing http:// URLs).]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Developer tried to raise the 'self' domain restriction for loading templates from other domains

angular.module('myApp', []).config(function($sceDelegateProvider) {
  $sceDelegateProvider.resourceUrlWhitelist([
    // Insecure - the wildcard allows resource loading from any domain using any protocol
    '**'
  ]);
});

angular.module('myApp', []).config(function($sceDelegateProvider) {
  $sceDelegateProvider.resourceUrlWhitelist([
    // Insecure - loads over HTTP, wildcard allows for any subdomain and any directory
    'http://**.example.com/**'
  ]);
});]]></example>
    <repair><![CDATA[angular.module('myApp', []).config(function($sceDelegateProvider) {
  $sceDelegateProvider.resourceUrlWhitelist([
    // Accepted - loads over HTTPS, only hosts in same domain owned by the organization
    'https://*.example.com/**'
  ]);
});]]></repair>
    <reference><![CDATA[https://www.owasp.org/images/4/46/OWASPLondon20170727_AngularJS.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:183,OWASP:2021:A1,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="badPattern" descname="Regexp for matching whitelist patterns for resource URL considered unsafe." value="^\*\*$|^\*\*?:|^http://|^\w+://([^/]*\*\*[^/]*)"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ANGULARJS.UnsafeUrlWhitelist" message="UnsafeUrlWhitelist: Unsafe URL whitelist" class="com.optimyth.qaking.rules.angularjs.UnsafeUrlWhitelist" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control,Framework:AngularJS]]></tags>
    <description><![CDATA[In AngularJS, whitelists for URLs for HTML links and images could be registered in the $compileProvider provider.

Such white-lists are a security measure aimed at prevent Cross-Site Scripting (XSS) attacks via links.
The default white-lists in Angular JS are reasonable. Developers may change such defaults, and that may
allow successful XSS attacks. For example, the javascript: protocol probably should not be allowed in links
rendered by AngularJS.

When AngularJS tries to render a URL in an HTML or image link, and the URL does not match the whitelist pattern,
it prefixes the URL with "unsafe:", so it is neutralized when written to the document to be rendered in the browser.

The default values for current AngularJS are: /^\s*(https?|ftp|mailto|tel|file):/ for HTML links, and
/^\s*((https?|ftp|file|blob):|data:image\/)/ for images.

This rule will emit a violation when the URL whitelist configured is considered unsafe.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var app = angular.module('app', []);
app.config(function($compileProvider){
  // VIOLATION, javascript: protocol not allowed
  $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|javascript):/);
});]]></example>
    <repair><![CDATA[// Do not allow unsafe URLs in whitelists (in particular, unsafe protocols like javascript:).]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/183.html,https://docs.angularjs.org/api/ng/provider/$compileProvider]]></reference>
    <normatives>
      <security><![CDATA[CWE:183,OWASP:2021:A1,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties>
      <property name="badPattern" descname="Regular expression that unsafe whitelist patterns should match." value="javascript"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.AvoidNegativeContentLenght" message="AvoidNegativeContentLenght: The Content-Length header should not have a negative value" class="com.als.js.rules.AvoidNegativeContentLenght" technology="JAVASCRIPT" active="true">
    <description><![CDATA[The configuration of the Content-Length header is used to indicate the length of the POST
data sent to the server.
        
This length must be an integer equal or greater than 0 according to the HTTP 1.1 specification.

A negative value for this field may be caused by a denial of service attack (DOS) or cause a buffer overflow allowing
the attackers to run arbitrary code.

This rule reports violation when Content-Length contains a negative value.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Buffer handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Checking the header length validity improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var xhr = new XMLHttpRequest();
xhr.setRequestHeader("Content-Length", "-1000"); // VIOLATION

var req = new XMLHttpRequest();
req.setRequestHeader("Content-Length", -741); // VIOLATION

var req = new XMLHttpRequest();
var valueInt = -741;
req.setRequestHeader("Content-Length", valueInt); // VIOLATION]]></example>
    <repair><![CDATA[var xhr = new XMLHttpRequest();
xhr.setRequestHeader("Content-Length", "1000"); // OK

var req = new XMLHttpRequest();
req.setRequestHeader("Content-Length", 741); // OK

var req = new XMLHttpRequest();
var valueInt = 741;
req.setRequestHeader("Content-Length", valueInt); // OK]]></repair>
    <reference><![CDATA[https://www.symantec.com/security_response/attacksignatures/detail.jsp?asid=21116,http://projects.webappsec.org/w/page/13246921/Denial%20of%20Service,https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html,http://projects.webappsec.org/w/page/13246916/Buffer%20Overflow,http://cwe.mitre.org/data/definitions/398.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:398,OWASP:2021:A3,PCI-DSS:6.5.6,WASC:10,WASC:7]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.AvoidOverlyPermissiveMessagePosting" message="AvoidOverlyPermissiveMessagePosting: Avoid post cross-document messages with an overly permissive target origin" class="com.als.js.rules.AvoidOverlyPermissiveMessagePosting" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[HTML5 provides the functionality of post cross-document messages (Web Messaging), allowing message posting between windows.

The postMessage() method lifts the same-origin restriction, by providing a way to securely pass messages across domains.
This feature allows the user to specify the target window, so be careful when specifying the allowed origin for the target.

Normally, scripts on different pages are allowed to access each other if and only if the pages that executed them came from same origins (protocol, host and port).
In the past, sending messages between windows/documents was only possible if the windows used the same origin (protocol, port, and host),
or by exploiting certain hacks (with libraries like easyXDM providing them as alternatives to the Window.postMessage() for old browsers).

The Window.postMessage() method safely enables cross-origin communication, and provides a controlled mechanism to send data cross-origin,
in a secure way when properly used.

For sending messages, syntax is: otherWindow.postMessage(message, targetOrigin, [transfer]), where otherWindow is the window that will
receive the message, and targetOrigin may contain the URL of the window that the message is being sent to, or either "*"
(any domain, no restriction) or "/" (same domain as sender).

The receiver registers an 'message' event handler, where the sender origin could be checked using the MessageEvent.origin property.
The MessageEvent.source contains the sender's window, for two-way communications. The message itself is provided in the
MessageEvent.data property (and should be considered by the receiver as untrusted input, unless the origin is checked and it is trusted).

An overly permissive target origin can provide a malicious script to communicate with the window in an inappropriate way.
This rule reports violation when the target origin is overly permissive (using '*' for the targetOrigin).]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Reducing the permissibility when specifying the target origin increases security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[o.contentWindow.postMessage(message, '*'); // VIOLATION]]></example>
    <repair><![CDATA[o.contentWindow.postMessage(message, "http://anotherdomain.com"); // OK]]></repair>
    <reference><![CDATA[http://www.qcert.org/sites/default/files/public/documents/ENISA-CIIP-STD-A%20Security%20Analysis%20of%20Next%20Generation%20Web%20Standards-Eng-2011.pdf,https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet#Web_Messaging]]></reference>
    <normatives>
      <security><![CDATA[CWE:942,OWASP:2021:A5,PCI-DSS:6.5.10,WASC:15]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.AvoidTransferValuesLocalSessionStorage" message="AvoidTransferValuesLocalSessionStorage: Avoid transferring data between localStorage and sessionStorage as it can expose confidential information" class="com.als.js.rules.AvoidTransferValuesLocalSessionStorage" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[SessionStorage and localStorage maps are provided by HTML5 for developers to store program
values.

The information stored in sessionStorage map is not persistent, lasting only the duration of the browser session; while
the information stored in localStorage map is persistent and does not expire even if you change the tab or close the
browser.

This will lead to a security leak, because sensible private data could be improperly accessed by unauthorized persons.

This rule reports violation when there are a transference of information between the sessionStorage and the localStorage.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding private data transferences improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[...
sessionStorage.setItem("user", currentUser);
...
var retrieveObject = sessionStorage.getItem("user");

localStorage.setItem("user",retrieveObject);   // VIOLATION (put in
                                               // 'localStorage' elements
                                               // of 'sessionStorage')
...
var userCCV = localStorage.getItem("user");
...]]></example>
    <repair><![CDATA[...
sessionStorage.setItem("user", currentUser);
...
var retrieveObject = sessionStorage.getItem("user");

...]]></repair>
    <reference><![CDATA[http://projects.webappsec.org/w/page/13246936/Information%20Leakage,http://cwe.mitre.org/data/definitions/501.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:501,OWASP-M:2016:M2,OWASP:2021:A4,PCI-DSS:6.5.1,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ClickjackingProtection" message="ClickjackingProtection: No clickjacking protection configured" class="com.optimyth.qaking.rules.javascript.security.ClickjackingProtection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.4.3,CAPEC:103,CWEScope:Access-Control,Framework:Node.js,clickjacking,global]]></tags>
    <description><![CDATA[Clickjacking, also known as a "UI redress attack", is when an attacker uses multiple transparent or opaque layers to trick a user
into clicking on a button or link on another page when they were intending to click on the the top level page.
Thus, the attacker is "hijacking" clicks meant for their page and routing them to another page, most likely owned by
another application, domain, or both.

Using a similar technique, keystrokes can also be hijacked. With a carefully crafted combination of stylesheets,
iframes, and text boxes, a user can be led to believe they are typing in the password to their email or bank account,
but are instead typing into an invisible frame controlled by the attacker.

The rule will emit a violation on the point where server is created or put to listen, when no cross-frame protection headers
are registered in the analyzed code.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Blocks clickjacking attacks]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// No specific cross-form prevention headers (X-Frame-Options, Content-Security-Policy:frame-ancestors)

var express = require('express')
var app = express() // VIOLATION

app.get('/', function (req, res) {
  // ...
})

app.listen(3000, function () {
  console.log('Example app listening on port 3000!')
})]]></example>
    <repair><![CDATA[// Add either X-Frame-Options, Content-Security-Policy with frame-ancestors directive, or both)
app.use(function(req, res, next) {
  res.set('X-Frame-Options', 'SAMEORIGIN');
  res.set('Content-Security-Policy', "frame-ancestors 'none'");
  next();
});

// Alternatively, use helmet (or koa-helmet if under Koa)
var helmet = require('helmet');
// or simply app.use(helmet()) for all default headers, including X-Frame-Options
app.use(helmet.frameguard());]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Headers,https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet,https://cwe.mitre.org/data/definitions/1021.html,https://blog.risingstack.com/node-js-security-checklist/]]></reference>
    <normatives>
      <security><![CDATA[CWE:1021,OWASP:2021:A4]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ClientSideTemplateInjection" message="ClientSideTemplateInjection: Client-side Template Injection" class="com.optimyth.qaking.rules.javascript.security.ClientSideTemplateInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.4,ASVS-v4.0.2:5.5.4,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,Framework:Angular,Framework:AngularJS]]></tags>
    <description><![CDATA[Template engines allow dynamic generation of content (HTML, JSON, email messages...) merged with data.
Unsafely embedding untrusted input in templates executed enables Client-Side Template Injection (CSTI),
when template rendering is done at the client-side (for example, in a browser with AngularJS).

If an attacker is able to inject expressions in the template, the attack payload may include code execution
or sensitive information leaks. Remember that for some frameworks like AngularJS, 'the page is the template',
and dynamic pages generated server-side are trusted by the browser framework.

A CSTI vulnerable app may open the gate for arbitrary JavaScript code execution in the user agent (browser),
including cross-site scripting and related cross-site request forgery attacks, stealing the victim's cookies,
performing actions on the users's behalf, or even logging keystrokes.

Browser cross-site scripting filters are typically unable to prevent CSTI attacks.

The check will emit a violation when non-neutralized user-controlled input is evaluated in template compilation
of expression evaluation functions.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// AngularJS
function MyController( function($stateParams, $interpolate) {
    var ctx = { foo : 'bar' };
    var interpolated = $interpolate( $stateParams.hiddenData );
    this.rendered = interpolated(ctx);
    ...
}

// Angular
import { Component, OnInit, ViewChild, ViewContainerRef, ComponentFactoryResolver } from '@angular/core';
import { Compiler } from '@angular/core';
import '@angular/compiler';

@Component({
    selector: 'app-test',
    template: `
        <p>test works!</p>
        <div>
            <input type="text" #val (click)="refreshContent(val.value)" />
            <div #dynamicContentPlaceHolder></div>
        </div>`
})
export class ClientSideTemplateInjection implements OnInit {

    @ViewChild('dynamicContentPlaceHolder', {read: ViewContainerRef}) vc: ViewContainerRef;

    constructor(
        protected compiler: Compiler,
        private  componentFactoryResolver: ComponentFactoryResolver
    ) { }

    ngOnInit(): void { }

    public refreshContent(template: string){
        if(!template) return;

        let tmpCmp = Component({template: template})(class { });    // VIOLATION
        let f = this.componentFactoryResolver.resolveComponentFactory(tmpCmp);
        this.vc.createComponent(f);
    }
}]]></example>
    <repair><![CDATA[// If possible, never let untrusted input to affect the template code or resource.
// See remediation for more details.]]></repair>
    <reference><![CDATA[https://angular.io/guide/security#use-the-offline-template-compiler,https://docs.angularjs.org/guide/security#angularjs-templates-and-expressions,http://blog.portswigger.net/2016/04/adapting-angularjs-payloads-to-exploit.html,http://blog.portswigger.net/2016/01/xss-without-html-client-side-template.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:95,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CodeInjection" message="CodeInjection: Improper Control of Generation of Code ('Code Injection')" class="com.optimyth.qaking.rules.tainting.CodeInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.4,ASVS-v4.0.2:5.2.5,ASVS-v4.0.2:5.2.8,ASVS-v4.0.2:5.5.4,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[Code injection term is used to identify all the attacks that are based on injecting
malicious data into a computer program and change the course of execution in an unexpected way.

Programs behaviour usually needs external data, and the vulnerability appears when the programmer trust in the data
supplied by the user, incorrectly assuming that the data just contains the expected operations.

Performing dynamic instructions based on input received from the user, without proper validation, can lead to
vulnerabilities of code injection.

This rule reports violation when an expression from an user input is evaluated without being properly neutralized.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Proper validation of expressions from user input mitigates injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var userOp = document.forms[0].operation.value;
calcResult = eval(userOp); // VIOLATION]]></example>
    <repair><![CDATA[var userOp = form.operation.value;
var numbers;
var operations;

//Use validation of input parameters and replace by direct call
function validate(userOp){
	...
	var stringNumbers = getNumbers(userOp);
	...
	for(i = 0;i < stringNumbers.lenght;i++){
		numbers[i] = parseInt(stringNumbers[i]);
		if(numbers[i].isNaN()){
			return false;
		}
	}
}

if(validate(userOp)){
	calcResult = calcValue(numbers, operations);
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/95.html,https://www.owasp.org/index.php/Code_Injection,https://cwe.mitre.org/data/definitions/94.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:94,CWE:95,CWETOP25:2021:28,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CodeInjectionWithDeserialization" message="CodeInjectionWithDeserialization: Dynamic code injection during object deserialization" class="com.optimyth.qaking.rules.tainting.CodeInjectionWithDeserialization" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.5.2,ASVS-v4.0.2:5.5.1,ASVS-v4.0.2:5.5.3,CWEScope:Availability,CWEScope:Integrity,code-injection,serialization]]></tags>
    <description><![CDATA[Certain common JavaScript serialization modules (like node-serialize, serialize-to-js, or js-yaml) provide a framework
for arbitrary object persistence (without mapping information), serializing objects to formats like JSON or YAML.
Such frameworks allow to serialize functions, to reconstruct object instances properly during deserialization.

If the application deserializes content from untrusted sources (e.g. in a REST framework), and if an attacker
can provide the content to be deserialized, he/she may be able to execute arbitrary code on the server, including
opening a reverse shell to launch commands.

If you think that this does not affect you, think twice. A top-level service framework (REST...) could
transfer objects using an underlying persistence framework. A REST framework typically process (HTTP) request messages,
and serializes/deserializes a resource representation (JSON, YAML...), potentially to JavaScript objects.
The underlying unmarshalling library could allow code injection if it does not limit which elements could be created,
and which code could be executed during deserialization.

In other words, any application that allows a user to pass content that will be deserialized by a vulnerable framework
is exposing a remote code execution flaw.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid code injection thru serialized objects]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const express = require('express');
const app = express();
const yaml = require("js-yaml");

app.post('/saveUser', function(req, res) {
    var user = yaml.load( req.params.user ); // VIOLATION
    // ...
});]]></example>
    <repair><![CDATA[const express = require('express');
const app = express();
const yaml = require("js-yaml");

app.post('/saveUser', function(req, res) {
    var user = yaml.safeLoad( req.params.user ); // FIXED
    // ...
});]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/502.html,https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/,https://nealpoole.com/blog/2013/06/code-execution-via-yaml-in-js-yaml-nodejs-module/]]></reference>
    <normatives>
      <security><![CDATA[CWE:502,CWETOP25:2021:13,OWASP:2021:A8,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CommandInjection" message="CommandInjection: Avoid non-neutralized user-controlled input to be part of an OS command" class="com.optimyth.qaking.rules.javascript.security.CommandInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.5,ASVS-v4.0.2:5.3.8,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[The software constructs all or part of an operating system (OS) command using externally-controlled input, but it does not neutralize
properly that input that could modify the intended command when it is sent to a function that executes the command.
For example, with Node.js, the child_process module could be used for executing OS commands, and in particular exec()
uses the system shell, making easy to insert flawed code allowing arbitrary OS command execution.

The rule detects a path in code between an user-input statement (source) and a command execution call (sink),
with command depending on non neutralized input. This allows for an attacker to change the intended command to execute,
or to add a malicious extra command, executed with the main process permissions.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid arbitrary OS command execution.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Simple utility to find sockets listening at a specified port
const port = process.argv[2]; // untrusted input
const exec = require('child_process').exec;

// VIOLATION, imagine port="80; rm -rf /"
exec('netstat -an | grep LISTENING | grep :' + port,
  function (error, stdout, stderr) { console.log(stdout); }
);]]></example>
    <repair><![CDATA[// FIXED: use spawn() to avoid running OS shell, arguments are not taken as part of the command
// Example of how to pipe commands without running the OS shell
const spawn = require('child_process').spawn,
      netstat = spawn('netstat', ['-an'], {stdio: 'pipe'}),
      grep1 = spawn('grep', ['LISTENING'], {stdio: [netstat.stdout, 'pipe', 'pipe']}),
      grep2 = spawn('grep', [':' + port], {stdio: [grep1.stdout, 'pipe', 'pipe']}); // port concat is safe here

var result = '';
grep2.stdout.on('data', data => result += data );
grep2.stderr.on('data', data => console.log('Error: ' + data));
grep2.on('close', () => console.log(result));]]></repair>
    <reference><![CDATA[https://blog.liftsecurity.io/2014/08/19/Avoid-Command-Injection-Node.js/,http://cwe.mitre.org/data/definitions/78.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:77,CWE:78,CWETOP25:2021:5,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:31]]></security>
    </normatives>
    <properties>
      <property name="sources" descname="Comma-separated list of input types to consider as sources (external_input, file_input, database_input)" value="external_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ConnectionStringParameterPollution" message="ConnectionStringParameterPollution: Connection string polluted with untrusted input" class="com.optimyth.qaking.rules.javascript.security.ConnectionStringParameterPollution" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.7,CWEScope:Integrity]]></tags>
    <description><![CDATA[When the connection string for an application resource (like database, remote server, persistence entity manager...) could
be affected by an untrusted source, not properly neutralized, the application is vulnerable to a Connection String Parameter Pollution attack.

An attack targeted at this vulnerability may use special characters (like ';' or ':') to add unexpected parts to the connection string,
for example to gain extra privileges, or to deactivate security features.

"Untrusted input" means, in this context, a user-controlled application input, an environment variable, or data fetched
from an external web source.

It should be suspicious that a connection string depends on untrusted input. Normally the application configuration uses
a fixed connection string, but other attacks, depending on where the connection string is stored (like an SQL injection or
path traversal attack) may affect the configuration item. This rule only checks for connection strings that are constructed
programmatically with untrusted input.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const oracle = require('oracle')
const connConfig = {
  connectString: process.argv[2],
  user: process.argv[3],
  password: process.argv[4]
}
oracle.getConnection(connConfig, function(err, connection) { // VIOLATION
  // ...
})

const MongoClient = require('mongodb').MongoClient
const url = process.argv[2]
MongoClient.connect(url, function(err, db) { // VIOLATION
  // ...
})]]></example>
    <repair><![CDATA[// Fetch connection string (or its parts) from a trusted source.]]></repair>
    <reference><![CDATA[https://www.blackhat.com/presentations/bh-dc-10/Alonso_Chema/Blackhat-DC-2010-Alonso-Connection-String-Parameter-Pollution-wp.pdf]]></reference>
    <normatives>
      <security><![CDATA[CWE:15,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CookiePoisoning" message="CookiePoisoning: Cookie Poisoning" class="com.optimyth.qaking.rules.javascript.security.CookiePoisoning" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Integrity]]></tags>
    <description><![CDATA[The application does not prevent malicious input from being inserted into application cookies.

If an attacker may insert an attack payload that is stored by client-side JavaScript code as part of a browser cookie,
that payload may be accepted as legitimate by the application.

The poisoned cookie can be used to bypass security controls, change user preferences, perform unintended actions
with logged user identity, etc.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var hash = window.location.hash;
document.cookie = 'mycookie=' + hash; // VIOLATION

// cookies-js is a client-side cookies library
var Cookie = require('cookies-js');
Cookie.set('mycookie', hash); // VIOLATION]]></example>
    <repair><![CDATA[// Do not set any part of the cookie with user-controlled input]]></repair>
    <reference><![CDATA[]]></reference>
    <normatives>
      <security><![CDATA[CWE:472,OWASP:2021:A4,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CORDOVA.AvoidEnabledDebugMode" message="AvoidEnabledDebugMode: Debug logs enabled" class="com.optimyth.qaking.rules.cordova.AvoidEnabledDebugMode" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.2,CWEScope:Confidentiality,Framework:Cordova]]></tags>
    <description><![CDATA[Logs can be very helpful at development stages but they should be used on later stages
because they can show rewarding information.

When a log shows sensible information, it can create a security leak, making useless any other system protection
mechanisms. Also sensible data can have many legal implications due to the established limitations about personal
information storage.

Also if left enabled debug in production mode, the application performance will be worse.

By default the debug level is set to ERROR.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improves both the application security and performance.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<widget id="de.zertapps.dvhma.featherweight" version="1.0.0-3.5.0" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0">
    <preference name="loglevel" value="DEBUG" /> <!-- VIOLATION -->
</widget>]]></example>
    <repair><![CDATA[<widget id="de.zertapps.dvhma.featherweight" version="1.0.0-3.5.0" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0">
    <preference name="loglevel" value="ERROR" />
</widget>]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/497.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:497,OWASP:2021:A1,PCI-DSS:6.5.5]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CORDOVA.InsecureAndroidMinSdkVersion" message="InsecureAndroidMinSdkVersion: Android SDK version too old" class="com.optimyth.qaking.rules.cordova.InsecureAndroidMinSdkVersion" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.3.1,ASVS-v4.0.2:14.1.3,ASVS-v4.0.2:2.5.4,ASVS-v4.0.2:3.4.3,ASVS-v4.0.2:3.4.4,ASVS-v4.0.2:3.4.5,CWEScope:Confidentiality,Framework:Cordova]]></tags>
    <description><![CDATA[API 10 is Gingerbread, and Gingerbread is no longer supported by Google or device manufacturers, and is therefore not
recommend by the Cordova team.

This rule is important due to Gingerbread has been shown to be insecure and one of the most targeted mobile OSs.

Also the Whitelist on Android does not work with Gingerbread or lower.  This means an attacker can load malicious code
in an iframe that would then have access to all of the Cordova APIs and could use that access to steal personal data,
send SMS messages to premium-rate numbers, and perform other malicious acts.

Set your min-target-sdk level higher than 10.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improves the application security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<widget id="de.zertapps.dvhma.featherweight" version="1.0.0-3.5.0" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0">
    <preference name="android-minSdkVersion" value="7" /> <!-- VIOLATION -->
</widget>]]></example>
    <repair><![CDATA[<widget id="de.zertapps.dvhma.featherweight" version="1.0.0-3.5.0" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0">
    <preference name="android-minSdkVersion" value="11" />
</widget>]]></repair>
    <reference><![CDATA[https://cordova.apache.org/docs/en/8.x/guide/appdev/security/index.html#general-tips]]></reference>
    <normatives>
      <security><![CDATA[CWE:16,OWASP-M:2016:M1,OWASP:2021:A5]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CORDOVA.TooBroadAccessOrigin" message="TooBroadAccessOrigin: Access policy too broad" class="com.optimyth.qaking.rules.cordova.TooBroadAccessOrigin" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.4.7,ASVS-v4.0.2:14.5.2,ASVS-v4.0.2:14.5.3,CWEScope:Access-Control,Framework:Cordova]]></tags>
    <description><![CDATA[The origin attribute defines the set of external domains the app is allowed to communicate with.

By default its value is "*" which allows it to access any server, meaning that any malicious app can potentially open a
malicious webpage by using the exposed intent functionality.]]></description>
    <priority>1</priority>
    <effort>1</effort>
    <vulntype>Permissions, privileges and access controls</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Reduce the range of servers to which the application is exposed]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<widget id="com.pkg.sample" version="1.0.0" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0">
    <access origin="*" /> <!-- VIOLATION -->
</widget>]]></example>
    <repair><![CDATA[<widget  id="com.pkg.sample" version="1.0.1" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0">
    <access origin="http://corp.net" /> <!-- FIXED -->
</widget>]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/346.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:346,OWASP:2021:A7,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CORDOVA.WhitelistPluginNotInstalled" message="WhitelistPluginNotInstalled: Whitelist plugin not installed" class="com.optimyth.qaking.rules.cordova.WhitelistPluginNotInstalled" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control,Framework:Cordova]]></tags>
    <description><![CDATA[The Whitelist plugin is an important security plugin that defines authorized URI for navigation, intent and network access.

The plugins also allows the definition of a CSP (content-security-policy), a very important protection against XSS
vulnerabilities, highly dangerous for Cordova application.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improves the application security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<widget id="de.zertapps.dvhma.featherweight" version="1.0.0-3.5.0" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0"> <!-- VIOLATION -->
</widget>]]></example>
    <repair><![CDATA[<widget id="de.zertapps.dvhma.featherweight" version="1.0.0-3.5.0" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0">
  <plugin name="cordova-plugin-whitelist" spec="1" />
</widget>]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/358.html,https://cordova.apache.org/docs/en/8.x/guide/appdev/whitelist/index.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:358,OWASP-M:2016:M6,OWASP:2021:A5]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CrossSiteRequestForgery" message="CrossSiteRequestForgery: Execution of an action on user behalf in a previously authenticated web site (cross-site request forgery, CSRF)" class="com.als.js.rules.CrossSiteRequestForgery" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:13.2.3,ASVS-v4.0.2:4.2.2,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation]]></tags>
    <description><![CDATA[When a user is authenticated in a web site, an attacker with knowledge about the web site can perform malicious requests
against the vulnerable site and execute actions while user remains authenticated.

Usually the attacker forces an authenticated user to launch the malicious request using social engineering, or by exploiting
an XSS vulnerability.

In web sites developed with JavaScript server-side frameworks (like Node.js, Express or Koa), anti-forgery tokens,
also known as request verification tokens, should be utilized to prevent CSRF attacks.

Anti-forgery tokens are random values generated in the server when a form is requested, and they are included in every request,
so the server can verify not only that user is authenticated, but that the request was originated from the application.

This rule checks:
(1) if a code fragment should be protected against CSRF attacks (for example, handling a POST request).
(2) if such code is protected with one of the recommended anti-CSRF protection schemes.
(3) If no protection is found for the candidate code, a violation is reported.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');
var express = require('express'); // VIOLATION, no anti-csrf control

var app = express();
app.use(cookieParser());
app.use(bodyParser.urlencoded({extended: false}));

app.get('/form', function(req, res) {
  res.render('form', {});
});

app.post('/process', function(req, res) { // vulnerable to CSRF attacks
  // ... sensitive operation ...
});

app.listen(80);]]></example>
    <repair><![CDATA[var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');
var csrf = require('csurf'); // Anti-CSRF module
var express = require('express');
var csrfProtection = csrf( {cookie: true} );

var app = express();
app.use(cookieParser());
app.use(bodyParser.urlencoded({extended: false}));
app.use(csrfProtection); // FIXED

app.get('/form', function(req, res) {
  // pass the csrfToken to the view, for rendering as hidden field
  // when form is posted to /process, the csrf cookie and the hidden field must match
  res.render('form', { csrfToken: req.csrfToken() });
});

app.post('/process', function(req, res) { // now not vulnerable
  // ... same as before ...
});

app.listen(80);]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/352.html,https://github.com/expressjs/csurf]]></reference>
    <normatives>
      <security><![CDATA[CWE:352,CWETOP25:2021:9,OWASP-M:2016:M4,OWASP:2013:A8,PCI-DSS:6.5.5,WASC:9]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.CrossSiteScripting" message="CrossSiteScripting: Improper neutralization of input during web content generation (Cross-site Scripting, XSS)" class="com.optimyth.qaking.rules.tainting.CrossSiteScripting" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software places user-controlled input in page content. An attacker could inject browser script code that is executed in the client browser.
The end-user is the attacked subject, and the software is the vehicle for the attack.

There are different kinds of XSS. The kind relevant for this check is:
* Reflected XSS: Attacker causes victim to supply malicious content to a vulnerable web application, which renders HTML content
  embedding a malicious script executed in victim's browser. A variant is named DOM-based XSS, where the vulnerable software
  does not generate content depending on user input but include script code that use user-controlled input.

The script executed in the victim's browser could perform malicious activities, like stealing active authentication tokens
(sometimes in the form of cookies) and performing operations on a insecure webapp (on behalf of the victim) that trusts
too much identity artifacts in browser and do not request additional authorization for sensitive operations
('Cross-Site Request Forgery attack', CSRF).

Many browsers could limit the damage via security restrictions (e.g. 'same origin policy'), but user browsers generally
allow scripting languages (e.g. JavaScript) in their browsers (disabling JavaScript severely limits a web site).

This rule detects potential flaws allowing XSS attacks of the reflected and DOM-based types.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Client-side example:
var url = document.location.href;
var from = url.indexOf("id=")+3;
document.getElementById('id').innerHTML = 'ID: ' + url.substring(from); // VIOLATION

// Server-side example (Express.js):
var express = require('express');
var app = express();

var bodyParser = require('body-parser');
app.use(bodyParser.json());
app.use(bodyParser.urlencoded());

app.get('/user/:user', function(req, res) {
  var uname = req.param('user'); // deprecated, allows parameter encoded in query string, body or URI path
  changeProfile(uname, req.body); // do it async...

  res.send('<p>Profile updated, user ' + uname + '</p>'); // VIOLATION
});]]></example>
    <repair><![CDATA[// Client-side example:
var url = document.location.href;
var from = url.indexOf("id=")+3;
var id = url.substring(from);
if(/^\d+$/.test(id)) { // FIXED, strong validation
  document.getElementById('id').textContent = 'ID: ' + id; // safer alternative
}

// Server-side example (Express.js):
var express = require('express');
var app = express();

var bodyParser = require('body-parser');
app.use(bodyParser.json());
app.use(bodyParser.urlencoded());
var xss = require('xss-filters'); // For escaping in HTML content

app.get('/user-fixed/:user', function(req, res) {
  var uname = req.params.user;
  changeProfile(uname, req.body);

  res.send('<p>Profile updated, user ' + xss.inHTMLData(uname) + '</p>'); // FIXED
});]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet,http://cwe.mitre.org/data/definitions/79.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWE:80,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.4,WASC:08]]></security>
    </normatives>
    <properties>
      <property name="sources" value="external_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.DenialOfService" message="DenialOfService: An attacker could cause the program becomes unavailable to legitimate users" class="com.als.js.rules.DenialOfService" technology="JAVASCRIPT" active="true">
    <description><![CDATA[By flooding the application with requests, malicious users could deny service to
legitimate users, but these attacks can often be defused at the network layer.

Other bugs are more problematic that allow an user to specify the amount of resources and time to use these resources
for their requests. Thus it could overload the application with a small number of requests.

This rule reports violation when the amount and the time to use these resources is being specified into the request.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Other</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding the application overload by an user improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// VIOLATION, the user can specify the size of the file system to be used.
var fsync = requestFileSystemSync(0, userInput);

function oninit(fs) {
  fs.root.getFile('applog.txt', {create: false}, function(fileEntry) {
    fileEntry.createWriter(function(fileWriter) {
      fileWriter.seek(fileWriter.length);
      var bb = new BlobBuilder();
      bb.append('Appending to a file');
      fileWriter.write(bb.getBlob('text/plain'));
    }, errorHandler);
  }, errorHandler);
}

// VIOLATION, can be written again and again in the file until it is deemed closed by the user agent.
window.requestFileSystem(window.TEMPORARY, 1024*1024, oninit, errorHandler);]]></example>
    <repair><![CDATA[Avoid users from modifying the amount and the time to use of the resources.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/730.html,http://projects.webappsec.org/w/page/13246921/Denial%20of%20Service]]></reference>
    <normatives>
      <security><![CDATA[CWE:730,OWASP:2004:A9,PCI-DSS:6.5.9,WASC:10]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.DoSRegexp" message="DoSRegexp: Potential denial-of-service attack through malicious regular expression (ReDoS)" class="com.optimyth.qaking.rules.javascript.security.DoSRegexp" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.1.1,CWEScope:Access-Control,ReDoS,denial-of-service]]></tags>
    <description><![CDATA[Regular expressions are a formal language for identifying strings of text, parsing, and matching them.

Most regular expressions engines are built over a non-deterministic Finite Automaton (NFA). They use backtracking and,
while these regular expression engines can quickly confirm a positive match, confirming a negative match can take much more longer.

There are lots of well-known regular expression patterns that, using selected inputs, take a time exponentially related to input size.

An attacker with total or partial control over a regular expression may carry out a denial-of-service (DoS) attack.
In certain server-side frameworks like Node.js, the event loop could be blocked, and the app will be unresponsive.

The rule checks wether (1) the regular expression is build using untrusted input (in that case, an attacker may
inyect a malicious pattern and force a DoS condition when applied to crafted strings), or (2) the coded regular expression
contains a structure that may lead to catastrophic backtracking and a DoS condition.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent denial of service attacks due to regular expressions.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Regular expressions are common for white-list validations, for better security...
// but developers must understand Regex DoS, what catastrophic backtracking is,
// and how to write safe regex, or the security check may inject DoS vulnerabilities.

validateEmailFormat = function( email ) {
  // VIOLATION, an invalid email like 'a@b.cccccccccccccccccccccccccccccccccccccccccccccccc{'
  // will keep a CPU running during an inordinate long time.
  var emailExpression = /^(?=[A-Z])[A-Z0-9_\-\.]+@([A-Z0-9_\-]+\.)+[A-Z]{2,4}$/i;
  return emailExpression.test( email );
}

function passwordContainsUsername() {
  var email = document.forms['login']['email'].value;
  var uname = email.split('@')[0];
  // VIOLATION, attacker may influence both pattern and input string, ReDoS is trivial
  var pattern = new RegExp('.*' + uname + '.*', 'i');
  var pass = document.forms['login']['password'].value;
  return pattern.test(pass);
}]]></example>
    <repair><![CDATA[// Rewrite pattern to avoid dangerous backtracking: possessive quantifiers, atomic groups and lookahead
// instead of nested groups with greedy quantifiers.

// Dangerous ([A-Z0-9_\-]+\.)+ could be replaced with ([A-Z0-9_\-]+\.)++ (possessive quantifier, no backtracking).
// A possesive quantifier like a++ could be replaced by atomic group (?>a+), and atomic group (?>a+) could be emulated
// with lookahead + backreference (?=(a+))\1.
// JavaScript regex engine does not support possessive quantifiers nor atomic groups, but it does support lookahead
// and backreferences. Such substitution was applied here.

validateEmailFormat = function( email ) {
  // FIXED
  var emailExpression = /^(?=[A-Z])[A-Z0-9_\-\.]+@(?=(([A-Z0-9_\-]+\.)+))\1[A-Z]{2,4}$/i;
  return emailExpression.test( email );
}

function passwordContainsUsername() {
  var email = document.forms['login']['email'].value;
  var uname = email.split('@')[0];
  var pass = document.forms['login']['password'].value;
  // FIXED
  return pass.toLowerCase().indexOf(uname.toLowerCase()) != -1;
}]]></repair>
    <reference><![CDATA[https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS,http://www.regular-expressions.info/catastrophic.html,https://snyk.io/blog/redos-and-catastrophic-backtracking/,https://cwe.mitre.org/data/definitions/400.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:400,CWETOP25:2021:27,OWASP:2004:A9]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.EasyToGuestDatabaseName" message="EasyToGuestDatabaseName: Do not use easy-to-guess Web SQL database name" class="com.als.js.rules.EasyToGuestDatabaseName" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.3.1,ASVS-v4.0.2:2.6.2,ASVS-v4.0.2:2.9.2,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[An attacker could steal sensitive data, if the names of the databases is easy to guess.

A remediation for this could be including the user name into the database name, or other random unique value.

This rule reports violation when the database name is not unique for each user or when it is easy to guess.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding the access to private data improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024); //VIOLATION]]></example>
    <repair><![CDATA[//Use an identifier of the database that is generated dynamically, or that depend on the user
var db = openDatabase('mydb' + userId, '1.0', 'Test DB', 2 * 1024 * 1024);]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/330.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:330,OWASP-M:2017:M2,OWASP:2021:A2,PCI-DSS:6.5.8,WASC:34]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.EmptyOrHardcodedPassword" message="EmptyOrHardcodedPassword: Empty or hardcoded passwords may compromise system security in a way that cannot be easily remedied" class="com.als.js.rules.EmptyOrHardcodedPassword" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.10.4,ASVS-v4.0.2:3.5.2,ASVS-v4.0.2:6.4.1,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[It is never a good idea to have an empty password or to hardcode a password.

Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the
problem extremely difficult. Once the code is in production, the password cannot be changed without patching the
software. If the account protected by the password is compromised, the owners of the system will be forced to choose
between security and availability.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid credential leakage, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// The following code uses a hardcoded password to connect to an application and retrieve addressbook entries:
...
var obj = new XMLHttpRequest();
obj.open('GET','/fetchusers.jsp?id='+form.id.value,'true','scott','tiger');   // VIOLATION
...
// This code will run successfully, but anyone who accesses the containing web page will be able to view the password.

// The following code has an empty password to connect to an application and retrieve addressbook entries:
...
obj = new XMLHttpRequest();
obj.open('GET','/fetchusers.jsp?id='+form.id.value,'true','scott','');        // VIOLATION
...
// This code will run successfully, but anyone can access when they know the username.]]></example>
    <repair><![CDATA[...
obj = new XMLHttpRequest();
obj.open('GET','/fetchusers.jsp?id='+form.id.value,'true', userName, password);   // OK
...]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/259.html,http://projects.webappsec.org/Insufficient-Authentication,http://cwe.mitre.org/data/definitions/798.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:259,CWE:798,CWETOP25:2021:16,OWASP-M:2016:M2,OWASP:2021:A7,PCI-DSS:6.5.8,WASC:01]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ESTILO.NeverUseHistory" message="NeverUseHistory: Never use JavaScript 'history' object or navigation-based positioning functions" class="com.als.js.rules.NeverUseHistory" technology="JAVASCRIPT" active="true">
    <description><![CDATA[This rule identifies any use of 'history' object or navigation-based positioning functions.
Using 'history' (window.history, self.history) or navigation-based positioning functions (window.back(), window.forward())
is a bad practice for different reasons:

* POST: If a visited page was generated with POST, browser will emit a warning if the submitted data is not encoded in the URL.
* PRIVACY: No application should know which pages a user visited (browsers will emit a security alert and block access).
* POOR NAVIGATION LOGIC: The exact page sequence taken by users may not match programmer expectations.

For such reasons, it is much better to place the user in the exact URL (using location), and let user to play with browser
navigation buttons if he needs to.]]></description>
    <priority>4</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Use of 'history' object can lead to navigation errors and goes against user privacy.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// VIOLATION, back in history
window.back();
// VIOLATION
self.history.go(-1);]]></example>
    <repair><![CDATA[// OK, not using navigation history
window.location.replace(targetUrl);]]></repair>
    <reference><![CDATA[]]></reference>
    <properties>
      <property name="functionNamesOfWindowToCheck" descname="Comma separated list of function names to check for window objects." value="back,forward,go"/>
      <property name="namesOfWindowReferencesToCheck" descname="Comma separated list of window references to check history access or navigation-based positioning function calls." value="window,self,top,parent,opener"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ExternalControlOfConfigurationSetting" message="ExternalControlOfConfigurationSetting: External Control of System or Configuration Setting" class="com.optimyth.qaking.rules.javascript.security.ExternalControlOfConfigurationSetting" technology="JAVASCRIPT" active="true">
    <description><![CDATA[One or more system settings or configuration elements can be externally controlled by a user.

Allowing external control of system settings can disrupt service or cause an application to behave in unexpected,
and potentially malicious ways.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const https = require('https');
// environment is untrusted source
const port = Number( process.env.MY_HTTPS_PORT );
// ...
https.createServer(options, (req, res) => {
  // ...
}).listen(port); // VIOLATION]]></example>
    <repair><![CDATA[const https = require('https');
const port = loadTrustedConf().sslPort; // FIXED
// ...
https.createServer(options, (req, res) => {
  // ...
}).listen(port);]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/15.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:15,PCI-DSS:6.5.6]]></security>
    </normatives>
    <properties>
      <property name="sources" descname="Comma-separated list of input kinds considered untrusted for configuration properties (external_input, database_input...)" value="external_input"/>
      <property name="allowed_source_resources" descname="Comma-separated list of source resources allowed (os, environment, filesystem...). Do not allow web or network as trusted sources." value="os,filesystem"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.HardcodedCryptoKey" message="HardcodedCryptoKey: Hardcoded cryptographic keys" class="com.optimyth.qaking.rules.javascript.security.HardcodedCryptoKey" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,crypto,essential]]></tags>
    <description><![CDATA[Never hard-code cryptographic keys (or passwords used to generate them) in your program.

Crypto keys are used for encryption/decryption, for generation of message authentication codes (MAC), during generation
of password-based encryption keys (the password is the "crypto key" that generates key material for the cipher), and other usages.
Source code is the worst place for key storage, as any change in keys needs recompilation, and it is easy to reverse-engineer
an application binary to learn any keys or secrets that may be embedded in it.

Instead, store crypto keys in some private location. For non-critical web applications, a file with proper permissions,
out of the resources served by the web application, could be enough for storing cryptographic keys.
A crypto key should not be stored in configuration files, in general.

Some data used in cryptographic operations (like initial vector for block ciphers, salt for password hashes, etc.)
are not "private", and it is recommended to generate a good random instance at the origin, and add it to the message
in plaintext, so the destination may use it. The security depends on properly protecting the "secret" thing
(private key in a public/private keypair, encryption key in a symmetric cipher, key in an HMAC, etc.).

Long-term cryptographic keys (in contrast with ephemeral ones), are better stored in a safe key storage.
Private keys in a public/private keypair should NEVER be unprotected (in raw form) and they should be stored in an even
safer key storage (the impact for a compromise of a private key is typically huge and brutal). For highly sensitive keys,
a hardware security module, where the key is generated by the hardware and the private/symmetric key never leaves the
hardware is a good alternative.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const crypto = require('crypto');
// Symmetric encryption
const encryptionKey = "hardcoded_key_01234";
const algorithm = 'aes-256-ctr';
const cipher = crypto.createCipher(algorithm, encryptionKey); // VIOLATION, hardcoded key
let encrypted = cipher.update('secret secret secret', 'utf8', 'base64');
encrypted += cipher.final('base64');

// HMAC also uses key
const hmacKey = "another_hardcoded_key";
const hash =
  crypto.createHmac('sha256', hmacKey) // VIOLATION
        .update(messageShouldNotBeModified)
        .digest('base64');]]></example>
    <repair><![CDATA[const crypto = require('crypto');
// Symmetric encryption
const encryptionKey = loadCipherKeyFromSafeStorage(); // FIXED
const algorithm = 'aes-256-ctr';
const cipher = crypto.createCipher(algorithm, encryptionKey);
let encrypted = cipher.update('secret secret secret', 'utf8', 'base64');
encrypted += cipher.final('base64');

// HMAC also uses key
const hmacKey = loadHmacKeyFromSafeStorage(); // FIXED
const hash =
  crypto.createHmac('sha256', hmacKey)
        .update(messageShouldNotBeModified)
        .digest('base64');]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/321.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:321,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.3.1,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.HeaderManipulation" message="HeaderManipulation: Unvalidated data in HTTP response header or in cookies ('HTTP Response Splitting')" class="com.optimyth.qaking.rules.tainting.HeaderManipulation" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Integrity]]></tags>
    <description><![CDATA[Including unvalidated data in Cookies can lead to HTTP Response header manipulation and
enable:
  - cache-poisoning
  - cross-site scripting
  - cross-user defacement
  - page hijacking
  - cookie manipulation
  - open redirect

Header Manipulation vulnerabilities occur when:
  - Data enters a web application through an untrusted source, most frequently an HTTP request.
  - The data is included in an HTTP response header sent to a web user without being validated.

Using this vulnerability, an attacker can pass malicious data to a vulnerable application and the application can
include the data into an HTTP response header.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Performing the input data validation improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[//Cookie
author = document.forms[0].author.value;
document.cookie = "author=" + author + ";expires=" + cookieExpiration; // VIOLATION

// Header
xhr.setRequestHeader("custom_header", value); //VIOLATION]]></example>
    <repair><![CDATA[author = document.forms[0].author.value;

// Use validation of inputs parameters. "validateAndReturn" function has been specified as a valid neutralization
// function into the rule metadata.
document.cookie = "author=" + validateAndReturn(author) + ";expires=" + validateAndReturn(cookieExpiration);

xhr.setRequestHeader("custom_header", validateAndReturn(value));]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/133.html,http://projects.webappsec.org/w/page/13246931/HTTP%20Response%20Splitting]]></reference>
    <normatives>
      <security><![CDATA[CWE:113,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:25]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.HidePoweredByHeader" message="HidePoweredByHeader: Deactivate X-Powered-By header" class="com.optimyth.qaking.rules.javascript.security.HidePoweredByHeader" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Node.js,global]]></tags>
    <description><![CDATA[Application frameworks under Node.js set an X-Powered-By HTTP header for documenting which framework and, optionally, which version.
An attacker may gain valuable information for fingerprinting the underlying framework and mount a targeted attack.
To avoid that, the X-Powered-By header should be deactivated.

The rule will check if server-side JavaScript code will either remove the X-Powered-By header or set a deceiving value,
either directly or using a security middleware like helmet.]]></description>
    <priority>4</priority>
    <effort>1</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var express = require('express')
var app = express() // VIOLATION

app.get('/', function (req, res) {
  res.send('Hello World!')
})

app.listen(3000, function () {
  console.log('Example app listening on port 3000!')
})]]></example>
    <repair><![CDATA[// Remove the header
app.disable('x-powered-by')

// Alternatively, use helmet (or koa-helmet when under Koa)
var helmet = require('helmet');
// you may set all default header-based protections with app.use(helmet()),
// which includes removing X-Powered-By; or add it specifically:
app.use(helmet.hidePoweredBy());]]></repair>
    <reference><![CDATA[https://blog.risingstack.com/node-js-security-checklist/,https://www.veracode.com/blog/2014/03/guidelines-for-setting-security-headers,https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Headers]]></reference>
    <normatives>
      <security><![CDATA[CWE:526,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:45]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.HijackingAdHocAjax" message="HijackingAdHocAjax: Do not use JavaScript to transport sensitive data" class="com.als.js.rules.HijackingAdHocAjax" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control]]></tags>
    <description><![CDATA[Use JavaScript to transport sensitive data could enable a malicious user to read sensitive
data.
        
The problems occur when JavaScript hijacking is used to transport sensitive data.

JavaScript hijacking allows an attacker to bypass the Same Origin Policy (SOP) required by web browsers to
protect users from malicious websites.

This rule reports violation when javascript code generated dynamically through Ajax requests is executed.
Avoid using JSON arrays for data transmission.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoiding to execute JS code from AJAX requests improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var object;
var req = new XMLHttpRequest();
req.open("GET", "/object.json",true);
req.onreadystatechange = function () {
  if (req.readyState == 4) {
    var txt = req.responseText;
    object = eval("(" + txt + ")"); // VIOLATION
    req = null;
  }
};
req.send(null);]]></example>
    <repair><![CDATA[//Avoid executing javascript generated dynamically through Ajax requests]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/501.html,http://haacked.com/archive/2009/06/25/json-hijacking.aspx/,http://projects.webappsec.org/w/page/13246936/Information%20Leakage,https://www.owasp.org/index.php/AJAX_Security_Cheat_Sheet#Protect_against_JSON_Hijacking_for_Older_Browsers]]></reference>
    <normatives>
      <security><![CDATA[CWE:501,OWASP-M:2016:M2,OWASP:2021:A2,WASC:13]]></security>
    </normatives>
    <properties>
      <property name="properties" descname="Properties of javascript objects separated by commas that check." value="responseText"/>
      <property name="functions" descname="Comma-separated list of Javascript functions that must be checked." value="eval"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.HttpParameterPollution" message="HttpParameterPollution: HTTP parameter pollution (HPP)" class="com.optimyth.qaking.rules.javascript.security.HttpParameterPollution" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.1,CWEScope:Integrity,Framework:Node.js,http-parameter-pollution]]></tags>
    <description><![CDATA[Concatenating untrusted input into path, query string, or parameters for HTTP message (in the URL or in the request body)
may allow an attacker to override/add unexpected request parameters.

An attacker may change the intended HTTP request semantics, and may give him/her access to unauthorized data or bypass web application
firewall validations. In addition, denial-of-service conditions may be provoked due to type mismatch errors not caught by
the application framework.

Such attacks are known as HTTP Parameter Pollution, or HPP.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unexpected behaviour for HTTP parameter pollution attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var express = require('express');
var app = express(); // VIOLATION, no HPP protection enforced
app.use(bodyParser.urlencoded()); // Make sure the body is parsed beforehand.
// Application logic...
app.get('/search', function (req, res, next) { /* ... */ });]]></example>
    <repair><![CDATA[var express = require('express');
var app = express();
// Make sure the body is parsed before hpp middleware.
app.use(bodyParser.urlencoded());

var hpp = require('hpp');
app.use(hpp()); // FIXED

// Application logic...
app.get('/search', function (req, res, next) { /* ... */ });
// They are safe from HTTP Parameter Pollution now]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/235.html,https://speakerdeck.com/ckarande/top-overlooked-security-threats-to-node-dot-js-web-applications?slide=48,https://github.com/analog-nico/hpp]]></reference>
    <normatives>
      <security><![CDATA[CWE:235,OWASP:2021:A3,PCI-DSS:6.5.6,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ImproperCertificateValidation" message="ImproperCertificateValidation: Improper Certificate Validation" class="com.optimyth.qaking.rules.javascript.security.ImproperCertificateValidation" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.9.2,ASVS-v4.0.2:9.2.1,CWEScope:Authentication,CWEScope:Integrity,Framework:Node.js]]></tags>
    <description><![CDATA[The software does not validate, or incorrectly validates, a digital certificate.

Typically in server-side JavaScript, when connecting to TLS/SSL peers, the connection has to be configured
at least to reject invalid certificates. Depending on the function used, the default may be unsafe, or the
developer may explicitly deactivate certificate validation.

When the certificate is invalid or malicious, an attacker may spoof a trusted entity by using a main-in-the-middle attack.
The software may connect to a malicious host while believing it is a trusted host.

Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.
Note: This rule does not check specific cases like revocation checks, or proper matching between host and the certificate subject.

The rule checks SSL/TLS configuration, and looks for an unsafe configuration allowing invalid connections to proceed.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const https = require('https');

const clientOptions = {
  host: 'www.bankrus.com',
  port: 443,
  // additional properties
  rejectUnauthorized: false // unsafe
};

https.get(clientOptions, (res) => {  // VIOLATION
  // ...
});]]></example>
    <repair><![CDATA[const https = require('https');

const clientOptions = {
  host: 'www.bankrus.com',
  port: 443,
  // additional properties
  rejectUnauthorized: true // FIXED, this is the default
};

https.get(clientOptions, (res) => {
  // ...
});]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/295.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:295,CWETOP25:2021:26,OWASP-M:2016:M3,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.InformationExposureThroughErrorMessage" message="InformationExposureThroughErrorMessage: Avoid sensitive information exposure through error messages" class="com.optimyth.qaking.rules.javascript.security.InformationExposureThroughErrorMessage" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.1,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[When an error message is generated, care should be taken to ensure that it does not contain
sensitive information about the environment, users or any other information that may be considered sensitive.

Such information may be valuable itself or may be useful for further attacks with a higher impact.

Attention should be paid to information explicitly included into error messages, and also to certain functions
that may produce an error that unexpectedly shows sensitive information.

Rule shows violation when some sensitive error information, or with excessive technical detail, is shown to the application end-user.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid sensitive information leakage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var http = require('http');

http.createServer(function(req, res) {
  var body;
  try {
    body = handleRequest(req);

  } catch (err) {
    res.statusCode = 500;
    res.setHeader("Content-Type", "text/plain");
    res.end(err.stack); // VIOLATION, stack info is too
    return;
  }

  renderOutput(body, res);

}).listen(3000);]]></example>
    <repair><![CDATA[var http = require('http');

http.createServer(function(req, res) {
  var body;
  try {
    body = handleRequest(req);

  } catch (err) {
    res.statusCode = 500;
    res.setHeader("Content-Type", "text/plain");
    res.end("Unexpected error"); // OK, message is neutral
    console.log(err); // logged for internal processing
    return;
  }

  renderOutput(body, res);

}).listen(3000);]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/209.html,http://projects.webappsec.org/w/page/13246936/Information%20Leakage]]></reference>
    <normatives>
      <security><![CDATA[CWE:209,OWASP:2021:A4,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.InsecureRandomness" message="InsecureRandomness: Standard pseudo-random number generators cannot withstand cryptographic attacks" class="com.als.js.rules.InsecureRandomness" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.3.1,ASVS-v4.0.2:2.6.2,ASVS-v4.0.2:2.9.2,ASVS-v4.0.2:6.3.1,ASVS-v4.0.2:6.3.2,ASVS-v4.0.2:6.3.3,CWEScope:Access-Control,CWEScope:Confidentiality,crypto,prng]]></tags>
    <description><![CDATA[Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness
in security-sensitive context.

Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators
(PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.

There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties,
but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use in cases
where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating
output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly
improbable for an attacker to distinguish between it and a truly random value. In general, if a PRNG algorithm is not
advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in
security-sensitive contexts, where its use can lead to serious vulnerabilities such as easy-to-guess temporary passwords,
predictable cryptographic keys, session hijacking, and DNS spoofing.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Using non predictable keys improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[The following code uses a statistical PRNG to create a URL for a receipt that remains active for some period of time after a purchase.

function genReceiptURL (baseURL){
  var randNum = Math.random();
  var receiptURL = baseURL + randNum + ".html";
  return receiptURL;
}

Uses Math.random() to generate "unique" identifiers for the receipt pages it generates.
Because Math.random() is a statistical PRNG, an attacker may guess the strings it generates.
Although the design of the receipt system is also faulty, it would be more secure with a PRNG
that did not produce predictable receipt identifiers, such as a cryptographic PRNG.]]></example>
    <repair><![CDATA[// Do no use Pseudo-Random Number Generators like Math.random().]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/338.html,http://cwe.mitre.org/data/definitions/330.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:330,CWE:338,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="pattern" descname="Regular expression for detecting when a non-cryptographic PRNG is used in a security context.
When blank, any non-cryptographic PRNG usage is reported as a rule violation." value="password|passwd|receipt|session|user|key|csrf|token|hash|mac|digest|uuid|guid|crypto|encrypt|decrypt"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.InsecureTransport" message="InsecureTransport: Insecure transport" class="com.optimyth.qaking.rules.javascript.security.InsecureTransport" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.1.1,ASVS-v4.0.2:6.1.2,ASVS-v4.0.2:6.1.3,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[An insecure transport is used in a request for a remote resource.

In JavaScript software, this rule requires that all requests for a remote HTTP resource are performed
on a secure transport (SSL/TLS).

Request content over an insecure transport is cleartext, and any sensitive information it contains may be eavesdropped.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[]]></example>
    <repair><![CDATA[]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/319.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:319,CWETOP25:2021:35,OWASP:2021:A2,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="checkFtpConn" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.InsuficientKeySize" message="InsuficientKeySize: An otherwise strong encryption algorithm is vulnerable to brute force attack when a small key size is used" class="com.als.js.rules.InsuficientKeySize" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.8.3,ASVS-v4.0.2:6.2.3,ASVS-v4.0.2:6.2.4,ASVS-v4.0.2:6.2.5,ASVS-v4.0.2:6.2.6,ASVS-v4.0.2:6.2.7,ASVS-v4.0.2:9.1.2,ASVS-v4.0.2:9.1.3,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Current cryptography guidelines suggest that key lengths of at least 1024 bits should be
used with the RSA algorithm.

However, increased computing power and advances in factoring techniques are challenging the security of 1024 bit RSA
encryption.

When it comes to symmetric encryption, the key lengths should be at least 128 bits.

This rule reports violation when the key size is lower than a customizable parameter, by default 128 bits.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Improve security, by avoiding not allowed access to sensible data or information.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[crmfObject = crypto.generateCRMFRequest("CN=" + name.value,
password.value,
authenticator,
keyTransportCert,
"setCRMFRequest();",
56, null, "rsa-dual-use");    // VIOLATION]]></example>
    <repair><![CDATA[crmfObject = crypto.generateCRMFRequest("CN=" + name.value,
password.value,
authenticator,
keyTransportCert,
"setCRMFRequest();",
128, null, "rsa-dual-use");   // OK]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/326.html,https://www.owasp.org/index.php/Guide_to_Cryptography#Cryptographic_Algorithms]]></reference>
    <normatives>
      <security><![CDATA[CWE:326,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.8,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="minKeySize" descname="Min value for key size." value="128"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.JSX.AutocompleteOnForSensitiveFields" message="AutocompleteOnForSensitiveFields: Autocomplete enabled for sensitive form fields" class="com.optimyth.qaking.rules.HtmlRuleWrapper" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:8.2.1,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[By default, browsers remember information that users submit through form input fields. This enables the browser to offer
autocomplete (suggesting possible completions for fields that the user starts typing in) or autofill (pre-populate
certain fields upon load).

Autocomplete/autofill could be a privacy concern for users. Browsers could be configured to disable autocomplete,
but it is typically enabled by default. Past values for some fields are either not useful (like a one-time pin),
or contain sensitive/private information (government identifier, credit card security code, or simply a password).
Forms in a web application should be configured to avoid remembering past values for some sensitive fields (or all fields in
a critical form), even if the browser's autocomplete feature is disabled.

That strategy limits information leakages, when a browser shows past submitted values for another person (in a shared device).
This rule will report any sensitive field (password, or fields with a name/id matching a configurable pattern).

Rule checks input fields into form tags but and also input fields outside from a form tag but specifying a form into their
form attribute.]]></description>
    <priority>3</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid information leakage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<form method="post" action="/form" id="form1">
  <div>
    <input type="password" id="auth" name="auth"/><!-- VIOLATION -->
    <input type="text" id="creditCard" name="creditCard"/><!-- VIOLATION -->
  </div>
</form>

<input type="password" id="input3" name="auth" form="form1"/><!-- VIOLATION -->]]></example>
    <repair><![CDATA[<form method="post" action="/form" id="form1" autocomplete="off">
  <div>
    <input type="password" id="auth" name="auth"/>
    <input type="text" id="creditCard" name="creditCard"/>
  </div>
</form>

<input type="password" id="input3" name="auth" form="form1"/>

Alternatively, disable autocomplete for sensitive fields only:

<form method="post" action="/form" autocomplete="on">
  <div>
    <input type="password" id="auth" name="auth" autocomplete="off"/>
    <input type="text" id="creditCard" name="creditCard" autocomplete="off"/>
  </div>
</form>

<input type="password" id="input3" name="auth" form="form1" autocomplete="off"/>]]></repair>
    <reference><![CDATA[https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion]]></reference>
    <normatives>
      <security><![CDATA[CWE:525,OWASP:2021:A4,PCI-DSS:3.2,WASC:13]]></security>
    </normatives>
    <properties>
      <property name="wrapped" value="com.optimyth.html.rules.html5.security.AutocompleteOnForSensitiveFields"/>
      <property name="acceptBrowserPasswordManagers" descname="If true, accept autocomplete behaviour for password fields, when it is assumed that browser password managers are safer than memorized passwords." value="false"/>
      <property name="sensitiveFieldsPattern" descname="Regular expression for detecting, by name, potentially sensitive fields." value="password|pass|username|user_name|creditcard|credit_card|cardnum|card_num"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.JSX.MissingPasswordFieldMasking" message="MissingPasswordFieldMasking: Password input field is not masked" class="com.optimyth.qaking.rules.HtmlRuleWrapper" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control,infoleak,privacy]]></tags>
    <description><![CDATA[When a form contains a password input field, the type attribute must be set to "password". Otherwise an attacker
directly or indirectly watching the user might capture it.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<form id="login">
  Username: <input name="user_name" type="text"/>
  <!-- VIOLATION -->
  Password: <input name="user_password" type="text"/>
</form>]]></example>
    <repair><![CDATA[<!-- FIXED -->
<form id="login">
  Username: <input name="user_name" type="text"/>
  Password: <input name="user_password" type="password"/>
</form>]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/549.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:549]]></security>
    </normatives>
    <properties>
      <property name="wrapped" value="com.optimyth.html.rules.html5.security.MissingPasswordFieldMasking"/>
      <property name="pattern" descname="Pattern to use. If blank, the default pattern is used." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.JSX.SandboxAllowScriptsAndSameOrigin" message="SandboxAllowScriptsAndSameOrigin: Unsafe sandbox with allow-scripts and allow-same-origin" class="com.optimyth.qaking.rules.HtmlRuleWrapper" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.6,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[In HTML5, iframe content could be sandboxed, and the developer may give the capabilities it requires
(a whitelist of capabilities that the framed content needs, specified in the iframe's sandbox attribute).
If you need to include external content in your application, sandboxing is an excelent measure (when properly set).
For example, plugins are blocked in sandbox, and that restriction cannot be lifted.

As the framed content needs certain capabilities enabled to be useful, developers must exercise due care
when choosing which sandbox restrictions to be lifted, and that the lifted restrictions are really the minimum
needed by the framed content ('principle of least-privilege').

Setting both the allow-scripts and allow-same-origin keywords together, when the embedded page
has the same origin as the page containing the iframe, allows the embedded page to simply remove
the sandbox attribute and then reload itself, effectively breaking out of the sandbox altogether.

Remember, allow-same-origin typically permits the sandboxed content to access its own DOM and originating site
(typical same-origin policy). But if the content origin is the same as your application's, and you add the
allow-scripts permission, an attacker may remove sandbox attribute and reload the content.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- VIOLATION, uploaded content may include JavaScript which is allowed to remove the sandbox attribute -->
<iframe id = 'sandboxed' sandbox = 'allow-scripts allow-same-origin' src = 'uploads/evil.html'></iframe>]]></example>
    <repair><![CDATA[<!-- option #1: place untrusted content in another domain -->
<iframe id = 'sandboxed' sandbox = 'allow-scripts allow-same-origin' src = 'https://uploads.my.org/evil.html'></iframe>

<!-- option #2: remove one of the problematic capabilities -->
<iframe id = 'sandboxed' sandbox = 'allow-scripts' src = 'uploads/evil.html'></iframe>]]></repair>
    <reference><![CDATA[https://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/,https://html.spec.whatwg.org/multipage/embedded-content.html#the-iframe-element]]></reference>
    <normatives>
      <security><![CDATA[CWE:830,OWASP:2021:A8]]></security>
    </normatives>
    <properties>
      <property name="wrapped" value="com.optimyth.html.rules.html5.security.SandboxAllowScriptsAndSameOrigin"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.JSX.TargetBlankVulnerability" message="TargetBlankVulnerability: Improper Neutralization of links to external sites" class="com.optimyth.qaking.rules.HtmlRuleWrapper" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[When an user clicks a link to an external site, and that link has the target="_blank" attribute,
then the new site will be opened into a new tab or window, but will share its process with the original tab or window.

The window.opener object stores information from the original window, so if a malicious attacker achieves to run code into
the target site then he/she might read or modify the properties included into the window.opener object, even when the
original and the target sites have different origin.

After that, the attacker might change the original windows for a malicious copy of it, where the user can be tricked
to login, or to input his/her bank account information or some other sensitive information.]]></description>
    <priority>2</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid malicious redirections to sites controlled by the attacker]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<a href="http://attacker-site.example.com/useful-page.html" target="_blank">    <!-- VIOLATION -->]]></example>
    <repair><![CDATA[<a href="http://attacker-site.example.com/useful-page.html" target="_blank" rel="noopener noreferrer">]]></repair>
    <reference><![CDATA[https://dev.to/ben/the-targetblank-vulnerability-by-example,https://owasp.org/www-community/attacks/Reverse_Tabnabbing,https://cwe.mitre.org/data/definitions/1022.html,https://mathiasbynens.github.io/rel-noopener/]]></reference>
    <normatives>
      <security><![CDATA[CWE:1022,OWASP:2021:A5]]></security>
    </normatives>
    <properties>
      <property name="wrapped" value="com.optimyth.html.rules.html5.security.TargetBlankVulnerability"/>
      <property name="allowedHref" descname="Separated comma list of allowed href values which, when used, exclude that element from
            being reported" value="#,javascript:void(0);"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.LdapInjection" message="LdapInjection: Avoid non-neutralized user-controlled input in LDAP search filters" class="com.optimyth.qaking.rules.tainting.LdapInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.7,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software constructs all or part of an LDAP query using externally-influenced input, but it does not neutralize or
incorrectly neutralizes special elements that could modify the intended LDAP query when sent to LDAP server.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const express = require("express")
const app = express()
app.use(require('body-parser').urlencoded({extended: true}))
app.use(require('body-parser').json())

const LDAP = require('ldap-client');
var ldap = new LDAP({
    uri:             'ldap://server',   // string
    validatecert:    false,             // Verify server certificate
    connecttimeout:  -1,                // seconds, default is -1 (infinite timeout), connect timeout
    base:            'dc=com',          // default base for all future searches
    attrs:           '*',               // default attribute list for future searches
    filter:          '(objectClass=*)', // default filter for all future searches
    scope:           LDAP.SUBTREE      // default scope for all future searches
}, function(err) {
    // connected and ready
});

app.post('/user', function (req, res) {
  var username = req.body.username;
  ldap.search({ // VIOLATION
    filter: '(&(objectClass=posixUser)(cn='+username+'))',
    scope: LDAP.SUBTREE
  }, function(err, data) {
    // ...
  });
});]]></example>
    <repair><![CDATA[// Neutralize external input (e.g. username) before usage in LDAP query
app.post('/user', function (req, res) {
  var username = LDAP.stringEscapeFilter( req.body.username );
  ldap.search({
    filter: '(&(objectClass=posixUser)(cn='+username+'))',
    scope: LDAP.SUBTREE
  }, function (err, data) {
    // ...
  });
});]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/90.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:90,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:29]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.MailCommandInjection" message="MailCommandInjection: Mail Command Injection" class="com.optimyth.qaking.rules.tainting.MailCommandInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Integrity]]></tags>
    <description><![CDATA[Mail command injection vulnerabilities occur when an attacker can influence the commands sent to an SMTP, POP3, or IMAP mail server.
If the library or the developer fails to safely encode the line breaks, an attacker controlling any of the arguments for these commands
will be able to inject line breaks and new commands after them.

As line breaks are the usual mechanism that attackers use to change the expected behaviour, this vulnerability
is considered a special CRLF Injection attack.

What the attacker may launch by exploting a Mail Command Injection vulnerability include:
- Generate spam (SMTP). The application acts as a "mail proxy" that attackers may use to create spam messages.
- Read messages from other users (POP3/IMAP).
- Abusing a trusted server to send HTML emails with malicious contents.
- Change authentication or security options, to skip security controls in mail servers.

See "MX Injection: Capturing and Exploiting Hidden Mail Servers", from Vicente Aguilera, for a full description on
the benefits that an attacker may gain.

The rule checks when vulnerable mail libraries are called with untrusted input, without validation, which might be vulnerable
to Mail Command Injection attacks.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid Mail Command Injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const express = require("express")
const app = express()
app.use(require('body-parser').urlencoded({extended: true}))
app.use(require('body-parser').json())

const mail = require('mail')
var mailer = mail.Mail({
  host: 'smtp.gmail.com',
  secure: true,
  username: getUsername(),
  password: getPassword()
})

app.post('/mailTo', function (req, res) {
  var from = getFrom(),
      to = req.body.to,
      subject = req.body.subject,
      text = req.body.text

  mailer.message({from: from, to: to, subject: subject}) // VIOLATION
      .body(text)
      .send(function(err) { /*...*/ })
});]]></example>
    <repair><![CDATA[// validate untrusted subject input with a white-list strategy,
// or at least ensure that line breaks (CR/LF) are removed from subject.

app.post('/mailTo/neutralized', function (req, res) {
    var crlf = /[\r\n]/g;
    var from = getFrom(),
        to = req.body.to,
        subject = req.body.subject,
        text = req.body.text

    // remove CR/LF from vulnerabled headers (typically, all except message body)
    to = to.replace(crlf, '')
    subject = subject.replace(crlf, '')

    mailer.message({from: from, to: to, subject: subject}) // FIXED
        .body(text)
        .send(function(err) { /*...*/ })
});]]></repair>
    <reference><![CDATA[OWASP Testing for IMAP/SMTP injection: https://www.owasp.org/index.php/Testing_for_IMAP/SMTP_Injection_(OTG-INPVAL-011),http://www.webappsec.org/projects/articles/121106.pdf,http://projects.webappsec.org/w/page/13246948/Mail%20Command%20Injection]]></reference>
    <normatives>
      <security><![CDATA[CWE:93,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:30]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.NoSQLInjection" message="NoSQLInjection: Improper neutralization of special elements in data query logic (NoSQL injection)" class="com.optimyth.qaking.rules.javascript.security.NoSQLInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Node.js,NoSQL]]></tags>
    <description><![CDATA[The application generates a query intended to access or manipulate data in a data store such as a NoSQL database,
but it does not neutralize or incorrectly neutralizes special elements that can modify the intended logic of the query.

Depending on the capabilities of the query language, an attacker could inject additional login into the query to:
- Modify the intended selection criteria, thus changing which data entities (e.g., records) are returned, modified, or otherwise manipulated.
- Append additional commands to the query.
- Return more or fewer entities than intended.
- Cause entities to be sorted in an unexpected way.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const express = require("express")
const app = express()
app.use(require('body-parser').urlencoded({extended: true}))
app.use(require('body-parser').json())

const dbUrl = "mongodb://localhost:27017/mydb"
const MongoClient = require("mongodb").MongoClient; // Driver for connecting to MongoDB

app.post('/user', function (req, res) {
  MongoClient.connect(dbUrl, function (err, db) {
    var query = {
      username: req.body.username, // user-controlled input
      password: req.body.password  // user-controlled input
    }

    // VIOLATION, a body like {"username": {"$gt": ""}, "password": {"$gt": ""}} change the query semantics
    db.collection('users').findOne(query, function (err, user) {
      console.log(user);
    })
  })
})]]></example>
    <repair><![CDATA[// Same code as in the ok example...
const sanitize = require('mongo-sanitize')

app.post('/user', function (req, res) {
  MongoClient.connect(dbUrl, function (err, db) {
    var query = {
      username: sanitize(req.body.username), // FIXED
      password: sanitize(req.body.password) // FIXED
    }

    db.collection('users').findOne(query, function (err, user) {
      console.log(user);
    })
  })
})]]></repair>
    <reference><![CDATA[https://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html,http://cwe.mitre.org/data/definitions/943.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:943,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.OpenRedirect" message="OpenRedirect: URL Redirection to Untrusted Site ('Open Redirect')" class="com.optimyth.qaking.rules.tainting.OpenRedirect" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.5,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.

Through open redirects, malicious users may mislead other users to visit a URL to a trusted site and redirect them to a
malicious site.

By encoding the URL, a malicious user can make it difficult to realize the target of malicious redirect.

The rule detects a path in code between an input statement (source) and a redirect statement (sink), to an URL depending
on non neutralized input.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limits phishing attacks, and unintended client-side redirections, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var strDest = document.forms[0].dest.value;

window.open(strDest, "myresults"); // VIOLATION

location.href = strDest;     // VIOLATION

location.assign(strDest);    // VIOLATION

location.pathname = strDest; // VIOLATION
document.location = strDest; // VIOLATION]]></example>
    <repair><![CDATA[var strDest = document.forms[0].dest.value;

// Use validation of inputs parameters.
// "validateAndReturn" function has been specified as a valid neutralization
// function into the rule metadata.
window.open(validateAndReturn(strDest), "myresults");

window.open("http://www.otherweb.com", "myresults");

location.href = validateAndReturn(strDest);

location.assign("http://www.otherweb.com");

location.pathname = validateAndReturn(strDest);
document.location = validateAndReturn(strDest);]]></repair>
    <reference><![CDATA[http://projects.webappsec.org/w/page/13246981/URL%20Redirector%20Abuse,http://cwe.mitre.org/data/definitions/601.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:601,CWETOP25:2021:37,OWASP:2013:A10,PCI-DSS:6.5.1,WASC:38]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.OpenRedirectHanaXS" message="OpenRedirectHanaXS: Open Redirect (HANA XS)" class="com.optimyth.qaking.rules.javascript.security.OpenRedirectHanaXS" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.1.5,CWEScope:Access-Control,CWEScope:Confidentiality,Framework:HANA-XS]]></tags>
    <description><![CDATA[Allowing unvalidated input in HANA XS to control the URL used in a redirect ("open redirect") may render phishing attacks possible.

Through open redirects, malicious users may mislead other users to visit a URL to a trusted site and redirect them to a malicious site.

By encoding the URL, a malicious user can make it difficult to realize the target of malicious redirect.

The rule detects a path in code between an input statement (source) and a redirect statement (sink), to an URL depending
on non neutralized input.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limits phishing attacks, and unintended client-side redirections, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var destination = $.request.parameters.get("dest");
$.response.headers.set("location", destination); // VIOLATION]]></example>
    <repair><![CDATA[// FIXED: White-list of allowed redirection targets

var destination = $.request.parameters.get("dest");

switch (destination) {
  case "1": $.response.headers.set("location", "http://FirstWhitelistedURL.com"); break;
  case "2": $.response.headers.set("location", "http://SecondWhitelistedURL.com"); break;
  default:  $.response.headers.set("location", "http://DefaultWhitelistedURL.com");
}]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/601.html,https://help.sap.com/viewer/d89d4595fae647eabc14002c0340a999/2.0.01/en-US/8c5ec75c27f543cb8b4c65c337b285ae.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:601,CWETOP25:2021:37,OWASP:2013:A10,PCI-DSS:6.5.1,WASC:38]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.PasswordInComments" message="PasswordInComments: Avoid hard-coded or in-comment passwords in code" class="com.als.js.rules.PasswordInComments" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Confidentiality]]></tags>
    <description><![CDATA[It is never a good idea to hardcode a password. Storing password details within commentsis equivalent to hardcoding passwords.

Not only does it allow all of the project's developers to view the password, it also makes fixing the problem extremely
difficult.

Once the code is in production, the password is now leaked to the outside world and cannot be protected or changed
without patching the software.

If the account protected by the password is compromised, the owners of the system will be forced to choose between
security and availability.

The rule checks if there are comments in the code that contain expressions that match with the pattern, so it can lead
to several false positives and/or false negatives.]]></description>
    <priority>4</priority>
    <effort>1</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Ensuring that password is kept in secret improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[The following comment specifies the default password to connect to a database:
...
// Default username for database connection is "scott"
// Default password for database connection is "tiger"
...
This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped,
there is no going back from the database user "scott" with a password of "tiger" unless the program is patched.
A devious employee with access to this information can use it to break into the system.]]></example>
    <repair><![CDATA[Do not code password information in the source code.]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/615.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:615,OWASP-M:2016:M4,OWASP:2021:A7,PCI-DSS:6.5.3]]></security>
    </normatives>
    <properties>
      <property name="passwordPattern" descname="Pattern to match possible password codifications in comments." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.PathManipulation" message="PathManipulation: External Control of File Name or Path" class="com.als.js.rules.PathManipulation" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.3.1,ASVS-v4.0.2:12.3.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Allowing external input to control paths used in filesystem operations could enable an attacker to access or modify
unintended files.

When the software concatenates external input in a path used during file operation, an attacker may 'escape' from
the directory reserved for such operations. Depending on which file operations the software performs, the attacker
may read or write arbitrary files, including sensitive application or operating system files, with the permissions
granted to the process running the software.

Attackers may :
- Upload executable code (typically followed by execution).
- Fetch sensitive information from the software or the operating system.
- Modify configuration files for removing security controls and gaining further access.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>File handling</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid path manipulation vulnerabilities, improving security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var express = require('express');
var fs = require('fs');
var path = require('path');
var bodyParser = require('body-parser');

var app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended: true}));

const UPLOAD_DIR = '/var/tmp/upload';
var dir = fs.mkdirSync(UPLOAD_DIR);

app.post('/product/:product', function(req, res) {
  var productName = req.params.product;
  var content = req.body.content;

  var fname = path.join(UPLOAD_DIR, productName);
  // bad!, path traversal, user may choose productName as
  // ../../../path/to/important/file to overwrite any file of interest
  fs.writeFile(fname, content, 'utf-8', (err) => { // VIOLATION
    if(err) return handleError(err, res);
    onSavedProduct({product: productName, content: content, file: fname}, res);
  })
});

app.get('/product/:product', function(req, res) {
  var productName = req.params.product;

  var fname = path.join(UPLOAD_DIR, productName);
  // bad!, path traversal, think about productName = ../../../etc/passwd
  fs.readFile(fname, 'utf-8', (err, data) => { // VIOLATION
    if(err) return handleError(err, res);
    renderProduct({product: productName, content: data, file: fname}, res);
  })
});]]></example>
    <repair><![CDATA[// You may white-list productName to restrict as much as possible what could be used in the path
if(!/[A-Z][A-Z0-9_]*/i.test(productName)) {
  return handleError(new Error('Illegal product name'), res);
}
var fname = path.join(UPLOAD_DIR, productName);

// Alternatively, check if the resulting path is inside the intended directory,
// taking care of properly normalizing paths before check for containment:
function isPathInDirectory(basedir, filepath) {
  var abspath = path.resolve(filepath);
  var absdir = path.resolve(basedir) + path.sep;
  return abspath.substring(0, absdir.length) === absdir;
}

var fname = path.join(UPLOAD_DIR, productName);
if( !isPathInDirectory(basedir, filepath) ) {
  return handleError(new Error('Illegal product name', res));
}]]></repair>
    <reference><![CDATA[http://projects.webappsec.org/Path-Traversal,http://cwe.mitre.org/data/definitions/22.html,http://cwe.mitre.org/data/definitions/73.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:22,CWE:73,CWETOP25:2021:8,OWASP:2021:A4,OWASP:2021:A5,PCI-DSS:6.5.8,WASC:33]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.PERFORMANCE.NoUseOfEval" message="NoUseOfEval: Do not use eval() function, for security and performance reasons" class="com.als.js.rules.NoUseOfEval" technology="JAVASCRIPT" active="true">
    <description><![CDATA[Avoid eval(code). The code must be 'compiled' at every execution, and the optimizations that
JavaScript engines perform on normal JS code are not used.

But the main reason for avoiding eval() is a security issue: If the end-user has control over evaluated code (because the code
is concatenated with user data), this leads to 'script injection' vulnerabilities, which could end in well-known security
attacks like cross-site scripting.

In Ajax apps it's usual to use eval() when converting a JSON-encoded object to JavaScript object, but it's a terrible idea
from a security perspective, unless it's performed with proper checks against potential misuse. A better way to do this
is with JSON.parse()]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[More efficient (and secure) code.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var value = eval("document.forms[" + id + "]['"+ formEl +"'].value");    // VIOLATION]]></example>
    <repair><![CDATA[var value = document.forms[id][formEl].value;]]></repair>
    <reference><![CDATA[]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.PlaintextStorageInACookie" message="PlaintextStorageInACookie: Cleartext Storage of Sensitive Information in a Cookie" class="com.optimyth.qaking.rules.javascript.security.PlaintextStorageInACookie" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Confidentiality]]></tags>
    <description><![CDATA[Sensitive data stored encrypted (or hashed) makes harder to read it than when stored in plaintext.
Cookies holding sensitive information are specially vulnerable, as an attacker could use widely-available tools to view cookie content.

The rule checks whether a cookie with sensitive data is being stored without any kind of cryptographic protection
preserving confidentiality, like hashing or encryption. Cookies with the 'Secure' flag are also allowed.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var express = require('express');

var app = express();
app.get('/', function (req, res) {
    var accountNumber = getAccountNumberForUser(req);
    // Setting a cookie value with cleartext sensitive data.
    res.cookie("AccountNumber", accountNumber); // VIOLATION
});]]></example>
    <repair><![CDATA[var express = require('express');
var crypto = require('crypto'),
    password = getPassword();

var app = express();
app.get('/', function (req, res) {
    var accountNumber = getAccountNumberForUser(req);
    res.cookie("AccountNumber", encrypt(accountNumber)); // FIXED
});

function encrypt(text){
    var cipher = crypto.createCipher('aes-256-ctr', password);
    return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');
}

app.get('/other', function (req, res) {
    var accountNumber = getAccountNumberForUser(req);
    res.cookie("AccountNumber", accountNumber, {secure: true}); // also accepted
});]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/315.html,https://www.owasp.org/index.php/Plaintext_Storage_in_Cookie,https://cwe.mitre.org/data/definitions/312.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:312,CWE:315]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.PreventMIMESniffing" message="PreventMIMESniffing: Prevent MIME sniffing" class="com.optimyth.qaking.rules.javascript.security.PreventMIMESniffing" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.12.2,CAPEC:269,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,Framework:Node.js,global]]></tags>
    <description><![CDATA[MIME sniffing is a browser feature, initially created for Internet Explorer, that attempts to determine the correct
content type for downloaded content.

By confusing the MIME sniffing algorithm, the browser can be manipulated into interpreting data in a way that allows
an attacker to carry out a cross site scripting.

Microsoft added a header to disable MIME sniffing in IE >= 8, X-Content-Type-Options. Later, other browsers added support for it.

The rule will check if server-side JavaScript code will set X-Content-Type-Options: nosniff, either directly or using a
security middleware like helmet.]]></description>
    <priority>2</priority>
    <effort>1</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent MIME sniffing attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var express = require('express')
var app = express() // VIOLATION

app.get('/', function (req, res) {
  res.send('Hello World!')
})

app.listen(3000, function () {
  console.log('Example app listening on port 3000!')
})]]></example>
    <repair><![CDATA[// Add X-Content-Type-Options: nosniff
app.use(function(req, res, next) {
  res.set('X-Content-Type-Options', 'nosniff');
  next();
});

// Alternatively, use helmet (or koa-helmet if under Koa)
var helmet = require('helmet');
// or simply app.use(helmet()) for all default headers, including X-Content-Type-Options
app.use(helmet.noSniff());]]></repair>
    <reference><![CDATA[https://www.veracode.com/blog/2014/03/guidelines-for-setting-security-headers,https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Headers]]></reference>
    <normatives>
      <security><![CDATA[CWE:646,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:24]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.PrivacyViolation" message="PrivacyViolation: Exposure of Private Information ('Privacy Violation')" class="com.als.js.rules.PrivacyViolation" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:10.2.1,CWEScope:Confidentiality,privacy]]></tags>
    <description><![CDATA[Managing private user information can compromise user privacy.

Privacy violations occur when private user data are stored in an external location.

User private information mustn't be exposed. Depending on its location, an organization may be required to comply with one or more state regulations to assurance of private information.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Keeping private data safe improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var password = document.forms[0].password.value;

var xhr_object = new XMLHttpRequest();
localStorage.setItem('password', password);   // VIOLATION
xhr_object.open(method, url, async, username, password);]]></example>
    <repair><![CDATA[// Do not write private data of the user in external locations]]></repair>
    <reference><![CDATA[http://projects.webappsec.org/Information-Leakage,http://cwe.mitre.org/data/definitions/359.html,https://www.owasp.org/index.php/Privacy_Violation]]></reference>
    <normatives>
      <security><![CDATA[CWE:359,OWASP-M:2016:M2,OWASP:2021:A1,PCI-DSS:8.2.1,WASC:13]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.REACT.DangerouslySetInnerHtml" message="DangerouslySetInnerHtml: Do not use dangerouslySetInnerHTML property in React components." class="com.optimyth.qaking.rules.react.DangerouslySetInnerHtml" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:AccessControl,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[dangerouslySetInnerHTML is React’s replacement for using innerHTML in the browser DOM.
In general, setting HTML from code is risky because it’s easy to inadvertently expose your users to a cross-site scripting (XSS) attack.
So, you can set HTML directly from React, but you have to type out dangerouslySetInnerHTML and pass an object with a __html key,
to remind yourself that it’s dangerous.

This rule simply reports any usage of the dangerouslySetInnerHTML property. Please note that the Cross-Site Scripting rule for JavaScript
also checks if the value passed to dangerouslySetInnerHTML could be injected from untrusted input.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid unintended XSS attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import React, { Component } from 'react';

function createMarkup() {
  return {__html: 'First &middot; Second'};
}

function MyComponent() {
  // VIOLATION
  return <div dangerouslySetInnerHTML={createMarkup()} />;
}]]></example>
    <repair><![CDATA[// Do not use dangerouslySetInnerHTML]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html,https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.4,WASC:08]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.REACT.FindDomNode" message="FindDomNode: Do not call ReactDOM.findDOMNode()." class="com.optimyth.qaking.rules.react.FindDomNode" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:AccessControl,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[The function findDOMNode is an escape hatch used to access the underlying DOM node.
In most cases, use of this function is discouraged because it pierces the component abstraction.
It has been deprecated in StrictMode. Its usage is discouraged and, possibly, it will be deleted in a future version.

This rule simply reports any call on ReactDOM.findDOMNode().]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Design error</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid deprecated / dangerous code.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import React, { Component } from "react";
import ReactDOM from "react-dom";
import ChildComponent from "./child-component";

class MyComponent extends Component {

  componentDidMount() {
    const node = ReactDOM.findDOMNode(this); // VIOLATION
    /* ... use DOM node ...  */
  }

  render () {
    return <ChildComponent>{this.props.children}</ChildComponent>;
  }
}]]></example>
    <repair><![CDATA[import React, { createRef, Component } from "react";
import ChildComponent from "./child-component";

class MyComponent extends Component {

  componentDidMount() {
    // Do not use ReactDOM.findDOMNode(). Use ref on a wrapper DOM element
     const node = this.wrapper.current;
     /* ... use DOM node ...  */
  }

  wrapper = createRef();

  render () {
    return (
      <div ref={this.wrapper}>
        <ChildComponent>{this.props.children}</ChildComponent>
      </div>
    );
  }
}]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/242.html,https://medium.com/trabe/getting-rid-of-finddomnode-method-in-your-react-application-a0d7093b2660,https://reactjs.org/docs/react-dom.html#finddomnode]]></reference>
    <normatives>
      <security><![CDATA[CWE:242]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.REACT.JavascriptUrl" message="JavascriptUrl: Usage of javascript: URL in JSX." class="com.optimyth.qaking.rules.react.JavascriptUrl" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWE-94,CWEScope:AccessControl,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[If an attacker can modify the contents of an URL in a DOM element, this is a security issue.
In particular, javascript: URLs are dangerous as results in code execution in the context of the page.

A simple JSX fragment like <a href={url}>Unsafe Link</a> could be exploited if url can be controlled
by an attacker (which is already an open-redirect security flaw), and using javascript: URLs
an attacker may run arbitrary code.

This rule checks any usage of a javascript: URL in React JSX elements, with are potentially dangerous.
The javascript:void(0) hack is permitted by the rule, even when there are alternatives (like using # as the URL plus
onClick={e => e.preventDefault()}.

Note that javascript: URLs should not be used in modern webapps, as attaching event listeners and the preventDefault()
provide better control than dynamic code in javascript: URLs.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[import React, { createRef, Component } from "react";

class MyComponent extends Component {
  render () {
     // Potential code injection (or XSS) here
     const url = "javascript:onClickHandler(" + process(this.state) + ")";
     return <a href={url}>Click me!</a>; // VIOLATION
  }
}]]></example>
    <repair><![CDATA[import React, { createRef, Component } from "react";

class MyComponent extends Component {
  render () {
     // FIXED
     return <a href='#' onClick='process2()'>Click me!</a>;
  }
}]]></repair>
    <reference><![CDATA[https://reactjs.org/blog/2019/08/08/react-v16.9.0.html#deprecating-javascript-urls]]></reference>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ResourceInjection" message="ResourceInjection: Do not allow external input to control resource identifiers" class="com.optimyth.qaking.rules.tainting.ResourceInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Allow external input to control resource identifiers, could enable an attacker to access or modify protection of system resources.

The conditions for injection issues are:
  - An attacker can specify the identifier used to access a system resource.
  - The attacker gains a capability that would not otherwise be permitted.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Keeping resources isolated from external resources improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var socket = new WebSocket(document.URL); // VIOLATION]]></example>
    <repair><![CDATA[//Avoid calls of this type with the user-controlled settings]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/99.html,http://projects.webappsec.org/w/page/13246933/Improper%20Input%20Handling]]></reference>
    <normatives>
      <security><![CDATA[CWE:99,OWASP-M:2016:M7,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.SameOriginMethodExecution" message="SameOriginMethodExecution: Same Origin Method Execution (SOME)" class="com.optimyth.qaking.rules.tainting.SameOriginMethodExecution" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[SOME is a web application attack which abuses callback endpoints by forcing a victim into
executing arbitrary scripting methods of any page on the endpoint’s domain.

In example, while JSONP is popular useful technology but it can make a website vulnerable as it uses a callback function
to get data from third-party services. By manipulating the callback parameter, attacker could execute arbitrary methods
on the affected website.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[function logResults(json){
  console.log(json);
}

var callbackname = process.argv[2];
$.ajax({ // VIOLATION
  url: "https://api.github.com/users/anyuser",
  dataType: "jsonp",
  jsonpCallback: callbackname
});]]></example>
    <repair><![CDATA[// Do not allow user to select the jsonp callback]]></repair>
    <reference><![CDATA[https://securitycafe.ro/2017/01/18/practical-jsonp-injection/,http://cwe.mitre.org/data/definitions/79.html,http://www.benhayak.com/2015/06/same-origin-method-execution-some.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.7,WASC:08]]></security>
    </normatives>
    <properties>
      <property name="inputs" descname="Comma-separated list of input types to consider as sources (user_input, file_input, database_input, other_input, environment_input, system_input, hardcoded_input)" value="user_input, database_input, file_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.SensitiveInfoInConfigurationFile" message="SensitiveInfoInConfigurationFile: Use of sensitive information into configuration file" class="com.optimyth.qaking.rules.javascript.security.SensitiveInfoInConfigurationFile" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Sensitive information written into a configuration file which is distributed along with the code are
visible to any person reading the source code. If the resource protected by such hardcoded sensitive information is important,
this may compromise system security.

Note: The rule considers .json files (the usual configuration format for JavaScript/TypeScript software),
but ignores build and project configuration files. Files in third-party modules (like NPM modules under node_modules directory)
are ignored as well.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Information leaks</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid sensitive information leakage.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[[Json example file]
{
  "security": {
    "tokenSecret": "dsfasfsafjlkjasdfljlkjdfasljdfafdsa="
  },
}]]></example>
    <repair><![CDATA[Either the configuration file should not be distributed along with the project, or sensitive info should be removed from files.]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/200.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:200,CWETOP25:2021:20,OWASP-M:2016:M2,OWASP:2021:A1]]></security>
    </normatives>
    <properties>
      <property name="fileExcludePattern" descname="Regular expression for additional exclude filter on file pathname. Leave empty for the default filter on project / package manager configuration files." value=""/>
      <property name="pattern" descname="Regular expression for matching field names containing sensitive information. The default value is &quot;password|passwd|receipt|ticket|session|user|key|csrf|token|hash|mac|digest|uuid|guid|crypto|encrypt|decrypt&quot;." value=""/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ServerInsecureTransport" message="ServerInsecureTransport: Insecure transport in Node.js HTTP servers" class="com.optimyth.qaking.rules.javascript.security.ServerInsecureTransport" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:6.1.1,ASVS-v4.0.2:6.1.2,ASVS-v4.0.2:6.1.3,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Node.js]]></tags>
    <description><![CDATA[For sensitive applications, a secure transport (like TLS/SSL) provides confidentiality and integrity in communications
with the server.

The rule demands that HTTP servers use SSL/TLS transport, to ensure server-side authentication,
confidentiality and integrity of the communications with clients.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const express = require('express')
const app = express()
// ... configure your app here ...

// VIOLATION, creates HTTP server
app.listen(8080)]]></example>
    <repair><![CDATA[const express = require('express')
const app = express()
// ... configure your app here ...

const https = require('https')
const fs = require('fs')

const options = {
  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),
  // ... rest of TLS configuration here ...
}

// FIXED
https.createServer(options, app).listen(8443)]]></repair>
    <reference><![CDATA[https://cwe.mitre.org/data/definitions/319.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:319,CWETOP25:2021:35,OWASP:2021:A2,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="onlyHttps" descname="If true, any HTTP server put to listen will be reported as violation, even when an HTTPS server is started." value="false"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ServerSideRequestForgery" message="ServerSideRequestForgery: Creation of requests from a vulnerable server using untrusted input (server side request forgery, SSRF)" class="com.optimyth.qaking.rules.javascript.security.ServerSideRequestForgery" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:12.6.1,ASVS-v4.0.2:5.2.6,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[A server side request forgery vulnerability appears when an attacker can send requests from a vulnerable server to remote services.

SSRF attacks allow accessing, through the vulnerable server, to internal systems located behind a firewall,
that normally should not be accessible.

There are two kinds of SSRF attacks:
- Trusted SSRF: we just can send requests to a list of predefined remote services.
- Remote SSRF: we can send requests to any remote IP and port.

SSRF attacks are commonly used for port scanning and attacking systems from the internal network.

This rule checks if there are connections established using untrusted input data.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Prevent SSRF attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const https = require('https')
const url = require('url')

let targetUrl = process.argv[2]
let _url = url.parse(targetUrl)
let _port = Number(_url.port || (_url.protocol === 'https:' ? 443 : 80))

https.get(targetUrl, (res) => { // // VIOLATION (url manipulation)
  res.on('data', (chunk) => { /*...*/ })
  res.on('end', () => { /*...*/ })
}).on('error', (err) => { /*...*/ })]]></example>
    <repair><![CDATA[// If the target url comes from external input, at least use a whitelist of allowed origins
let allowedSites = [/* ... */];
const https = require('https')
const url = require('url')

let targetUrl = process.argv[2]
let _url = url.parse(targetUrl)
let _port = Number(_url.port || (_url.protocol === 'https:' ? 443 : 80))

// FIXED, whitelist of allowed origins
let _site = url.protocol + ':' + url.hostname + ':' + _port;
if(!allowedSites.contains(_site)) {
  throw new PotentialServerSideRequestForgery(targetUrl);
}

https.get(targetUrl, (res) => { /* ... */ })]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/918.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:918,CWETOP25:2021:24,OWASP:2021:A10,PCI-DSS:6.5.8]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.ServerSideTemplateInjection" message="ServerSideTemplateInjection: Server-side Template Injection" class="com.optimyth.qaking.rules.javascript.security.ServerSideTemplateInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.2.4,ASVS-v4.0.2:5.5.4,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,Framework:Node.js,ssti]]></tags>
    <description><![CDATA[Template engines allow dynamic generation of content (HTML, JSON, email messages...) merged with data.
Unsafely embedding untrusted input in templates executed enables Server-Side Template Injection (SSTI),
when template rendering is done at the server-side (for example, with Node.js).

Template injection may happen thru a development flaw, or even as a feature if the application allows
users to upload templates, something that happens in blogs, wikis, or content-management tools, to name a few.

Note: Some template engines offer a 'sandboxed' mode for this purpose, but such sandboxes typically fail against
a willy hacker founding ways to escape the sandbox.

If an attacker is able to send parts of the template, or select which template to use, the rendered content could
be influenced by the attacker, and the attack payload may include code execution or sensitive information leaks.

Some template engines allow a URL or path for selecting the template to use. When the attacker may choose
which URL/path to use, we are one step below remote code execution, command injection, or web defacement,
depending on how the attack is done.

A SSTI vulnerable app may open the gate for arbitrary code execution, combined with local file injection
techniques (when code is embedded in log/session files, or by abuse of /proc/self/environ).

The check will emit a violation when user-controlled input is concatenated in template source or the reference to a template
resource, without neutralization.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid successful SSTI attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var express = require('express');
var app = express();

var bodyParser = require('body-parser');
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended: true}));

var ejs = require('ejs'); // The template engine

app.get('/todoList', function(req, res) {
  var code = req.body.templateCode; // attacker-controlled
  var ctx = {todoList: fetchTodoList(req)};
  var html = ejs.render(code, ctx); // VIOLATION
  res.send( html );
})]]></example>
    <repair><![CDATA[// If possible, never let untrusted input to affect the template code or resource.
// See remediation for more details.]]></repair>
    <reference><![CDATA[http://blog.portswigger.net/2015/08/server-side-template-injection.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:95,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:20]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.SqlInjection" message="SqlInjection: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" class="com.optimyth.qaking.rules.tainting.SqlInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.4,ASVS-v4.0.2:5.3.5,CWEScope:Access-Control,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Allow the construction of dynamic SQL statement with an input, could enable an attacker to
modify the statement's meaning or to execute arbitrary SQL commands.

SQL injection errors occur when data from an untrusted external input are used to create SQL queries dynamically.

The ways to avoid SQL injection are:
  - Use parametrized SQL, so SQL code and parameters are not mixed (no parameter could change semantics of the SQL).
  - If SQL code must depend on user input (e.g. to build 'dynamic' WHERE clauses), even with prepared statements, all
  user-controlled inputs used to compose such "dynamic" SQL should be neutralized.

A neutralization function either validates inputs and report an (neutral) error without allowing SQL execution, or
replaces sensitive SQL characters in the input to avoid that the resulting SQL has different semantics.

It is recommended to use parametrized SQL (when possible).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid SQL injection vulnerabilities improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var db = openDatabase('mydb', '1.0', 'my database', 1024);
var username = document.form.username.value;
var itemName = document.form.itemName.value;
var query = "SELECT * FROM items WHERE owner = " + username + " AND itemname = " + itemName + ";";
db.transaction(function (tx) {
	tx.executeSql(query); // VIOLATION
	}
)]]></example>
    <repair><![CDATA[//Avoid calls of this type with the user-controlled settings]]></repair>
    <reference><![CDATA[http://projects.webappsec.org/w/page/13246963/SQL%20Injection,http://cwe.mitre.org/data/definitions/89.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:89,CWETOP25:2021:6,OWASP-M:2016:M8,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:19]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.StoredCrossSiteScripting" message="StoredCrossSiteScripting: Web content generation from improper sanitized database data and escaped output (Stored Cross-site Scripting, XSS)" class="com.optimyth.qaking.rules.tainting.StoredCrossSiteScripting" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Software places input taken from database in page content. An attacker could inject browser script code that is executed in the client browser.
The end-user is the attacked subject, and the software is the vehicle for the attack. This attack is known as Cross-Site Scripting (XSS).

There are different kinds of XSS:
* Reflected XSS: Attacker causes victim to supply malicious content to a vulnerable web application, which renders HTML content
  embedding a malicious script executed in victim's browser.
  A variation of this is named DOM-based XSS, where the vulnerable software does not generate content depending on user input
  but include script code that use user-controlled input.

* Persistent XSS: Attacker provides malicious content to the vulnerable application, which is stored somewhere.
  When stored data is fetched and rendered,

This rule analyzes only the "Persistent XSS" case.

When other user access to vulnerable pages that embed without proper neutralization the attacker content,
script code is executed in the victim's browser. For this, you should add other input kinds (e.g. file_input and/or database_input)
to the 'inputs' rule property.

The script executed in the victim's browser could perform malicious activities, like stealing active authentication tokens
(sometimes in the form of cookies) and performing operations on a insecure webapp (on behalf of the victim) that trusts
too much identity artifacts in browser and do not request additional authorization for operations ('Cross-Site Request Forgery attack', CSRF).

Many browsers could limit the damage via security restrictions (e.g. 'same origin policy'), but user browsers generally allow scripting languages
(e.g. JavaScript) in their browsers (disabling JavaScript severely limits a web application).]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Neutralizing data form untrusted sources improves security.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var http = require('express');
var mysql = require('mysql');
var connection = mysql.createConnection({host:'localhost', user: 'app', password: 'secret'});
connection.connect();
var app = express();

app.get('/posts', function(req, res) {
  connection.query('SELECT * FROM posts WHERE id=?', [id], function(err, posts) {
    if (error) throw error;
    res.write('<ul>');
    for(let post of posts) {
      res.write('<li>Post ' + post.id + ': ' + post.message + '</li>'); // VIOLATION, stored XSS
    }
    res.end('</ul>');
  });
});]]></example>
    <repair><![CDATA[// ...same code as before...

var xss = require('xss-filters'); // For escaping in HTML content

app.get('/posts', function(req, res) {
  connection.query('SELECT * FROM posts WHERE id=?', [id], function(err, rows) {
    if (error) throw error;
    res.write('<ul>');
    for(let row of rows) {
      let postId = xss.inHTMLData(row.id);
      let postMsg = xss.inHTMLData(row.message);
      res.write('<li>Post ' + postId + ': ' + postMsg + '</li>'); // FIXED
    }
    res.end('</ul>');
  });
});]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html,https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWE:80,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.4,WASC:08]]></security>
    </normatives>
    <properties>
      <property name="sources" value="database_input,file_input"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.TooMuchOriginsAllowed" message="TooMuchOriginsAllowed: CORS policy (Cross-origin resource sharing) too broad" class="com.optimyth.qaking.rules.javascript.security.TooMuchOriginsAllowed" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CORS,CWEScope:Access-Control]]></tags>
    <description><![CDATA[Too much allowed origins in HTML5 Access-Control-Allow-Origin header.
        
Traditionally, web browsers enforced the Same Origin Policy (SOP) to avoid cross-domain JavaScript to access
certain contents in web page. This policy prevents a malicious script on one page from obtaining
access to sensitive data on another web page ("victim") with a different origin ('cross-site' request).
A strict separation between content from unrelated sites must be maintained on the browser
to prevent loss of data confidentiality or integrity.

Sites receive cross-site data when they own multiple domains, or during exchanges with affiliate sites
(when the user's browser is visiting the affiliate or subdomain site).

Cross-Origin Resource Sharing (CORS) relaxes the SOP. To do this, essentially two HTTP headers (Origin, emitted by client,
and Access-Control-Allow-Origin, emitted by server) are involved. This allows that Ajax requests (XMLHttpRequest or Fetch API)
can access content from different origin that should be otherwise forbidden by the SOP.

With Access-Control-Allow-Origin header, server defines which other domains are allowed to access content in its domain
using cross-origin requests. A too much permissive value (like '*') will allow a malicious application to communicate
with the vulnerable application in unexpected ways, leading to different security problems.

NOTE: CORS is intended to avoid data read from pages coming from other origins, and it is enforced by modern browsers.
Remember that an attacker has full control over an HTTP request message, so do not rely on CORS Origin header for
validating the source of a request, or for CSRF protection.]]></description>
    <priority>1</priority>
    <effort>2</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Limits read application data from content coming from hostile origins.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var https = require('https'),
    url = require('url');

var server = https.createServer(function(){});

server.on('request', function(req, res) {
    // fetch origin from the request
    let origin = url.parse(req.url, true).query.origin;
    res.setHeader("Access-Control-Allow-Origin", origin); // VIOLATION - attacker can choose the value of origin
    // greatest impact, attacker may grab authentication cookies !!!
    res.setHeader("Access-Control-Allow-Credentials", true);

    // ...
});]]></example>
    <repair><![CDATA[var https = require('https'),
    url = require('url');

var server = https.createServer(function(){});

server.on('request', function(req, res) {
    let origin = url.parse(req.url, true).query.origin,
        whitelist = [
            "https://myorg.com",
            "https://subdomain.myorg.com",
            "https://myorg.com:1337"
        ];

    if ( whitelist.includes(origin) ) {
        // FIXED: the origin is in the whitelist
        res.setHeader("Access-Control-Allow-Origin", origin);
        res.setHeader("Access-Control-Allow-Credentials", true);
    }

    // ... other validation alternatives are possible, e.g. based on regular expressions for subdomain origins.
    // important: use ^ and $ for full match (otherwise, attacker may use a domain like myorg.com.attacker.org)
    // It might be safer to keep a fixed list of allowed origins
    let whitelist = /^https:\/\/((\w[\w\d\-]*\.)?myorg.com|api.affiliate.com)$/;
    if ( whitelist.test(origin) ) {
        // FIXED: the origin is in the whitelist
        res.setHeader("Access-Control-Allow-Origin", origin);
        res.setHeader("Access-Control-Allow-Credentials", true);
    }
});]]></repair>
    <reference><![CDATA[https://enable-cors.org/server_expressjs.html,http://cwe.mitre.org/data/definitions/942.html,https://w3c.github.io/webappsec-cors-for-developers,http://expressjs.com/en/resources/middleware/cors.html#configuring-cors-w-dynamic-origin,https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties]]></reference>
    <normatives>
      <security><![CDATA[CWE:942,OWASP:2021:A5,PCI-DSS:6.5.10,WASC:15]]></security>
    </normatives>
    <properties>
      <property name="disallowedOriginPattern" descname="Regular expression for CORS origins do not considered valid" value="\*|null"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.TrustBoundaryViolation" message="TrustBoundaryViolation: Trust boundary violation" class="com.optimyth.qaking.rules.tainting.TrustBoundaryViolation" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Access-Control,trust-boundary]]></tags>
    <description><![CDATA[The product mixes trusted and untrusted data in the same data structure or structured message.

A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted.
By combining trusted and untrusted data in the same data structure, it becomes easier for programmers
to mistakenly trust unvalidated data. This violation may open attack avenues, like injection attacks,
when the application takes untrusted data from the trusted domain without validation.

When untrusted external input (e.g. input HTTP message contents) is set as session data,
without proper validation / neutralization, the check emits a violation.]]></description>
    <priority>3</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid security issues when data passed to trusted domain is used without specific validation from other places in the application.]]></benefits>
    <inconvenients><![CDATA[Need explicit input validation before data movement.]]></inconvenients>
    <example><![CDATA[// Sample express application
var express = require('express');
var session = require('express-session');
var bodyParser = require('body-parser');
var app = express();

app.use( session({ /* ... */ }) );
app.use( bodyParser.json() );
app.use( bodyParser.urlencoded({extended: true}) );

app.get('/login', function(req, res) {
  var email = req.body.email; // untrusted input
  console.log('New session: ' + email);
  req.session.email = email; // VIOLATION
});]]></example>
    <repair><![CDATA[const validEmail = /... your favourite valid email pattern .../i;

app.get('/login', function(req, res) {
  var email = req.body.email; // source
  if ( validEmail.test(String(email)) ) {
    console.log('New session: ' + email);
    req.session.email = email; // FIXED, email is validated
  } else {
    // ... generate error ...
  }
});]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/501.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:501,PCI-DSS:6.5.1]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.UnsafeCookie" message="UnsafeCookie: Generate server-side cookies with adequate security properties" class="com.optimyth.qaking.rules.javascript.security.UnsafeCookie" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:14.3.3,ASVS-v4.0.2:3.2.3,ASVS-v4.0.2:3.4.1,ASVS-v4.0.2:3.4.2,ASVS-v4.0.2:7.3.3,ASVS-v4.0.2:8.3.4,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Node.js]]></tags>
    <description><![CDATA[Checks that cookies generated server-side (for example, in Node.js) have the following security properties:

* Non persistent - Cookie is not stored persistently by the browser (it is hold in memory)
* HttpOnly - Cookie is not accessible by client-side scripts (not all browsers support this)
* Secure - Cookie is sent in HTTP/SSL communications only (more difficult to capture on the net)
* Path - Path should not match a certain patterns that allow transmission to unintended web applications.
* Domain - Domain should not be too wide so the cookie is sent to unintended servers.

HttpOnly, for example, could mitigate some CSRF (cross-site request forgery) issues as it makes
more difficult for the attacker to capture sensitive cookies from client-side code generated by
exploiting an XSS vulnerability in a web application.

Additionally, the name of any session cookie should be chosen to avoid providing common names that may give clues
to the attacker about how are sessions handled in the server. For example, connect.sid is the default name
in express-session module, and that knowledge may help attackers to mount a targeted attack.

Other rules (like HeaderManipulation) check other conditions, like HTTP Splitting, that could be
produced when the cookie value depends on user-controlled input non properly neutralized.

NOTE: Not setting domain or path forces browser to send the cookie to the originator's domain and
application path, so this is considered secure.]]></description>
    <priority>3</priority>
    <effort>4</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var express = require('express');
var app = express();

app.get('/', function(req, res) {
  // VIOLATION: persistent cookie, too-broad domain, cookie could be sent in clear, not httpOnly
  res.cookie('secret', 'top-secret', {domain: '.com', secure: false, maxAge: 900000});
  res.send('...');
});]]></example>
    <repair><![CDATA[var express = require('express');
var app = express();

app.get('/', function(req, res) {
  // FIXED
  res.cookie('secret', 'top-secret', {domain: 'myorg.com', secure: true, httpOnly: true});
  res.send('...');
});]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/200.html,https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely]]></reference>
    <normatives>
      <security><![CDATA[CWE:1004,CWE:200,CWE:539,CWE:614,CWETOP25:2021:20]]></security>
    </normatives>
    <properties>
      <property name="domainPatternToAvoid" descname="Domain pattern to avoid" value="\.[^\.]+"/>
      <property name="avoidPersistentCookies" descname="Avoid persistent cookies" value="true"/>
      <property name="cookieNamePatternToAvoid" descname="Pattern for session cookie names to avoid" value=".*session.*|connect\.sid"/>
      <property name="avoidUnsecureCookies" descname="Avoid unsecure cookies" value="false"/>
      <property name="pathPatternToAvoid" descname="Path pattern to avoid" value="/"/>
      <property name="forceHttpOnly" descname="Set HttpOnly" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.UseStrictTransportSecurity" message="UseStrictTransportSecurity: Use HTTP Strict Transport Security" class="com.optimyth.qaking.rules.javascript.security.UseStrictTransportSecurity" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:1.9.1,ASVS-v4.0.2:2.2.5,ASVS-v4.0.2:8.3.1,ASVS-v4.0.2:9.1.1,ASVS-v4.0.2:9.2.2,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Node.js,global]]></tags>
    <description><![CDATA[The application does not set HTTP Strict Transport Security (HSTS), allowing attackers
to replace SSL/TLS connections with plain HTTP for capturing sensitive information
(HTTPS stripping attack).

An HTTPS stripping attack is a man-in-the-middle attack, where the attacker intercepts HTTP traffic (using ARP spoofing
or other attack), watches HTTP traffic for location headers and links referencing HTTPS, and replaces them with
HTTP versions. The stripped HTTP connections are proxied out to the spoofed server over HTTPS.
The attacker may then grab sensitive information in clear text, like usernames, passwords, session IDs, etc., and
even perform malicious activity on user's behalf.

HSTS is a security header (Strict-Transport-Security) that instructs the browser to stick with SSL/TLS
during the time period specified in the header, and never visit the insecure HTTP version.
Any connection to the server under HTTP will be automatically replaced in supporting browsers
with HTTPS, even if the user types http:// in the browser URL bar.

IMPORTANT: The HSTS header do not automatically makes the browser switch to HTTPS, and that session may be spoofed
by attackers. Your domain may be added to the preloaded list of HSTS sites (add preload flag to the HSTS header),
so the browser will not allow HTTP connections to your domain.

This rule emits a single violation in server-side JavaScript on the first HTTPS server allocation site,
when no HSTS header is set, either explicitly or by using a protection middleware like helmet.
If no HTTPS server allocation is found, the rule does not demand HSTS protection.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var express = require('express'),
    https = require('https')

var app = express()
/* ... */

var httpsConfig = {/* ... */}
var httpsServer = https.createServer(httpsConfig, app) // VIOLATION
httpsServer.listen(8443)]]></example>
    <repair><![CDATA[var express = require('express'),
    https = require('https'),
    helmet = require('helmet')

var app = express()
// FIXED - Sets HSTS for 60 days:
// Strict-Transport-Security: max-age=5184000; includeSubDomains
app.use(helmet.hsts({ maxAge: 5184000 }))
/* ... */

var httpsConfig = {/* ... */}
var httpsServer = https.createServer(httpsConfig, app)
httpsServer.listen(8443)]]></repair>
    <reference><![CDATA[https://blog.risingstack.com/node-js-security-checklist/,https://www.owasp.org/index.php/HTTP_Strict_Transport_Security]]></reference>
    <normatives>
      <security><![CDATA[CWE:319,CWETOP25:2021:35,OWASP:2021:A2,PCI-DSS:6.5.4,WASC:04]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.VUE.VueHtmlEscapeDisabled" message="VueHtmlEscapeDisabled: Vue HTML escaping is disabled." class="com.optimyth.qaking.rules.vue.VueHtmlEscapeDisabled" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:AccessControl,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity,Framework:Vue,essential,xss]]></tags>
    <description><![CDATA[Vue allows direct rendering of HTML using v-html attribute in templates, or domProps.innerHTML in render functions
or JSX (see examples). This is dangerous unless the content passed is sanitized against cross-site scripting injection.
Only in a sandboxed iframe or in a part of the application when the user that wrote the HTML input is exposed
to it.

In addition, the following constructs are dangerous and should be avoided when possible,
when the passed value is is affected by user-controlled input:
* The v-bind:href directive could be exploited using javascript: URLs,
* v-bind:style directive,
* event directives like v-on:onclick,
* rendering part of content in <script> or <style> elements in Vue templates and render functions.

Vue framework use native browser APIs, like textContent, to render HTML content in the browser,
so any JavaScript code is escaped and not interpreted as JavaScript.

That means that in template the text between curly brackets like this:
  <h1>{{ userProvidedInput }}</h2>
When userProvidedInput contains something like '<script>alert("You are pwnd!")</script>',
it would be escaped to the following HTML, preventing the script injection:
  &lt;script&gt;alert(&quot;You are pwnd!&quot;)&lt;/script&gt;

The same escaping is done at attributes of HTML elements:
  <h1 v-bind:title="userProvidedInput">...</h1>
malicious input like '" onclick="some_javascript'
will be rendered as:
  <h1 title='&quot; onclick=&quotsome_encoded_javascript'>...</h1>
which is properly sanitized against code injection.

The rule reports any use of direct html rendering constructs listed before.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid Cross-Site scripting attacks (or Click-Jacking attacks for styles injection).]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[<!-- VIOLATION -->
<div v-html="userProvidedHtml"></div>

<!-- VIOLATION, JSX syntax in render functions -->
<div domPropsInnerHTML={this.userProvidedHtml}></div>

<!-- VIOLATION, attacker may inject javascript: URLs
(and navigation to attacker-controlled sites is dangerous) -->
<a v-bind:href="userProvidedUrl"></a>

<script>
  // call in a render function
  h('div', {
    domProps: {
      innerHTML: this.userProvidedHtml // VIOLATION
    }
  })
</script>]]></example>
    <repair><![CDATA[<!-- SAFE -->
<div>{{ userProvided }}</div>

<!-- SAFE (JSX syntax inside JavaScript render functions) -->
<div>{this.userProvided}</div>

<!-- SAFE if user may chose between a set of allowed fixed URLs -->
<a href="whiteListedUrl" v-if="cond_1">...</a>
<a href="whiteListedUrl2" v-else-if="cond_2">...</a>
...
<a href="whiteListedUrlN" v-else>...</a>

<script>
  // call in a render function
  h('div', {
    domProps: {
      innerText: this.userProvided // SAFE
    }
    // Also SAFE when written as child node
    this.userProvided
  })
</script>]]></repair>
    <reference><![CDATA[https://blog.sqreen.com/xss-in-vue-js/,https://vuejs.org/v2/guide/security.html#Injecting-HTML]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.4,WASC:08]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.WeakCryptographicHash" message="WeakCryptographicHash: Weak cryptographic hash" class="com.optimyth.qaking.rules.javascript.security.WeakCryptographicHash" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[CWEScope:Accountability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,crypto,hash]]></tags>
    <description><![CDATA[Use of weak cryptographic hash does not guarantee data integrity.

A (cryptographic) hash function maps data of arbitrary size ("the message") to a bit string of a fixed size ("the digest"),
designed to be a 'one-way' function, infeasible to invert. Ideally, a brute-force search of possible inputs to check
for a match on the expected digest (or a 'rainbow' table of precomputed message/hash pairs) should be the unique way
to recreate an input for a given digest.

Hash functions are the "workhorses" of modern cryptography, with many usages in digital signatures, message authentication codes (MACs),
symmetric key generation, indexing in hash tables, duplicate data detection, checksum against accidental data corruption...

A hash function hash() should have resistance against certain attacks:
* pre-image resistance: given hash value h, it should be difficult to find m such that h = hash(m).
* second pre-image resistance: given m1, it should be difficult to find another m2 such that hash(m1) = hash(m2).
* collision resistance ("birthday attack"): it should be difficult to find m1, m2 such that hash(m1) = hash(m2).
* length-extension resistance: given hash(m) and len(m) but not m, by choosing a suitable m' an attacker can calculate hash(m | m')
  (| denotes concatenation).

Resources needed for brute-force attacks obviously vary exponentially with hash size in bits, while for other attacks
could be half the bits in time or pre-image space (or much lower, if the algorithm has weaknesses).

MD5 and SHA1 are often used to verify the integrity of data but last advances in cryptanalysis have discovered weaknesses
in both algorithms. In particular, they use the Merkle-Damgard construction, which are vulnerable to length-extension attacks
against naive MAC generation, like hash(K | M).

Note: Currently, a few JavaScript crypto libraries include the newly NIST standarized hash algorithm SHA-3 (Keccak),
which is a variable-size hash function (actually, a "cryptographic sponge") under sha3-224 ... sha3-512. When available
their usage is recommended in new code.

The rule looks for usages of crypto primitives (hash or hmac) using a weak function.]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid data integrity issues due to a poor selection of hash function.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[// Example, using Node.js crypto module:
const crypto = require('crypto');
// VIOLATION, SHA-1 is now too-weak
const hmac = crypto.createHmac('sha1', secretKey);

var sensitiveData = ...;
hmac.update(sensitiveData);
var mac = hmac.digest('encoding');]]></example>
    <repair><![CDATA[// Example, using Node.js crypto module:
const crypto = require('crypto');
// FIXED, SHA-256 is ok for now
const hmac = crypto.createHmac('sha256', secretKey);

var sensitiveData = ...;
hmac.update(sensitiveData);
var mac = hmac.digest('encoding');]]></repair>
    <reference><![CDATA[https://crackstation.net/hashing-security.htm,http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf,https://en.wikipedia.org/wiki/Hash_function_security_summary,http://cwe.mitre.org/data/definitions/328.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:328,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:50]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="List of robust hash functions">
        <value><![CDATA[
sha224, sha256, sha384, sha512, sha3, sha3-224, sha3-256, sha3-384, sha3-512, keccak, ripemd128, ripemd160, rmd160, ripemd256, ripemd320, whirlpool, dss1, bcrypt, pbkdf2
        ]]></value>
      </property>
      <property name="forbiddenAlgorithms" descname="List of weak hash functions">
        <value><![CDATA[
md2, md4, md5, sha1, gost, gost-crypto, tiger128, tiger160, tiger192, panama, haval128, snefru, adler32, crc32, crc32b, fnv132, fnv1a32, fnv164, fnv1a64, joaat, plaintext
        ]]></value>
      </property>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.WeakEncryption" message="WeakEncryption: Weak symmetric encryption algorithm" class="com.optimyth.qaking.rules.javascript.security.WeakEncryptionAlgorithm" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:2.9.3,ASVS-v4.0.2:6.2.2,ASVS-v4.0.2:8.3.7,CWEScope:Accountability,CWEScope:Confidentiality,CWEScope:Integrity,CWEScope:Non-Repudiation,crypto]]></tags>
    <description><![CDATA[Using a weak encryption algorithms does not guarantee the confidentiality of sensitive data.

Home-grown ciphers, or standard algorithms that were proven flawed or weak, compromise the confidentiality of data.

Encryption algorithms like DES, Triple-DES and RC2 are nowadays too weak for cryptographic usage,
in particular for ensuring information confidentiality.

DES is currently broken, as an small key size renders it unsafe against brute-force attacks.

RC2 is currently broken, as a related-key attack, where an attacker finds mathematical relationships
between key values, renders it unsafe as well.

Triple-DES (or 3DES) is weak, and should be migrated to a more robust standard cipher.

The AES standard algorithm, with an adequate key length and proper setup (initial vector, mode, padding)
should be used instead, for cryptographic operations.

The rule checks usages of weak ciphers in cryptographic primitives, not registred in the allowed list, and registed in the forbidden list.
The rule does not check if the cipher operation is coded properly (key length, initial vector and feedback mode, padding).]]></description>
    <priority>2</priority>
    <effort>4</effort>
    <vulntype>Encryption and randomness</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid loss of confidentiality due to weak ciphers.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[var crypto = require('crypto');
var keymgr = require('my_key_management');

var key = keymgr.loadKey(); // Warning: bad key management makes crypto theory irrelevant...
var data = {};
data.iv = crypto.randomBytes(8).toString('utf8');
var cipher = crypto.createCipheriv('des-cbc', key, data.iv); // VIOLATION, too weak
data.ciphertext = cipher.update(text, 'utf8', 'hex');
data.ciphertext += cipher.final('hex');

// Decryption at receiver:
var key = keymgr.loadKey();
var decipher = crypto.createDecipheriv('des-cbc', key, data.iv); // VIOLATION
var text = decipher.update(data.ciphertext, 'hex', 'utf8');
text += decipher.final('utf8');]]></example>
    <repair><![CDATA[var crypto = require('crypto');
var keymgr = require('my_key_management');

var key = keymgr.loadKey(); // Warning: bad key management makes crypto theory irrelevant...
// for decryption with authentication modes, cipher-text, iv, and tag should be passed
var data = {};
data.iv = crypto.randomBytes(256).toString('utf8');
var cipher = crypto.createCipheriv('aes-256-gcm', key, data.iv);
data.ciphertext = cipher.update(text, 'utf8', 'hex');
data.ciphertext += cipher.final('hex');
data.tag = cipher.getAuthTag();

// Decryption at receiver:
var key = keymgr.loadKey();
var decipher = crypto.createDecipheriv('aes-256-gcm', key, data.iv);
decipher.setAuthTag(data.tag); // Do not forget the authentication tag !
var text = decipher.update(data.ciphertext, 'hex', 'utf8');
text += decipher.final('utf8');]]></repair>
    <reference><![CDATA[https://blog.cryptographyengineering.com/2012/05/19/how-to-choose-authenticated-encryption/]]></reference>
    <normatives>
      <security><![CDATA[CWE:327,OWASP-M:2016:M5,OWASP:2021:A2,PCI-DSS:6.5.3,WASC:04]]></security>
    </normatives>
    <properties>
      <property name="allowedAlgorithms" descname="Comma-separated list of allowed ciphers." value="aes, rijndael, camellia, cast, cast5, tripledes, 3des, des3, des-ede, des-ede3, mars, twofish, saferplus, seed, serpent, idea, rc5, rc6, rabbit, trivium, salsa20, chacha20"/>
      <property name="forbiddenAlgorithms" descname="Comma-separated list of ciphers that should NOT be used." value="des, desx, gost, loki, blowfish, enigma, rc2, rc4, arc4, arcfour, rc4drop, threeway, kasumi, panama, skipjack, crypt"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.XmlEntityInjection" message="XmlEntityInjection: XML entity injection" class="com.optimyth.qaking.rules.javascript.security.XmlEntityInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.5.2,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[In XML parsers, when XML document to parse could be altered by untrusted input, and the untrusted input may
alter the Document Type Definition (DTD, embedded or external), the parser should be configured to avoid
two kinds of potential attacks:

* XML entity expansion DoS (XML bomb or "billion laughs attack"), CWE-776, where well-formed DTD with
  internal entities are expanded exponentially until they exhaust memory.

* XML external entity injection (XXE), CWE-611, where an external entity controlled by the attacker refers to the URL
  of a resource that gives unauthorized access to sensitive files on the server machine, or to a resource
  like /dev/random in Unix systems that, when entity is expanded, leads to a denial-of-service condition.
  A variant of this attack is the server-side request forgery (SSRF), where the URL for external DTD or XML-Schema
  is processed by the URL handler used by the XML parser, allowing the attacker access to an unexpected
  network resource (for cross-site request forgery attacks or port-scanning enumeration).

A particular parser might be vulnerable to XML entity injection attacks when their default settings have both entity expansion
and external entity resolution enabled. Disabling validations does not help, as entity expansion / external entity loading is done,
even when validation is disabled.

DTD is not the unique element that an attacker could use for injection: XML-Schema attributes could be specified
on any tag, so SSRF injection may happen at any place in the XML document, not only at the start where DTD should
be placed, but fortunately common parsers do not seem to fetch schema URLs by default.

XML parsing could be hidden in other frameworks and libraries. For example, with REST, when a resource has an XML
representation, the REST framework typically use an underlying XML parser for processing the request message, which
obviusly is fully under control of a potential attacker.

To be safe during XML processing coming from untrusted sources, a number of XML features should be disabled
when configuring the parser:
* DTD interpretation - Ensure DOCTYPE tags are ignored, or documents containing them are rejected.
* Ignore or reject external entities.
* schemaLocation and noNamespaceSchemaLocation should not fetch URLs.
* XIncludes - Should be disabled or left disabled.

The rule checks that there is a path between an untrusted input and the XML document to parse,
then verifies that the XML parser is configured to avoid both external entity and entity expansion attacks.

Many XML parsers available in the JavaScript ecosystem are either wrappers over existing native XML parsers (like Expat or libxml2),
with some of them allowing bad configuration leading to XXE, or simple SAX-based parsers implemented in JavaScript,
not allowing external entity expansion.]]></description>
    <priority>1</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XML entity attacks that could cause denial-of-service and information leakage.]]></benefits>
    <inconvenients><![CDATA[Dependencies on certain features related to DTD or entity expansion may render runtime errors.]]></inconvenients>
    <example><![CDATA[const libxml = require('libxmljs');
var doc = libxml.parseXml(xmlSrc, { noent: true }); // VIOLATION

This code is vulnerable to well-known XML attack vectors like:

* "billion laughs" attack, 1K payload expands to 3GB!:
<?xml version="1.0"?>
<!DOCTYPE lolz [
 <!ENTITY lol "lol">
 <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
 <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
 <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
 <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
 <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
 <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
 <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
 <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>

* XXE (external entity attack), for sensitive file disclosure:
<!DOCTYPE roottag [
 <!ENTITY windowsfile SYSTEM "file:///c:/boot.ini">
]>
<roottag>
 <sometag>&windowsfile;</sometag>
</roottag>

* XXE, for denial-of-service under Unix servers:
<!DOCTYPE foo [
  <!ELEMENT root ANY >
  <!ENTITY unixfile SYSTEM "file:///dev/random" >
]>
<root>&unixfile;</root>]]></example>
    <repair><![CDATA[const libxml = require('libxmljs');
var doc = libxml.parseXml(xmlSrc, { noent: false, dtdload: false }); // FIXED]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/776.html,http://cwe.mitre.org/data/definitions/611.html,XML Schema, DTD, and Entity Attacks: http://www.vsecurity.com/download/papers/XMLDTDEntityAttacks.pdf,OWASP XML External Entity Processing: https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing]]></reference>
    <normatives>
      <security><![CDATA[CWE:611,CWE:776,CWETOP25:2021:23,OWASP:2021:A5,PCI-DSS:6.5.1,WASC:43,WASC:44]]></security>
    </normatives>
    <properties>
      <property name="parametersAsSources" descname="Assume that method parameters are untrusted inputs" value="true"/>
    </properties>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.XPathInjection" message="XPathInjection: Improper Neutralization of Data within XPath Expressions ('XPath Injection')" class="com.optimyth.qaking.rules.tainting.XPathInjection" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.10,CWEScope:Access-Control,CWEScope:Confidentiality]]></tags>
    <description><![CDATA[The software uses external input to dynamically construct an XPath expression used to
retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input.
This allows an attacker to control the structure of the query.

Effect: the attacker will have control over the information selected from the XML database and may use that ability
to control application flow, modify logic, retrieve unauthorized data, or bypass important checks (e.g. authentication).

This check looks for calls that create or execute an XPath expression, and detects if an untrusted input could
change the XPath code used at that call.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Injection</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[Avoid XPath injection attacks.]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const express = require("express");
const app = express();

const
  xpath = require('xpath'),
  dom = require('xmldom').DOMParser;

app.get('/books/:author', function(req, res) {
  var author = req.params.author;
  var xpathExpr = `//books[@author = '${author}']`; // vulnerable to XPath injection
  var nodes = xpath.select(xpathExpr, doc); // VIOLATION
  dumpResult(node, req, res);
});]]></example>
    <repair><![CDATA[// Validate untrusted input
const
  validate = require('validate.js'),
  authorValidation = {
    presence: true,
    format: { pattern: /(a-z0-9\. ){2,16}/i, message: 'Invalid author name' }
  };

app.get('/books/:author', function(req, res) {
  var author = req.params.author;

  // FIXED
  var unsafe = validate.single(author, authorValidation);
  if(unsafe) {
    dumpError(unsafe, req, res);

  } else {
    var xpathExpr = `//books[@author = '${author}']`;
    var nodes = xpath.select(xpathExpr, doc);
    dumpResult(node, req, res);
  }
});]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/643.html]]></reference>
    <normatives>
      <security><![CDATA[CWE:643,OWASP:2021:A3,PCI-DSS:6.5.1,WASC:39]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <rule name="OPT.JAVASCRIPT.XssProtectionDisabled" message="XssProtectionDisabled: Cross-site scripting protection disabled" class="com.optimyth.qaking.rules.javascript.security.XssProtectionDisabled" technology="JAVASCRIPT" active="true">
    <tags><![CDATA[ASVS-v4.0.2:5.3.3,CWEScope:Access-Control,CWEScope:Availability,CWEScope:Confidentiality,CWEScope:Integrity]]></tags>
    <description><![CDATA[Template engines may provide some protection against cross-site scripting (XSS) attacks,
but it may be disabled, either explicitly or implicitly. The rule emits a violation
when the template engine configuration disables XSS protection.

Note: helmet under Node.js provides client-side XSS protection (enabled by default). There is a
dangerous configuration in the xssFilter() middleware, setOnOldIE:true, that on old
buggy versions of IE (IE8 in particular) opens the door to XSS instead of closing it!

Note: many template engines provide filters that could be used in the template to either
escape content, or to NOT escape content when done by default (for example, in dust or pug).
This rule does not check such constructs in template code, as it is not JavaScript code.]]></description>
    <priority>2</priority>
    <effort>3</effort>
    <vulntype>Misconfiguration</vulntype>
    <impl>1</impl>
    <benefits><![CDATA[]]></benefits>
    <inconvenients><![CDATA[]]></inconvenients>
    <example><![CDATA[const express = require('express')
const app = express()

const consolidate = require('consolidate')
const swig = require('swig')
const nunjucks = require('nunjucks')
const helmet = require('helmet')

swig.setDefaults({ // VIOLATION
  autoescape: false
})
nunjucks.configure({autoescape: false}) // VIOLATION
app.use(helmet.xssFilter({setOnOldIE: true})) // VIOLATION]]></example>
    <repair><![CDATA[// Same code as before
swig.setDefaults({
  autoescape: true // FIXED
})
nunjucks.configure({autoescape: true}) // FIXED
app.use(helmet.xssFilter()) // FIXED]]></repair>
    <reference><![CDATA[http://cwe.mitre.org/data/definitions/79.html,https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet]]></reference>
    <normatives>
      <security><![CDATA[CWE:79,CWE:80,CWETOP25:2021:2,OWASP:2021:A3,PCI-DSS:6.5.4,WASC:08]]></security>
    </normatives>
    <properties/>
    <idcat>OPT.CRITERIUM_VALUE.CQM.SECURITY</idcat>
  </rule>
  <categories>
    <category name="JAVASCRIPT" technology="JAVASCRIPT" active="true" weight="1.0">
      <description><![CDATA[JAVASCRIPT rules]]></description>
      <children>
        <category name="OPT.CRITERIUM_VALUE.CQM.EFFICIENCY" technology="JAVASCRIPT" active="true" weight="0.0">
          <description><![CDATA[Efficiency]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.MAINTAINABILITY" technology="JAVASCRIPT" active="true" weight="0.0">
          <description><![CDATA[Maintainability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.PORTABILITY" technology="JAVASCRIPT" active="true" weight="0.0">
          <description><![CDATA[Portability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.RELIABILITY" technology="JAVASCRIPT" active="true" weight="0.0">
          <description><![CDATA[Reliability]]></description>
        </category>
        <category name="OPT.CRITERIUM_VALUE.CQM.SECURITY" technology="JAVASCRIPT" active="true" weight="10.0">
          <description><![CDATA[Security]]></description>
        </category>
      </children>
    </category>
  </categories>
</ruleset>
