{"_id":"persist","_rev":"32-0b1561b9e8adff9fa0d9ffef34033a1e","name":"persist","description":"Node.js ORM framework supporting various relational databases","dist-tags":{"latest":"0.2.7"},"versions":{"0.1.0":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","keywords":["database","db","orm","sqlite","mysql","PostgreSQL"],"homepage":"https://github.com/nearinfinity/node-persist","version":"0.1.0","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"licenses":[{"type":"MIT"}],"repositories":[{"type":"git","url":"https://github.com/nearinfinity/node-persist.git"}],"dependencies":{"async":"0.1.15"},"devDependencies":{"nodeunit":"~>0.6.4"},"_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"},"_id":"persist@0.1.0","_engineSupported":true,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.6.4","_defaultsLoaded":true,"dist":{"shasum":"3bbdc6a2c9878aa90d8d4409bae3eda38b01cff7","tarball":"https://registry.npmjs.org/persist/-/persist-0.1.0.tgz","integrity":"sha512-heC8zS7QWUJb/nvdlbq3PwVOoJu39gRW4qb7GoDa1XZylGLi5Q6NMZBTSs3DMce9oXgxHx7I9yjElMt/9qCx0w==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIE6TDC7Ec9Zih02hljayBZiQPT14o2hGrt1eA3oRnRNGAiEA7XlKkbl/Fg6ihdPulZgB7GvGVchM5g2gnRAOxB2N8pM="}]},"directories":{}},"0.1.1":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","keywords":["database","db","orm","sqlite","mysql","PostgreSQL"],"homepage":"https://github.com/nearinfinity/node-persist","version":"0.1.1","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"licenses":[{"type":"MIT"}],"repositories":[{"type":"git","url":"https://github.com/nearinfinity/node-persist.git"}],"dependencies":{"async":"0.1.15"},"devDependencies":{"nodeunit":"~>0.6.4"},"_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"},"_id":"persist@0.1.1","_engineSupported":true,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.6.4","_defaultsLoaded":true,"dist":{"shasum":"142b09f93134e15aa329274bd525963b973e2ed4","tarball":"https://registry.npmjs.org/persist/-/persist-0.1.1.tgz","integrity":"sha512-pKZRdnrMOEnb7SD5bL+NyVw73wIB7biWEO9rAK9cRd28Or6ZlVmi6IMWks/lrvhSmTaQdxD4SePy4Uh1dGDzMQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDr6l3Mnvnov6zPI2nauRgqgVHkWrOUiHFv1pkWAUxLLwIhANrJ7cWlfaTWFdplNsCQX7cTzqXB3rvnFVFCIxko6CDP"}]},"directories":{}},"0.2.0":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","keywords":["database","db","orm","sqlite","mysql","PostgreSQL","oracle","db-oracle"],"homepage":"https://github.com/nearinfinity/node-persist","version":"0.2.0","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"licenses":[{"type":"MIT"}],"repositories":[{"type":"git","url":"https://github.com/nearinfinity/node-persist.git"}],"dependencies":{"async":"0.1.15"},"devDependencies":{"nodeunit":"~>0.6.4"},"_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"},"_id":"persist@0.2.0","_engineSupported":true,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.6.4","_defaultsLoaded":true,"dist":{"shasum":"c7e9d39fa44c51f008a0ef25ad0c741cc8771b9a","tarball":"https://registry.npmjs.org/persist/-/persist-0.2.0.tgz","integrity":"sha512-glkQNs5RKIws5N6jaU9kScmAWmFUvuwffQGLGXZsDaVQujh1VmvZcz9V6YDdZrcTk5hXptO5qiesFOPyYEQA7A==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDIiRPP8ksupkFyQkIBpyZnsSm6RqwxemXt8xrfPVRneAiB2nXuE/AdIfvE3BrZ33uBn7yRlHcRmmVXKPQpEDlH0vA=="}]},"directories":{}},"0.2.1":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","keywords":["database","db","orm","sqlite","mysql","PostgreSQL","oracle","db-oracle"],"homepage":"https://github.com/nearinfinity/node-persist","version":"0.2.1","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"licenses":[{"type":"MIT"}],"repositories":[{"type":"git","url":"https://github.com/nearinfinity/node-persist.git"}],"dependencies":{"async":"0.1.15"},"devDependencies":{"nodeunit":"~>0.6.4"},"_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"},"_id":"persist@0.2.1","_engineSupported":true,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.6.4","_defaultsLoaded":true,"dist":{"shasum":"343633658bab95df7ac74410514c667a8cb9b36a","tarball":"https://registry.npmjs.org/persist/-/persist-0.2.1.tgz","integrity":"sha512-YwvgFxJuJb4BTZJTbAimsGP9TVXNVCH4E1Yy5HYE0AQDv9TFlbE4z3ZaDVsa/bnamhr2VDG1XT6+H/Bv+p7U0g==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFIR4jzpNsb/3+gUYu4LDIQmuBQ97xmj/s5JO17/7l3iAiB8wuRb49hpIJhegihSd74t4oeOtRu5wMJ4qF51pDMrxg=="}]}},"0.2.2":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","author":{"name":"Joe Ferner","email":"joe.ferner@nearinfinity.com"},"keywords":["database","db","orm","sqlite","mysql","PostgreSQL","oracle","db-oracle"],"homepage":"https://github.com/nearinfinity/node-persist","version":"0.2.2","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"licenses":[{"type":"MIT"}],"repository":{"type":"git","url":"git://github.com/nearinfinity/node-persist.git"},"dependencies":{"async":"0.1.15"},"devDependencies":{"nodeunit":"~>0.6.4"},"scripts":{"test":"nodeunit test"},"main":"./index.js","_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"},"_id":"persist@0.2.2","_engineSupported":true,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.6.4","_defaultsLoaded":true,"dist":{"shasum":"fdd284db4547c5054710419329129b346883d616","tarball":"https://registry.npmjs.org/persist/-/persist-0.2.2.tgz","integrity":"sha512-B6KM6jiKulSB0/mw04LY4NBbSmOO70CdQeLBu9YU83hvKiZa+GYdkHiXOnuz0GEacAigeax3LccMhXmAggbS5w==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGyy5cVDBb8IxL33bnNP8kI7Dc3aY3manujat82dQThtAiBQ9SObsenpgxFGbelo+RWOqQ6Iz0v3an4VkVgopCNrvA=="}]}},"0.2.3":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","author":{"name":"Joe Ferner","email":"joe.ferner@nearinfinity.com"},"keywords":["database","db","orm","sqlite","mysql","PostgreSQL","oracle","db-oracle"],"version":"0.2.3","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"license":"MIT","repository":{"type":"git","url":"git://github.com/nearinfinity/node-persist.git"},"dependencies":{"async":"0.1.15"},"devDependencies":{"nodeunit":"~>0.6.4"},"scripts":{"test":"nodeunit test"},"main":"./index.js","_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"},"_id":"persist@0.2.3","optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.4","_nodeVersion":"v0.7.7","_defaultsLoaded":true,"dist":{"shasum":"26aa63610dae2346a580662b6e36d4968240ec2e","tarball":"https://registry.npmjs.org/persist/-/persist-0.2.3.tgz","integrity":"sha512-Mswkw26gKSC2r784QpnE6MbrVFWPNKljh4pxLdQ1c3cJ2MaH83WMv2U5zLb6kYUYuaEJO/fry0I2r/wRJGtl5A==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHFFtprOgjQpOCrk3TQ3xa3+1C3CUln+uTiH8KVvgnqqAiEA0PB7Thn3+SL9siPDopNajiFPynRIapc+XbOCZ3H11L4="}]}},"0.2.4":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","author":{"name":"Joe Ferner","email":"joe.ferner@nearinfinity.com"},"keywords":["database","db","orm","sqlite","mysql","PostgreSQL","oracle","db-oracle"],"version":"0.2.4","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"license":"MIT","repository":{"type":"git","url":"git://github.com/nearinfinity/node-persist.git"},"dependencies":{"async":"0.1.15"},"devDependencies":{"nodeunit":"~>0.6.4","sqlite3":"git://github.com/joeferner/node-sqlite3.git"},"scripts":{"test":"nodeunit test"},"main":"./index.js","_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"},"_id":"persist@0.2.4","optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.4","_nodeVersion":"v0.7.11","_defaultsLoaded":true,"dist":{"shasum":"cf54e6362bbd29404a405412ea866f4e2afc9c42","tarball":"https://registry.npmjs.org/persist/-/persist-0.2.4.tgz","integrity":"sha512-B9raIksEqUD2TOh+P7pgf0H3JVwQIk3EOLoqi1Y7UnFgOSGX6EpYCFoo9mNhZ6oCVtYrHDpf+Ql4Tg7puTLmxA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBKjOJLv+BQY++rQvvyh/1iNO57T7pdisgJ28/10HSZcAiEA+Xgkonh4YKFQsjMqGhcd6Dw1ma4mzJILM9oXGnT8lXk="}]}},"0.2.5":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","author":{"name":"Joe Ferner","email":"joe.ferner@nearinfinity.com"},"keywords":["database","db","orm","sqlite","mysql","PostgreSQL","oracle","db-oracle"],"version":"0.2.5","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"license":"MIT","repository":{"type":"git","url":"https://github.com/nearinfinity/node-persist.git"},"dependencies":{"async":"0.1.15","over":"git://github.com/nearinfinity/node-over.git"},"devDependencies":{"nodeunit":"~>0.6.4","sqlite3":"git://github.com/joeferner/node-sqlite3.git"},"scripts":{"test":"nodeunit test"},"main":"./index.js","readme":"# persist\n\npersist is an ORM framework for node.js.\n\nThe following databases are currently supported:\n\n * sqlite3 - via: [node-sqlite3](https://github.com/developmentseed/node-sqlite3)\n * mysql - via: [node-mysql](https://github.com/felixge/node-mysql)\n * PostgreSQL - via: [node-postgres](https://github.com/brianc/node-postgres)\n * Oracle - via: [node-oracle](https://github.com/nearinfinity/node-oracle)\n\n# Quick Examples\n    var persist = require(\"persist\");\n    var type = persist.type;\n\n    // define some model objects\n    Phone = persist.define(\"Phone\", {\n      \"number\": type.STRING\n    });\n\n    Person = persist.define(\"Person\", {\n      \"name\": type.STRING\n    }).hasMany(this.Phone);\n\n    persist.connect({\n      driver: 'sqlite3',\n      filename: 'test.db',\n      trace: true\n    }, function(err, connection) {\n      Person.using(connection).all(function(err, people) {\n        // people contains all the people\n      });\n    });\n\n# Download\n\nYou can install using Node Package Manager (npm):\n\n    npm install persist\n\n# Index\n\n## [database.json](#databaseJson)\n\n## persist\n * [env](#persistEnv)\n * [connect](#persistConnect)\n * [define](#persistDefine)\n * [setDefaultConnectOptions](#persistSetDefaultConnectOptions)\n\n## Connection\n\n * [chain](#connectionChain)\n * [tx](#connectionTx)\n * [runSql](#connectionRunSql)\n * [runSqlAll](#connectionRunSqlAll)\n * [runSqlEach](#connectionRunSqlEach)\n * [runSqlFromFile](#connectionRunSqlFromFile)\n * [runSqlAllFromFile](#connectionRunSqlAllFromFile)\n * [runSqlEachFromFile](#connectionRunSqlEachFromFile)\n\n## Model\n\n * [hasMany](#modelHasMany)\n * [hasOne](#modelHasOne)\n * [using](#modelUsing)\n * [save](#modelSave)\n * [update (instance)](#modelInstanceUpdate)\n * [update](#modelUpdate)\n * [delete](#modelDelete)\n * [getById](#modelGetById)\n * [onSave](#modelOnSave)\n * [onLoad](#modelOnLoad)\n * [Associated Object Properties](#associatedObjectProperties)\n\n## Query\n\n * [all](#queryAll)\n * [each](#queryEach)\n * [first](#queryFirst)\n * [orderBy](#queryOrderBy)\n * [limit](#queryLimit)\n * [where](#queryWhere)\n * [count](#queryCount)\n * [min](#queryMin)\n * [max](#queryMax)\n * [deleteAll](#queryDeleteAll)\n * [updateAll](#queryUpdateAll)\n * [include](#queryInclude)\n\n## Transaction\n\n * [commit](#txCommit)\n * [rollback](#txRollback)\n\n## Results Set\n * [getById](#resultSetGetById)\n\n<a name=\"databaseJson\"/>\n# database.json\n\nIf the current working directory contains a file called database.json this file will be loaded upon requiring persist.\nThe file should follow a format like this:\n\n    {\n      \"default\": \"dev\",\n\n      \"dev\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \":memory:\"\n      },\n\n      \"test\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \":memory:\"\n      },\n\n      \"prod\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \"prod.db\"\n        \"sqlDir\": \"./prodSql\"\n      }\n    }\n\n\"default\" specifies which environment to load.\n\n# API Documentation\n\n<a name=\"persist\"/>\n## persist\n\n<a name=\"persistEnv\" />\n### persist.env\n\nThe environment to read from the database.json file. If not set will use the value of default from the database.json.\n\n__Example__\n\n    persist.env = 'prod';\n\n<a name=\"persistConnect\" />\n### persist.connect([options], callback)\n\nConnects to a database.\n\n__Arguments__\n\n * options - (optional) Options used to connect to the database. If options are not specified the default connect options are used.\n             see [database.json](#databaseJson) and [SetDefaultConnectOptions](#persistSetDefaultConnectOptions)\n  * driver - The driver to use to connect (ie sqlite3, mysql, oracle, or postgresql).\n  * db - If db is specified this parameter will be assumed to be an already open connection to the database.\n  * _other_ - see the documentation for your driver. The options hash will be passed to that driver.\n * callback(err, connection) - Callback to be called when the connection is established.\n\n__Example__\n\n    persist.connect({\n      driver: 'sqlite3',\n      filename: 'test.db',\n      trace: true\n    }, function(err, connection) {\n      // connnection esablished\n    });\n\n<a name=\"persistDefine\" />\n### persist.define(modelName, properties): Model\n\nDefines a model object for use in persist.\n\nThe primary key column does not need to be specified and will default to the name 'id' with the attributes dbColumnName='id',\ntype='integer'. You can override the database name using dbColumnName or setting the primaryKey attribute on any column.\n\n__Arguments__\n\n * modelName - The name of the model. This name will map to the database name.\n * properties - Hash of properties (or columns). The value of each property can simply be the type name (ie type.STRING)\n                or it can be a hash of more options.\n  * type - type of the property (ie type.STRING)\n  * defaultValue - this can be a value or a function that will be called each time this model object is created\n  * dbColumnName - the name of the database column. (default: name of the property, all lower case, seperated by '_')\n  * primaryKey - Marks this column as being the primary key column. You can have only one primary key column.\n\n__Returns__\n\n A model class.\n\n__Example__\n\n    Person = persist.define(\"Person\", {\n      \"name\": type.STRING,\n      \"createdDate\": { type: type.DATETIME, defaultValue: function() { return self.testDate1 }, dbColumnName: 'new_date' },\n      \"lastUpdated\": { type: type.DATETIME }\n    })\n\n<a name=\"persistSetDefaultConnectOptions\"/>\n### persist.setDefaultConnectOptions(options)\n\nSets the default connection options to be used on future connect calls. see [database.json](#databaseJson)\n\n__Arguments__\n * options - See [connect](#persistConnect) for the description of options\n\n__Example__\n\n    persist.setDefaultConnectOptions({\n      driver: 'sqlite3',\n      filename: 'test.db',\n      trace: true});\n\n<a name=\"connection\"/>\n## Connection\n\n<a name=\"connectionChain\"/>\n### connection.chain(chainables, callback)\n\nChains multiple statements together in order and gets the results.\n\n__Arguments__\n\n * chainables - An array of chainable queries. These can be save, updates, selects, or deletes. Each item in the array will be\n   executed, wait for the results, and then execute the next. This can also be a hash of queries in which case the results\n   will contain a hash of results where each key corresponds to a key in the results.\n * callback(err, results) - Callback called when all the items have been executed.\n\n__Example__\n\n    // array chaining\n    connection.chain([\n      person3.save,\n      Person.min('age'),\n      Person.max('age'),\n      phone3.delete,\n      person2.delete,\n      Person.orderBy('name').all,\n      Phone.orderBy('number').first,\n      Phone.count,\n      Phone.deleteAll,\n      Phone.all,\n      Person.getById(1),\n      persist.runSql('SELECT * FROM Person')\n    ], function(err, results) {\n      // results[0] = person3\n      // results[1] = 21\n      // results[2] = 25\n      // results[3] = []\n      // results[4] = []\n      // results[5] = -- all people ordered by name\n      // results[6] = -- first phone ordered by number\n      // results[7] = 100\n      // results[8] = []\n      // results[9] = [] -- nobody left\n      // results[10] = -- the person with id 1\n      // results[11] = Results of select.\n    });\n\n    // mapped chaining\n    connection.chain({\n      minAge: Person.min('age'),\n      maxAge: Person.max('age')\n    }, function(err, results) {\n      // results.minAge = 21\n      // results.maxAge = 25\n    });\n\n<a name=\"connectionTx\"/>\n### connection.tx(callback)\n\nBegins a transaction on the connection.\n\n__Arguments__\n\n * callback(err, tx) - Callback called when the transaction has started. tx is a transaction object which you can\n   call [commit](#txCommit) or [rollback](#txRollback)\n\n__Example__\n\n    connection.tx(function(err, tx) {\n      person1.save(connection, function(err) {\n        tx.commit(function(err) {\n          // person1 saved and committed to database\n        });\n      });\n    });\n\n<a name=\"connectionRunSql\"/>\n### connection.runSql(sql, values, callback)\n\nRuns a sql statement that does not return results (INSERT, UPDATE, etc).\n\n__Arguments__\n\n * sql - The SQL statement to run.\n * values - The values to substitute in the SQL statement. This is DB specific but typically you would use \"?\".\n * callback(err, results) - Callback called when SQL statement completes. results will contain the number of affected\n   rows or last insert id.\n\n__Example__\n\n    connection.runSql(\"UPDATE people SET age = ?\", [32], function(err, results) {\n      // people updated\n    });\n\n<a name=\"connectionRunSqlAll\"/>\n### connection.runSqlAll(sql, values, callback)\n\nRuns a sql statement that returns results (ie SELECT).\n\n__Arguments__\n\n * sql - The SQL statement to run.\n * values - The values to substitute in the SQL statement. This is DB specific but typically you would use \"?\".\n * callback(err, results) - Callback called when SQL statement completes. results will contain the row data.\n\n__Example__\n\n    connection.runSqlAll(\"SELECT * FROM people WHERE age = ?\", [32], function(err, people) {\n      // people contains all the people with age 32\n    });\n\n<a name=\"connectionRunSqlEach\"/>\n### connection.runSqlEach(sql, values, callback, doneCallback)\n\nRuns a sql statement that returns results (ie SELECT). This is different from runSqlAll in that it returns each row\nin a seperate callback.\n\n__Arguments__\n\n * sql - The SQL statement to run.\n * values - The values to substitute in the SQL statement. This is DB specific but typically you would use \"?\".\n * callback(err, row) - Callback called for each row returned.\n * doneCallback(err) - Callback called after all the rows have returned.\n\n__Example__\n\n    connection.runSqlEach(\"SELECT * FROM people WHERE age = ?\", [32], function(err, person) {\n      // a single person\n    }, function(err) {\n      // all done\n    });\n\n<a name=\"connectionRunSqlFromFile\"/>\n<a name=\"connectionRunSqlAllFromFile\"/>\n<a name=\"connectionRunSqlEachFromFile\"/>\n### connection.runSqlFromFile(filename, values, callback)\n### connection.runSqlAllFromFile(filename, values, callback)\n### connection.runSqlEachFromFile(filename, values, callback, doneCallback)\n\nSame as [runSql](#connectionRunSql), [runSqlAll](#connectionRunSqlAll), [runSqlEach](#connectionRunSqlEach) except the first parameter is a filename of where to load the SQL from.\n\n__Example__\n\n    connection.runSqlFromFile('report.sql', [32], function(err, person) {\n      // a single person\n    }, function(err) {\n      // all done\n    });\n\n<a name=\"model\" />\n## Model\n\n<a name=\"modelHasMany\" />\n### Model.hasMany(AssociatedModel, [options]): Model\n\nAdds a has many relationship to a model. This will automatically add a property to the associated model which links to this\nmodel. It will also define a property on instances of this model to get the releated objects - see [Associated Object Properties](#associatedObjectProperties)\n\n__Arguments__\n\n * AssociatedModel - The name of the model to associate to.\n * options - (optional) An hash of options.\n  * through - creates a many to many relationship using the value of through as the join table.\n  * name - the name of the property to expose.\n\n__Returns__\n\n The model class object suitable for chaining.\n\n__Example__\n\n    Phone = persist.define(\"Phone\", {\n      \"number\": persist.String\n    });\n\n    Person = persist.define(\"Person\", {\n      \"name\": persist.String\n    }).hasMany(Phone);\n\n<a name=\"modelHasOne\" />\n### Model.hasOne(AssociatedModel, [options]): Model\n\nAdds a has one relationship to a model. This will automatically add a property to the associated model which links to this\nmodel. It will also define a property on instances of this model to get the releated objects - see [Associated Object Properties](#associatedObjectProperties)\n\n__Arguments__\n\n * AssociatedModel - The name of the model to associate to.\n * options - (optional) An hash of options.\n  * foreignKey - The foreign key to use for the relationship\n  * name - the name of the property to expose.\n  * createHasMany - true/false to create the other side of the relationship.\n\n__Returns__\n\n The model class object suitable for chaining.\n\n__Example__\n\n    Phone = persist.define(\"Phone\", {\n      \"number\": persist.String\n    }).hasMany(Person);\n\n    Person = persist.define(\"Person\", {\n      \"name\": persist.String\n    });\n\n<a name=\"modelUsing\" />\n### Model.using(connection): query\n\nGets a query object bound to a connection object.\n\n__Arguments__\n\n * connection - The connection to bind the query object to.\n\n__Returns__\n\n A new [Query](#query) object.\n\n__Example__\n\n    Person.using(connection).first(...);\n\n<a name=\"modelSave\" />\n### Model.save(connection, callback)\n\nSaves the model object to the database\n\n__Arguments__\n\n * connection - The connection to use to save the object with.\n * callback(err) - The callback to be called when the save is complete\n\n__Example__\n\n    person1.save(connection, function() {\n      // person1 saved\n    });\n\n<a name=\"modelInstanceUpdate\" />\n### modelInstance.update(connection, params, callback)\n\nUpdates the model object to the database\n\n__Arguments__\n\n * connection - The connection to use to update the object with.\n * params - Object containing properties to update.\n * callback(err) - The callback to be called when the update is complete\n\n__Example__\n\n    person1.update(connection, { name: 'Tom' }, function() {\n      // person1 saved\n    });\n\n<a name=\"modelUpdate\" />\n### Model.update(connection, id, params, callback)\n\nUpdates the model object specified with id to the database. This will only update the values\nspecified and will not retreive the item from the database first.\n\n__Arguments__\n\n * connection - The connection to use to update the object with.\n * id - The id of the row you would like to update.\n * params - Object containing properties to update.\n * callback(err) - The callback to be called when the update is complete\n\n__Example__\n\n    Person.update(connection, 5, { name: 'Tom' }, function() {\n      // person with id = 5 updated with name 'Tom'.\n    });\n\n    // or chaining\n    connection.chain([\n      Person.update(5, { name: 'Tom' })\n    ], function(err, results) {\n      // person with id = 5 updated with name 'Tom'.\n    });\n\n<a name=\"modelDelete\" />\n### Model.delete(connection, callback)\n\nDeletes the model object from the database\n\n__Arguments__\n\n * connection - The connection to use to delete the object with.\n * callback(err) - The callback to be called when the delete is complete\n\n__Example__\n\n    person1.delete(connection, function() {\n      // person1 deleted\n    });\n\n<a name=\"modelGetById\" />\n### Model.getById(connection, id, callback)\n\nGets an object from the database by id.\n\n__Arguments__\n\n * connection - The connection to use to delete the object with.\n * id - The if of the item to get.\n * callback(err, obj) - The callback to be called when the delete is complete\n\n__Example__\n\n    Person.getById(connection, 1, function(err, person) {\n      // person is the person with id equal to 1. Or null if not found\n    });\n\n<a name=\"modelOnSave\" />\n### Model.onSave(obj)\n\nIf preset this function will be called when an update or save occures. You would typically create this method\nin your model file.\n\n__Arguments__\n\n * obj - The object or partial object, in the case of [update](#modelUpdate), being saved.\n\n__Example__\n\n    Person.onSave = function(obj) {\n      obj.lastUpdated = new Date();\n    };\n\n<a name=\"modelOnLoad\" />\n### Model.onLoad(obj)\n\nIf preset this function will be called after an object is loaded from the database. You would typically\ncreate this method in your model file.\n\n__Arguments__\n\n * obj - The object that was just loaded from the database.\n\n__Example__\n\n    Person.onLoad = function(obj) {\n      obj.fullName = obj.firstName + ' ' + obj.lastName;\n    };\n\n<a name=\"associatedObjectProperties\" />\n### Associated Object Properties\n\nIf you have setup an associated property using [hasMany](#modelHasMany) instances of your model will have an additional property\nwhich allows you to get the associated data. This property returns a [Query](#query) object which you can further chain to limit\nthe results.\n\n__Example__\n\n    Phone = persist.define(\"Phone\", {\n      \"number\": persist.String\n    });\n\n    Person = persist.define(\"Person\", {\n      \"name\": persist.String\n    }).hasMany(Phone);\n\n    Person.using(connection).first(function(err, person) {\n      person.phones.orderBy('number').all(function(err, phones) {\n        // all the phones of the first person\n      });\n    });\n\n<a name=\"query\" />\n## Query\n\n<a name=\"queryAll\" />\n### query.all([connection], callback)\n\nGets all items from a query as a single array of items. The array returned will have additional\nmethods see [here for documentation](#resultSetMethods).\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, items) - Callback to be called after the rows have been fetched. items is an array of model instances.\n\n__Example__\n\n    Person.all(connection, function(err, people) {\n      // all the people\n    });\n\n<a name=\"queryEach\" />\n### query.each([connection], callback, doneCallback)\n\nGets items from a query calling the callback for each item returned.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after each row has been fetched. item is a model instance.\n * doneCallback(err) - Callback called after all rows have been retrieved.\n\n__Example__\n\n    Person.each(connection, function(err, person) {\n      // a person\n    }, function() {\n      // all done\n    });\n\n<a name=\"queryFirst\" />\n### query.first([connection], callback)\n\nGets the first item from a query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after the row has been fetched. item is a model instance.\n\n__Example__\n\n    Person.first(connection, function(err, person) {\n      // gets the first person\n    });\n\n<a name=\"queryOrderBy\" />\n### query.orderBy(propertyName): query\n\nOrders the results of a query.\n\n__Arguments__\n\n * propertyName - Name of the property to order by.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.orderBy('name').all(connection, function(err, people) {\n      // all the people ordered by name\n    });\n\n<a name=\"queryLimit\" />\n### query.limit(count, [offset]): query\n\nLimits the number of results of a query.\n\n__Arguments__\n\n * count - Number of items to return.\n * offset - (Optional) The number of items to skip.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.orderBy('name').limit(5, 5).all(connection, function(err, people) {\n      // The 5-10 people ordered by name\n    });\n\n<a name=\"queryWhere\" />\n### query.where(clause, [values...]): query\n### query.where(hash): query\n\nFilters the results by a where clause.\n\n__Arguments__\n\n * clause - A clause to filter the results by.\n * values - (Optional) A single value or array of values to substitute in for '?'s in the clause.\n * hash - A hash of columns and values to match on (see example)\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.where('name = ?', 'bob').all(connection, function(err, people) {\n      // All the people named 'bob'\n    });\n\n    Person.where('name = ? or age = ?', ['bob', 23]).all(connection, function(err, people) {\n      // All the people named 'bob' or people with age 23\n    });\n\n    Person.where({'name': 'bob', 'age': 23}).all(connection, function(err, people) {\n      // All the people named 'bob' with the age of 23\n    });\n\n<a name=\"queryCount\" />\n### query.count([connection], callback)\n\nCounts the number of items that would be returned by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, count) - Callback with the count of items.\n\n__Example__\n\n    Person.where('name = ?', 'bob').count(connection, function(err, count) {\n      // count = the number of people with the name bob\n    });\n\n<a name=\"queryMin\" />\n### query.min([connection], fieldName, callback)\n\nGets the minimum value in the query of the given field.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * fieldName - The field name of the value you would like to get the minimum for.\n * callback(err, min) - Callback with the minimum value.\n\n__Example__\n\n    Person.where('name = ?', 'bob').min(connection, 'age', function(err, min) {\n      // the minimum age of all bobs\n    });\n\n<a name=\"queryMax\" />\n### query.max([connection], fieldName, callback)\n\nGets the maximum value in the query of the given field.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * fieldName - The field name of the value you would like to get the maximum for.\n * callback(err, min) - Callback with the maximum value.\n\n__Example__\n\n    Person.where('name = ?', 'bob').max(connection, 'age', function(err, min) {\n      // the maximum age of all bobs\n    });\n\n\n<a name=\"queryDeleteAll\" />\n### query.deleteAll([connection], callback)\n\nDeletes all the items specified by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err) - Callback called upon completion.\n\n__Example__\n\n    Person.where('name = ?', 'bob').deleteAll(connection, function(err) {\n      // all people name 'bob' have been deleted.\n    });\n\n<a name=\"queryUpdateAll\" />\n### query.updateAll([connection], data, callback)\n\nUpdates all the items specified by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * data - A hash of properties to update. Key is the property name to update. Value is the value to update the property to.\n * callback(err) - Callback called upon completion.\n\n__Example__\n\n    Person.where('name = ?', 'bob').updateAll(connection, { age: 25 }, function(err) {\n      // all people name 'bob' have their age set to 25.\n    });\n\n<a name=\"queryInclude\" />\n### query.include(propertyName): query\n\nIncludes the associated data linked by (hasMany or hasMany(through)) the propertyName when retrieving data from the database.\nThis will replace obj.propertyName with an array of results as opposed to the default before which is a query.\n\nInternally this will do a join to the associated table in the case of a one to many. And will do a join to the associated through table\nand the associated table in the case of a many to many.\n\n__Arguments__\n\n * propertyName - This can be a single property name or an array of property names to include.\n\n__Example__\n\n    Person.include(\"phones\").where('name = ?', 'bob').all(connection, function(err, people) {\n      // all people named 'bob' and all their phone numbers\n      // so you can do... people[0].phones[0].number\n      // as opposed to... people[0].phones.all(function(err, phones) {});\n    });\n\n<a name=\"tx\"/>\n## Transaction\n\n<a name=\"txCommit\"/>\n### tx.commit(callback)\n\nCommits a transaction.\n\n__Arguments__\n\n * callback(err) - Callback called when the transaction has committed.\n\n__Example__\n\n    connection.tx(function(err, tx) {\n      person1.save(connection, function(err) {\n        tx.commit(function(err) {\n          // person1 saved and committed to database\n        });\n      });\n    });\n\n<a name=\"txRollback\"/>\n### tx.rollback(callback)\n\nRollsback a transaction.\n\n__Arguments__\n\n * callback(err) - Callback called when the transaction has rolledback.\n\n__Example__\n\n    connection.tx(function(err, tx) {\n      person1.save(connection, function(err) {\n        tx.rollback(function(err) {\n          // person1 not saved. Transaction rolledback.\n        });\n      });\n    });\n\n<a name=\"resultSetMethods\"/>\n## Result Set\n\n<a name=\"resultSetGetById\"/>\n### rs.getById(id)\n\nGets an item from the result set by id.\n\n__Arguments__\n\n * id - The id of the item to get.\n\n__Example__\n\n    Person.all(connection, function(err, people) {\n      var person2 = people.getById(2);\n    });\n","_id":"persist@0.2.5","dist":{"shasum":"cf9db2c35d6a4f1502f8b3b5dd7919b48d071fbd","tarball":"https://registry.npmjs.org/persist/-/persist-0.2.5.tgz","integrity":"sha512-L3Sl+l8yDhUKwc+KDcNFq3OCKNILDQKu92Ep8VrdUlf1ppJQzGUcEDMiVf/WZDGwX+N6rTo+RnJyBqJjMwFSgg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBLxyYmcx768TgAcTfoLTZop3dCpkWevz+Wj+2mbGduBAiEA6Iriu+jZ7WEcs6QaliYQV2fPNATodJ0helya49LflFA="}]}},"0.2.6":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","author":{"name":"Joe Ferner","email":"joe.ferner@nearinfinity.com"},"keywords":["database","db","orm","sqlite","mysql","PostgreSQL","oracle","db-oracle"],"version":"0.2.6","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"license":"MIT","repository":{"type":"git","url":"https://github.com/nearinfinity/node-persist.git"},"dependencies":{"async":"0.1.15","over":">=0.0.5","db-info":"0.0.3"},"devDependencies":{"nodeunit":"~>0.6.4","sqlite3":"git://github.com/joeferner/node-sqlite3.git"},"scripts":{"test":"nodeunit test"},"main":"./index.js","readme":"# persist\n\npersist is an ORM framework for node.js.\n\nThe following databases are currently supported:\n\n * sqlite3 - via: [node-sqlite3](https://github.com/developmentseed/node-sqlite3)\n * mysql - via: [node-mysql](https://github.com/felixge/node-mysql)\n * PostgreSQL - via: [node-postgres](https://github.com/brianc/node-postgres)\n * Oracle - via: [node-oracle](https://github.com/nearinfinity/node-oracle)\n\n# Quick Examples\n    var persist = require(\"persist\");\n    var type = persist.type;\n\n    // define some model objects\n    Phone = persist.define(\"Phone\", {\n      \"number\": type.STRING\n    });\n\n    Person = persist.define(\"Person\", {\n      \"name\": type.STRING\n    }).hasMany(this.Phone);\n\n    persist.connect({\n      driver: 'sqlite3',\n      filename: 'test.db',\n      trace: true\n    }, function(err, connection) {\n      Person.using(connection).all(function(err, people) {\n        // people contains all the people\n      });\n    });\n\n# Download\n\nYou can install using Node Package Manager (npm):\n\n    npm install persist\n\n# Index\n\n## [database.json](#databaseJson)\n\n## persist\n * [env](#persistEnv)\n * [connect](#persistConnect)\n * [define](#persistDefine)\n * [defineAuto](#persistDefineAuto)\n * [setDefaultConnectOptions](#persistSetDefaultConnectOptions)\n\n## Connection\n\n * [chain](#connectionChain)\n * [tx](#connectionTx)\n * [runSql](#connectionRunSql)\n * [runSqlAll](#connectionRunSqlAll)\n * [runSqlEach](#connectionRunSqlEach)\n * [runSqlFromFile](#connectionRunSqlFromFile)\n * [runSqlAllFromFile](#connectionRunSqlAllFromFile)\n * [runSqlEachFromFile](#connectionRunSqlEachFromFile)\n\n## Model\n\n * [hasMany](#modelHasMany)\n * [hasOne](#modelHasOne)\n * [using](#modelUsing)\n * [save](#modelSave)\n * [update (instance)](#modelInstanceUpdate)\n * [update](#modelUpdate)\n * [delete](#modelDelete)\n * [getById](#modelGetById)\n * [onSave](#modelOnSave)\n * [onLoad](#modelOnLoad)\n * [Associated Object Properties](#associatedObjectProperties)\n\n## Query\n\n * [all](#queryAll)\n * [each](#queryEach)\n * [first](#queryFirst)\n * [last](#queryLast)\n * [orderBy](#queryOrderBy)\n * [limit](#queryLimit)\n * [where](#queryWhere)\n * [whereIn](#queryWhereIn)\n * [count](#queryCount)\n * [min](#queryMin)\n * [max](#queryMax)\n * [deleteAll](#queryDeleteAll)\n * [updateAll](#queryUpdateAll)\n * [include](#queryInclude)\n\n## Transaction\n\n * [commit](#txCommit)\n * [rollback](#txRollback)\n\n## Results Set\n * [getById](#resultSetGetById)\n\n<a name=\"databaseJson\"/>\n# database.json\n\nIf the current working directory contains a file called database.json this file will be loaded upon requiring persist.\nThe file should follow a format like this:\n\n    {\n      \"default\": \"dev\",\n\n      \"dev\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \":memory:\"\n      },\n\n      \"test\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \":memory:\"\n      },\n\n      \"prod\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \"prod.db\"\n        \"sqlDir\": \"./prodSql\"\n      }\n    }\n\n\"default\" specifies which environment to load.\n\n# API Documentation\n\n<a name=\"persist\"/>\n## persist\n\n<a name=\"persistEnv\" />\n### persist.env\n\nThe environment to read from the database.json file. If not set will use the value of default from the database.json.\n\n__Example__\n\n    persist.env = 'prod';\n\n<a name=\"persistConnect\" />\n### persist.connect([options], callback)\n\nConnects to a database.\n\n__Arguments__\n\n * options - (optional) Options used to connect to the database. If options are not specified the default connect options are used.\n             see [database.json](#databaseJson) and [SetDefaultConnectOptions](#persistSetDefaultConnectOptions)\n  * driver - The driver to use to connect (ie sqlite3, mysql, oracle, or postgresql).\n  * db - If db is specified this parameter will be assumed to be an already open connection to the database.\n  * _other_ - see the documentation for your driver. The options hash will be passed to that driver.\n * callback(err, connection) - Callback to be called when the connection is established.\n\n__Example__\n\n    persist.connect({\n      driver: 'sqlite3',\n      filename: 'test.db',\n      trace: true\n    }, function(err, connection) {\n      // connnection esablished\n    });\n\n<a name=\"persistDefine\" />\n### persist.define(modelName, properties): Model\n\nDefines a model object for use in persist.\n\nThe primary key column does not need to be specified and will default to the name 'id' with the attributes dbColumnName='id',\ntype='integer'. You can override the database name using dbColumnName or setting the primaryKey attribute on any column.\n\n__Arguments__\n\n * modelName - The name of the model. This name will map to the database name.\n * properties - Hash of properties (or columns). The value of each property can simply be the type name (ie type.STRING)\n                or it can be a hash of more options.\n  * type - type of the property (ie type.STRING)\n  * defaultValue - this can be a value or a function that will be called each time this model object is created\n  * dbColumnName - the name of the database column. (default: name of the property, all lower case, seperated by '_')\n  * primaryKey - Marks this column as being the primary key column. You can have only one primary key column.\n\n__Returns__\n\n A model class.\n\n__Example__\n\n    Person = persist.define(\"Person\", {\n      \"name\": type.STRING,\n      \"createdDate\": { type: type.DATETIME, defaultValue: function() { return self.testDate1 }, dbColumnName: 'new_date' },\n      \"lastUpdated\": { type: type.DATETIME }\n    })\n\n<a name=\"persistDefineAuto\" />\n### persist.defineAuto(modelName, dbConfig, callback): Model\n\nDefines a model object for use in persist. Columns are defined by the program in this method. Uses an existing database connection to retrieve column data.\n\n__Arguments__\n\n * modelName - The name of the model. This name will map to the table name.\n * dbConfig - Hash of dbConfig. Should contain the driver, as well as the database name.\n * database - The database connection to use.\n * driver - The name of the database driver to use.\n\n__Returns__\n\n A model class.\n\n__Example__\n\n    persist.defineAuto(\"Person\",{driver:dbDriver, db:self.connection.db},function(err,model){\n      Person = model.hasMany(Phone)\n        .on('beforeSave', function (obj) {\n          obj.lastUpdated = testDate;\n        })\n        .on('afterSave', function (obj) {\n          if (!obj.updateCount) obj.updateCount = 0;\n          obj.updateCount++;\n        });\n    });\n\n<a name=\"persistSetDefaultConnectOptions\"/>\n### persist.setDefaultConnectOptions(options)\n\nSets the default connection options to be used on future connect calls. see [database.json](#databaseJson)\n\n__Arguments__\n * options - See [connect](#persistConnect) for the description of options\n\n__Example__\n\n    persist.setDefaultConnectOptions({\n      driver: 'sqlite3',\n      filename: 'test.db',\n      trace: true});\n\n<a name=\"connection\"/>\n## Connection\n\n<a name=\"connectionChain\"/>\n### connection.chain(chainables, callback)\n\nChains multiple statements together in order and gets the results.\n\n__Arguments__\n\n * chainables - An array of chainable queries. These can be save, updates, selects, or deletes. Each item in the array will be\n   executed, wait for the results, and then execute the next. This can also be a hash of queries in which case the results\n   will contain a hash of results where each key corresponds to a key in the results.\n * callback(err, results) - Callback called when all the items have been executed.\n\n__Example__\n\n    // array chaining\n    connection.chain([\n      person3.save,\n      Person.min('age'),\n      Person.max('age'),\n      phone3.delete,\n      person2.delete,\n      Person.orderBy('name').all,\n      Phone.orderBy('number').first,\n      Phone.count,\n      Phone.deleteAll,\n      Phone.all,\n      Person.getById(1),\n      persist.runSql('SELECT * FROM Person')\n    ], function(err, results) {\n      // results[0] = person3\n      // results[1] = 21\n      // results[2] = 25\n      // results[3] = []\n      // results[4] = []\n      // results[5] = -- all people ordered by name\n      // results[6] = -- first phone ordered by number\n      // results[7] = 100\n      // results[8] = []\n      // results[9] = [] -- nobody left\n      // results[10] = -- the person with id 1\n      // results[11] = Results of select.\n    });\n\n    // mapped chaining\n    connection.chain({\n      minAge: Person.min('age'),\n      maxAge: Person.max('age')\n    }, function(err, results) {\n      // results.minAge = 21\n      // results.maxAge = 25\n    });\n\n<a name=\"connectionTx\"/>\n### connection.tx(callback)\n\nBegins a transaction on the connection.\n\n__Arguments__\n\n * callback(err, tx) - Callback called when the transaction has started. tx is a transaction object which you can\n   call [commit](#txCommit) or [rollback](#txRollback)\n\n__Example__\n\n    connection.tx(function(err, tx) {\n      person1.save(connection, function(err) {\n        tx.commit(function(err) {\n          // person1 saved and committed to database\n        });\n      });\n    });\n\n<a name=\"connectionRunSql\"/>\n### connection.runSql(sql, values, callback)\n\nRuns a sql statement that does not return results (INSERT, UPDATE, etc).\n\n__Arguments__\n\n * sql - The SQL statement to run.\n * values - The values to substitute in the SQL statement. This is DB specific but typically you would use \"?\".\n * callback(err, results) - Callback called when SQL statement completes. results will contain the number of affected\n   rows or last insert id.\n\n__Example__\n\n    connection.runSql(\"UPDATE people SET age = ?\", [32], function(err, results) {\n      // people updated\n    });\n\n<a name=\"connectionRunSqlAll\"/>\n### connection.runSqlAll(sql, values, callback)\n\nRuns a sql statement that returns results (ie SELECT).\n\n__Arguments__\n\n * sql - The SQL statement to run.\n * values - The values to substitute in the SQL statement. This is DB specific but typically you would use \"?\".\n * callback(err, results) - Callback called when SQL statement completes. results will contain the row data.\n\n__Example__\n\n    connection.runSqlAll(\"SELECT * FROM people WHERE age = ?\", [32], function(err, people) {\n      // people contains all the people with age 32\n    });\n\n<a name=\"connectionRunSqlEach\"/>\n### connection.runSqlEach(sql, values, callback, doneCallback)\n\nRuns a sql statement that returns results (ie SELECT). This is different from runSqlAll in that it returns each row\nin a seperate callback.\n\n__Arguments__\n\n * sql - The SQL statement to run.\n * values - The values to substitute in the SQL statement. This is DB specific but typically you would use \"?\".\n * callback(err, row) - Callback called for each row returned.\n * doneCallback(err) - Callback called after all the rows have returned.\n\n__Example__\n\n    connection.runSqlEach(\"SELECT * FROM people WHERE age = ?\", [32], function(err, person) {\n      // a single person\n    }, function(err) {\n      // all done\n    });\n\n<a name=\"connectionRunSqlFromFile\"/>\n<a name=\"connectionRunSqlAllFromFile\"/>\n<a name=\"connectionRunSqlEachFromFile\"/>\n### connection.runSqlFromFile(filename, values, callback)\n### connection.runSqlAllFromFile(filename, values, callback)\n### connection.runSqlEachFromFile(filename, values, callback, doneCallback)\n\nSame as [runSql](#connectionRunSql), [runSqlAll](#connectionRunSqlAll), [runSqlEach](#connectionRunSqlEach) except the first parameter is a filename of where to load the SQL from.\n\n__Example__\n\n    connection.runSqlFromFile('report.sql', [32], function(err, person) {\n      // a single person\n    }, function(err) {\n      // all done\n    });\n\n<a name=\"model\" />\n## Model\n\n<a name=\"modelHasMany\" />\n### Model.hasMany(AssociatedModel, [options]): Model\n\nAdds a has many relationship to a model. This will automatically add a property to the associated model which links to this\nmodel. It will also define a property on instances of this model to get the releated objects - see [Associated Object Properties](#associatedObjectProperties)\n\n__Arguments__\n\n * AssociatedModel - The name of the model to associate to.\n * options - (optional) An hash of options.\n  * through - creates a many to many relationship using the value of through as the join table.\n  * name - the name of the property to expose.\n\n__Returns__\n\n The model class object suitable for chaining.\n\n__Example__\n\n    Phone = persist.define(\"Phone\", {\n      \"number\": persist.String\n    });\n\n    Person = persist.define(\"Person\", {\n      \"name\": persist.String\n    }).hasMany(Phone);\n\n<a name=\"modelHasOne\" />\n### Model.hasOne(AssociatedModel, [options]): Model\n\nAdds a has one relationship to a model. This will automatically add a property to the associated model which links to this\nmodel. It will also define a property on instances of this model to get the releated objects - see [Associated Object Properties](#associatedObjectProperties)\n\n__Arguments__\n\n * AssociatedModel - The name of the model to associate to.\n * options - (optional) An hash of options.\n  * foreignKey - The foreign key to use for the relationship\n  * name - the name of the property to expose.\n  * createHasMany - true/false to create the other side of the relationship.\n\n__Returns__\n\n The model class object suitable for chaining.\n\n__Example__\n\n    Phone = persist.define(\"Phone\", {\n      \"number\": persist.String\n    }).hasMany(Person);\n\n    Person = persist.define(\"Person\", {\n      \"name\": persist.String\n    });\n\n<a name=\"modelUsing\" />\n### Model.using(connection): query\n\nGets a query object bound to a connection object.\n\n__Arguments__\n\n * connection - The connection to bind the query object to.\n\n__Returns__\n\n A new [Query](#query) object.\n\n__Example__\n\n    Person.using(connection).first(...);\n\n<a name=\"modelSave\" />\n### Model.save(connection, callback)\n\nSaves the model object to the database\n\n__Arguments__\n\n * connection - The connection to use to save the object with.\n * callback(err) - The callback to be called when the save is complete\n\n__Example__\n\n    person1.save(connection, function() {\n      // person1 saved\n    });\n\n<a name=\"modelInstanceUpdate\" />\n### modelInstance.update(connection, params, callback)\n\nUpdates the model object to the database\n\n__Arguments__\n\n * connection - The connection to use to update the object with.\n * params - Object containing properties to update.\n * callback(err) - The callback to be called when the update is complete\n\n__Example__\n\n    person1.update(connection, { name: 'Tom' }, function() {\n      // person1 saved\n    });\n\n<a name=\"modelUpdate\" />\n### Model.update(connection, id, params, callback)\n\nUpdates the model object specified with id to the database. This will only update the values\nspecified and will not retreive the item from the database first.\n\n__Arguments__\n\n * connection - The connection to use to update the object with.\n * id - The id of the row you would like to update.\n * params - Object containing properties to update.\n * callback(err) - The callback to be called when the update is complete\n\n__Example__\n\n    Person.update(connection, 5, { name: 'Tom' }, function() {\n      // person with id = 5 updated with name 'Tom'.\n    });\n\n    // or chaining\n    connection.chain([\n      Person.update(5, { name: 'Tom' })\n    ], function(err, results) {\n      // person with id = 5 updated with name 'Tom'.\n    });\n\n<a name=\"modelDelete\" />\n### Model.delete(connection, callback)\n\nDeletes the model object from the database\n\n__Arguments__\n\n * connection - The connection to use to delete the object with.\n * callback(err) - The callback to be called when the delete is complete\n\n__Example__\n\n    person1.delete(connection, function() {\n      // person1 deleted\n    });\n\n<a name=\"modelGetById\" />\n### Model.getById(connection, id, callback)\n\nGets an object from the database by id.\n\n__Arguments__\n\n * connection - The connection to use to delete the object with.\n * id - The if of the item to get.\n * callback(err, obj) - The callback to be called when the delete is complete\n\n__Example__\n\n    Person.getById(connection, 1, function(err, person) {\n      // person is the person with id equal to 1. Or null if not found\n    });\n\n<a name=\"modelOnSave\" />\n### Model.onSave(obj)\n\nIf preset this function will be called when an update or save occures. You would typically create this method\nin your model file.\n\n__Arguments__\n\n * obj - The object or partial object, in the case of [update](#modelUpdate), being saved.\n\n__Example__\n\n    Person.onSave = function(obj) {\n      obj.lastUpdated = new Date();\n    };\n\n<a name=\"modelOnLoad\" />\n### Model.onLoad(obj)\n\nIf preset this function will be called after an object is loaded from the database. You would typically\ncreate this method in your model file.\n\n__Arguments__\n\n * obj - The object that was just loaded from the database.\n\n__Example__\n\n    Person.onLoad = function(obj) {\n      obj.fullName = obj.firstName + ' ' + obj.lastName;\n    };\n\n<a name=\"associatedObjectProperties\" />\n### Associated Object Properties\n\nIf you have setup an associated property using [hasMany](#modelHasMany) instances of your model will have an additional property\nwhich allows you to get the associated data. This property returns a [Query](#query) object which you can further chain to limit\nthe results.\n\n__Example__\n\n    Phone = persist.define(\"Phone\", {\n      \"number\": persist.String\n    });\n\n    Person = persist.define(\"Person\", {\n      \"name\": persist.String\n    }).hasMany(Phone);\n\n    Person.using(connection).first(function(err, person) {\n      person.phones.orderBy('number').all(function(err, phones) {\n        // all the phones of the first person\n      });\n    });\n\n<a name=\"query\" />\n## Query\n\n<a name=\"queryAll\" />\n### query.all([connection], callback)\n\nGets all items from a query as a single array of items. The array returned will have additional\nmethods see [here for documentation](#resultSetMethods).\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, items) - Callback to be called after the rows have been fetched. items is an array of model instances.\n\n__Example__\n\n    Person.all(connection, function(err, people) {\n      // all the people\n    });\n\n<a name=\"queryEach\" />\n### query.each([connection], callback, doneCallback)\n\nGets items from a query calling the callback for each item returned.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after each row has been fetched. item is a model instance.\n * doneCallback(err) - Callback called after all rows have been retrieved.\n\n__Example__\n\n    Person.each(connection, function(err, person) {\n      // a person\n    }, function() {\n      // all done\n    });\n\n<a name=\"queryFirst\" />\n### query.first([connection], callback)\n\nGets the first item from a query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after the row has been fetched. item is a model instance.\n\n__Example__\n\n    Person.first(connection, function(err, person) {\n      // gets the first person\n    });\n\n<a name=\"queryLast\" />\n### query.last([connection], callback)\n\nGets the last item from a query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after the row has been fetched. item is a model instance.\n\n__Example__\n\n    Person.last(connection, function(err, person) {\n      // gets the last person\n    });\n\n\n<a name=\"queryOrderBy\" />\n### query.orderBy(propertyName, direction): query\n\nOrders the results of a query.\n\n__Arguments__\n\n * propertyName - Name of the property to order by.\n * direction - The direction to orderBy. Can be persist.Ascending or persist.Descending.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.orderBy('name').all(connection, function(err, people) {\n      // all the people ordered by name\n    });\n\n<a name=\"queryLimit\" />\n### query.limit(count, [offset]): query\n\nLimits the number of results of a query.\n\n__Arguments__\n\n * count - Number of items to return.\n * offset - (Optional) The number of items to skip.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.orderBy('name').limit(5, 5).all(connection, function(err, people) {\n      // The 5-10 people ordered by name\n    });\n\n<a name=\"queryWhere\" />\n### query.where(clause, [values...]): query\n### query.where(hash): query\n\nFilters the results by a where clause.\n\n__Arguments__\n\n * clause - A clause to filter the results by.\n * values - (Optional) A single value or array of values to substitute in for '?'s in the clause.\n * hash - A hash of columns and values to match on (see example)\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.where('name = ?', 'bob').all(connection, function(err, people) {\n      // All the people named 'bob'\n    });\n\n    Person.where('name = ? or age = ?', ['bob', 23]).all(connection, function(err, people) {\n      // All the people named 'bob' or people with age 23\n    });\n\n    Person.where({'name': 'bob', 'age': 23}).all(connection, function(err, people) {\n      // All the people named 'bob' with the age of 23\n    });\n\n<a name=\"queryWhereIn\" />\n### query.whereIn(property, [values...]): query\nFilters the results by a where clause using an IN clause.\n\n__Arguments__\n * property - The property to invoke the IN clause on.\n * values - An array of values to include in the IN clause.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.whereIn('name', ['bob', 'alice', 'cindy']).all(connection, function(err,people) {\n      // All the people named 'bob', 'alice', or 'cindy'\n    });\n\n    Person.include(\"phones\").whereIn('phones.number', ['111-2222','333-4444']).all(connection, function(err,people){\n      // All the people whose phone numbers are '111-2222' or '333-4444'\n    });\n\n<a name=\"queryCount\" />\n### query.count([connection], callback)\n\nCounts the number of items that would be returned by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, count) - Callback with the count of items.\n\n__Example__\n\n    Person.where('name = ?', 'bob').count(connection, function(err, count) {\n      // count = the number of people with the name bob\n    });\n\n<a name=\"queryMin\" />\n### query.min([connection], fieldName, callback)\n\nGets the minimum value in the query of the given field.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * fieldName - The field name of the value you would like to get the minimum for.\n * callback(err, min) - Callback with the minimum value.\n\n__Example__\n\n    Person.where('name = ?', 'bob').min(connection, 'age', function(err, min) {\n      // the minimum age of all bobs\n    });\n\n<a name=\"queryMax\" />\n### query.max([connection], fieldName, callback)\n\nGets the maximum value in the query of the given field.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * fieldName - The field name of the value you would like to get the maximum for.\n * callback(err, min) - Callback with the maximum value.\n\n__Example__\n\n    Person.where('name = ?', 'bob').max(connection, 'age', function(err, min) {\n      // the maximum age of all bobs\n    });\n\n\n<a name=\"queryDeleteAll\" />\n### query.deleteAll([connection], callback)\n\nDeletes all the items specified by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err) - Callback called upon completion.\n\n__Example__\n\n    Person.where('name = ?', 'bob').deleteAll(connection, function(err) {\n      // all people name 'bob' have been deleted.\n    });\n\n<a name=\"queryUpdateAll\" />\n### query.updateAll([connection], data, callback)\n\nUpdates all the items specified by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * data - A hash of properties to update. Key is the property name to update. Value is the value to update the property to.\n * callback(err) - Callback called upon completion.\n\n__Example__\n\n    Person.where('name = ?', 'bob').updateAll(connection, { age: 25 }, function(err) {\n      // all people name 'bob' have their age set to 25.\n    });\n\n<a name=\"queryInclude\" />\n### query.include(propertyName): query\n\nIncludes the associated data linked by (hasMany or hasMany(through)) the propertyName when retrieving data from the database.\nThis will replace obj.propertyName with an array of results as opposed to the default before which is a query.\n\nInternally this will do a join to the associated table in the case of a one to many. And will do a join to the associated through table\nand the associated table in the case of a many to many.\n\n__Arguments__\n\n * propertyName - This can be a single property name or an array of property names to include.\n\n__Example__\n\n    Person.include(\"phones\").where('name = ?', 'bob').all(connection, function(err, people) {\n      // all people named 'bob' and all their phone numbers\n      // so you can do... people[0].phones[0].number\n      // as opposed to... people[0].phones.all(function(err, phones) {});\n    });\n\n<a name=\"tx\"/>\n## Transaction\n\n<a name=\"txCommit\"/>\n### tx.commit(callback)\n\nCommits a transaction.\n\n__Arguments__\n\n * callback(err) - Callback called when the transaction has committed.\n\n__Example__\n\n    connection.tx(function(err, tx) {\n      person1.save(connection, function(err) {\n        tx.commit(function(err) {\n          // person1 saved and committed to database\n        });\n      });\n    });\n\n<a name=\"txRollback\"/>\n### tx.rollback(callback)\n\nRollsback a transaction.\n\n__Arguments__\n\n * callback(err) - Callback called when the transaction has rolledback.\n\n__Example__\n\n    connection.tx(function(err, tx) {\n      person1.save(connection, function(err) {\n        tx.rollback(function(err) {\n          // person1 not saved. Transaction rolledback.\n        });\n      });\n    });\n\n<a name=\"resultSetMethods\"/>\n## Result Set\n\n<a name=\"resultSetGetById\"/>\n### rs.getById(id)\n\nGets an item from the result set by id.\n\n__Arguments__\n\n * id - The id of the item to get.\n\n__Example__\n\n    Person.all(connection, function(err, people) {\n      var person2 = people.getById(2);\n    });\n","_id":"persist@0.2.6","dist":{"shasum":"fd1f34232617bcd06f83d16ab85151414aa54661","tarball":"https://registry.npmjs.org/persist/-/persist-0.2.6.tgz","integrity":"sha512-MTFA0LiGafr8yRvNZq9U6HlZROJ6CQaf7Use4x1RFGTEjVcgKnkhDRCJB0cTcoeYOwPdnxosVuex2NvNpijixQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDLjeQopzfOKYHg5gJm8Xt/PTD9po10LmMxATHwejhFLgIhAM99OCMY702LGY8lCnfsN5I8j9cx95iROxDWdTfRvo2l"}]},"_npmVersion":"1.1.49","_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"}},"0.2.7":{"name":"persist","description":"Node.js ORM framework supporting various relational databases","author":{"name":"Joe Ferner","email":"joe.ferner@nearinfinity.com"},"keywords":["database","db","orm","sqlite","mysql","PostgreSQL","oracle","db-oracle"],"version":"0.2.7","engines":{"node":">=0.6.0"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"bugs":{"url":"https://github.com/nearinfinity/node-persist/issues"},"license":"MIT","repository":{"type":"git","url":"https://github.com/nearinfinity/node-persist.git"},"dependencies":{"async":"0.1.15","over":">=0.0.5","db-info":"0.0.3","generic-pool":"~2.0.2"},"devDependencies":{"nodeunit":"~>0.6.4","sqlite3":"git://github.com/joeferner/node-sqlite3.git"},"scripts":{"test":"nodeunit test"},"main":"./index.js","readme":"# persist\n\npersist is an ORM framework for node.js.\n\nThe following databases are currently supported:\n\n * sqlite3 - via: [node-sqlite3](https://github.com/developmentseed/node-sqlite3)\n * mysql - via: [node-mysql](https://github.com/felixge/node-mysql)\n * PostgreSQL - via: [node-postgres](https://github.com/brianc/node-postgres)\n * Oracle - via: [node-oracle](https://github.com/nearinfinity/node-oracle)\n\n# Quick Examples\n```javascript\nvar persist = require(\"persist\");\nvar type = persist.type;\n\n// define some model objects\nPhone = persist.define(\"Phone\", {\n  \"number\": type.STRING\n});\n\nPerson = persist.define(\"Person\", {\n  \"name\": type.STRING\n}).hasMany(this.Phone);\n\npersist.connect({\n  driver: 'sqlite3',\n  filename: 'test.db',\n  trace: true\n}, function(err, connection) {\n  Person.using(connection).all(function(err, people) {\n    // people contains all the people\n  });\n});\n```\n# Download\n\nYou can install using Node Package Manager (npm):\n\n    npm install persist\n\n# Index\n\n## [database.json](#databaseJson)\n\n## persist\n * [env](#persistEnv)\n * [connect](#persistConnect)\n * [define](#persistDefine)\n * [defineAuto](#persistDefineAuto)\n * [setDefaultConnectOptions](#persistSetDefaultConnectOptions)\n * [shutdown](#persistShutdown)\n\n## Connection\n\n * [chain](#connectionChain)\n * [tx](#connectionTx)\n * [runSql](#connectionRunSql)\n * [runSqlAll](#connectionRunSqlAll)\n * [runSqlEach](#connectionRunSqlEach)\n * [runSqlFromFile](#connectionRunSqlFromFile)\n * [runSqlAllFromFile](#connectionRunSqlAllFromFile)\n * [runSqlEachFromFile](#connectionRunSqlEachFromFile)\n\n## Model\n\n * [hasMany](#modelHasMany)\n * [hasOne](#modelHasOne)\n * [using](#modelUsing)\n * [save](#modelSave)\n * [update (instance)](#modelInstanceUpdate)\n * [update](#modelUpdate)\n * [delete](#modelDelete)\n * [getById](#modelGetById)\n * [onSave](#modelOnSave)\n * [onLoad](#modelOnLoad)\n * [Associated Object Properties](#associatedObjectProperties)\n\n## Query\n\n * [all](#queryAll)\n * [each](#queryEach)\n * [first](#queryFirst)\n * [last](#queryLast)\n * [orderBy](#queryOrderBy)\n * [limit](#queryLimit)\n * [where](#queryWhere)\n * [whereIn](#queryWhereIn)\n * [count](#queryCount)\n * [min](#queryMin)\n * [max](#queryMax)\n * [sum](#querySum)\n * [deleteAll](#queryDeleteAll)\n * [updateAll](#queryUpdateAll)\n * [include](#queryInclude)\n\n## Transaction\n\n * [commit](#txCommit)\n * [rollback](#txRollback)\n\n## Results Set\n * [getById](#resultSetGetById)\n\n## Connection Pooling\n * [using](#connectionPoolingUsing)\n\n<a name=\"databaseJson\"/>\n# database.json\n\nIf the current working directory contains a file called database.json this file will be loaded upon requiring persist.\nThe file should follow a format like this:\n\n    {\n      \"default\": \"dev\",\n\n      \"dev\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \":memory:\"\n      },\n\n      \"test\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \":memory:\"\n      },\n\n      \"prod\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \"prod.db\"\n        \"sqlDir\": \"./prodSql\",\n        \"pooling\": {\n          \"name\": \"testPool\",\n          \"max\": 2,\n          \"min\": 1,\n          \"idleTimeoutMillis\": 30000\n        }\n      }\n    }\n\n\"default\" specifies which environment to load.\n\n# API Documentation\n\n<a name=\"persist\"/>\n## persist\n\n<a name=\"persistEnv\" />\n### persist.env\n\nThe environment to read from the database.json file. If not set will use the value of default from the database.json.\n\n__Example__\n\n    persist.env = 'prod';\n\n<a name=\"persistConnect\" />\n### persist.connect([options], callback)\n\nConnects to a database.\n\n__Arguments__\n\n * options - (optional) Options used to connect to the database. If options are not specified the default connect options are used.\n             see [database.json](#databaseJson) and [SetDefaultConnectOptions](#persistSetDefaultConnectOptions)\n  * driver - The driver to use to connect (ie sqlite3, mysql, oracle, or postgresql).\n  * db - If db is specified this parameter will be assumed to be an already open connection to the database.\n  * _other_ - see the documentation for your driver. The options hash will be passed to that driver.\n * callback(err, connection) - Callback to be called when the connection is established.\n\n__Example__\n```javascript\npersist.connect({\n  driver: 'sqlite3',\n  filename: 'test.db',\n  trace: true\n}, function(err, connection) {\n  // connnection esablished\n});\n```\n<a name=\"persistDefine\" />\n### persist.define(modelName, properties, [opts]): Model\n\nDefines a model object for use in persist.\n\nThe primary key column does not need to be specified and will default to the name 'id' with the attributes dbColumnName='id',\ntype='integer'. You can override the database name using dbColumnName or setting the primaryKey attribute on any column.\n\n__Arguments__\n\n * modelName - The name of the model. This name will map to the database name.\n * properties - Hash of properties (or columns). The value of each property can simply be the type name (ie type.STRING)\n                or it can be a hash of more options.\n  * type - type of the property (ie type.STRING)\n  * defaultValue - this can be a value or a function that will be called each time this model object is created\n  * dbColumnName - the name of the database column. (default: name of the property, all lower case, seperated by '_')\n  * primaryKey - Marks this column as being the primary key column. You can have only one primary key column.\n * opts - Options for this column.\n  * tableName - The name of the table (default: modelName pluralized).\n\n__Returns__\n\n A model class.\n\n__Example__\n```javascript\nPerson = persist.define(\"Person\", {\n  \"name\": type.STRING,\n  \"createdDate\": { type: type.DATETIME, defaultValue: function() { return self.testDate1 }, dbColumnName: 'new_date' },\n  \"lastUpdated\": { type: type.DATETIME }\n})\n```\n<a name=\"persistDefineAuto\" />\n### persist.defineAuto(modelName, dbConfig, callback): Model\n\nDefines a model object for use in persist. Columns are defined by the program in this method. Uses an existing database connection to retrieve column data.\n\n__Arguments__\n\n * modelName - The name of the model. This name will map to the table name.\n * dbConfig - Hash of dbConfig. Should contain the driver, as well as the database name.\n * database - The database connection to use.\n * driver - The name of the database driver to use.\n\n__Returns__\n\n A model class.\n\n__Example__\n```javascript\npersist.defineAuto(\"Person\",{driver:dbDriver, db:self.connection.db},function(err,model){\n  Person = model.hasMany(Phone)\n    .on('beforeSave', function (obj) {\n      obj.lastUpdated = testDate;\n    })\n    .on('afterSave', function (obj) {\n      if (!obj.updateCount) obj.updateCount = 0;\n      obj.updateCount++;\n    });\n});\n```\n<a name=\"persistSetDefaultConnectOptions\"/>\n### persist.setDefaultConnectOptions(options)\n\nSets the default connection options to be used on future connect calls. see [database.json](#databaseJson)\n\n__Arguments__\n * options - See [connect](#persistConnect) for the description of options\n\n__Example__\n```javascript\npersist.setDefaultConnectOptions({\n  driver: 'sqlite3',\n  filename: 'test.db',\n  trace: true});\n```\n<a name=\"persistShutdown\"/>\n### persist.shutdown([callback])\n\nShutdown persist. This is currently only required if you are using connection pooling. see [generic-pool](https://github.com/coopernurse/node-pool).\n\n__Arguments__\n * [callback] - Optional callback on successful shutdown.\n\n__Example__\n```javascript\npersist.shutdown(function() {\n  console.log('persist shutdown');\n});\n```\n<a name=\"connection\"/>\n## Connection\n\n<a name=\"connectionChain\"/>\n### connection.chain(chainables, callback)\n\nChains multiple statements together in order and gets the results.\n\n__Arguments__\n\n * chainables - An array of chainable queries. These can be save, updates, selects, or deletes. Each item in the array will be\n   executed, wait for the results, and then execute the next. This can also be a hash of queries in which case the results\n   will contain a hash of results where each key corresponds to a key in the results.\n * callback(err, results) - Callback called when all the items have been executed.\n\n__Example__\n```javascript\n// array chaining\nconnection.chain([\n  person3.save,\n  Person.min('age'),\n  Person.max('age'),\n  phone3.delete,\n  person2.delete,\n  Person.orderBy('name').all,\n  Phone.orderBy('number').first,\n  Phone.count,\n  Phone.deleteAll,\n  Phone.all,\n  Person.getById(1),\n  persist.runSql('SELECT * FROM Person')\n], function(err, results) {\n  // results[0] = person3\n  // results[1] = 21\n  // results[2] = 25\n  // results[3] = []\n  // results[4] = []\n  // results[5] = -- all people ordered by name\n  // results[6] = -- first phone ordered by number\n  // results[7] = 100\n  // results[8] = []\n  // results[9] = [] -- nobody left\n  // results[10] = -- the person with id 1\n  // results[11] = Results of select.\n});\n\n// mapped chaining\nconnection.chain({\n  minAge: Person.min('age'),\n  maxAge: Person.max('age')\n}, function(err, results) {\n  // results.minAge = 21\n  // results.maxAge = 25\n});\n```\n<a name=\"connectionTx\"/>\n### connection.tx(callback)\n\nBegins a transaction on the connection.\n\n__Arguments__\n\n * callback(err, tx) - Callback called when the transaction has started. tx is a transaction object which you can\n   call [commit](#txCommit) or [rollback](#txRollback)\n\n__Example__\n```javascript\nconnection.tx(function(err, tx) {\n  person1.save(connection, function(err) {\n    tx.commit(function(err) {\n      // person1 saved and committed to database\n    });\n  });\n});\n```\n<a name=\"connectionRunSql\"/>\n### connection.runSql(sql, values, callback)\n\nRuns a sql statement that does not return results (INSERT, UPDATE, etc).\n\n__Arguments__\n\n * sql - The SQL statement to run.\n * values - The values to substitute in the SQL statement. This is DB specific but typically you would use \"?\".\n * callback(err, results) - Callback called when SQL statement completes. results will contain the number of affected\n   rows or last insert id.\n\n__Example__\n```javascript\nconnection.runSql(\"UPDATE people SET age = ?\", [32], function(err, results) {\n  // people updated\n});\n```\n<a name=\"connectionRunSqlAll\"/>\n### connection.runSqlAll(sql, values, callback)\n\nRuns a sql statement that returns results (ie SELECT).\n\n__Arguments__\n\n * sql - The SQL statement to run.\n * values - The values to substitute in the SQL statement. This is DB specific but typically you would use \"?\".\n * callback(err, results) - Callback called when SQL statement completes. results will contain the row data.\n\n__Example__\n```javascript\nconnection.runSqlAll(\"SELECT * FROM people WHERE age = ?\", [32], function(err, people) {\n  // people contains all the people with age 32\n});\n```\n<a name=\"connectionRunSqlEach\"/>\n### connection.runSqlEach(sql, values, callback, doneCallback)\n\nRuns a sql statement that returns results (ie SELECT). This is different from runSqlAll in that it returns each row\nin a seperate callback.\n\n__Arguments__\n\n * sql - The SQL statement to run.\n * values - The values to substitute in the SQL statement. This is DB specific but typically you would use \"?\".\n * callback(err, row) - Callback called for each row returned.\n * doneCallback(err) - Callback called after all the rows have returned.\n\n__Example__\n```javascript\nconnection.runSqlEach(\"SELECT * FROM people WHERE age = ?\", [32], function(err, person) {\n  // a single person\n}, function(err) {\n  // all done\n});\n```\n<a name=\"connectionRunSqlFromFile\"/>\n<a name=\"connectionRunSqlAllFromFile\"/>\n<a name=\"connectionRunSqlEachFromFile\"/>\n### connection.runSqlFromFile(filename, values, callback)\n### connection.runSqlAllFromFile(filename, values, callback)\n### connection.runSqlEachFromFile(filename, values, callback, doneCallback)\n\nSame as [runSql](#connectionRunSql), [runSqlAll](#connectionRunSqlAll), [runSqlEach](#connectionRunSqlEach) except the first parameter is a filename of where to load the SQL from.\n\n__Example__\n```javascript\nconnection.runSqlFromFile('report.sql', [32], function(err, person) {\n  // a single person\n}, function(err) {\n  // all done\n});\n```\n<a name=\"model\" />\n## Model\n\n<a name=\"modelHasMany\" />\n### Model.hasMany(AssociatedModel, [options]): Model\n\nAdds a has many relationship to a model. This will automatically add a property to the associated model which links to this\nmodel. It will also define a property on instances of this model to get the releated objects - see [Associated Object Properties](#associatedObjectProperties)\n\n__Arguments__\n\n * AssociatedModel - The name of the model to associate to.\n * options - (optional) An hash of options.\n  * through - creates a many to many relationship using the value of through as the join table.\n  * name - the name of the property to expose.\n\n__Returns__\n\n The model class object suitable for chaining.\n\n__Example__\n```javascript\nPhone = persist.define(\"Phone\", {\n  \"number\": persist.String\n});\n\nPerson = persist.define(\"Person\", {\n  \"name\": persist.String\n}).hasMany(Phone);\n```\n<a name=\"modelHasOne\" />\n### Model.hasOne(AssociatedModel, [options]): Model\n\nAdds a has one relationship to a model. This will automatically add a property to the associated model which links to this\nmodel. It will also define a property on instances of this model to get the releated objects - see [Associated Object Properties](#associatedObjectProperties)\n\n__Arguments__\n\n * AssociatedModel - The name of the model to associate to.\n * options - (optional) An hash of options.\n  * foreignKey - The foreign key to use for the relationship\n  * name - the name of the property to expose.\n  * createHasMany - true/false to create the other side of the relationship.\n\n__Returns__\n\n The model class object suitable for chaining.\n\n__Example__\n```javascript\nPhone = persist.define(\"Phone\", {\n  \"number\": persist.String\n}).hasMany(Person);\n\nPerson = persist.define(\"Person\", {\n  \"name\": persist.String\n});\n```\n<a name=\"modelUsing\" />\n### Model.using(connection): query\n\nGets a query object bound to a connection object.\n\n__Arguments__\n\n * connection - The connection to bind the query object to.\n\n__Returns__\n\n A new [Query](#query) object.\n\n__Example__\n```javascript\nPerson.using(connection).first(...);\n```\n<a name=\"modelSave\" />\n### Model.save(connection, callback)\n\nSaves the model object to the database\n\n__Arguments__\n\n * connection - The connection to use to save the object with.\n * callback(err) - The callback to be called when the save is complete\n\n__Example__\n```javascript\nperson1.save(connection, function() {\n  // person1 saved\n});\n```\n<a name=\"modelInstanceUpdate\" />\n### modelInstance.update(connection, params, callback)\n\nUpdates the model object to the database\n\n__Arguments__\n\n * connection - The connection to use to update the object with.\n * params - Object containing properties to update.\n * callback(err) - The callback to be called when the update is complete\n\n__Example__\n```javascript\nperson1.update(connection, { name: 'Tom' }, function() {\n  // person1 saved\n});\n```\n<a name=\"modelUpdate\" />\n### Model.update(connection, id, params, callback)\n\nUpdates the model object specified with id to the database. This will only update the values\nspecified and will not retreive the item from the database first.\n\n__Arguments__\n\n * connection - The connection to use to update the object with.\n * id - The id of the row you would like to update.\n * params - Object containing properties to update.\n * callback(err) - The callback to be called when the update is complete\n\n__Example__\n```javascript\nPerson.update(connection, 5, { name: 'Tom' }, function() {\n  // person with id = 5 updated with name 'Tom'.\n});\n\n// or chaining\nconnection.chain([\n  Person.update(5, { name: 'Tom' })\n], function(err, results) {\n  // person with id = 5 updated with name 'Tom'.\n});\n```\n<a name=\"modelDelete\" />\n### Model.delete(connection, callback)\n\nDeletes the model object from the database\n\n__Arguments__\n\n * connection - The connection to use to delete the object with.\n * callback(err) - The callback to be called when the delete is complete\n\n__Example__\n```javascript\nperson1.delete(connection, function() {\n  // person1 deleted\n});\n```\n<a name=\"modelGetById\" />\n### Model.getById(connection, id, callback)\n\nGets an object from the database by id.\n\n__Arguments__\n\n * connection - The connection to use to delete the object with.\n * id - The if of the item to get.\n * callback(err, obj) - The callback to be called when the delete is complete\n\n__Example__\n```javascript\nPerson.getById(connection, 1, function(err, person) {\n  // person is the person with id equal to 1. Or null if not found\n});\n```\n<a name=\"modelOnSave\" />\n### Model.onSave(obj, connection, callback)\n\nIf preset this function will be called when an update or save occures. You would typically create this method\nin your model file.\n\n__Arguments__\n\n * obj - The object or partial object, in the case of [update](#modelUpdate), being saved.\n * connection - The connection persist is currently using to do the save\n * callback() - The callback to be called when the onSave is complete\n\n__Example__\n```javascript\nPerson.onSave = function(obj, connection, callback) {\n  obj.lastUpdated = new Date();\n  callback();\n};\n```\n<a name=\"modelOnLoad\" />\n### Model.onLoad(obj)\n\nIf preset this function will be called after an object is loaded from the database. You would typically\ncreate this method in your model file.\n\n__Arguments__\n\n * obj - The object that was just loaded from the database.\n\n__Example__\n```javascript\nPerson.onLoad = function(obj) {\n  obj.fullName = obj.firstName + ' ' + obj.lastName;\n};\n```\n<a name=\"associatedObjectProperties\" />\n### Associated Object Properties\n\nIf you have setup an associated property using [hasMany](#modelHasMany) instances of your model will have an additional property\nwhich allows you to get the associated data. This property returns a [Query](#query) object which you can further chain to limit\nthe results.\n\n__Example__\n```javascript\nPhone = persist.define(\"Phone\", {\n  \"number\": persist.String\n});\n\nPerson = persist.define(\"Person\", {\n  \"name\": persist.String\n}).hasMany(Phone);\n\nPerson.using(connection).first(function(err, person) {\n  person.phones.orderBy('number').all(function(err, phones) {\n    // all the phones of the first person\n  });\n});\n```\n<a name=\"query\" />\n## Query\n\n<a name=\"queryAll\" />\n### query.all([connection], callback)\n\nGets all items from a query as a single array of items. The array returned will have additional\nmethods see [here for documentation](#resultSetMethods).\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, items) - Callback to be called after the rows have been fetched. items is an array of model instances.\n\n__Example__\n```javascript\nPerson.all(connection, function(err, people) {\n  // all the people\n});\n```\n<a name=\"queryEach\" />\n### query.each([connection], callback, doneCallback)\n\nGets items from a query calling the callback for each item returned.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after each row has been fetched. item is a model instance.\n * doneCallback(err) - Callback called after all rows have been retrieved.\n\n__Example__\n```javascript\nPerson.each(connection, function(err, person) {\n  // a person\n}, function() {\n  // all done\n});\n```\n<a name=\"queryFirst\" />\n### query.first([connection], callback)\n\nGets the first item from a query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after the row has been fetched. item is a model instance.\n\n__Example__\n```javascript\nPerson.first(connection, function(err, person) {\n  // gets the first person\n});\n```\n<a name=\"queryLast\" />\n### query.last([connection], callback)\n\nGets the last item from a query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after the row has been fetched. item is a model instance.\n\n__Example__\n```javascript\nPerson.last(connection, function(err, person) {\n  // gets the last person\n});\n```\n<a name=\"queryOrderBy\" />\n### query.orderBy(propertyName, direction): query\n\nOrders the results of a query.\n\n__Arguments__\n\n * propertyName - Name of the property to order by.\n * direction - The direction to orderBy. Can be persist.Ascending or persist.Descending.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n```javascript\nPerson.orderBy('name').all(connection, function(err, people) {\n  // all the people ordered by name\n});\n```\n<a name=\"queryLimit\" />\n### query.limit(count, [offset]): query\n\nLimits the number of results of a query.\n\n__Arguments__\n\n * count - Number of items to return.\n * offset - (Optional) The number of items to skip.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n```javascript\nPerson.orderBy('name').limit(5, 5).all(connection, function(err, people) {\n  // The 5-10 people ordered by name\n});\n```\n<a name=\"queryWhere\" />\n### query.where(clause, [values...]): query\n### query.where(hash): query\n\nFilters the results by a where clause.\n\n__Arguments__\n\n * clause - A clause to filter the results by.\n * values - (Optional) A single value or array of values to substitute in for '?'s in the clause.\n * hash - A hash of columns and values to match on (see example)\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n```javascript\nPerson.where('name = ?', 'bob').all(connection, function(err, people) {\n  // All the people named 'bob'\n});\n\nPerson.where('name = ? or age = ?', ['bob', 23]).all(connection, function(err, people) {\n  // All the people named 'bob' or people with age 23\n});\n\nPerson.where({'name': 'bob', 'age': 23}).all(connection, function(err, people) {\n  // All the people named 'bob' with the age of 23\n});\n```\n<a name=\"queryWhereIn\" />\n### query.whereIn(property, [values...]): query\nFilters the results by a where clause using an IN clause.\n\n__Arguments__\n * property - The property to invoke the IN clause on.\n * values - An array of values to include in the IN clause.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n```javascript\nPerson.whereIn('name', ['bob', 'alice', 'cindy']).all(connection, function(err,people) {\n  // All the people named 'bob', 'alice', or 'cindy'\n});\n\nPerson.include(\"phones\").whereIn('phones.number', ['111-2222','333-4444']).all(connection, function(err,people){\n  // All the people whose phone numbers are '111-2222' or '333-4444'\n});\n```\n<a name=\"queryCount\" />\n### query.count([connection], callback)\n\nCounts the number of items that would be returned by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, count) - Callback with the count of items.\n\n__Example__\n```javascript\nPerson.where('name = ?', 'bob').count(connection, function(err, count) {\n  // count = the number of people with the name bob\n});\n```\n<a name=\"queryMin\" />\n### query.min([connection], fieldName, callback)\n\nGets the minimum value in the query of the given field.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * fieldName - The field name of the value you would like to get the minimum for.\n * callback(err, min) - Callback with the minimum value.\n\n__Example__\n```javascript\nPerson.where('name = ?', 'bob').min(connection, 'age', function(err, min) {\n  // the minimum age of all bobs\n});\n```\n<a name=\"queryMax\" />\n### query.max([connection], fieldName, callback)\n\nGets the maximum value in the query of the given field.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * fieldName - The field name of the value you would like to get the maximum for.\n * callback(err, min) - Callback with the maximum value.\n\n__Example__\n```javascript\nPerson.where('name = ?', 'bob').max(connection, 'age', function(err, min) {\n  // the maximum age of all bobs\n});\n```\n<a name=\"querySum\" />\n### query.sum([connection], fieldName, callback)\n\nGets the sum of all values in the query of the given field.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * fieldName - The field name you would like to sum.\n * callback(err, sum) - Callback with the sum value.\n\n__Example__\n```javascript\nPerson.where('name = ?', 'bob').sum(connection, 'age', function(err, sum) {\n  // the sum of all ages whos name is bob\n});\n```\n<a name=\"queryDeleteAll\" />\n### query.deleteAll([connection], callback)\n\nDeletes all the items specified by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err) - Callback called upon completion.\n\n__Example__\n```javascript\nPerson.where('name = ?', 'bob').deleteAll(connection, function(err) {\n  // all people name 'bob' have been deleted.\n});\n```\n<a name=\"queryUpdateAll\" />\n### query.updateAll([connection], data, callback)\n\nUpdates all the items specified by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * data - A hash of properties to update. Key is the property name to update. Value is the value to update the property to.\n * callback(err) - Callback called upon completion.\n\n__Example__\n```javascript\nPerson.where('name = ?', 'bob').updateAll(connection, { age: 25 }, function(err) {\n  // all people name 'bob' have their age set to 25.\n});\n```\n<a name=\"queryInclude\" />\n### query.include(propertyName): query\n\nIncludes the associated data linked by (hasMany or hasMany(through)) the propertyName when retrieving data from the database.\nThis will replace obj.propertyName with an array of results as opposed to the default before which is a query.\n\nInternally this will do a join to the associated table in the case of a one to many. And will do a join to the associated through table\nand the associated table in the case of a many to many.\n\n__Arguments__\n\n * propertyName - This can be a single property name or an array of property names to include.\n\n__Example__\n```javascript\nPerson.include(\"phones\").where('name = ?', 'bob').all(connection, function(err, people) {\n  // all people named 'bob' and all their phone numbers\n  // so you can do... people[0].phones[0].number\n  // as opposed to... people[0].phones.all(function(err, phones) {});\n});\n```\n<a name=\"tx\"/>\n## Transaction\n\n<a name=\"txCommit\"/>\n### tx.commit(callback)\n\nCommits a transaction.\n\n__Arguments__\n\n * callback(err) - Callback called when the transaction has committed.\n\n__Example__\n```javascript\nconnection.tx(function(err, tx) {\n  person1.save(connection, function(err) {\n    tx.commit(function(err) {\n      // person1 saved and committed to database\n    });\n  });\n});\n```\n<a name=\"txRollback\"/>\n### tx.rollback(callback)\n\nRollsback a transaction.\n\n__Arguments__\n\n * callback(err) - Callback called when the transaction has rolledback.\n\n__Example__\n```javascript\nconnection.tx(function(err, tx) {\n  person1.save(connection, function(err) {\n    tx.rollback(function(err) {\n      // person1 not saved. Transaction rolledback.\n    });\n  });\n});\n```\n<a name=\"resultSetMethods\"/>\n## Result Set\n\n<a name=\"resultSetGetById\"/>\n### rs.getById(id)\n\nGets an item from the result set by id.\n\n__Arguments__\n\n * id - The id of the item to get.\n\n__Example__\n```javascript\nPerson.all(connection, function(err, people) {\n  var person2 = people.getById(2);\n});\n```\n<a name=\"connectionPooling\"/>\n## Connection Pooling\n\n<a name=\"connectionPoolingUsing\"/>\n### Using\n\nPersist uses [generic-pool](https://github.com/coopernurse/node-pool) to manage the connection pool. If you specify\n\"pooling\" in your configuration you must specify a pool name. See [generic-pool](https://github.com/coopernurse/node-pool)\nfor other options. To cleanly shutdown the connection pool you must also call persist.[shutdown](#persistShutdown).\n\nExample database.json to enable pooling:\n\n    {\n      \"default\": \"dev\",\n\n      \"dev\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \":memory:\",\n        \"pooling\": {\n          \"name\": \"myDatabasePool\"\n        }\n      }\n    }\n","readmeFilename":"README.md","_id":"persist@0.2.7","dist":{"shasum":"d0b2d63e17920008d59599b20848a39c57382830","tarball":"https://registry.npmjs.org/persist/-/persist-0.2.7.tgz","integrity":"sha512-qO0Ddk4g9Zqq1QggASJMRDUMB5y+SVVdnnGEDosxVmGZfRjHrk4Bcn8GDPReRmjsQf26Et8XBHWTEtQLYncQTQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAtYkRI3hSO9nsrF5FAHrGK5p90l8rnstFaKc7/jNUETAiAfuAC37ARlU5WsxLL51bNA6lKvxZH6H5nma0mBFf19cw=="}]},"_from":".","_npmVersion":"1.2.14","_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"}}},"readme":"# persist\n\npersis is an orm framework for node.js.\n\nThe following databases are currently supported:\n\n * sqlite3 - via: [node-sqlite3](https://github.com/developmentseed/node-sqlite3)\n * mysql - via: [node-mysql](https://github.com/felixge/node-mysql)\n * PostgreSQL - via: [node-postgres](https://github.com/brianc/node-postgres) \n\n# Quick Examples\n    var persist = require(\"persist\");\n    var type = persist.type;\n\n    // define some model objects\n    Phone = persist.define(\"Phone\", {\n      \"number\": type.STRING\n    });\n\n    Person = persist.define(\"Person\", {\n      \"name\": type.STRING\n    }).hasMany(this.Phone);\n\n    persist.connect({\n      driver: 'sqlite3',\n      filename: 'test.db',\n      trace: true\n    }, function(err, connection) {\n      Person.using(connection).all(function(err, people) {\n        // people contains all the people\n      });\n    });\n\n# Download\n\nYou can install using Node Package Manager (npm):\n\n    npm install persist\n\n# Index\n\n## [database.json](#databaseJson)\n\n## persist\n * [connect](#persistConnect)\n * [define](#persistDefine)\n * [setDefaultConnectOptions](#persistSetDefaultConnectOptions)\n\n## Connection\n\n * [chain](#connectionChain)\n * [tx](#connectionTx)\n\n## Model\n\n * [hasMany](#modelHasMany)\n * [using](#modelUsing)\n * [save](#modelSave)\n * [delete](#modelDelete)\n * [Associated Object Properties](#associatedObjectProperties)\n\n## Query\n\n * [all](#queryAll)\n * [each](#queryEach)\n * [first](#queryFirst)\n * [orderBy](#queryOrderBy)\n * [limit](#queryLimit)\n * [where](#queryWhere)\n * [count](#queryCount)\n * [min](#queryMin)\n * [max](#queryMax)\n * [deleteAll](#queryDeleteAll)\n * [include](#queryInclude)\n\n## Transaction\n\n * [commit](#txCommit)\n * [rollback](#txRollback)\n\n<a name=\"databaseJson\"/>\n# database.json\n\nIf the current working directory contains a file called database.json this file will be loaded upon requiring persist.\nThe file should follow a format like this:\n\n    {\n      \"default\": \"dev\",\n\n      \"dev\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \":memory:\"\n      },\n\n      \"test\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \":memory:\"\n      },\n\n      \"prod\": {\n        \"driver\": \"sqlite3\",\n        \"filename\": \"prod.db\"\n      }\n    }\n\n\"default\" specifies which environment to load.\n\n# API Documentation\n\n<a name=\"persist\"/>\n## persist\n\n<a name=\"persistConnect\" />\n### persist.connect([options], callback)\n\nConnects to a database.\n\n__Arguments__\n\n * options - (optional) Options used to connect to the database. If options are not specified the default connect options are used.\n             see [database.json](#databaseJson) and [SetDefaultConnectOptions](#persistSetDefaultConnectOptions)\n  * driver - The driver to use to connect (ie sqlite3, mysql, or postgresql).\n  * _other_ - see the documentation for your driver. The options hash will be passed to that driver.\n * callback(err, connection) - Callback to be called when the connection is established.\n\n__Example__\n\n    persist.connect({\n      driver: 'sqlite3',\n      filename: 'test.db',\n      trace: true\n    }, function(err, connection) {\n      // connnection esablished\n    });\n\n<a name=\"persistDefine\" />\n### persist.define(modelName, properties): Model\n\nDefines a model object for use in persist.\n\n__Arguments__\n\n * modelName - The name of the model. This name will map to the database name.\n * properties - Hash of properties (or columns). The value of each property can simply be the type name (ie type.String)\n                or it can be a hash of more options.\n  * type - type of the property (ie type.String)\n  * defaultValue - this can be a value or a function that will be called each time this model object is created\n  * dbColumnName - the name of the database column. (default: name of the property, all lower case, seperated by '_')\n\n__Returns__\n\n A model class.\n\n__Example__\n\n    Person = persist.define(\"Person\", {\n      \"name\": type.String,\n      \"createdDate\": { type: persist.DateTime, defaultValue: function() { return self.testDate1 }, dbColumnName: 'new_date' },\n      \"lastUpdated\": { type: persist.DateTime }\n    })\n\n<a name=\"persistSetDefaultConnectOptions\"/>\n### persist.setDefaultConnectOptions(options)\n\nSets the default connection options to be used on future connect calls. see [database.json](#databaseJson)\n\n__Arguments__\n * options - See [connect](#persistConnect) for the description of options\n\n__Example__\n\n    persist.setDefaultConnectOptions({\n      driver: 'sqlite3',\n      filename: 'test.db',\n      trace: true});\n\n<a name=\"connection\"/>\n## Connection\n\n<a name=\"connectionChain\"/>\n### connection.chain(chainables, callback)\n\nChains multiple statements together in order and gets the results.\n\n__Arguments__\n\n * chainables - An array of chainable queries. These can be save, updates, selects, or deletes. Each item in the array will be\n   executed, wait for the results, and then execute the next.\n * callback(err, results) - Callback called when all the items have been executed.\n\n__Example__\n\n    connection.chain([\n      person3.save,\n      Person.min('age'),\n      Person.max('age'),\n      phone3.delete,\n      person2.delete,\n      Person.orderBy('name').all,\n      Phone.orderBy('number').first,\n      Phone.count,\n      Phone.deleteAll,\n      Phone.all\n    ], function(err, results) {\n      // results[0] = person3\n      // results[1] = 21\n      // results[2] = 25\n      // results[3] = []\n      // results[4] = []\n      // results[5] = -- all people ordered by name\n      // results[6] = -- first phone ordered by number\n      // results[7] = 100\n      // results[8] = []\n      // results[9] = [] -- nobody left\n    });\n\n<a name=\"connectionTx\"/>\n### connection.tx(callback)\n\nBegins a transaction on the connection.\n\n__Arguments__\n\n * callback(err, tx) - Callback called when the transaction has started. tx is a transaction object which you can\n   call [commit](#txCommit) or [rollback](#txRollback)\n\n__Example__\n\n    connection.tx(function(err, tx) {\n      person1.save(connection, function(err) {\n        tx.commit(function(err) {\n          // person1 saved and committed to database\n        });\n      });\n    });\n\n<a name=\"model\" />\n## Model\n\n<a name=\"modelHasMany\" />\n### Model.hasMany(AssociatedModel, [options]): Model\n\nAdds a has many relationship to a model. This will automatically add a property to the associated model which links to this\nmodel. It will also define a property on instances of this model to get the releated objects - see [Associated Object Properties](#associatedObjectProperties)\n\n__Arguments__\n\n * AssociatedModel - The name of the model to associate to.\n * options - (optional) An hash of options.\n  * through - creates a many to many relationship using the value of through as the join table.\n\n__Returns__\n\n The model class object suitable for chaining.\n\n__Example__\n\n    Phone = persist.define(\"Phone\", {\n      \"number\": persist.String\n    });\n\n    Person = persist.define(\"Person\", {\n      \"name\": persist.String\n    }).hasMany(Phone);\n\n<a name=\"modelUsing\" />\n### Model.using(connection): query\n\nGets a query object bound to a connection object.\n\n__Arguments__\n\n * connection - The connection to bind the query object to.\n\n__Returns__\n\n A new [Query](#query) object.\n\n__Example__\n\n    Person.using(connection).first(...);\n\n<a name=\"modelSave\" />\n### Model.save(connection, callback)\n\nSaves the model object to the database\n\n__Arguments__\n\n * connection - The connection to use to save the object with.\n * callback(err) - The callback to be called when the save is complete\n\n__Example__\n\n    person1.save(connection, function() {\n      // person1 saved\n    });\n\n<a name=\"modelDelete\" />\n### Model.delete(connection, callback)\n\nDeletes the model object from the database\n\n__Arguments__\n\n * connection - The connection to use to delete the object with.\n * callback(err) - The callback to be called when the delete is complete\n\n__Example__\n\n    person1.delete(connection, function() {\n      // person1 deleted\n    });\n\n<a name=\"associatedObjectProperties\" />\n### Associated Object Properties\n\nIf you have setup an associated property using [hasMany](#modelHasMany) instances of your model will have an additional property\nwhich allows you to get the associated data. This property returns a [Query](#query) object which you can further chain to limit\nthe results.\n\n__Example__\n\n    Phone = persist.define(\"Phone\", {\n      \"number\": persist.String\n    });\n\n    Person = persist.define(\"Person\", {\n      \"name\": persist.String\n    }).hasMany(Phone);\n\n    Person.using(connection).first(function(err, person) {\n      person.phones.orderBy('number').all(function(err, phones) {\n        // all the phones of the first person\n      });\n    });\n\n<a name=\"query\" />\n## Query\n\n<a name=\"queryAll\" />\n### query.all([connection], callback)\n\nGets all items from a query as a single array of items.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, items) - Callback to be called after the rows have been fetched. items is an array of model instances.\n\n__Example__\n\n    Person.all(connection, function(err, people) {\n      // all the people\n    });\n\n<a name=\"queryEach\" />\n### query.each([connection], callback, doneCallback)\n\nGets items from a query calling the callback for each item returned.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after each row has been fetched. item is a model instance.\n * doneCallback(err) - Callback called after all rows have been retrieved.\n\n__Example__\n\n    Person.each(connection, function(err, person) {\n      // a person\n    }, function() {\n      // all done\n    });\n\n<a name=\"queryFirst\" />\n### query.first([connection], callback)\n\nGets the first item from a query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, item) - Callback to be called after the row has been fetched. item is a model instance.\n\n__Example__\n\n    Person.first(connection, function(err, person) {\n      // gets the first person\n    });\n\n<a name=\"queryOrderBy\" />\n### query.orderBy(propertyName): query\n\nOrders the results of a query.\n\n__Arguments__\n\n * propertyName - Name of the property to order by.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.orderBy('name').all(connection, function(err, people) {\n      // all the people ordered by name\n    });\n\n<a name=\"queryLimit\" />\n### query.limit(count, [offset]): query\n\nLimits the number of results of a query.\n\n__Arguments__\n\n * count - Number of items to return.\n * offset - (Optional) The number of items to skip.\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.orderBy('name').limit(5, 5).all(connection, function(err, people) {\n      // The 5-10 people ordered by name\n    });\n\n<a name=\"queryWhere\" />\n### query.where(clause, [values...]): query\n### query.where(hash): query\n\nFilters the results by a where clause.\n\n__Arguments__\n\n * clause - A clause to filter the results by.\n * values - (Optional) A single value or array of values to substitute in for '?'s in the clause.\n * hash - A hash of columns and values to match on (see example)\n\n__Returns__\n\n The query object suitable for chaining.\n\n__Example__\n\n    Person.where('name = ?', 'bob').all(connection, function(err, people) {\n      // All the people named 'bob'\n    });\n\n    Person.where({'name': 'bob', 'age': 23}).all(connection, function(err, people) {\n      // All the people named 'bob' with the age of 23\n    });\n\n<a name=\"queryCount\" />\n### query.count([connection], callback)\n\nCounts the number of items that would be returned by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err, count) - Callback with the count of items.\n\n__Example__\n\n    Person.where('name = ?', 'bob').count(connection, function(err, count) {\n      // count = the number of people with the name bob\n    });\n\n<a name=\"queryMin\" />\n### query.min([connection], fieldName, callback)\n\nGets the minimum value in the query of the given field.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * fieldName - The field name of the value you would like to get the minimum for.\n * callback(err, min) - Callback with the minimum value.\n\n__Example__\n\n    Person.where('name = ?', 'bob').min(connection, 'age', function(err, min) {\n      // the minimum age of all bobs\n    });\n\n<a name=\"queryMax\" />\n### query.max([connection], fieldName, callback)\n\nGets the maximum value in the query of the given field.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * fieldName - The field name of the value you would like to get the maximum for.\n * callback(err, min) - Callback with the maximum value.\n\n__Example__\n\n    Person.where('name = ?', 'bob').max(connection, 'age', function(err, min) {\n      // the maximum age of all bobs\n    });\n\n\n<a name=\"queryDeleteAll\" />\n### query.deleteAll([connection], callback)\n\nDeletes all the items specified by the query.\n\n__Arguments__\n\n * connection - (Optional) The connection to use. If this is not specified a [using](#modelUsing) statement must be specified earlier.\n * callback(err) - Callback called upon completion.\n\n__Example__\n\n    Person.where('name = ?', 'bob').deleteAll(connection, function(err) {\n      // all people name 'bob' have been deleted.\n    });\n\n<a name=\"queryInclude\" />\n### query.include(propertyName): query\n\nIncludes the associated data linked by (hasMany or hasMany(through)) the propertyName when retrieving data from the database.\nThis will replace obj.propertyName with an array of results as opposed to the default before which is a query.\n\nInternally this will do a join to the associated table in the case of a one to many. And will do a join to the associated through table\nand the associated table in the case of a many to many.\n\n__Arguments__\n\n * propertyName - This can be a single property name or an array of property names to include.\n\n__Example__\n\n    Person.include(\"phones\").where('name = ?', 'bob').all(connection, function(err, people) {\n      // all people named 'bob' and all their phone numbers\n      // so you can do... people[0].phones[0].number\n      // as opposed to... people[0].phones.all(function(err, phones) {});\n    });\n\n<a name=\"tx\"/>\n## Transaction\n\n<a name=\"txCommit\"/>\n### tx.commit(callback)\n\nCommits a transaction.\n\n__Arguments__\n\n * callback(err) - Callback called when the transaction has committed.\n\n__Example__\n\n    connection.tx(function(err, tx) {\n      person1.save(connection, function(err) {\n        tx.commit(function(err) {\n          // person1 saved and committed to database\n        });\n      });\n    });\n\n<a name=\"txRollback\"/>\n### tx.rollback(callback)\n\nRollsback a transaction.\n\n__Arguments__\n\n * callback(err) - Callback called when the transaction has rolledback.\n\n__Example__\n\n    connection.tx(function(err, tx) {\n      person1.save(connection, function(err) {\n        tx.rollback(function(err) {\n          // person1 not saved. Transaction rolledback.\n        });\n      });\n    });","maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"time":{"modified":"2022-06-23T18:51:30.207Z","created":"2011-12-16T18:38:00.381Z","0.1.0":"2011-12-16T18:38:01.051Z","0.1.1":"2011-12-19T21:15:01.132Z","0.2.0":"2011-12-27T17:15:56.455Z","0.2.1":"2012-01-11T15:46:04.056Z","0.2.2":"2012-02-17T14:55:12.614Z","0.2.3":"2012-04-02T15:33:03.936Z","0.2.4":"2012-06-22T18:15:11.452Z","0.2.5":"2012-07-30T14:11:41.179Z","0.2.6":"2012-08-23T14:13:27.263Z","0.2.7":"2013-04-01T17:45:00.476Z"},"users":{"joeferner":true,"kunklejr":true,"fgribreau":true},"author":{"name":"Joe Ferner","email":"joe.ferner@nearinfinity.com"},"repository":{"type":"git","url":"https://github.com/nearinfinity/node-persist.git"}}