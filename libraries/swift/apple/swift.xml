<?xml version="1.0" encoding="UTF-8"?>
<library xmlns="http://www.optimyth.com/schema/definitions/library_metadata"
         technology="swift" name="swift" standard="swift">

  <description url="https://developer.apple.com/documentation/swift/swift_standard_library">Base layer of functionality for writing Swift programs</description>

  <module name="swift">
    <function name="print" signature="print(Any..., separator: String, terminator: String)">
      <sink argpos="0" kind="log_forging"/>
      <sink argpos="0" kind="privacy_violation"/>
    </function>
    <function name="print" signature="print(Any..., separator: String, terminator: String, to: Target)">
      <sink argpos="0" kind="log_forging"/>
      <sink argpos="0" kind="privacy_violation"/>
    </function>
    <function name="debugPrint" signature="debugPrint(Any..., separator: String, terminator: String)">
      <sink argpos="0" kind="log_forging"/>
      <sink argpos="0" kind="privacy_violation"/>
    </function>
    <function name="debugPrint" signature="debugPrint(Any..., separator: String, terminator: String, to: Target)">
      <sink argpos="0" kind="log_forging"/>
      <sink argpos="0" kind="privacy_violation"/>
    </function>
    <function name="dump" signature="dump(T, name: String?, indent: Int, maxDepth: Int, maxItems: Int)">
      <sink argpos="0" kind="log_forging"/>
      <sink argpos="0" kind="privacy_violation"/>
    </function>
    <function name="dump" signature="dump(T, to: inout TargetStream, name: String?, indent: Int, maxDepth: Int, maxItems: Int)">
      <sink argpos="0" kind="log_forging"/>
      <sink argpos="0" kind="privacy_violation"/>
    </function>
    <function name="fatalError" signature="fatalError(message:String, file:String, line:Int)" >
      <parameters>
        <param type="String"/>
        <param type="String" name="file"/>
        <param type="Int" name="line"/>
      </parameters>
      <sink argpos="0" kind="log_forging"/>
      <sink argpos="0" kind="privacy_violation"/>
    </function>
    <function name="readLine" signature="readLine(strippingNewline: Bool)">
      <return type="String" />
      <source argpos="-1" kind="user_input"/>
    </function>

    <class kind="struct" name="Bool">
      <method name="==" signature="==(Bool, Bool)"/>
      <method name="!=" signature="!=(Bool, Bool)"/>
      <method name="!" signature="!(Bool)"/>
      <method name="||" signature="||(Bool, () -&gt; Bool)"/>
      <method name="&amp;&amp;" signature="&amp;&amp;(Bool, () -&gt; Bool)"/>
      <field name="description" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="customPlaygroundQuickLook" type="PlaygroundQuickLook"/>
      <field name="hashValue" type="Int"/>
      <constructor name="Bool" signature="Bool(Bool)"/>
      <constructor name="Bool" signature="Bool?(String)"/>
      <constructor name="Bool" signature="Bool(NSNumber)"/>
      <constructor name="Bool" signature="Bool(truncating: NSNumber)"/>
      <constructor name="Bool" signature="Bool?(exactly: NSNumber)"/>
      <constructor name="Bool" signature="Bool(from: Decoder)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="Bool" signature="Bool()"/>
      <constructor name="Bool" signature="Bool(booleanLiteral: Bool)"/>
    </class>

    <class kind="struct" name="Int">
      <constructor name="Int" signature="Int&lt;T&gt;(T)"/>
      <constructor name="Int" signature="Int?&lt;T&gt;(exactly: T)"/>
      <constructor name="Int" signature="Int&lt;Other&gt;(clamping: Other)"/>
      <constructor name="Int" signature="Int&lt;T&gt;(truncatingIfNeeded: T)"/>
      <constructor name="Int" signature="Int(bitPattern: UInt)"/>
      <constructor name="Int" signature="Int&lt;T&gt;(T)"/>
      <constructor name="Int" signature="Int?&lt;T&gt;(exactly: T)"/>
      <constructor name="Int" signature="Int(Double)"/>
      <constructor name="Int" signature="Int(Float)"/>
      <constructor name="Int" signature="Int(CGFloat)"/>
      <constructor name="Int" signature="Int(Float80)"/>
      <constructor name="Int" signature="Int(NSNumber)"/>
      <constructor name="Int" signature="Int?(exactly: Double)"/>
      <constructor name="Int" signature="Int?(exactly: Float)"/>
      <constructor name="Int" signature="Int?(exactly: Float80)"/>
      <constructor name="Int" signature="Int?(exactly: NSNumber)"/>
      <constructor name="Int" signature="Int(truncating: NSNumber)"/>
      <constructor name="Int" signature="Int?(String)"/>
      <constructor name="Int" signature="Int?&lt;S&gt;(S, radix: Int)"/>
      <method name="negate" signature="negate()"/>
      <method name="quotientAndRemainder" signature="quotientAndRemainder(dividingBy: Int)"/>
      <method name="addingReportingOverflow" signature="addingReportingOverflow(Int)">
        <return type="(partialValue: Int, overflow: Bool)"/>
      </method>
      <method name="subtractingReportingOverflow" signature="subtractingReportingOverflow(Int)">
        <return type="(partialValue: Int, overflow: Bool)"/>
      </method>
      <method name="multipliedReportingOverflow" signature="multipliedReportingOverflow(by: Int)">
        <return type="(partialValue: Int, overflow: Bool)"/>
      </method>
      <method name="dividedReportingOverflow" signature="dividedReportingOverflow(by: Int)">
        <return type="(partialValue: Int, overflow: Bool)"/>
      </method>
      <method name="remainderReportingOverflow" signature="remainderReportingOverflow(dividingBy: Int)">
        <return type="(partialValue: Int, overflow: Bool)"/>
      </method>
      <method name="unsafeAdding" signature="unsafeAdding(Int)">
        <return type="Int"/>
      </method>
      <method name="unsafeSubtracting" signature="unsafeSubtracting(Int)">
        <return type="Int"/>
      </method>
      <method name="unsafeMultiplied" signature="unsafeMultiplied(by: Int)">
        <return type="Int"/>
      </method>
      <method name="unsafeDivided" signature="unsafeDivided(by: Int)">
        <return type="Int"/>
      </method>
      <method name="multipliedFullWidth" signature="multipliedFullWidth(by: Int)"/>
      <method name="dividingFullWidth" signature="dividingFullWidth((high: Int, low: Int.Magnitude))"/>
      <field name="magnitude" type="UInt"/>
      <method name="abs" signature="abs&lt;T&gt;(T)">
        <return type="T where T : Comparable, T : SignedNumeric"/>
      </method>
      <method name="signum" signature="signum()">
        <return type="Int"/>
      </method>
      <field name="min" type="Int"/>
      <field name="max" type="Int"/>
      <field name="isSigned" type="Bool"/>
      <field name="byteSwapped" type="Int"/>
      <field name="littleEndian" type="Int"/>
      <field name="bigEndian" type="Int"/>
      <constructor name="Int" signature="Int(littleEndian: Int)"/>
      <constructor name="Int" signature="Int(bigEndian: Int)"/>
      <field name="bitWidth" type="Int"/>
      <field name="bitWidth" type="Int"/>
      <field name="words" type="Int.Words"/>
      <field name="nonzeroBitCount" type="Int"/>
      <field name="leadingZeroBitCount" type="Int"/>
      <field name="trailingZeroBitCount" type="Int"/>
      <constructor name="Int" signature="Int(bitPattern: ObjectIdentifier)"/>
      <constructor name="Int" signature="Int&lt;U&gt;(bitPattern: UnsafePointer&lt;U&gt;?)"/>
      <constructor name="Int" signature="Int&lt;U&gt;(bitPattern: UnsafeMutablePointer&lt;U&gt;?)"/>
      <constructor name="Int" signature="Int(bitPattern: UnsafeRawPointer?)"/>
      <constructor name="Int" signature="Int(bitPattern: UnsafeMutableRawPointer?)"/>
      <constructor name="Int" signature="Int(bitPattern: OpaquePointer?)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="Int" signature="Int(from: Decoder)"/>
      <field name="description" type="String"/>
      <field name="hashValue" type="Int"/>
      <field name="customMirror" type="Mirror"/>
      <field name="customPlaygroundQuickLook" type="PlaygroundQuickLook"/>
      <constructor name="Int" signature="Int()"/>
      <constructor name="Int" signature="Int(integerLiteral: Int)"/>
      <method name="distance" signature="distance(to: Int)"/>
      <method name="advanced" signature="advanced(by: Int)"/>
    </class>

    <class kind="struct" name="Int8" supertypes="Int" />
    <class kind="struct" name="Int16" supertypes="Int" />
    <class kind="struct" name="Int32" supertypes="Int" />
    <class kind="struct" name="Int64" supertypes="Int" />
    <class kind="struct" name="UInt" supertypes="Int" />
    <class kind="struct" name="UInt8" supertypes="Int" />
    <class kind="struct" name="UInt16" supertypes="Int" />
    <class kind="struct" name="UInt32" supertypes="Int" />
    <class kind="struct" name="UInt64" supertypes="Int" />

    <class kind="struct" name="Float">
      <constructor name="Float" signature="Float(Int)"/>
      <constructor name="Float" signature="Float(Int16)"/>
      <constructor name="Float" signature="Float(Int8)"/>
      <constructor name="Float" signature="Float(Int32)"/>
      <constructor name="Float" signature="Float(UInt)"/>
      <constructor name="Float" signature="Float(UInt8)"/>
      <constructor name="Float" signature="Float(UInt16)"/>
      <constructor name="Float" signature="Float(UInt32)"/>
      <constructor name="Float" signature="Float(UInt64)"/>
      <constructor name="Float" signature="Float?&lt;S&gt;(S)"/>
      <constructor name="Float" signature="Float(Double)"/>
      <constructor name="Float" signature="Float(Float)"/>
      <constructor name="Float" signature="Float(Float80)"/>
      <constructor name="Float" signature="Float(CGFloat)"/>
      <constructor name="Float" signature="Float(NSNumber)"/>
      <constructor name="Float" signature="Float(truncating: NSNumber)"/>
      <constructor name="Float" signature="Float(signOf: Float, magnitudeOf: Float)"/>
      <constructor name="Float" signature="Float(sign: FloatingPointSign, exponent: Int, significand: Float)"/>
      <constructor name="Float" signature="Float?&lt;T&gt;(exactly: T)"/>
      <constructor name="Float" signature="Float?(exactly: Double)"/>
      <constructor name="Float" signature="Float?(exactly: Float)"/>
      <constructor name="Float" signature="Float?(exactly: Float80)"/>
      <constructor name="Float" signature="Float?(exactly: NSNumber)"/>
      <constructor name="Float" signature="Float?(exactly: Int)"/>
      <constructor name="Float" signature="Float?(exactly: Int8)"/>
      <constructor name="Float" signature="Float?(exactly: Int16)"/>
      <constructor name="Float" signature="Float?(exactly: Int32)"/>
      <constructor name="Float" signature="Float?(exactly: Int64)"/>
      <constructor name="Float" signature="Float?(exactly: UInt)"/>
      <constructor name="Float" signature="Float?(exactly: UInt8)"/>
      <constructor name="Float" signature="Float?(exactly: UInt16)"/>
      <constructor name="Float" signature="Float?(exactly: UInt32)"/>
      <constructor name="Float" signature="Float?(exactly: UInt64)"/>
      <method name="addingProduct" signature="addingProduct(Float, Float)">
        <return type="Float"/>
      </method>
      <method name="addProduct" signature="addProduct(Float, Float)"/>
      <method name="squareRoot" signature="squareRoot()">
        <return type="Float"/>
      </method>
      <method name="formSquareRoot" signature="formSquareRoot()"/>
      <method name="remainder" signature="remainder(dividingBy: Float)">
        <return type="Float"/>
      </method>
      <method name="formRemainder" signature="formRemainder(dividingBy: Float)"/>
      <method name="truncatingRemainder" signature="truncatingRemainder(dividingBy: Float)">
        <return type="Float"/>
      </method>
      <method name="formTruncatingRemainder" signature="formTruncatingRemainder(dividingBy: Float)"/>
      <method name="negate" signature="negate()"/>
      <method name="negate" signature="negate()"/>
      <method name="rounded" signature="rounded()">
        <return type="Float"/>
      </method>
      <method name="rounded" signature="rounded(FloatingPointRoundingRule)">
        <return type="Float"/>
      </method>
      <method name="round" signature="round()"/>
      <method name="round" signature="round(FloatingPointRoundingRule)"/>
      <method name="isEqual" signature="isEqual(to: Float)">
        <return type="Bool"/>
      </method>
      <method name="isLess" signature="isLess(than: Float)">
        <return type="Bool"/>
      </method>
      <method name="isLessThanOrEqualTo" signature="isLessThanOrEqualTo(Float)">
        <return type="Bool"/>
      </method>
      <method name="isTotallyOrdered" signature="isTotallyOrdered(belowOrEqualTo: Float)">
        <return type="Bool"/>
      </method>
      <method name="maximum" signature="maximum(Float, Float)">
        <return type="Float"/>
      </method>
      <method name="maximumMagnitude" signature="maximumMagnitude(Float, Float)">
        <return type="Float"/>
      </method>
      <method name="minimum" signature="minimum(Float, Float)">
        <return type="Float"/>
      </method>
      <method name="minimumMagnitude" signature="minimumMagnitude(Float, Float)">
        <return type="Float"/>
      </method>
      <field name="magnitude" type="Float"/>
      <field name="sign" type="FloatingPointSign"/>
      <field name="ulp" type="Float"/>
      <field name="significand" type="Float"/>
      <field name="exponent" type="Int"/>
      <field name="nextUp" type="Float"/>
      <field name="nextDown" type="Float"/>
      <field name="binade" type="Float"/>
      <field name="pi" type="Float"/>
      <field name="infinity" type="Float"/>
      <field name="greatestFiniteMagnitude" type="Float"/>
      <field name="nan" type="Float"/>
      <field name="signalingNaN" type="Float"/>
      <field name="ulpOfOne" type="Float"/>
      <field name="leastNormalMagnitude" type="Float"/>
      <field name="leastNonzeroMagnitude" type="Float"/>
      <field name="bitPattern" type="UInt32"/>
      <field name="significandBitPattern" type="UInt32"/>
      <field name="significandWidth" type="Int"/>
      <field name="exponentBitPattern" type="UInt"/>
      <field name="significandBitCount" type="Int"/>
      <field name="exponentBitCount" type="Int"/>
      <field name="radix" type="Int"/>
      <constructor name="Float" signature="Float(bitPattern: UInt32)"/>
      <constructor name="Float" signature="Float(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt32)"/>
      <constructor name="Float" signature="Float(nan: Float.RawSignificand, signaling: Bool)"/>
      <field name="isZero" type="Bool"/>
      <field name="isFinite" type="Bool"/>
      <field name="isInfinite" type="Bool"/>
      <field name="isNaN" type="Bool"/>
      <field name="isSignalingNaN" type="Bool"/>
      <field name="isNormal" type="Bool"/>
      <field name="isSubnormal" type="Bool"/>
      <field name="isCanonical" type="Bool"/>
      <field name="floatingPointClass" type="FloatingPointClassification"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="Float" signature="Float(from: Decoder)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="customPlaygroundQuickLook" type="PlaygroundQuickLook"/>
      <field name="hashValue" type="Int"/>
      <constructor name="Float" signature="Float()"/>
      <constructor name="Float" signature="Float(Int64)"/>
      <constructor name="Float" signature="Float(integerLiteral: Int64)"/>
      <constructor name="Float" signature="Float(floatLiteral: Float)"/>
      <constructor name="Float" signature="Float(integerLiteral: Float)"/>
      <method name="advanced" signature="advanced(by: Float)">
        <return type="Float"/>
      </method>
      <method name="distance" signature="distance(to: Float)">
        <return type="Float"/>
      </method>
    </class>

    <class kind="struct" name="Double">
      <constructor name="Double" signature="Double(Int)"/>
      <constructor name="Double" signature="Double(Int8)"/>
      <constructor name="Double" signature="Double(Int16)"/>
      <constructor name="Double" signature="Double(Int32)"/>
      <constructor name="Double" signature="Double(Int64)"/>
      <constructor name="Double" signature="Double(UInt)"/>
      <constructor name="Double" signature="Double(UInt8)"/>
      <constructor name="Double" signature="Double(UInt16)"/>
      <constructor name="Double" signature="Double(UInt32)"/>
      <constructor name="Double" signature="Double(UInt64)"/>
      <constructor name="Double" signature="Double?&lt;S&gt;(S)"/>
      <constructor name="Double" signature="Double(Double)"/>
      <constructor name="Double" signature="Double(Float)"/>
      <constructor name="Double" signature="Double(Float80)"/>
      <constructor name="Double" signature="Double(CGFloat)"/>
      <constructor name="Double" signature="Double(NSNumber)"/>
      <constructor name="Double" signature="Double(sign: FloatingPointSign, exponent: Int, significand: Double)"/>
      <constructor name="Double" signature="Double(truncating: NSNumber)"/>
      <constructor name="Double" signature="Double(signOf: Double, magnitudeOf: Double)"/>
      <constructor name="Double" signature="Double?&lt;T&gt;(exactly: T)"/>
      <constructor name="Double" signature="Double?(exactly: Double)"/>
      <constructor name="Double" signature="Double?(exactly: Float)"/>
      <constructor name="Double" signature="Double?(exactly: Float80)"/>
      <constructor name="Double" signature="Double?(exactly: NSNumber)"/>
      <constructor name="Double" signature="Double?(exactly: Int)"/>
      <constructor name="Double" signature="Double?(exactly: Int16)"/>
      <constructor name="Double" signature="Double?(exactly: Int8)"/>
      <constructor name="Double" signature="Double?(exactly: Int32)"/>
      <constructor name="Double" signature="Double?(exactly: Int64)"/>
      <constructor name="Double" signature="Double?(exactly: UInt)"/>
      <constructor name="Double" signature="Double?(exactly: UInt8)"/>
      <constructor name="Double" signature="Double?(exactly: UInt16)"/>
      <constructor name="Double" signature="Double?(exactly: UInt32)"/>
      <constructor name="Double" signature="Double?(exactly: UInt64)"/>
      <method name="addingProduct" signature="addingProduct(Double, Double)">
        <return type="Double"/>
      </method>
      <method name="addProduct" signature="addProduct(Double, Double)"/>
      <method name="squareRoot" signature="squareRoot()">
        <return type="Double"/>
      </method>
      <method name="formSquareRoot" signature="formSquareRoot()"/>
      <method name="remainder" signature="remainder(dividingBy: Double)">
        <return type="Double"/>
      </method>
      <method name="formRemainder" signature="formRemainder(dividingBy: Double)"/>
      <method name="truncatingRemainder" signature="truncatingRemainder(dividingBy: Double)">
        <return type="Double"/>
      </method>
      <method name="formTruncatingRemainder" signature="formTruncatingRemainder(dividingBy: Double)"/>
      <method name="negate" signature="negate()"/>
      <method name="negate" signature="negate()"/>
      <method name="rounded" signature="rounded()">
        <return type="Double"/>
      </method>
      <method name="rounded" signature="rounded(FloatingPointRoundingRule)">
        <return type="Double"/>
      </method>
      <method name="round" signature="round()"/>
      <method name="round" signature="round(FloatingPointRoundingRule)"/>
      <method name="isEqual" signature="isEqual(to: Double)">
        <return type="Bool"/>
      </method>
      <method name="isLess" signature="isLess(than: Double)">
        <return type="Bool"/>
      </method>
      <method name="isLessThanOrEqualTo" signature="isLessThanOrEqualTo(Double)">
        <return type="Bool"/>
      </method>
      <method name="isTotallyOrdered" signature="isTotallyOrdered(belowOrEqualTo: Double)">
        <return type="Bool"/>
      </method>
      <method name="minimum" signature="minimum(Double, Double)">
        <return type="Double"/>
      </method>
      <method name="minimumMagnitude" signature="minimumMagnitude(Double, Double)">
        <return type="Double"/>
      </method>
      <method name="maximum" signature="maximum(Double, Double)">
        <return type="Double"/>
      </method>
      <method name="maximumMagnitude" signature="maximumMagnitude(Double, Double)">
        <return type="Double"/>
      </method>
      <field name="magnitude" type="Double"/>
      <method name="abs" signature="abs&lt;T&gt;(T)"/>
      <field name="sign" type="FloatingPointSign"/>
      <field name="ulp" type="Double"/>
      <field name="significand" type="Double"/>
      <field name="exponent" type="Int"/>
      <field name="nextUp" type="Double"/>
      <field name="nextDown" type="Double"/>
      <field name="binade" type="Double"/>
      <field name="pi" type="Double"/>
      <field name="infinity" type="Double"/>
      <field name="greatestFiniteMagnitude" type="Double"/>
      <field name="nan" type="Double"/>
      <field name="signalingNaN" type="Double"/>
      <field name="ulpOfOne" type="Double"/>
      <field name="leastNonzeroMagnitude" type="Double"/>
      <field name="leastNormalMagnitude" type="Double"/>
      <field name="bitPattern" type="UInt64"/>
      <field name="significandBitPattern" type="UInt64"/>
      <field name="significandWidth" type="Int"/>
      <field name="exponentBitPattern" type="UInt"/>
      <field name="significandBitCount" type="Int"/>
      <field name="exponentBitCount" type="Int"/>
      <field name="radix" type="Int"/>
      <constructor name="Double" signature="Double(bitPattern: UInt64)"/>
      <constructor name="Double" signature="Double(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)"/>
      <constructor name="Double" signature="Double(nan: Double.RawSignificand, signaling: Bool)"/>
      <field name="isZero" type="Bool"/>
      <field name="isFinite" type="Bool"/>
      <field name="isInfinite" type="Bool"/>
      <field name="isNaN" type="Bool"/>
      <field name="isSignalingNaN" type="Bool"/>
      <field name="isNormal" type="Bool"/>
      <field name="isSubnormal" type="Bool"/>
      <field name="isCanonical" type="Bool"/>
      <field name="floatingPointClass" type="FloatingPointClassification"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="Double" signature="Double(from: Decoder)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="customPlaygroundQuickLook" type="PlaygroundQuickLook"/>
      <field name="hashValue" type="Int"/>
      <constructor name="Double" signature="Double()"/>
      <constructor name="Double" signature="Double(floatLiteral: Double)"/>
      <constructor name="Double" signature="Double(integerLiteral: Int64)"/>
      <constructor name="Double" signature="Double(integerLiteral: Double)"/>
      <method name="advanced" signature="advanced(by: Double)">
        <return type="Double"/>
      </method>
      <method name="distance" signature="distance(to: Double)">
        <return type="Double"/>
      </method>
    </class>

    <class kind="struct" name="Range">
      <method name="..&lt;" signature="..&lt;&lt;Bound&gt;(Bound, Bound)"/>
      <method name="relative" signature="relative&lt;C&gt;(to: C)"/>
      <constructor name="Range" signature="Range(Range&lt;Bound&gt;)"/>
      <constructor name="Range" signature="Range(ClosedRange&lt;Bound&gt;)"/>
      <constructor name="Range" signature="Range(CountableRange&lt;Bound&gt;)"/>
      <constructor name="Range" signature="Range(CountableClosedRange&lt;Bound&gt;)"/>
      <constructor name="Range" signature="Range?(NSRange)"/>
      <constructor name="Range" signature="Range?(NSRange)"/>
      <field name="isEmpty" type="Bool"/>
      <field name="count" type="Bound.Stride"/>
      <method name="contains" signature="contains(Bound)">
        <return type="Bool"/>
      </method>
      <method name="~=" signature="~=(Range&lt;Bound&gt;, Bound)"/>
      <constructor name="Range" signature="Range?(NSRange, in: String)"/>
      <method name="clamped" signature="clamped(to: Range&lt;Bound&gt;)">
        <return type="Range&lt;Bound&gt;"/>
      </method>
      <method name="==" signature="==(Range&lt;Bound&gt;, Range&lt;Bound&gt;)"/>
      <method name="!=" signature="!=(Range&lt;Bound&gt;, Range&lt;Bound&gt;)"/>
      <method name="overlaps" signature="overlaps(Range&lt;Bound&gt;)">
        <return type="Bool"/>
      </method>
      <method name="overlaps" signature="overlaps(ClosedRange&lt;Bound&gt;)">
        <return type="Bool"/>
      </method>
      <method name="overlaps" signature="overlaps(CountableRange&lt;Bound&gt;)">
        <return type="Bool"/>
      </method>
      <method name="overlaps" signature="overlaps(CountableClosedRange&lt;Bound&gt;)">
        <return type="Bool"/>
      </method>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <constructor name="Range" signature="Range(uncheckedBounds: (lower: Bound, upper: Bound))"/>
    </class>

    <class kind="struct" name="ClosedRange">
      <method name="..." signature="...&lt;Bound&gt;(Bound, Bound)"/>
      <method name="relative" signature="relative&lt;C&gt;(to: C)"/>
      <constructor name="ClosedRange" signature="ClosedRange(Range&lt;Bound&gt;)"/>
      <constructor name="ClosedRange" signature="ClosedRange(ClosedRange&lt;Bound&gt;)"/>
      <constructor name="ClosedRange" signature="ClosedRange(CountableRange&lt;Bound&gt;)"/>
      <constructor name="ClosedRange" signature="ClosedRange(CountableClosedRange&lt;Bound&gt;)"/>
      <field name="isEmpty" type="Bool"/>
      <field name="count" type="Bound.Stride"/>
      <method name="contains" signature="contains(Bound)">
        <return type="Bool"/>
      </method>
      <method name="~=" signature="~=(ClosedRange&lt;Bound&gt;, Bound)"/>
      <constructor name="ClosedRange" signature="ClosedRange(uncheckedBounds: (lower: Bound, upper: Bound))"/>
      <method name="clamped" signature="clamped(to: ClosedRange&lt;Bound&gt;)">
        <return type="ClosedRange&lt;Bound&gt;"/>
      </method>
      <method name="==" signature="==(ClosedRange&lt;Bound&gt;, ClosedRange&lt;Bound&gt;)"/>
      <method name="!=" signature="!=(ClosedRange&lt;Bound&gt;, ClosedRange&lt;Bound&gt;)"/>
      <method name="overlaps" signature="overlaps(Range&lt;Bound&gt;)">
        <return type="Bool"/>
      </method>
      <method name="overlaps" signature="overlaps(ClosedRange&lt;Bound&gt;)">
        <return type="Bool"/>
      </method>
      <method name="overlaps" signature="overlaps(CountableClosedRange&lt;Bound&gt;)">
        <return type="Bool"/>
      </method>
      <method name="overlaps" signature="overlaps(CountableRange&lt;Bound&gt;)">
        <return type="Bool"/>
      </method>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
    </class>

    <class kind="protocol" name="Error">
      <field name="localizedDescription" type="String"/>
    </class>

    <class kind="enum" name="Optional">
      <constructor name="Optional" signature="Optional(Wrapped)"/>
      <constructor name="Optional" signature="Optional(nilLiteral: ())"/>
      <method name="map" signature="map&lt;U&gt;((Wrapped) -&gt; U)">
        <return type="U?"/>
      </method>
      <method name="flatMap" signature="flatMap&lt;U&gt;((Wrapped) -&gt; U?)">
        <return type="U?"/>
      </method>
      <field name="unsafelyUnwrapped" type="Wrapped"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <method name="??" signature="??&lt;T&gt;(T?, () -&gt; T)"/>
      <method name="??" signature="??&lt;T&gt;(T?, () -&gt; T?)"/>
      <method name="==" signature="==&lt;T&gt;(T?, T?)"/>
      <method name="!=" signature="!=&lt;T&gt;(T?, T?)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="Optional" signature="Optional(from: Decoder)"/>
    </class>

    <class kind="protocol" name="Numeric" supertypes="ExpressibleByIntegerLiteral, Equatable">
      <constructor name="Numeric" signature="Numeric?&lt;T&gt;(exactly: T)"/>
      <field name="magnitude" type="Numeric.Magnitude"/>
      <method name="*" signature="*(Numeric, Numeric)"/>
      <method name="*=" signature="*=(inout Numeric, Numeric)"/>
      <method name="+" signature="+(Numeric)">
        <return type="Numeric"/>
      </method>
      <method name="+" signature="+(Numeric, Numeric)"/>
      <method name="+=" signature="+=(inout Numeric, Numeric)"/>
      <method name="-" signature="-(Numeric, Numeric)"/>
      <method name="-=" signature="-=(inout Numeric, Numeric)"/>
    </class>

    <class kind="protocol" name="SignedNumeric" supertypes="Numeric">
      <method name="negate" signature="negate()"/>
      <method name="-" signature="-(SignedNumeric)">
        <return type="SignedNumeric"/>
      </method>
    </class>

    <class kind="protocol" name="Strideable" supertypes="Comparable">
      <method name="advanced" signature="advanced(by: Strideable.Stride)"/>
      <method name="+" signature="+(Strideable, Strideable.Stride)"/>
      <method name="+" signature="+(Strideable.Stride, Strideable)"/>
      <method name="+=" signature="+=(inout Strideable, Strideable.Stride)"/>
      <method name="-" signature="-(Strideable, Strideable.Stride)"/>
      <method name="-" signature="-(Strideable, Strideable)"/>
      <method name="-=" signature="-=(inout Strideable, Strideable.Stride)"/>
      <method name="distance" signature="distance(to: Strideable)"/>
      <method name="..." signature="...(Strideable)"/>
      <method name="==" signature="==(Strideable, Strideable)"/>
    </class>

    <class kind="protocol" name="SignedInteger" supertypes="BinaryInteger, SignedNumeric">
      <field name="description" type="String"/>
      <field name="max" type="SignedInteger"/>
      <field name="min" type="SignedInteger"/>
      <method name="&amp;+" signature="&amp;+(SignedInteger, SignedInteger)"/>
      <method name="&amp;-" signature="&amp;-(SignedInteger, SignedInteger)"/>
    </class>

    <class kind="protocol" name="BinaryInteger" supertypes="CustomStringConvertible, Strideable, Numeric, Hashable">
      <constructor name="BinaryInteger" signature="BinaryInteger()"/>
      <constructor name="BinaryInteger" signature="BinaryInteger&lt;T&gt;(T)"/>
      <constructor name="BinaryInteger" signature="BinaryInteger&lt;T&gt;(T)"/>
      <constructor name="BinaryInteger" signature="BinaryInteger&lt;T&gt;(clamping: T)"/>
      <constructor name="BinaryInteger" signature="BinaryInteger?&lt;T&gt;(exactly: T)"/>
      <constructor name="BinaryInteger" signature="BinaryInteger&lt;T&gt;(truncatingIfNeeded: T)"/>
      <field name="bitWidth" type="Int"/>
      <field name="trailingZeroBitCount" type="Int"/>
      <field name="words" type="BinaryInteger.Words"/>
      <field name="isSigned" type="Bool"/>
      <method name="quotientAndRemainder" signature="quotientAndRemainder(dividingBy: BinaryInteger)">
        <return type="(quotient: BinaryInteger, remainder: BinaryInteger)"/>
      </method>
      <method name="signum" signature="signum()">
        <return type="BinaryInteger"/>
      </method>
      <method name="!=" signature="!=&lt;Other&gt;(BinaryInteger, Other)"/>
      <method name="!=" signature="!=(BinaryInteger, BinaryInteger)"/>
      <method name="%" signature="%(BinaryInteger, BinaryInteger)"/>
      <method name="%=" signature="%=(inout BinaryInteger, BinaryInteger)"/>
      <method name="&amp;" signature="&amp;(BinaryInteger, BinaryInteger)"/>
      <method name="&amp;=" signature="&amp;=(inout BinaryInteger, BinaryInteger)"/>
      <method name="*" signature="*(BinaryInteger, BinaryInteger)"/>
      <method name="*=" signature="*=(inout BinaryInteger, BinaryInteger)"/>
      <method name="+" signature="+(BinaryInteger, BinaryInteger)"/>
      <method name="+=" signature="+=(inout BinaryInteger, BinaryInteger)"/>
      <method name="-" signature="-(BinaryInteger, BinaryInteger)"/>
      <method name="-=" signature="-=(inout BinaryInteger, BinaryInteger)"/>
      <method name="/" signature="/(BinaryInteger, BinaryInteger)"/>
      <method name="/=" signature="/=(inout BinaryInteger, BinaryInteger)"/>
      <method name="&lt;" signature="&lt;&lt;Other&gt;(BinaryInteger, Other)"/>
      <method name="&lt;&lt;" signature="&lt;&lt;&lt;RHS&gt;(BinaryInteger, RHS)"/>
      <method name="&lt;&lt;=" signature="&lt;&lt;=&lt;RHS&gt;(inout BinaryInteger, RHS)"/>
      <method name="&lt;=" signature="&lt;=(BinaryInteger, BinaryInteger)"/>
      <method name="&lt;=" signature="&lt;=&lt;Other&gt;(BinaryInteger, Other)"/>
      <method name="==" signature="==&lt;Other&gt;(BinaryInteger, Other)"/>
      <method name="&gt;" signature="&gt;&lt;Other&gt;(BinaryInteger, Other)"/>
      <method name="&gt;" signature="&gt;(BinaryInteger, BinaryInteger)"/>
      <method name="&gt;=" signature="&gt;=(BinaryInteger, BinaryInteger)"/>
      <method name="&gt;=" signature="&gt;=&lt;Other&gt;(BinaryInteger, Other)"/>
      <method name="&gt;&gt;" signature="&gt;&gt;&lt;RHS&gt;(BinaryInteger, RHS)"/>
      <method name="&gt;&gt;=" signature="&gt;&gt;=&lt;RHS&gt;(inout BinaryInteger, RHS)"/>
      <method name="^" signature="^(BinaryInteger, BinaryInteger)"/>
      <method name="^=" signature="^=(inout BinaryInteger, BinaryInteger)"/>
      <method name="|" signature="|(BinaryInteger, BinaryInteger)"/>
      <method name="|=" signature="|=(inout BinaryInteger, BinaryInteger)"/>
      <method name="~" signature="~(BinaryInteger)"/>
    </class>

    <class kind="protocol" name="UnsignedInteger" supertypes="BinaryInteger">
      <field name="description" type="String"/>
      <field name="magnitude" type="UnsignedInteger"/>
      <field name="max" type="UnsignedInteger"/>
      <field name="min" type="UnsignedInteger"/>
    </class>

    <class kind="protocol" name="FixedWidthInteger" supertypes="LosslessStringConvertible, BinaryInteger">
      <constructor name="FixedWidthInteger" signature="FixedWidthInteger?&lt;S&gt;(S, radix: Int)"/>
      <constructor name="FixedWidthInteger" signature="FixedWidthInteger(bigEndian: FixedWidthInteger)"/>
      <constructor name="FixedWidthInteger" signature="FixedWidthInteger(littleEndian: FixedWidthInteger)"/>
      <field name="bigEndian" type="FixedWidthInteger"/>
      <field name="byteSwapped" type="FixedWidthInteger"/>
      <field name="leadingZeroBitCount" type="Int"/>
      <field name="littleEndian" type="FixedWidthInteger"/>
      <field name="nonzeroBitCount" type="Int"/>
      <field name="bitWidth" type="Int"/>
      <field name="max" type="FixedWidthInteger"/>
      <field name="min" type="FixedWidthInteger"/>
      <method name="addingReportingOverflow" signature="addingReportingOverflow(FixedWidthInteger)">
        <return type="(partialValue: FixedWidthInteger, overflow: Bool)"/>
      </method>
      <method name="dividedReportingOverflow" signature="dividedReportingOverflow(by: FixedWidthInteger)">
        <return type="(partialValue: FixedWidthInteger, overflow: Bool)"/>
      </method>
      <method name="dividingFullWidth" signature="dividingFullWidth((high: FixedWidthInteger, low: FixedWidthInteger.Magnitude))">
        <return type="(quotient: FixedWidthInteger, remainder: FixedWidthInteger)"/>
      </method>
      <method name="multipliedFullWidth" signature="multipliedFullWidth(by: FixedWidthInteger)"/>
      <method name="multipliedReportingOverflow" signature="multipliedReportingOverflow(by: FixedWidthInteger)">
        <return type="(partialValue: FixedWidthInteger, overflow: Bool)"/>
      </method>
      <method name="remainderReportingOverflow" signature="remainderReportingOverflow(dividingBy: FixedWidthInteger)">
        <return type="(partialValue: FixedWidthInteger, overflow: Bool)"/>
      </method>
      <method name="subtractingReportingOverflow" signature="subtractingReportingOverflow(FixedWidthInteger)">
        <return type="(partialValue: FixedWidthInteger, overflow: Bool)"/>
      </method>
      <method name="unsafeAdding" signature="unsafeAdding(FixedWidthInteger)">
        <return type="FixedWidthInteger"/>
      </method>
      <method name="unsafeDivided" signature="unsafeDivided(by: FixedWidthInteger)">
        <return type="FixedWidthInteger"/>
      </method>
      <method name="unsafeMultiplied" signature="unsafeMultiplied(by: FixedWidthInteger)">
        <return type="FixedWidthInteger"/>
      </method>
      <method name="unsafeSubtracting" signature="unsafeSubtracting(FixedWidthInteger)">
        <return type="FixedWidthInteger"/>
      </method>
      <method name="&amp;*" signature="&amp;*(FixedWidthInteger, FixedWidthInteger)"/>
      <method name="&amp;+" signature="&amp;+(FixedWidthInteger, FixedWidthInteger)"/>
      <method name="&amp;-" signature="&amp;-(FixedWidthInteger, FixedWidthInteger)"/>
      <method name="&amp;&lt;&lt;" signature="&amp;&lt;&lt;(FixedWidthInteger, FixedWidthInteger)"/>
      <method name="&amp;&lt;&lt;=" signature="&amp;&lt;&lt;=(inout FixedWidthInteger, FixedWidthInteger)"/>
      <method name="&amp;&gt;&gt;" signature="&amp;&gt;&gt;(FixedWidthInteger, FixedWidthInteger)"/>
      <method name="&amp;&gt;&gt;=" signature="&amp;&gt;&gt;=(inout FixedWidthInteger, FixedWidthInteger)"/>
    </class>


    <class kind="protocol" name="FloatingPoint" supertypes="Strideable, SignedNumeric, Hashable">
      <method name="&lt;" signature="&lt;(FloatingPoint, FloatingPoint)"/>
      <method name="&lt;=" signature="&lt;=(FloatingPoint, FloatingPoint)"/>
      <method name="&gt;" signature="&gt;(FloatingPoint, FloatingPoint)"/>
      <method name="&gt;=" signature="&gt;=(FloatingPoint, FloatingPoint)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(Int16)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(Int32)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(Int64)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(UInt8)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(UInt64)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(UInt32)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(UInt16)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(UInt)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(Int8)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(Int)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(sign: FloatingPointSign, exponent: FloatingPoint.Exponent, significand: FloatingPoint)"/>
      <constructor name="FloatingPoint" signature="FloatingPoint(signOf: FloatingPoint, magnitudeOf: FloatingPoint)"/>
      <field name="exponent" type="FloatingPoint.Exponent"/>
      <field name="floatingPointClass" type="FloatingPointClassification"/>
      <field name="isCanonical" type="Bool"/>
      <field name="isFinite" type="Bool"/>
      <field name="isInfinite" type="Bool"/>
      <field name="isNaN" type="Bool"/>
      <field name="isNormal" type="Bool"/>
      <field name="isSignalingNaN" type="Bool"/>
      <field name="isSubnormal" type="Bool"/>
      <field name="isZero" type="Bool"/>
      <field name="nextDown" type="FloatingPoint"/>
      <field name="nextUp" type="FloatingPoint"/>
      <field name="sign" type="FloatingPointSign"/>
      <field name="significand" type="FloatingPoint"/>
      <field name="ulp" type="FloatingPoint"/>
      <field name="greatestFiniteMagnitude" type="FloatingPoint"/>
      <field name="infinity" type="FloatingPoint"/>
      <field name="leastNonzeroMagnitude" type="FloatingPoint"/>
      <field name="leastNormalMagnitude" type="FloatingPoint"/>
      <field name="nan" type="FloatingPoint"/>
      <field name="pi" type="FloatingPoint"/>
      <field name="radix" type="Int"/>
      <field name="signalingNaN" type="FloatingPoint"/>
      <field name="ulpOfOne" type="FloatingPoint"/>
      <method name="addProduct" signature="addProduct(FloatingPoint, FloatingPoint)"/>
      <method name="addingProduct" signature="addingProduct(FloatingPoint, FloatingPoint)">
        <return type="FloatingPoint"/>
      </method>
      <method name="formRemainder" signature="formRemainder(dividingBy: FloatingPoint)"/>
      <method name="formSquareRoot" signature="formSquareRoot()"/>
      <method name="formTruncatingRemainder" signature="formTruncatingRemainder(dividingBy: FloatingPoint)"/>
      <method name="isEqual" signature="isEqual(to: FloatingPoint)">
        <return type="Bool"/>
      </method>
      <method name="isLess" signature="isLess(than: FloatingPoint)">
        <return type="Bool"/>
      </method>
      <method name="isLessThanOrEqualTo" signature="isLessThanOrEqualTo(FloatingPoint)">
        <return type="Bool"/>
      </method>
      <method name="isTotallyOrdered" signature="isTotallyOrdered(belowOrEqualTo: FloatingPoint)">
        <return type="Bool"/>
      </method>
      <method name="negate" signature="negate()"/>
      <method name="remainder" signature="remainder(dividingBy: FloatingPoint)">
        <return type="FloatingPoint"/>
      </method>
      <method name="round" signature="round()"/>
      <method name="round" signature="round(FloatingPointRoundingRule)"/>
      <method name="rounded" signature="rounded()">
        <return type="FloatingPoint"/>
      </method>
      <method name="rounded" signature="rounded(FloatingPointRoundingRule)">
        <return type="FloatingPoint"/>
      </method>
      <method name="squareRoot" signature="squareRoot()">
        <return type="FloatingPoint"/>
      </method>
      <method name="truncatingRemainder" signature="truncatingRemainder(dividingBy: FloatingPoint)">
        <return type="FloatingPoint"/>
      </method>
      <method name="maximum" signature="maximum(FloatingPoint, FloatingPoint)">
        <return type="FloatingPoint"/>
      </method>
      <method name="maximumMagnitude" signature="maximumMagnitude(FloatingPoint, FloatingPoint)">
        <return type="FloatingPoint"/>
      </method>
      <method name="minimum" signature="minimum(FloatingPoint, FloatingPoint)">
        <return type="FloatingPoint"/>
      </method>
      <method name="minimumMagnitude" signature="minimumMagnitude(FloatingPoint, FloatingPoint)">
        <return type="FloatingPoint"/>
      </method>
      <method name="*" signature="*(FloatingPoint, FloatingPoint)"/>
      <method name="*=" signature="*=(inout FloatingPoint, FloatingPoint)"/>
      <method name="+" signature="+(FloatingPoint, FloatingPoint)"/>
      <method name="+=" signature="+=(inout FloatingPoint, FloatingPoint)"/>
      <method name="-" signature="-(FloatingPoint)"/>
      <method name="-" signature="-(FloatingPoint, FloatingPoint)"/>
      <method name="-=" signature="-=(inout FloatingPoint, FloatingPoint)"/>
      <method name="/" signature="/(FloatingPoint, FloatingPoint)"/>
      <method name="/=" signature="/=(inout FloatingPoint, FloatingPoint)"/>
      <method name="==" signature="==(FloatingPoint, FloatingPoint)"/>
    </class>

    <class kind="protocol" name="BinaryFloatingPoint" supertypes="ExpressibleByFloatLiteral, FloatingPoint">
      <constructor name="BinaryFloatingPoint" signature="BinaryFloatingPoint(Float)"/>
      <constructor name="BinaryFloatingPoint" signature="BinaryFloatingPoint(Double)"/>
      <constructor name="BinaryFloatingPoint" signature="BinaryFloatingPoint(Float80)"/>
      <constructor name="BinaryFloatingPoint" signature="BinaryFloatingPoint(sign: FloatingPointSign, exponentBitPattern: BinaryFloatingPoint.RawExponent, significandBitPattern: BinaryFloatingPoint.RawSignificand)"/>
      <field name="binade" type="BinaryFloatingPoint"/>
      <field name="exponentBitPattern" type="BinaryFloatingPoint.RawExponent"/>
      <field name="significandBitPattern" type="BinaryFloatingPoint.RawSignificand"/>
      <field name="significandWidth" type="Int"/>
      <field name="exponentBitCount" type="Int"/>
      <field name="significandBitCount" type="Int"/>
    </class>




    <class kind="struct" name="Array">
      <constructor name="Array" signature="Array()"/>
      <constructor name="Array" signature="Array&lt;S&gt;(S)"/>
      <constructor name="Array" signature="Array&lt;S&gt;(S)"/>
      <constructor name="Array" signature="Array(repeating: Element, count: Int)"/>
      <field name="isEmpty" type="Bool"/>
      <field name="count" type="Int"/>
      <field name="capacity" type="Int"/>
      <field name="first" type="Element?"/>
      <field name="last" type="Element?"/>
      <method name="append" signature="append(Array.Element)"/>
      <method name="append" signature="append(Element)"/>
      <method name="append" signature="append&lt;S&gt;(contentsOf: S)">
        <tags>hardcoded_path:withContentsOf</tags>
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="append" signature="append&lt;S&gt;(contentsOf: S)">
        <tags>hardcoded_path:withContentsOf</tags>
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="insert" signature="insert(Element, at: Int)"/>
      <method name="insert" signature="insert(Array.Element, at: Int)"/>
      <method name="insert" signature="insert&lt;C&gt;(contentsOf: C, at: Int)">
        <tags>hardcoded_path:withContentsOf</tags>
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="replaceSubrange" signature="replaceSubrange&lt;C&gt;(Range&lt;Int&gt;, with: C)"/>
      <method name="replaceSubrange" signature="replaceSubrange&lt;C, R&gt;(R, with: C)"/>
      <method name="reserveCapacity" signature="reserveCapacity(Int)"/>
      <method name="reserveCapacity" signature="reserveCapacity(Int)"/>
      <method name="remove" signature="remove(at: Int)">
        <return type="Array.Element"/>
      </method>
      <method name="remove" signature="remove(at: Int)">
        <return type="Element"/>
      </method>
      <method name="removeFirst" signature="removeFirst()">
        <return type="Element"/>
      </method>
      <method name="removeFirst" signature="removeFirst(Int)"/>
      <method name="removeLast" signature="removeLast()">
        <return type="Element"/>
      </method>
      <method name="removeLast" signature="removeLast(Int)"/>
      <method name="removeSubrange" signature="removeSubrange(Range&lt;Int&gt;)"/>
      <method name="removeSubrange" signature="removeSubrange&lt;R&gt;(R)"/>
      <method name="removeAll" signature="removeAll(keepingCapacity: Bool)"/>
      <method name="removeAll" signature="removeAll(keepingCapacity: Bool)"/>
      <method name="popLast" signature="popLast()">
        <return type="Array.Element?"/>
      </method>
      <method name="contains" signature="contains(where: (Element) -&gt; Bool)">
        <return type="Bool"/>
      </method>
      <method name="first" signature="first(where: (Element) -&gt; Bool)">
        <return type="Element?"/>
      </method>
      <method name="index" signature="index(of: Element)">
        <return type="Int?"/>
      </method>
      <method name="index" signature="index(where: (Element) -&gt; Bool)">
        <return type="Int?"/>
      </method>
      <method name="min" signature="min()">
        <return type="Element?"/>
      </method>
      <method name="min" signature="min(by: (Element, Element) -&gt; Bool)">
        <return type="Element?"/>
      </method>
      <method name="max" signature="max()">
        <return type="Element?"/>
      </method>
      <method name="max" signature="max(by: (Element, Element) -&gt; Bool)">
        <return type="Element?"/>
      </method>
      <method name="prefix" signature="prefix(Int)">
        <return type="ArraySlice&lt;Element&gt;"/>
      </method>
      <method name="prefix" signature="prefix(through: Int)">
        <return type="ArraySlice&lt;Element&gt;"/>
      </method>
      <method name="prefix" signature="prefix(upTo: Int)">
        <return type="ArraySlice&lt;Element&gt;"/>
      </method>
      <method name="prefix" signature="prefix(while: (Element) -&gt; Bool)"/>
      <method name="suffix" signature="suffix(Int)">
        <return type="ArraySlice&lt;Element&gt;"/>
      </method>
      <method name="suffix" signature="suffix(from: Int)">
        <return type="ArraySlice&lt;Element&gt;"/>
      </method>
      <method name="dropFirst" signature="dropFirst()">
        <return type="ArraySlice&lt;Element&gt;"/>
      </method>
      <method name="dropFirst" signature="dropFirst(Int)">
        <return type="ArraySlice&lt;Element&gt;"/>
      </method>
      <method name="dropLast" signature="dropLast()">
        <return type="ArraySlice&lt;Element&gt;"/>
      </method>
      <method name="dropLast" signature="dropLast(Int)">
        <return type="ArraySlice&lt;Element&gt;"/>
      </method>
      <method name="drop" signature="drop(while: (Element) -&gt; Bool)"/>
      <method name="map" signature="map&lt;T&gt;((Element) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="map" signature="map&lt;T&gt;((Element) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="flatMap" signature="flatMap((Element) -&gt; String?)"/>
      <method name="reduce" signature="reduce&lt;Result&gt;(Result, (Result, Element) -&gt; Result)">
        <return type="Result"/>
      </method>
      <method name="reduce" signature="reduce&lt;Result&gt;(into: Result, (inout Result, Element) -&gt; ())">
        <return type="Result"/>
      </method>
      <field name="lazy" type="LazyCollection&lt;Array&lt;Element&gt;&gt;"/>
      <field name="lazy" type="LazySequence&lt;Array&lt;Element&gt;&gt;"/>
      <field name="lazy" type="LazyBidirectionalCollection&lt;Array&lt;Element&gt;&gt;"/>
      <field name="lazy" type="LazyRandomAccessCollection&lt;Array&lt;Element&gt;&gt;"/>
      <method name="forEach" signature="forEach((Element) -&gt; Void)"/>
      <method name="enumerated" signature="enumerated()">
        <return type="EnumeratedSequence&lt;Array&lt;Element&gt;&gt;"/>
      </method>
      <method name="makeIterator" signature="makeIterator()"/>
      <field name="underestimatedCount" type="Int"/>
      <field name="underestimatedCount" type="Int"/>
      <method name="sort" signature="sort()"/>
      <method name="sort" signature="sort(by: (Element, Element) -&gt; Bool)"/>
      <method name="sorted" signature="sorted()">
        <return type="[Element]"/>
      </method>
      <method name="sorted" signature="sorted()">
        <return type="[Element]"/>
      </method>
      <method name="sorted" signature="sorted(by: (Element, Element) -&gt; Bool)">
        <return type="[Element]"/>
      </method>
      <method name="reversed" signature="reversed()"/>
      <method name="partition" signature="partition(by: (Element) -&gt; Bool)"/>
      <method name="partition" signature="partition(by: (Element) -&gt; Bool)"/>
      <method name="swapAt" signature="swapAt(Int, Int)"/>
      <method name="split" signature="split(separator: Element, maxSplits: Int, omittingEmptySubsequences: Bool)">
        <return type="[AnySequence&lt;Element&gt;]"/>
      </method>
      <method name="split" signature="split(separator: Element, maxSplits: Int, omittingEmptySubsequences: Bool)">
        <return type="[ArraySlice&lt;Element&gt;]"/>
      </method>
      <method name="split" signature="split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (Element) -&gt; Bool)">
        <return type="[ArraySlice&lt;Element&gt;]"/>
      </method>
      <method name="joined" signature="joined(separator: String)">
        <return type="String"/>
      </method>
      <method name="joined" signature="joined()">
        <return type="FlattenBidirectionalCollection&lt;Array&lt;Element&gt;&gt;"/>
      </method>
      <method name="joined" signature="joined()">
        <return type="FlattenCollection&lt;Array&lt;Element&gt;&gt;"/>
      </method>
      <method name="joined" signature="joined()">
        <return type="FlattenSequence&lt;Array&lt;Element&gt;&gt;"/>
      </method>
      <method name="joined" signature="joined(separator: String)">
        <return type="String"/>
      </method>
      <method name="joined" signature="joined&lt;Separator&gt;(separator: Separator)">
        <return type="JoinedSequence&lt;Array&lt;Element&gt;&gt; where Separator : Sequence, Separator.Element == Element.Element"/>
      </method>
      <method name="==" signature="==&lt;Element&gt;(Array&lt;Element&gt;, Array&lt;Element&gt;)"/>
      <method name="!=" signature="!=&lt;Element&gt;(Array&lt;Element&gt;, Array&lt;Element&gt;)"/>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, Element == OtherSequence.Element"/>
      </method>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence, by: (Element, Element) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, Element == OtherSequence.Element"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix)">
        <return type="Bool where PossiblePrefix : Sequence, Element == PossiblePrefix.Element"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix, by: (Element, Element) -&gt; Bool)">
        <return type="Bool where PossiblePrefix : Sequence, Element == PossiblePrefix.Element"/>
      </method>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, Element == OtherSequence.Element"/>
      </method>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence, by: (Element, Element) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, Element == OtherSequence.Element"/>
      </method>
      <field name="startIndex" type="Int"/>
      <field name="endIndex" type="Int"/>
      <method name="index" signature="index(after: Int)"/>
      <method name="formIndex" signature="formIndex(after: inout Int)"/>
      <method name="index" signature="index(before: Int)"/>
      <method name="formIndex" signature="formIndex(before: inout Int)"/>
      <method name="index" signature="index(Int, offsetBy: Int)">
        <return type="Int"/>
      </method>
      <method name="index" signature="index(Int, offsetBy: Int, limitedBy: Int)">
        <return type="Int?"/>
      </method>
      <method name="distance" signature="distance(from: Int, to: Int)">
        <return type="Int"/>
      </method>
      <field name="indices" type="CountableRange&lt;Int&gt;"/>
      <field name="indices" type="DefaultRandomAccessIndices&lt;Array&lt;Element&gt;&gt;"/>
      <method name="withUnsafeBufferPointer" signature="withUnsafeBufferPointer&lt;R&gt;((UnsafeBufferPointer&lt;Array.Element&gt;) -&gt; R)">
        <return type="R"/>
      </method>
      <method name="withUnsafeMutableBufferPointer" signature="withUnsafeMutableBufferPointer&lt;R&gt;((inout UnsafeMutableBufferPointer&lt;Array.Element&gt;) -&gt; R)">
        <return type="R"/>
      </method>
      <method name="withUnsafeBytes" signature="withUnsafeBytes&lt;R&gt;((UnsafeRawBufferPointer) -&gt; R)">
        <return type="R"/>
      </method>
      <method name="withUnsafeMutableBytes" signature="withUnsafeMutableBytes&lt;R&gt;((UnsafeMutableRawBufferPointer) -&gt; R)">
        <return type="R"/>
      </method>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="Array" signature="Array(from: Decoder)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <constructor name="Array" signature="Array(arrayLiteral: Array.Element...)"/>
    </class>


    <class kind="struct" name="Dictionary">
      <constructor name="Dictionary" signature="Dictionary()"/>
      <constructor name="Dictionary" signature="Dictionary(minimumCapacity: Int)"/>
      <constructor name="Dictionary" signature="Dictionary&lt;S&gt;(uniqueKeysWithValues: S)"/>
      <constructor name="Dictionary" signature="Dictionary&lt;S&gt;(S, uniquingKeysWith: (Value, Value) -&gt; Value)"/>
      <constructor name="Dictionary" signature="Dictionary&lt;S&gt;(grouping: S, by: (S.Element) -&gt; Key)"/>
      <field name="isEmpty" type="Bool"/>
      <field name="count" type="Int"/>
      <field name="capacity" type="Int"/>
      <method name="index" signature="index(forKey: Dictionary.Key)">
        <return type="Dictionary&lt;Key, Value&gt;.Index?"/>
      </method>
      <field name="first" type="Value)?"/>
      <field name="keys" type="Value&gt;.Keys"/>
      <field name="values" type="Value&gt;.Values"/>
      <method name="updateValue" signature="updateValue(Dictionary.Value, forKey: Dictionary.Key)">
        <return type="Dictionary.Value?"/>
      </method>
      <method name="merge" signature="merge([Dictionary.Key : Dictionary.Value], uniquingKeysWith: (Dictionary.Value, Dictionary.Value) -&gt; Dictionary.Value)"/>
      <method name="merge" signature="merge&lt;S&gt;(S, uniquingKeysWith: (Dictionary.Value, Dictionary.Value) -&gt; Dictionary.Value)"/>
      <method name="merging" signature="merging([Dictionary.Key : Dictionary.Value], uniquingKeysWith: (Dictionary.Value, Dictionary.Value) -&gt; Dictionary.Value)">
        <return type="[Dictionary.Key : Dictionary.Value]"/>
      </method>
      <method name="merging" signature="merging&lt;S&gt;(S, uniquingKeysWith: (Dictionary.Value, Dictionary.Value) -&gt; Dictionary.Value)">
        <return type="[Dictionary.Key : Dictionary.Value] where S : Sequence, S.Element == (Dictionary.Key, Dictionary.Value)"/>
      </method>
      <method name="reserveCapacity" signature="reserveCapacity(Int)"/>
      <method name="filter" signature="filter((Dictionary.Element) -&gt; Bool)">
        <return type="[Dictionary.Key : Dictionary.Value]"/>
      </method>
      <method name="removeValue" signature="removeValue(forKey: Dictionary.Key)">
        <return type="Dictionary.Value?"/>
      </method>
      <method name="remove" signature="remove(at: Dictionary&lt;Key, Value&gt;.Index)">
        <return type="Dictionary.Element"/>
      </method>
      <method name="removeAll" signature="removeAll(keepingCapacity: Bool)"/>
      <method name="==" signature="==([Key : Value], [Key : Value])"/>
      <method name="!=" signature="!=([Key : Value], [Key : Value])"/>
      <method name="forEach" signature="forEach(((key: Key, value: Value)) -&gt; Void)"/>
      <method name="enumerated" signature="enumerated()">
        <return type="EnumeratedSequence&lt;Dictionary&lt;Key, Value&gt;&gt;"/>
      </method>
      <field name="lazy" type="Value&gt;&gt;"/>
      <field name="lazy" type="Value&gt;&gt;"/>
      <method name="makeIterator" signature="makeIterator()">
        <return type="DictionaryIterator&lt;Dictionary.Key, Dictionary.Value&gt;"/>
      </method>
      <field name="underestimatedCount" type="Int"/>
      <field name="underestimatedCount" type="Int"/>
      <method name="contains" signature="contains(where: ((key: Key, value: Value)) -&gt; Bool)">
        <return type="Bool"/>
      </method>
      <method name="first" signature="first(where: ((key: Key, value: Value)) -&gt; Bool)">
        <return type="(key: Key, value: Value)?"/>
      </method>
      <method name="index" signature="index(where: ((key: Key, value: Value)) -&gt; Bool)">
        <return type="Dictionary&lt;Key, Value&gt;.Index?"/>
      </method>
      <method name="min" signature="min(by: ((key: Key, value: Value), (key: Key, value: Value)) -&gt; Bool)">
        <return type="(key: Key, value: Value)?"/>
      </method>
      <method name="max" signature="max(by: ((key: Key, value: Value), (key: Key, value: Value)) -&gt; Bool)">
        <return type="(key: Key, value: Value)?"/>
      </method>
      <method name="mapValues" signature="mapValues&lt;T&gt;((Dictionary.Value) -&gt; T)">
        <return type="Dictionary&lt;Dictionary.Key, T&gt;"/>
      </method>
      <method name="reduce" signature="reduce&lt;Result&gt;(Result, (Result, (key: Key, value: Value)) -&gt; Result)">
        <return type="Result"/>
      </method>
      <method name="reduce" signature="reduce&lt;Result&gt;(into: Result, (inout Result, (key: Key, value: Value)) -&gt; ())">
        <return type="Result"/>
      </method>
      <method name="map" signature="map&lt;T&gt;(((key: Key, value: Value)) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="map" signature="map&lt;T&gt;(((key: Key, value: Value)) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="flatMap" signature="flatMap(((key: Key, value: Value)) -&gt; String?)"/>
      <method name="sorted" signature="sorted(by: ((key: Key, value: Value), (key: Key, value: Value)) -&gt; Bool)">
        <return type="[(key: Key, value: Value)]"/>
      </method>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="Dictionary" signature="Dictionary(from: Decoder)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <constructor name="Dictionary" signature="Dictionary(dictionaryLiteral: (Key, Value)...)"/>
    </class>


    <class kind="struct" name="Set">
      <constructor name="Set" signature="Set()"/>
      <constructor name="Set" signature="Set(minimumCapacity: Int)"/>
      <constructor name="Set" signature="Set&lt;Source&gt;(Source)"/>
      <constructor name="Set" signature="Set&lt;S&gt;(S)"/>
      <field name="isEmpty" type="Bool"/>
      <field name="isEmpty" type="Bool"/>
      <field name="isEmpty" type="Bool"/>
      <field name="count" type="Int"/>
      <field name="count" type="Int"/>
      <field name="first" type="Element?"/>
      <field name="first" type="Element?"/>
      <field name="capacity" type="Int"/>
      <method name="contains" signature="contains(Set.Element)">
        <return type="Bool"/>
      </method>
      <method name="insert" signature="insert(Set.Element)">
        <return type="(inserted: Bool, memberAfterInsert: Set.Element)"/>
      </method>
      <method name="insert" signature="insert&lt;ConcreteElement&gt;(ConcreteElement)"/>
      <method name="update" signature="update(with: Set.Element)">
        <return type="Set.Element?"/>
      </method>
      <method name="update" signature="update&lt;ConcreteElement&gt;(with: ConcreteElement)"/>
      <method name="reserveCapacity" signature="reserveCapacity(Int)"/>
      <method name="filter" signature="filter((Set.Element) -&gt; Bool)">
        <return type="Set&lt;Element&gt;"/>
      </method>
      <method name="remove" signature="remove(Set.Element)">
        <return type="Set.Element?"/>
      </method>
      <method name="remove" signature="remove&lt;ConcreteElement&gt;(ConcreteElement)"/>
      <method name="removeFirst" signature="removeFirst()">
        <return type="Set.Element"/>
      </method>
      <method name="remove" signature="remove(at: Set&lt;Element&gt;.Index)">
        <return type="Set.Element"/>
      </method>
      <method name="removeAll" signature="removeAll(keepingCapacity: Bool)"/>
      <method name="union" signature="union&lt;S&gt;(S)">
        <return type="Set&lt;Set.Element&gt; where Element == S.Element, S : Sequence"/>
      </method>
      <method name="formUnion" signature="formUnion&lt;S&gt;(S)"/>
      <method name="intersection" signature="intersection(Set&lt;Set.Element&gt;)">
        <return type="Set&lt;Set.Element&gt;"/>
      </method>
      <method name="intersection" signature="intersection&lt;S&gt;(S)">
        <return type="Set&lt;Set.Element&gt; where Element == S.Element, S : Sequence"/>
      </method>
      <method name="formIntersection" signature="formIntersection&lt;S&gt;(S)"/>
      <method name="symmetricDifference" signature="symmetricDifference&lt;S&gt;(S)">
        <return type="Set&lt;Set.Element&gt; where Element == S.Element, S : Sequence"/>
      </method>
      <method name="formSymmetricDifference" signature="formSymmetricDifference(Set&lt;Set.Element&gt;)"/>
      <method name="formSymmetricDifference" signature="formSymmetricDifference&lt;S&gt;(S)"/>
      <method name="subtract" signature="subtract(Set&lt;Element&gt;)"/>
      <method name="subtract" signature="subtract(Set&lt;Set.Element&gt;)"/>
      <method name="subtract" signature="subtract&lt;S&gt;(S)"/>
      <method name="subtracting" signature="subtracting(Set&lt;Set.Element&gt;)">
        <return type="Set&lt;Set.Element&gt;"/>
      </method>
      <method name="subtracting" signature="subtracting&lt;S&gt;(S)">
        <return type="Set&lt;Set.Element&gt; where Element == S.Element, S : Sequence"/>
      </method>
      <method name="==" signature="==(Set&lt;Element&gt;, Set&lt;Element&gt;)">
        <return type="Bool"/>
      </method>
      <method name="!=" signature="!=(Set&lt;Element&gt;, Set&lt;Element&gt;)"/>
      <method name="isSubset" signature="isSubset(of: Set&lt;Set.Element&gt;)">
        <return type="Bool"/>
      </method>
      <method name="isSubset" signature="isSubset&lt;S&gt;(of: S)">
        <return type="Bool where Element == S.Element, S : Sequence"/>
      </method>
      <method name="isStrictSubset" signature="isStrictSubset(of: Set&lt;Set.Element&gt;)">
        <return type="Bool"/>
      </method>
      <method name="isStrictSubset" signature="isStrictSubset&lt;S&gt;(of: S)">
        <return type="Bool where Element == S.Element, S : Sequence"/>
      </method>
      <method name="isSuperset" signature="isSuperset(of: Set&lt;Set.Element&gt;)">
        <return type="Bool"/>
      </method>
      <method name="isSuperset" signature="isSuperset&lt;S&gt;(of: S)">
        <return type="Bool where Element == S.Element, S : Sequence"/>
      </method>
      <method name="isStrictSuperset" signature="isStrictSuperset(of: Set&lt;Set.Element&gt;)">
        <return type="Bool"/>
      </method>
      <method name="isStrictSuperset" signature="isStrictSuperset&lt;S&gt;(of: S)">
        <return type="Bool where Element == S.Element, S : Sequence"/>
      </method>
      <method name="isDisjoint" signature="isDisjoint(with: Set&lt;Set.Element&gt;)">
        <return type="Bool"/>
      </method>
      <method name="isDisjoint" signature="isDisjoint&lt;S&gt;(with: S)">
        <return type="Bool where Element == S.Element, S : Sequence"/>
      </method>
      <method name="contains" signature="contains(where: (Element) -&gt; Bool)">
        <return type="Bool"/>
      </method>
      <method name="first" signature="first(where: (Element) -&gt; Bool)">
        <return type="Element?"/>
      </method>
      <method name="index" signature="index(of: Set.Element)">
        <return type="Set&lt;Element&gt;.Index?"/>
      </method>
      <method name="index" signature="index(where: (Element) -&gt; Bool)">
        <return type="Set&lt;Element&gt;.Index?"/>
      </method>
      <method name="min" signature="min()">
        <return type="Element?"/>
      </method>
      <method name="min" signature="min(by: (Element, Element) -&gt; Bool)">
        <return type="Element?"/>
      </method>
      <method name="max" signature="max()">
        <return type="Element?"/>
      </method>
      <method name="max" signature="max(by: (Element, Element) -&gt; Bool)">
        <return type="Element?"/>
      </method>
      <method name="map" signature="map&lt;T&gt;((Element) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="map" signature="map&lt;T&gt;((Element) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="flatMap" signature="flatMap((Element) -&gt; String?)"/>
      <method name="reduce" signature="reduce&lt;Result&gt;(Result, (Result, Element) -&gt; Result)">
        <return type="Result"/>
      </method>
      <method name="reduce" signature="reduce&lt;Result&gt;(into: Result, (inout Result, Element) -&gt; ())">
        <return type="Result"/>
      </method>
      <method name="sorted" signature="sorted()">
        <return type="[Element]"/>
      </method>
      <method name="sorted" signature="sorted(by: (Element, Element) -&gt; Bool)">
        <return type="[Element]"/>
      </method>
      <field name="lazy" type="LazyCollection&lt;Set&lt;Element&gt;&gt;"/>
      <field name="lazy" type="LazySequence&lt;Set&lt;Element&gt;&gt;"/>
      <method name="enumerated" signature="enumerated()">
        <return type="EnumeratedSequence&lt;Set&lt;Element&gt;&gt;"/>
      </method>
      <method name="forEach" signature="forEach((Element) -&gt; Void)"/>
      <method name="makeIterator" signature="makeIterator()"/>
      <field name="underestimatedCount" type="Int"/>
      <field name="underestimatedCount" type="Int"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="Set" signature="Set(from: Decoder)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <constructor name="Set" signature="Set(arrayLiteral: Element...)"/>
    </class>


    <class kind="struct" name="String">
      <property name="bridgeTypes" value="Foundation.NSString"/>
      <constructor name="String" signature="String()"/>
      <constructor name="String" signature="String(Character)"/>
      <constructor name="String" signature="String&lt;S&gt;(S)"/>
      <constructor name="String" signature="String&lt;S&gt;(S)"/>
      <constructor name="String" signature="String&lt;S&gt;(S)"/>
      <constructor name="String" signature="String(repeating: String, count: Int)"/>
      <constructor name="String" signature="String(Substring)"/>
      <constructor name="String" signature="String(repeating: Character, count: Int)"/>
      <constructor name="String" signature="String(repeating: Character, count: Int)"/>
      <field name="isEmpty" type="Bool"/>
      <field name="count" type="String.CharacterView.IndexDistance"/>
      <constructor name="String" signature="String?(data: Data, encoding: String.Encoding)">
        <sink argpos="-1" kind="encoding_buffer_overflow" />
      </constructor>
      <constructor name="String" signature="String?(utf8String: UnsafePointer&lt;CChar&gt;)"/>
      <constructor name="String" signature="String?(validatingUTF8: UnsafePointer&lt;CChar&gt;)"/>
      <constructor name="String" signature="String(utf16CodeUnits: UnsafePointer&lt;unichar&gt;, count: Int)"/>
      <constructor name="String" signature="String(utf16CodeUnitsNoCopy: UnsafePointer&lt;unichar&gt;, count: Int, freeWhenDone: Bool)"/>
      <constructor name="String" signature="String&lt;C, Encoding&gt;(decoding: C, as: Encoding.Type)"/>
      <constructor name="String" signature="String(format: String, CVarArg...)">
        <parameters>
          <param type="String" name="format" />
          <param type="StrinArray" name="arguments" />
        </parameters>
        <sink argpos="2" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="String" signature="String(format: String, arguments: [CVarArg])">
        <parameters>
          <param type="String" name="format" />
          <param type="StrinArrayg" name="arguments" />
        </parameters>
        <sink argpos="2" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="String" signature="String(format: String, locale: Locale?, CVarArg...)">
        <parameters>
          <param type="String" name="format" />
          <param type="Locale" name="locale" />
        </parameters>
        <sink argpos="2" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="String" signature="String(format: String, locale: Locale?, arguments: [CVarArg])">
        <parameters>
          <param type="String" name="format" />
          <param type="Locale" name="locale" />
          <param type="Array" name="arguments" />
        </parameters>
        <sink argpos="2" kind="format_injection" resource="other" />
      </constructor>
      <method name="localizedStringWithFormat" signature="localizedStringWithFormat(String, CVarArg...)">
        <parameters>
          <param type="String"/>
        </parameters>
        <sink argpos="2" kind="format_injection" resource="other" />
      </method>
      <constructor name="String" signature="String&lt;T&gt;(T, radix: Int, uppercase: Bool)"/>
      <constructor name="String" signature="String&lt;T&gt;(T, radix: Int, uppercase: Bool)"/>
      <constructor name="String" signature="String?&lt;S&gt;(bytes: S, encoding: String.Encoding)"/>
      <constructor name="String" signature="String?(bytesNoCopy: UnsafeMutableRawPointer, length: Int, encoding: String.Encoding, freeWhenDone: Bool)"/>
      <constructor name="String" signature="String(cString: UnsafePointer&lt;CChar&gt;)"/>
      <constructor name="String" signature="String(cString: UnsafePointer&lt;UInt8&gt;)"/>
      <constructor name="String" signature="String?(cString: UnsafePointer&lt;CChar&gt;, encoding: String.Encoding)"/>
      <constructor name="String" signature="String&lt;Encoding&gt;(decodingCString: UnsafePointer&lt;Encoding.CodeUnit&gt;, as: Encoding.Type)"/>
      <method name="decodeCString" signature="decodeCString&lt;Encoding&gt;(UnsafePointer&lt;Encoding.CodeUnit&gt;?, as: Encoding.Type, repairingInvalidCodeUnits: Bool)">
        <return type="(result: String, repairsMade: Bool)? where Encoding : _UnicodeEncoding"/>
      </method>
      <constructor name="String" signature="String&lt;T&gt;(T)"/>
      <constructor name="String" signature="String&lt;Subject&gt;(describing: Subject)"/>
      <constructor name="String" signature="String&lt;Subject&gt;(reflecting: Subject)"/>
      <constructor name="String" signature="String(contentsOf: URL)">
        <tags>hardcoded_path:withContentsOf</tags>
        <parameters>
          <param type="String" name="URL"/>
        </parameters>
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
        <sink paramNames="contentsOf" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="String" signature="String(contentsOf: URL, encoding: String.Encoding)">
        <tags>hardcoded_path:withContentsOf</tags>
        <parameters>
          <param type="String" name="contentsOf"/>
        </parameters>
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
      </constructor>
      <constructor name="String" signature="String(contentsOf: URL, usedEncoding: inout String.Encoding)">
        <tags>hardcoded_path:withContentsOf</tags>
        <parameters>
          <param type="String" name="contentsOf"/>
          <param type="String.Encoding" name="usedEncoding"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="String" signature="String(contentsOfFile: String)">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param type="String" name="contentsOfFile"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="String" signature="String(contentsOfFile: String, encoding: String.Encoding)">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param type="String" name="contentsOfFile"/>
          <param type="String.Encoding" name="encoding"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="String" signature="String(contentsOfFile: String, usedEncoding: inout String.Encoding)">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param type="String" name="contentsOfFile"/>
          <param type="String.Encoding" name="usedEncoding"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <method name="write" signature="write(String)">
        <parameters>
          <param type="String" />
        </parameters>
      </method>
      <method name="write" signature="write&lt;Target&gt;(to: Target)">
        <parameters>
          <param type="String" />
          <param type="Target" name="to"/>
        </parameters>
      </method>
      <method name="write" signature="write&lt;Target&gt;(toFile: Target, atomically:Bool)">
        <parameters>
          <param type="String" />
          <param type="Target" name="toFile"/>
          <param type="Bool" name="atomically"/>
        </parameters>
        <sink argpos="-2" kind="insecure_temporary_file" resource="filesystem">
          <checker id="foundation.atomicallyChecker" />
        </sink>
      </method>
      <method name="write" signature="write&lt;Target&gt;(toFile: Target, atomically:Bool, encoding:String.Encoding)">
        <parameters>
          <param type="String" />
          <param type="Target" name="to"/>
          <param type="Bool" name="atomically"/>
          <param type="String.Encoding" name="encoding"/>
        </parameters>
        <sink argpos="-2" kind="insecure_temporary_file" resource="filesystem">
          <checker id="foundation.atomicallyChecker" />
        </sink>
      </method>
      <method name="append" signature="append(Character)"/>
      <method name="append" signature="append(String)"/>
      <method name="append" signature="append&lt;S&gt;(contentsOf: String)">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param type="String" name="contentsOf" />
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="reserveCapacity" signature="reserveCapacity(Int)"/>
      <method name="+" signature="+(String, String)"/>
      <method name="+=" signature="+=(inout String, String)"/>
      <method name="insert" signature="insert(Character, at: String.Index)"/>
      <method name="insert" signature="insert(Character, at: String.Index)"/>
      <method name="insert" signature="insert&lt;S&gt;(contentsOf: S, at: String.Index)">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param type="String" name="contentsOf" />
          <param type="String.Index" name="at" />
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="reserveCapacity" signature="reserveCapacity(String.CharacterView.IndexDistance)"/>
      <method name="replaceSubrange" signature="replaceSubrange&lt;C, R&gt;(R, with: C)">
        <parameters>
          <param type="Range" name="" />
          <param type="Collection" name="with" />
        </parameters>
        <neutralization argpos="-1" kind="string" />
      </method>
      <method name="replaceSubrange" signature="replaceSubrange&lt;C&gt;(Range&lt;String.Index&gt;, with: C)"/>
      <method name="remove" signature="remove(at: String.Index)">
        <return type="Character"/>
      </method>
      <method name="remove" signature="remove(at: String.Index)">
        <return type="Character"/>
      </method>
      <method name="removeAll" signature="removeAll(keepingCapacity: Bool)"/>
      <method name="removeFirst" signature="removeFirst()">
        <return type="Character"/>
      </method>
      <method name="removeFirst" signature="removeFirst(Int)"/>
      <method name="removeLast" signature="removeLast()">
        <return type="Character"/>
      </method>
      <method name="removeLast" signature="removeLast(Int)"/>
      <method name="removeSubrange" signature="removeSubrange&lt;R&gt;(R)"/>
      <method name="removeSubrange" signature="removeSubrange(Range&lt;String.Index&gt;)"/>
      <method name="removeSubrange" signature="removeSubrange(Range&lt;String.Index&gt;)"/>
      <method name="filter" signature="filter((Character) -&gt; Bool)">
        <return type="String"/>
      </method>
      <method name="drop" signature="drop(while: (Character) -&gt; Bool)"/>
      <method name="dropFirst" signature="dropFirst()">
        <return type="Substring"/>
      </method>
      <method name="dropFirst" signature="dropFirst(Int)">
        <return type="Substring"/>
      </method>
      <method name="dropLast" signature="dropLast()">
        <return type="Substring"/>
      </method>
      <method name="dropLast" signature="dropLast(Int)">
        <return type="Substring"/>
      </method>
      <method name="lowercased" signature="lowercased()">
        <return type="String"/>
      </method>
      <method name="uppercased" signature="uppercased()">
        <return type="String"/>
      </method>
      <method name="==" signature="==(String, String)"/>
      <method name="==" signature="==&lt;R&gt;(String, R)"/>
      <method name="!=" signature="!=(String, String)"/>
      <method name="!=" signature="!=&lt;R&gt;(String, R)"/>
      <method name="&lt;" signature="&lt;(String, String)"/>
      <method name="&lt;" signature="&lt;&lt;R&gt;(String, R)"/>
      <method name="&lt;=" signature="&lt;=(String, String)"/>
      <method name="&lt;=" signature="&lt;=&lt;R&gt;(String, R)"/>
      <method name="&gt;" signature="&gt;(String, String)"/>
      <method name="&gt;" signature="&gt;&lt;R&gt;(String, R)"/>
      <method name="&gt;=" signature="&gt;=(String, String)">
        <return type="Bool"/>
      </method>
      <method name="&gt;=" signature="&gt;=&lt;R&gt;(String, R)"/>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence, by: (Character, Character) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, String.Element == OtherSequence.Element"/>
      </method>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, String.Element == OtherSequence.Element"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix)">
        <return type="Bool where PossiblePrefix : Sequence, String.Element == PossiblePrefix.Element"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix, by: (Character, Character) -&gt; Bool)">
        <return type="Bool where PossiblePrefix : Sequence, String.Element == PossiblePrefix.Element"/>
      </method>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, String.Element == OtherSequence.Element"/>
      </method>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence, by: (Character, Character) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, String.Element == OtherSequence.Element"/>
      </method>
      <method name="hasPrefix" signature="hasPrefix(String)">
        <return type="Bool"/>
      </method>
      <method name="hasSuffix" signature="hasSuffix(String)">
        <return type="Bool"/>
      </method>
      <method name="contains" signature="contains(Character)">
        <return type="Bool"/>
      </method>
      <method name="contains" signature="contains(where: (Character) -&gt; Bool)">
        <return type="Bool"/>
      </method>
      <method name="first" signature="first(where: (Character) -&gt; Bool)">
        <return type="Character?"/>
      </method>
      <method name="index" signature="index(of: Character)">
        <return type="String.Index?"/>
      </method>
      <method name="index" signature="index(where: (Character) -&gt; Bool)">
        <return type="String.Index?"/>
      </method>
      <method name="max" signature="max()">
        <return type="Character?"/>
      </method>
      <method name="max" signature="max&lt;T&gt;(T, T)"/>
      <method name="max" signature="max(by: (Character, Character) -&gt; Bool)">
        <return type="Character?"/>
      </method>
      <method name="min" signature="min()">
        <return type="Character?"/>
      </method>
      <method name="min" signature="min&lt;T&gt;(T, T)"/>
      <method name="min" signature="min(by: (Character, Character) -&gt; Bool)">
        <return type="Character?"/>
      </method>
      <method name="prefix" signature="prefix(Int)">
        <return type="Substring"/>
      </method>
      <method name="prefix" signature="prefix(through: String.Index)">
        <return type="Substring"/>
      </method>
      <method name="prefix" signature="prefix(upTo: String.Index)">
        <return type="Substring"/>
      </method>
      <method name="prefix" signature="prefix(while: (Character) -&gt; Bool)"/>
      <method name="suffix" signature="suffix(Int)">
        <return type="Substring"/>
      </method>
      <method name="suffix" signature="suffix(from: String.Index)">
        <return type="Substring"/>
      </method>
      <method name="split" signature="split(separator: Character, maxSplits: Int, omittingEmptySubsequences: Bool)">
        <return type="[Substring]"/>
      </method>
      <method name="split" signature="split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (Character) -&gt; Bool)">
        <return type="[Substring]"/>
      </method>
      <field name="first" type="Character?"/>
      <field name="last" type="Character?"/>
      <field name="availableStringEncodings" type="[String.Encoding]"/>
      <field name="defaultCStringEncoding" type="String.Encoding"/>
      <method name="localizedName" signature="localizedName(of: String.Encoding)"/>
      <field name="characters" type="String.CharacterView"/>
      <constructor name="String" signature="String(String.CharacterView)"/>
      <constructor name="String" signature="String(Substring.CharacterView)"/>
      <method name="withMutableCharacters" signature="withMutableCharacters&lt;R&gt;((inout String.CharacterView) -&gt; R)">
        <return type="R"/>
      </method>
      <field name="unicodeScalars" type="String.UnicodeScalarView"/>
      <constructor name="String" signature="String(String.UnicodeScalarView)"/>
      <constructor name="String" signature="String(Substring.UnicodeScalarView)"/>
      <field name="utf16" type="String.UTF16View"/>
      <constructor name="String" signature="String(String.UTF16View)"/>
      <constructor name="String" signature="String?(Substring.UTF16View)"/>
      <field name="utf8" type="String.UTF8View"/>
      <constructor name="String" signature="String(String.UTF8View)"/>
      <constructor name="String" signature="String?(Substring.UTF8View)"/>
      <method name="map" signature="map&lt;T&gt;((Character) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="map" signature="map&lt;T&gt;((Character) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="flatMap" signature="flatMap((Character) -&gt; String?)"/>
      <method name="reduce" signature="reduce&lt;Result&gt;(Result, (Result, Character) -&gt; Result)">
        <return type="Result"/>
      </method>
      <method name="reduce" signature="reduce&lt;Result&gt;(into: Result, (inout Result, Character) -&gt; ())">
        <return type="Result"/>
      </method>
      <field name="lazy" type="LazyBidirectionalCollection&lt;String&gt;"/>
      <field name="lazy" type="LazyCollection&lt;String&gt;"/>
      <field name="lazy" type="LazySequence&lt;String&gt;"/>
      <method name="forEach" signature="forEach((Character) -&gt; Void)"/>
      <method name="enumerated" signature="enumerated()">
        <return type="EnumeratedSequence&lt;String&gt;"/>
      </method>
      <method name="makeIterator" signature="makeIterator()"/>
      <field name="underestimatedCount" type="Int"/>
      <field name="underestimatedCount" type="Int"/>
      <method name="sorted" signature="sorted()">
        <return type="[Character]"/>
      </method>
      <method name="sorted" signature="sorted(by: (Character, Character) -&gt; Bool)">
        <return type="[Character]"/>
      </method>
      <method name="reversed" signature="reversed()"/>
      <field name="utf8CString" type="ContiguousArray&lt;CChar&gt;"/>
      <method name="withCString" signature="withCString&lt;Result&gt;((UnsafePointer&lt;Int8&gt;) -&gt; Result)">
        <return type="Result"/>
      </method>
      <method name="withCString" signature="withCString&lt;Result, TargetEncoding&gt;(encodedAs: TargetEncoding.Type, (UnsafePointer&lt;TargetEncoding.CodeUnit&gt;) -&gt; Result)">
        <return type="Result where TargetEncoding : _UnicodeEncoding"/>
      </method>
      <field name="startIndex" type="String.Index"/>
      <field name="endIndex" type="String.Index"/>
      <method name="index" signature="index(after: String.Index)">
        <return type="String.Index"/>
      </method>
      <method name="index" signature="index(String.Index, offsetBy: String.IndexDistance)">
        <return type="String.Index"/>
      </method>
      <method name="index" signature="index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index)">
        <return type="String.Index?"/>
      </method>
      <method name="index" signature="index(before: String.Index)"/>
      <method name="distance" signature="distance(from: String.Index, to: String.Index)">
        <return type="String.IndexDistance"/>
      </method>
      <field name="indices" type="DefaultBidirectionalIndices&lt;String&gt;"/>
      <method name="..&lt;" signature="..&lt;(String)"/>
      <method name="..." signature="...(String)"/>
      <method name="..." signature="...(String)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="String" signature="String(from: Decoder)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="customPlaygroundQuickLook" type="PlaygroundQuickLook"/>
      <field name="hashValue" type="Int"/>
      <field name="hashValue" type="Int"/>
      <constructor name="String" signature="String(NSString)"/>
      <constructor name="String" signature="String(stringInterpolation: String...)"/>
      <constructor name="String" signature="String&lt;T&gt;(stringInterpolationSegment: T)"/>
      <constructor name="String" signature="String&lt;T&gt;(stringInterpolationSegment: T)"/>
      <constructor name="String" signature="String&lt;T&gt;(stringInterpolationSegment: T)"/>
      <constructor name="String" signature="String&lt;T&gt;(stringInterpolationSegment: T)"/>
      <constructor name="String" signature="String(stringLiteral: String)"/>
      <constructor name="String" signature="String(unicodeScalarLiteral: String)"/>
      <constructor name="String" signature="String(extendedGraphemeClusterLiteral: String)"/>
    </class>


    <class kind="struct" name="UInt">
      <constructor name="UInt" signature="UInt()"/>
      <constructor name="UInt" signature="UInt(NSNumber)"/>
      <constructor name="UInt" signature="UInt(CGFloat)"/>
      <constructor name="UInt" signature="UInt(Double)"/>
      <constructor name="UInt" signature="UInt(Float80)"/>
      <constructor name="UInt" signature="UInt(Float)"/>
      <constructor name="UInt" signature="UInt&lt;T&gt;(T)"/>
      <constructor name="UInt" signature="UInt&lt;T&gt;(T)"/>
      <constructor name="UInt" signature="UInt?(String)"/>
      <constructor name="UInt" signature="UInt?&lt;S&gt;(S, radix: Int)"/>
      <constructor name="UInt" signature="UInt(bigEndian: UInt)"/>
      <constructor name="UInt" signature="UInt(bitPattern: Int)"/>
      <constructor name="UInt" signature="UInt&lt;U&gt;(bitPattern: UnsafePointer&lt;U&gt;?)"/>
      <constructor name="UInt" signature="UInt(bitPattern: OpaquePointer?)"/>
      <constructor name="UInt" signature="UInt&lt;U&gt;(bitPattern: UnsafeMutablePointer&lt;U&gt;?)"/>
      <constructor name="UInt" signature="UInt(bitPattern: ObjectIdentifier)"/>
      <constructor name="UInt" signature="UInt(bitPattern: UnsafeRawPointer?)"/>
      <constructor name="UInt" signature="UInt(bitPattern: UnsafeMutableRawPointer?)"/>
      <constructor name="UInt" signature="UInt&lt;Other&gt;(clamping: Other)"/>
      <constructor name="UInt" signature="UInt?(exactly: Float)"/>
      <constructor name="UInt" signature="UInt?(exactly: Double)"/>
      <constructor name="UInt" signature="UInt?(exactly: Float80)"/>
      <constructor name="UInt" signature="UInt?&lt;T&gt;(exactly: T)"/>
      <constructor name="UInt" signature="UInt?&lt;T&gt;(exactly: T)"/>
      <constructor name="UInt" signature="UInt?(exactly: NSNumber)"/>
      <constructor name="UInt" signature="UInt(from: Decoder)"/>
      <constructor name="UInt" signature="UInt(integerLiteral: UInt)"/>
      <constructor name="UInt" signature="UInt(littleEndian: UInt)"/>
      <constructor name="UInt" signature="UInt(truncating: NSNumber)"/>
      <constructor name="UInt" signature="UInt&lt;T&gt;(truncatingIfNeeded: T)"/>
      <field name="bigEndian" type="UInt"/>
      <field name="bitWidth" type="Int"/>
      <field name="byteSwapped" type="UInt"/>
      <field name="customMirror" type="Mirror"/>
      <field name="customPlaygroundQuickLook" type="PlaygroundQuickLook"/>
      <field name="description" type="String"/>
      <field name="hashValue" type="Int"/>
      <field name="leadingZeroBitCount" type="Int"/>
      <field name="littleEndian" type="UInt"/>
      <field name="magnitude" type="UInt"/>
      <field name="nonzeroBitCount" type="Int"/>
      <field name="trailingZeroBitCount" type="Int"/>
      <field name="words" type="UInt.Words"/>
      <field name="bitWidth" type="Int"/>
      <field name="isSigned" type="Bool"/>
      <field name="max" type="UInt"/>
      <field name="min" type="UInt"/>
      <method name="addingReportingOverflow" signature="addingReportingOverflow(UInt)">
        <return type="(partialValue: UInt, overflow: Bool)"/>
      </method>
      <method name="advanced" signature="advanced(by: Int)"/>
      <method name="distance" signature="distance(to: UInt)"/>
      <method name="dividedReportingOverflow" signature="dividedReportingOverflow(by: UInt)">
        <return type="(partialValue: UInt, overflow: Bool)"/>
      </method>
      <method name="dividingFullWidth" signature="dividingFullWidth((high: UInt, low: UInt.Magnitude))"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <method name="multipliedFullWidth" signature="multipliedFullWidth(by: UInt)"/>
      <method name="multipliedReportingOverflow" signature="multipliedReportingOverflow(by: UInt)">
        <return type="(partialValue: UInt, overflow: Bool)"/>
      </method>
      <method name="quotientAndRemainder" signature="quotientAndRemainder(dividingBy: UInt)"/>
      <method name="remainderReportingOverflow" signature="remainderReportingOverflow(dividingBy: UInt)">
        <return type="(partialValue: UInt, overflow: Bool)"/>
      </method>
      <method name="signum" signature="signum()">
        <return type="UInt"/>
      </method>
      <method name="subtractingReportingOverflow" signature="subtractingReportingOverflow(UInt)">
        <return type="(partialValue: UInt, overflow: Bool)"/>
      </method>
      <method name="unsafeAdding" signature="unsafeAdding(UInt)">
        <return type="UInt"/>
      </method>
      <method name="unsafeDivided" signature="unsafeDivided(by: UInt)">
        <return type="UInt"/>
      </method>
      <method name="unsafeMultiplied" signature="unsafeMultiplied(by: UInt)">
        <return type="UInt"/>
      </method>
      <method name="unsafeSubtracting" signature="unsafeSubtracting(UInt)">
        <return type="UInt"/>
      </method>
      <method name="!=" signature="!=(UInt, UInt)"/>
      <method name="!=" signature="!=(UInt, UInt)"/>
      <method name="!=" signature="!=&lt;Other&gt;(UInt, Other)"/>
      <method name="%" signature="%(UInt, UInt)"/>
      <method name="%=" signature="%=(inout UInt, UInt)"/>
      <method name="&amp;" signature="&amp;(UInt, UInt)"/>
      <method name="&amp;" signature="&amp;(UInt, UInt)"/>
      <method name="&amp;*" signature="&amp;*(UInt, UInt)"/>
      <method name="&amp;+" signature="&amp;+(UInt, UInt)"/>
      <method name="&amp;-" signature="&amp;-(UInt, UInt)"/>
      <method name="&amp;&lt;&lt;" signature="&amp;&lt;&lt;(UInt, UInt)"/>
      <method name="&amp;&lt;&lt;" signature="&amp;&lt;&lt;&lt;Other&gt;(UInt, Other)"/>
      <method name="&amp;&lt;&lt;" signature="&amp;&lt;&lt;(UInt, UInt)"/>
      <method name="&amp;&lt;&lt;=" signature="&amp;&lt;&lt;=(inout UInt, UInt)"/>
      <method name="&amp;&lt;&lt;=" signature="&amp;&lt;&lt;=&lt;Other&gt;(inout UInt, Other)"/>
      <method name="&amp;=" signature="&amp;=(inout UInt, UInt)"/>
      <method name="&amp;&gt;&gt;" signature="&amp;&gt;&gt;(UInt, UInt)"/>
      <method name="&amp;&gt;&gt;" signature="&amp;&gt;&gt;&lt;Other&gt;(UInt, Other)"/>
      <method name="&amp;&gt;&gt;" signature="&amp;&gt;&gt;(UInt, UInt)"/>
      <method name="&amp;&gt;&gt;=" signature="&amp;&gt;&gt;=&lt;Other&gt;(inout UInt, Other)"/>
      <method name="&amp;&gt;&gt;=" signature="&amp;&gt;&gt;=(inout UInt, UInt)"/>
      <method name="*" signature="*(UInt, UInt)"/>
      <method name="*=" signature="*=(inout UInt, UInt)"/>
      <method name="+" signature="+(UInt)">
        <return type="UInt"/>
      </method>
      <method name="+" signature="+(UInt, UInt)"/>
      <method name="+=" signature="+=(inout UInt, UInt)"/>
      <method name="-" signature="-(UInt, UInt)"/>
      <method name="-=" signature="-=(inout UInt, UInt)"/>
      <method name="..." signature="...(UInt)"/>
      <method name="..." signature="...(UInt)"/>
      <method name="..." signature="...(UInt)"/>
      <method name="..&lt;" signature="..&lt;(UInt)"/>
      <method name="/" signature="/(UInt, UInt)"/>
      <method name="/=" signature="/=(inout UInt, UInt)"/>
      <method name="&lt;" signature="&lt;&lt;Other&gt;(UInt, Other)"/>
      <method name="&lt;" signature="&lt;(UInt, UInt)"/>
      <method name="&lt;" signature="&lt;(UInt, UInt)"/>
      <method name="&lt;&lt;" signature="&lt;&lt;&lt;Other&gt;(UInt, Other)"/>
      <method name="&lt;&lt;" signature="&lt;&lt;&lt;RHS&gt;(UInt, RHS)"/>
      <method name="&lt;&lt;=" signature="&lt;&lt;=&lt;Other&gt;(inout UInt, Other)"/>
      <method name="&lt;=" signature="&lt;=&lt;Other&gt;(UInt, Other)"/>
      <method name="&lt;=" signature="&lt;=(UInt, UInt)"/>
      <method name="&lt;=" signature="&lt;=(UInt, UInt)"/>
      <method name="==" signature="==&lt;Other&gt;(UInt, Other)"/>
      <method name="==" signature="==(UInt, UInt)"/>
      <method name="==" signature="==(UInt, UInt)"/>
      <method name="&gt;" signature="&gt;(UInt, UInt)"/>
      <method name="&gt;" signature="&gt;&lt;Other&gt;(UInt, Other)"/>
      <method name="&gt;" signature="&gt;(UInt, UInt)"/>
      <method name="&gt;=" signature="&gt;=(UInt, UInt)"/>
      <method name="&gt;=" signature="&gt;=(UInt, UInt)">
        <return type="Bool"/>
      </method>
      <method name="&gt;=" signature="&gt;=&lt;Other&gt;(UInt, Other)"/>
      <method name="&gt;&gt;" signature="&gt;&gt;&lt;Other&gt;(UInt, Other)"/>
      <method name="&gt;&gt;" signature="&gt;&gt;&lt;RHS&gt;(UInt, RHS)"/>
      <method name="&gt;&gt;=" signature="&gt;&gt;=&lt;Other&gt;(inout UInt, Other)"/>
      <method name="^" signature="^(UInt, UInt)"/>
      <method name="^" signature="^(UInt, UInt)"/>
      <method name="^=" signature="^=(inout UInt, UInt)"/>
      <method name="|" signature="|(UInt, UInt)"/>
      <method name="|" signature="|(UInt, UInt)"/>
      <method name="|=" signature="|=(inout UInt, UInt)"/>
      <method name="~" signature="~(UInt)"/>
    </class>

    <class name="NSDictionary">
      <method name="write" signature="write(toFile: String, atomically: Bool)">
      <parameters>
        <param name="toFile" type="String"/>
        <param name="atomically" type="Bool"/>
      </parameters>
      <return type="Bool"/>
      <sink paramNames="toFile" kind="sensitive_output" resource="filesystem" />
      <sink paramNames="toFile" kind="path_traversal" resource="filesystem" />
      <sink argpos="-2" kind="insecure_temporary_file" resource="filesystem">
        <checker id="foundation.atomicallyChecker" />
      </sink>
    </method>
    <method name="write" signature="write(toFile: String, options: NSData.WritingOptions = [])">
      <parameters>
        <param name="toFile" type="String"/>
        <param name="options" type="NSData.WritingOptions = []"/>
      </parameters>
      <sink paramNames="toFile" kind="sensitive_output" resource="filesystem" />
      <sink paramNames="toFile" kind="path_traversal" resource="filesystem" />
    </method>
    </class>

    <class name="NSMutableDictionary" supertypes="NSDictionary"/>
  </module>

</library>