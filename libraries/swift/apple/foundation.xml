<?xml version="1.0" encoding="UTF-8"?>
<library xmlns="http://www.optimyth.com/schema/definitions/library_metadata"
         technology="swift" name="foundation" standard="swift">

  <description url="https://developer.apple.com/documentation/foundation">Access essential data types, collections, and operating-system services</description>

  <module name="Foundation">
    <member name="NSNotFound" type="Int" />

    <function name="NSLocalizedString" signature="NSLocalizedString(String, tableName: String?, bundle: Bundle, value: String, comment: String)">
      <return type="String"/>
    </function>

    <function name="NSLog" signature="NSLog(_ format: String, _ args: CVarArg...)">
      <sink argpos="0, 1, 2" kind="log_forging" />
      <sink argpos="0, 1, 2" kind="privacy_violation"/>
    </function>

    <function name="NSLogv" signature="NSLogv(_ format: String, _ args: CVaListPointer)">
      <sink argpos="0, 1, 2" kind="log_forging" />
      <sink argpos="0, 1, 2" kind="privacy_violation"/>
    </function>

    <class name="NSError">
      <field name="userInfo" type="Dictionary" >
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </field>
    </class>

    <class name="NSException">
      <method name="raise" signature="raise(NSExceptionName, format: String, arguments: CVaListPointer)" >
        <parameters>
          <param type="NSExceptionName" />
          <param type="String" name="format" />
          <param type="CVaListPointer" name="arguments" />
        </parameters>
        <sink paramNames="fomat" kind="format_injection" resource="other" />
      </method>
    </class>

    <class kind="struct" name="AffineTransform">
      <constructor name="AffineTransform" signature="AffineTransform()"/>
      <constructor name="AffineTransform" signature="AffineTransform(m11: CGFloat, m12: CGFloat, m21: CGFloat, m22: CGFloat, tX: CGFloat, tY: CGFloat)"/>
      <constructor name="AffineTransform" signature="AffineTransform(rotationByDegrees: CGFloat)"/>
      <constructor name="AffineTransform" signature="AffineTransform(rotationByRadians: CGFloat)"/>
      <constructor name="AffineTransform" signature="AffineTransform(scale: CGFloat)"/>
      <constructor name="AffineTransform" signature="AffineTransform(scaleByX: CGFloat, byY: CGFloat)"/>
      <constructor name="AffineTransform" signature="AffineTransform(translationByX: CGFloat, byY: CGFloat)"/>
      <method name="rotate" signature="rotate(byDegrees: CGFloat)"/>
      <method name="rotate" signature="rotate(byRadians: CGFloat)"/>
      <method name="scale" signature="scale(CGFloat)"/>
      <method name="scale" signature="scale(x: CGFloat, y: CGFloat)"/>
      <method name="translate" signature="translate(x: CGFloat, y: CGFloat)"/>
      <method name="append" signature="append(AffineTransform)"/>
      <method name="prepend" signature="prepend(AffineTransform)"/>
      <method name="invert" signature="invert()"/>
      <method name="inverted" signature="inverted()"/>
      <method name="transform" signature="transform(NSPoint)"/>
      <method name="transform" signature="transform(NSSize)"/>
      <field name="m11" type="CGFloat"/>
      <field name="m12" type="CGFloat"/>
      <field name="m21" type="CGFloat"/>
      <field name="m22" type="CGFloat"/>
      <field name="tX" type="CGFloat"/>
      <field name="tY" type="CGFloat"/>
      <method name="==" signature="==(AffineTransform, AffineTransform)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="hashValue" type="Int"/>
      <constructor name="AffineTransform" signature="AffineTransform(from: Decoder)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
    </class>


    <class kind="struct" name="Calendar">
      <constructor name="Calendar" signature="Calendar(identifier: Calendar.Identifier)"/>
      <field name="autoupdatingCurrent" type="Calendar"/>
      <field name="current" type="Foundation.Calendar"/>
      <method name="date" signature="date(Date, matchesComponents: DateComponents)" match="fullsignature">
        <return type="Bool"/>
      </method>
      <method name="component" signature="component(Calendar.Component, from: Date)">
        <return type="Int"/>
      </method>
      <method name="dateComponents" signature="dateComponents(Set&lt;Calendar.Component&gt;, from: Date)">
        <return type="DateComponents"/>
      </method>
      <method name="dateComponents" signature="dateComponents(Set&lt;Calendar.Component&gt;, from: Date, to: Date)">
        <return type="DateComponents"/>
      </method>
      <method name="dateComponents" signature="dateComponents(Set&lt;Calendar.Component&gt;, from: DateComponents, to: DateComponents)">
        <return type="DateComponents"/>
      </method>
      <method name="dateComponents" signature="dateComponents(in: TimeZone, from: Date)">
        <return type="DateComponents"/>
      </method>
      <field name="identifier" type="Calendar.Identifier"/>
      <field name="locale" type="Locale?"/>
      <field name="firstWeekday" type="Int"/>
      <field name="minimumDaysInFirstWeek" type="Int"/>
      <field name="timeZone" type="TimeZone"/>
      <method name="maximumRange" signature="maximumRange(of: Calendar.Component)">
        <return type="Range&lt;Int&gt;?"/>
      </method>
      <method name="minimumRange" signature="minimumRange(of: Calendar.Component)">
        <return type="Range&lt;Int&gt;?"/>
      </method>
      <method name="ordinality" signature="ordinality(of: Calendar.Component, in: Calendar.Component, for: Date)">
        <return type="Int?"/>
      </method>
      <method name="range" signature="range(of: Calendar.Component, in: Calendar.Component, for: Date)">
        <return type="Range&lt;Int&gt;?"/>
      </method>
      <method name="startOfDay" signature="startOfDay(for: Date)">
        <return type="Date"/>
      </method>
      <method name="enumerateDates" signature="enumerateDates(startingAfter: Date, matching: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy, direction: Calendar.SearchDirection, using: (Date?, Bool, inout Bool) -&gt; Void)"/>
      <method name="nextDate" signature="nextDate(after: Date, matching: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy, direction: Calendar.SearchDirection)">
        <return type="Date?"/>
      </method>
      <method name="date" signature="date(from: DateComponents)">
        <return type="Date"/>
      </method>
      <method name="date" signature="date(byAdding: DateComponents, to: Date, wrappingComponents: Bool)" >
        <return type="Date"/>
      </method>
      <method name="date" signature="date(byAdding: DateComponents, to: Date)" >
        <parameters>
          <param type="Foundation.DataComponents" name="byAdding" />
          <param type="Date" name="to" />
        </parameters>
        <return type="Date"/>
      </method>
      <method name="date" signature="date(byAdding: Calendar.Component, value: Int, to: Date, wrappingComponents: Bool)">
        <return type="Date"/>
      </method>
      <method name="date" signature="date(bySetting: Calendar.Component, value: Int, of: Date)"/>
      <method name="date" signature="date(bySettingHour: Int, minute: Int, second: Int, of: Date, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy, direction: Calendar.SearchDirection)">
        <return type="Date"/>
      </method>
      <method name="dateInterval" signature="dateInterval(of: Calendar.Component, for: Date)">
        <return type="DateInterval?"/>
      </method>
      <method name="dateInterval" signature="dateInterval(of: Calendar.Component, start: inout Date, interval: inout TimeInterval, for: Date)">
        <return type="Bool"/>
      </method>
      <method name="dateIntervalOfWeekend" signature="dateIntervalOfWeekend(containing: Date)">
        <return type="DateInterval?"/>
      </method>
      <method name="dateIntervalOfWeekend" signature="dateIntervalOfWeekend(containing: Date, start: inout Date, interval: inout TimeInterval)">
        <return type="Bool"/>
      </method>
      <method name="nextWeekend" signature="nextWeekend(startingAfter: Date, direction: Calendar.SearchDirection)">
        <return type="DateInterval?"/>
      </method>
      <method name="nextWeekend" signature="nextWeekend(startingAfter: Date, start: inout Date, interval: inout TimeInterval, direction: Calendar.SearchDirection)">
        <return type="Bool"/>
      </method>
      <method name="!=" signature="!=(Calendar, Calendar)"/>
      <method name="==" signature="==(Calendar, Calendar)"/>
      <method name="==" signature="==(Calendar, Calendar)"/>
      <field name="amSymbol" type="String"/>
      <field name="pmSymbol" type="String"/>
      <field name="weekdaySymbols" type="[String]"/>
      <field name="shortWeekdaySymbols" type="[String]"/>
      <field name="veryShortWeekdaySymbols" type="[String]"/>
      <field name="standaloneWeekdaySymbols" type="[String]"/>
      <field name="shortStandaloneWeekdaySymbols" type="[String]"/>
      <field name="veryShortStandaloneWeekdaySymbols" type="[String]"/>
      <field name="monthSymbols" type="[String]"/>
      <field name="shortMonthSymbols" type="[String]"/>
      <field name="veryShortMonthSymbols" type="[String]"/>
      <field name="standaloneMonthSymbols" type="[String]"/>
      <field name="shortStandaloneMonthSymbols" type="[String]"/>
      <field name="veryShortStandaloneMonthSymbols" type="[String]"/>
      <field name="quarterSymbols" type="[String]"/>
      <field name="shortQuarterSymbols" type="[String]"/>
      <field name="standaloneQuarterSymbols" type="[String]"/>
      <field name="shortStandaloneQuarterSymbols" type="[String]"/>
      <field name="eraSymbols" type="[String]"/>
      <field name="longEraSymbols" type="[String]"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <constructor name="Calendar" signature="Calendar(from: Decoder)"/>
      <method name="compare" signature="compare(Date, to: Date, toGranularity: Calendar.Component)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <method name="isDate" signature="isDate(Date, equalTo: Date, toGranularity: Calendar.Component)">
        <return type="Bool"/>
      </method>
      <method name="isDate" signature="isDate(Date, inSameDayAs: Date)">
        <return type="Bool"/>
      </method>
      <method name="isDateInToday" signature="isDateInToday(Date)">
        <return type="Bool"/>
      </method>
      <method name="isDateInTomorrow" signature="isDateInTomorrow(Date)">
        <return type="Bool"/>
      </method>
      <method name="isDateInWeekend" signature="isDateInWeekend(Date)">
        <return type="Bool"/>
      </method>
      <method name="isDateInYesterday" signature="isDateInYesterday(Date)">
        <return type="Bool"/>
      </method>
    </class>


    <class kind="struct" name="CharacterSet">
      <field name="alphanumerics" type="CharacterSet"/>
      <field name="capitalizedLetters" type="CharacterSet"/>
      <field name="controlCharacters" type="CharacterSet"/>
      <field name="decimalDigits" type="CharacterSet"/>
      <field name="decomposables" type="CharacterSet"/>
      <field name="illegalCharacters" type="CharacterSet"/>
      <field name="letters" type="CharacterSet"/>
      <field name="lowercaseLetters" type="CharacterSet"/>
      <field name="newlines" type="CharacterSet"/>
      <field name="nonBaseCharacters" type="CharacterSet"/>
      <field name="punctuationCharacters" type="CharacterSet"/>
      <field name="symbols" type="CharacterSet"/>
      <field name="uppercaseLetters" type="CharacterSet"/>
      <field name="whitespaces" type="CharacterSet"/>
      <field name="whitespacesAndNewlines" type="CharacterSet"/>
      <field name="urlFragmentAllowed" type="CharacterSet"/>
      <field name="urlHostAllowed" type="CharacterSet"/>
      <field name="urlPasswordAllowed" type="CharacterSet"/>
      <field name="urlPathAllowed" type="CharacterSet"/>
      <field name="urlQueryAllowed" type="CharacterSet"/>
      <field name="urlUserAllowed" type="CharacterSet"/>
      <constructor name="CharacterSet" signature="CharacterSet()"/>
      <constructor name="CharacterSet" signature="CharacterSet&lt;S&gt;(S)"/>
      <constructor name="CharacterSet" signature="CharacterSet(charactersIn: String)"/>
      <constructor name="CharacterSet" signature="CharacterSet(bitmapRepresentation: Data)"/>
      <constructor name="CharacterSet" signature="CharacterSet?(contentsOfFile: String)">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param type="String" name="contentsOfFile"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <field name="bitmapRepresentation" type="Data"/>
      <method name="invert" signature="invert()"/>
      <field name="inverted" type="CharacterSet"/>
      <method name="formIntersection" signature="formIntersection(CharacterSet)"/>
      <method name="formSymmetricDifference" signature="formSymmetricDifference(CharacterSet)"/>
      <method name="formUnion" signature="formUnion(CharacterSet)"/>
      <method name="hasMember" signature="hasMember(inPlane: UInt8)"/>
      <method name="insert" signature="insert(charactersIn: String)"/>
      <method name="intersection" signature="intersection(CharacterSet)"/>
      <method name="invert" signature="invert()"/>
      <method name="isDisjoint" signature="isDisjoint(with: CharacterSet)">
        <return type="Bool"/>
      </method>
      <method name="isStrictSubset" signature="isStrictSubset(of: CharacterSet)">
        <return type="Bool"/>
      </method>
      <method name="isStrictSuperset" signature="isStrictSuperset(of: CharacterSet)">
        <return type="Bool"/>
      </method>
      <method name="isSubset" signature="isSubset(of: CharacterSet)">
        <return type="Bool"/>
      </method>
      <method name="isSuperset" signature="isSuperset(of: CharacterSet)"/>
      <method name="remove" signature="remove(charactersIn: String)"/>
      <method name="subtract" signature="subtract(CharacterSet)"/>
      <method name="subtract" signature="subtract(CharacterSet)"/>
      <method name="subtracting" signature="subtracting(CharacterSet)"/>
      <method name="symmetricDifference" signature="symmetricDifference(CharacterSet)"/>
      <method name="union" signature="union(CharacterSet)"/>
      <method name="insert" signature="insert(charactersIn: String)"/>
      <method name="remove" signature="remove(charactersIn: String)"/>
      <method name="subtracting" signature="subtracting(CharacterSet)"/>
      <method name="hasMember" signature="hasMember(inPlane: UInt8)"/>
      <method name="isDisjoint" signature="isDisjoint(with: CharacterSet)">
        <return type="Bool"/>
      </method>
      <method name="isStrictSubset" signature="isStrictSubset(of: CharacterSet)">
        <return type="Bool"/>
      </method>
      <method name="isStrictSuperset" signature="isStrictSuperset(of: CharacterSet)">
        <return type="Bool"/>
      </method>
      <method name="isSubset" signature="isSubset(of: CharacterSet)">
        <return type="Bool"/>
      </method>
      <method name="isSuperset" signature="isSuperset(of: CharacterSet)"/>
      <field name="isEmpty" type="Bool"/>
      <method name="!=" signature="!=(CharacterSet, CharacterSet)"/>
      <method name="==" signature="==(CharacterSet, CharacterSet)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="hashValue" type="Int"/>
      <constructor name="CharacterSet" signature="CharacterSet(arrayLiteral: Unicode.Scalar...)"/>
      <constructor name="CharacterSet" signature="CharacterSet(charactersIn: Range&lt;Unicode.Scalar&gt;)"/>
      <constructor name="CharacterSet" signature="CharacterSet(charactersIn: ClosedRange&lt;Unicode.Scalar&gt;)"/>
      <constructor name="CharacterSet" signature="CharacterSet(from: Decoder)"/>
      <method name="contains" signature="contains(Unicode.Scalar)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <method name="insert" signature="insert(Unicode.Scalar)"/>
      <method name="insert" signature="insert(charactersIn: ClosedRange&lt;Unicode.Scalar&gt;)"/>
      <method name="insert" signature="insert(charactersIn: Range&lt;Unicode.Scalar&gt;)"/>
      <method name="remove" signature="remove(Unicode.Scalar)"/>
      <method name="remove" signature="remove(charactersIn: ClosedRange&lt;Unicode.Scalar&gt;)"/>
      <method name="remove" signature="remove(charactersIn: Range&lt;Unicode.Scalar&gt;)"/>
      <method name="update" signature="update(with: Unicode.Scalar)"/>
    </class>


    <class kind="struct" name="Data">
      <constructor name="Data" signature="Data()"/>
      <constructor name="Data" signature="Data(capacity: Int)"/>
      <constructor name="Data" signature="Data(count: Int)"/>
      <method name="resetBytes" signature="resetBytes(in: Range&lt;Data.Index&gt;)"/>
      <constructor name="Data" signature="Data()"/>
      <constructor name="Data" signature="Data&lt;S&gt;(S)"/>
      <constructor name="Data" signature="Data?(base64Encoded: Data, options: Data.Base64DecodingOptions)"/>
      <constructor name="Data" signature="Data?(base64Encoded: String, options: Data.Base64DecodingOptions)"/>
      <constructor name="Data" signature="Data&lt;SourceType&gt;(buffer: UnsafeBufferPointer&lt;SourceType&gt;)"/>
      <constructor name="Data" signature="Data&lt;SourceType&gt;(buffer: UnsafeMutableBufferPointer&lt;SourceType&gt;)"/>
      <constructor name="Data" signature="Data(bytes: Array&lt;UInt8&gt;)"/>
      <constructor name="Data" signature="Data(bytes: ArraySlice&lt;UInt8&gt;)"/>
      <constructor name="Data" signature="Data(bytes: UnsafeRawPointer, count: Int)"/>
      <constructor name="Data" signature="Data(bytesNoCopy: UnsafeMutableRawPointer, count: Int, deallocator: Data.Deallocator)"/>
      <constructor name="Data" signature="Data(capacity: Int)"/>
      <constructor name="Data" signature="Data(contentsOf: URL, options: Data.ReadingOptions)">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param type="String" name="contentsOf"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="Data" signature="Data(count: Int)"/>
      <constructor name="Data" signature="Data(referencing: NSData)"/>
      <constructor name="Data" signature="Data(repeating: UInt8, count: Int)"/>
      <constructor name="Data" signature="Data(repeating: UInt8, count: Int)"/>
      <constructor name="Data" signature="Data(bytes: UnsafeRawPointer, count: Int)"/>
      <constructor name="Data" signature="Data&lt;SourceType&gt;(buffer: UnsafeBufferPointer&lt;SourceType&gt;)"/>
      <constructor name="Data" signature="Data&lt;SourceType&gt;(buffer: UnsafeMutableBufferPointer&lt;SourceType&gt;)"/>
      <constructor name="Data" signature="Data(bytesNoCopy: UnsafeMutableRawPointer, count: Int, deallocator: Data.Deallocator)"/>
      <constructor name="Data" signature="Data(contentsOf: URL, options: Data.ReadingOptions)">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param type="String" name="contentsOf"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </constructor>
      <method name="write" signature="write(to: URL, options: Data.WritingOptions)"/>
      <constructor name="Data" signature="Data?(base64Encoded: Data, options: Data.Base64DecodingOptions)"/>
      <constructor name="Data" signature="Data?(base64Encoded: String, options: Data.Base64DecodingOptions)"/>
      <method name="base64EncodedData" signature="base64EncodedData(options: Data.Base64EncodingOptions)">
        <return type="Data"/>
      </method>
      <method name="base64EncodedString" signature="base64EncodedString(options: Data.Base64EncodingOptions)">
        <return type="String"/>
      </method>
      <field name="isEmpty" type="Bool"/>
      <method name="withUnsafeBytes" signature="withUnsafeBytes&lt;ResultType, ContentType&gt;((UnsafePointer&lt;ContentType&gt;) -&gt; ResultType)"/>
      <method name="withUnsafeMutableBytes" signature="withUnsafeMutableBytes&lt;ResultType, ContentType&gt;((UnsafeMutablePointer&lt;ContentType&gt;) -&gt; ResultType)"/>
      <method name="copyBytes" signature="copyBytes(to: UnsafeMutablePointer&lt;UInt8&gt;, count: Int)"/>
      <method name="copyBytes" signature="copyBytes(to: UnsafeMutablePointer&lt;UInt8&gt;, from: Range&lt;Data.Index&gt;)"/>
      <method name="copyBytes" signature="copyBytes&lt;DestinationType&gt;(to: UnsafeMutableBufferPointer&lt;DestinationType&gt;, from: Range&lt;Data.Index&gt;?)">
        <return type="Int"/>
      </method>
      <method name="append" signature="append(UInt8)"/>
      <method name="append" signature="append(Data)"/>
      <method name="append" signature="append&lt;SourceType&gt;(UnsafeBufferPointer&lt;SourceType&gt;)"/>
      <method name="append" signature="append(UnsafePointer&lt;UInt8&gt;, count: Int)"/>
      <method name="append" signature="append(contentsOf: [UInt8])">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param type="String" name="contentsOf"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="insert" signature="insert(UInt8, at: Int)"/>
      <method name="insert" signature="insert&lt;C&gt;(contentsOf: C, at: Int)">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param type="String" name="contentsOf"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="reserveCapacity" signature="reserveCapacity(Int)"/>
      <method name="remove" signature="remove(at: Int)">
        <return type="UInt8"/>
      </method>
      <method name="removeAll" signature="removeAll(keepingCapacity: Bool)"/>
      <method name="removeFirst" signature="removeFirst(Int)"/>
      <method name="removeLast" signature="removeLast(Int)"/>
      <method name="removeSubrange" signature="removeSubrange(Range&lt;Int&gt;)"/>
      <method name="replaceSubrange" signature="replaceSubrange(Range&lt;Data.Index&gt;, with: Data)"/>
      <method name="replaceSubrange" signature="replaceSubrange&lt;ByteCollection&gt;(Range&lt;Data.Index&gt;, with: ByteCollection)"/>
      <method name="replaceSubrange" signature="replaceSubrange&lt;SourceType&gt;(Range&lt;Data.Index&gt;, with: UnsafeBufferPointer&lt;SourceType&gt;)"/>
      <method name="replaceSubrange" signature="replaceSubrange(Range&lt;Data.Index&gt;, with: UnsafeRawPointer, count: Int)"/>
      <method name="first" signature="first(where: (UInt8) -&gt; Bool)">
        <return type="UInt8?"/>
      </method>
      <method name="index" signature="index(of: UInt8)">
        <return type="Int?"/>
      </method>
      <method name="index" signature="index(where: (UInt8) -&gt; Bool)">
        <return type="Int?"/>
      </method>
      <method name="max" signature="max()">
        <return type="UInt8?"/>
      </method>
      <method name="max" signature="max(by: (UInt8, UInt8) -&gt; Bool)">
        <return type="UInt8?"/>
      </method>
      <method name="min" signature="min()">
        <return type="UInt8?"/>
      </method>
      <method name="min" signature="min(by: (UInt8, UInt8) -&gt; Bool)">
        <return type="UInt8?"/>
      </method>
      <method name="range" signature="range(of: Data, options: Data.SearchOptions, in: Range&lt;Data.Index&gt;?)">
        <return type="Range&lt;Data.Index&gt;?"/>
      </method>
      <method name="filter" signature="filter((UInt8) -&gt; Bool)">
        <return type="Data"/>
      </method>
      <method name="prefix" signature="prefix(Int)">
        <return type="Data"/>
      </method>
      <method name="prefix" signature="prefix(through: Int)">
        <return type="Data"/>
      </method>
      <method name="prefix" signature="prefix(upTo: Int)">
        <return type="Data"/>
      </method>
      <method name="prefix" signature="prefix(while: (UInt8) -&gt; Bool)"/>
      <method name="suffix" signature="suffix(Int)">
        <return type="Data"/>
      </method>
      <method name="suffix" signature="suffix(from: Int)">
        <return type="Data"/>
      </method>
      <method name="dropLast" signature="dropLast()">
        <return type="Data"/>
      </method>
      <method name="dropLast" signature="dropLast(Int)">
        <return type="Data"/>
      </method>
      <method name="dropFirst" signature="dropFirst()">
        <return type="Data"/>
      </method>
      <method name="dropFirst" signature="dropFirst(Int)">
        <return type="Data"/>
      </method>
      <method name="drop" signature="drop(while: (UInt8) -&gt; Bool)"/>
      <method name="advanced" signature="advanced(by: Int)">
        <return type="Data"/>
      </method>
      <method name="reduce" signature="reduce&lt;Result&gt;(Result, (Result, UInt8) -&gt; Result)">
        <return type="Result"/>
      </method>
      <field name="lazy" type="LazyBidirectionalCollection&lt;Data&gt;"/>
      <field name="lazy" type="LazyCollection&lt;Data&gt;"/>
      <field name="lazy" type="LazySequence&lt;Data&gt;"/>
      <field name="lazy" type="LazyRandomAccessCollection&lt;Data&gt;"/>
      <method name="forEach" signature="forEach((UInt8) -&gt; Void)"/>
      <method name="enumerated" signature="enumerated()">
        <return type="EnumeratedSequence&lt;Data&gt;"/>
      </method>
      <method name="makeIterator" signature="makeIterator()"/>
      <method name="enumerateBytes" signature="enumerateBytes((UnsafeBufferPointer&lt;UInt8&gt;, Data.Index, inout Bool) -&gt; Void)"/>
      <method name="sort" signature="sort(by: (UInt8, UInt8) -&gt; Bool)"/>
      <method name="sorted" signature="sorted()">
        <return type="[UInt8]"/>
      </method>
      <method name="sorted" signature="sorted(by: (UInt8, UInt8) -&gt; Bool)">
        <return type="[UInt8]"/>
      </method>
      <method name="reversed" signature="reversed()"/>
      <method name="subdata" signature="subdata(in: Range&lt;Data.Index&gt;)"/>
      <method name="split" signature="split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (UInt8) -&gt; Bool)">
        <return type="[Data]"/>
      </method>
      <method name="split" signature="split(separator: UInt8, maxSplits: Int, omittingEmptySubsequences: Bool)">
        <return type="[Data]"/>
      </method>
      <method name="==" signature="==(Data, Data)"/>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, Data.Element == OtherSequence.Element"/>
      </method>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence, by: (UInt8, UInt8) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, Data.Element == OtherSequence.Element"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix)">
        <return type="Bool where PossiblePrefix : Sequence, Data.Element == PossiblePrefix.Element"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix, by: (UInt8, UInt8) -&gt; Bool)">
        <return type="Bool where PossiblePrefix : Sequence, Data.Element == PossiblePrefix.Element"/>
      </method>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, Data.Element == OtherSequence.Element"/>
      </method>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence, by: (UInt8, UInt8) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, Data.Element == OtherSequence.Element"/>
      </method>
      <field name="startIndex" type="Data.Index"/>
      <field name="endIndex" type="Data.Index"/>
      <method name="index" signature="index(Int, offsetBy: Int)">
        <return type="Int"/>
      </method>
      <method name="index" signature="index(after: Data.Index)"/>
      <method name="index" signature="index(before: Data.Index)"/>
      <field name="indices" type="DefaultRandomAccessIndices&lt;Data&gt;"/>
      <method name="distance" signature="distance(from: Int, to: Int)">
        <return type="Int"/>
      </method>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <constructor name="Data" signature="Data&lt;S&gt;(S)"/>
      <constructor name="Data" signature="Data(from: Decoder)"/>
      <field name="count" type="Int"/>
      <field name="count" type="Int"/>
      <field name="first" type="UInt8?"/>
      <field name="indices" type="CountableRange&lt;Int&gt;"/>
      <field name="indices" type="CountableRange&lt;Int&gt;"/>
      <field name="last" type="UInt8?"/>
      <field name="underestimatedCount" type="Int"/>
      <field name="underestimatedCount" type="Int"/>
      <method name="append" signature="append&lt;S&gt;(contentsOf: S)">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param type="String" name="contentsOf"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="encode" signature="encode(to: Encoder)"/>
      <method name="flatMap" signature="flatMap((UInt8) -&gt; String?)"/>
      <method name="map" signature="map&lt;T&gt;((UInt8) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="map" signature="map&lt;T&gt;((UInt8) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="partition" signature="partition(by: (UInt8) -&gt; Bool)"/>
      <method name="partition" signature="partition(by: (UInt8) -&gt; Bool)"/>
      <method name="popFirst" signature="popFirst()">
        <return type="UInt8?"/>
      </method>
      <method name="popLast" signature="popLast()">
        <return type="UInt8?"/>
      </method>
      <method name="reduce" signature="reduce&lt;Result&gt;(into: Result, (inout Result, UInt8) -&gt; ())">
        <return type="Result"/>
      </method>
      <method name="removeFirst" signature="removeFirst()">
        <return type="UInt8"/>
      </method>
      <method name="removeFirst" signature="removeFirst()">
        <return type="UInt8"/>
      </method>
      <method name="removeFirst" signature="removeFirst()">
        <return type="UInt8"/>
      </method>
      <method name="removeFirst" signature="removeFirst(Int)"/>
      <method name="removeFirst" signature="removeFirst(Int)"/>
      <method name="removeLast" signature="removeLast()">
        <return type="UInt8"/>
      </method>
      <method name="removeLast" signature="removeLast()">
        <return type="UInt8"/>
      </method>
      <method name="removeLast" signature="removeLast()">
        <return type="UInt8"/>
      </method>
      <method name="removeLast" signature="removeLast(Int)"/>
      <method name="removeLast" signature="removeLast(Int)"/>
      <method name="removeSubrange" signature="removeSubrange&lt;R&gt;(R)"/>
      <method name="replaceSubrange" signature="replaceSubrange(CountableRange&lt;Data.Index&gt;, with: Data)"/>
      <method name="replaceSubrange" signature="replaceSubrange&lt;C, R&gt;(R, with: C)"/>
      <method name="swapAt" signature="swapAt(Int, Int)"/>
      <method name="!=" signature="!=(Data, Data)"/>
    </class>


    <class kind="struct" name="Date">
      <constructor name="Date" signature="Date()"/>
      <constructor name="Date" signature="Date(timeIntervalSinceNow: TimeInterval)"/>
      <constructor name="Date" signature="Date(timeInterval: TimeInterval, since: Date)"/>
      <constructor name="Date" signature="Date(timeIntervalSinceReferenceDate: TimeInterval)"/>
      <constructor name="Date" signature="Date(timeIntervalSince1970: TimeInterval)"/>
      <method name="&lt;" signature="&lt;(Date, Date)"/>
      <method name="==" signature="==(Date, Date)"/>
      <method name="&gt;" signature="&gt;(Date, Date)"/>
      <method name="compare" signature="compare(Date)"/>
      <method name="timeIntervalSince" signature="timeIntervalSince(Date)">
        <return type="TimeInterval"/>
      </method>
      <field name="timeIntervalSinceNow" type="TimeInterval"/>
      <field name="timeIntervalSinceReferenceDate" type="TimeInterval"/>
      <field name="timeIntervalSince1970" type="Foundation.TimeInterval"/>
      <field name="timeIntervalSinceReferenceDate" type="TimeInterval"/>
      <method name="!=" signature="!=(Date, Date)"/>
      <method name="+" signature="+(Date, TimeInterval)"/>
      <method name="+=" signature="+=(inout Date, TimeInterval)"/>
      <method name="-" signature="-(Date, TimeInterval)"/>
      <method name="-=" signature="-=(inout Date, TimeInterval)"/>
      <method name="&lt;" signature="&lt;(Date, Date)"/>
      <method name="&lt;=" signature="&lt;=(Date, Date)"/>
      <method name="==" signature="==(Date, Date)"/>
      <method name="&gt;" signature="&gt;(Date, Date)"/>
      <method name="&gt;" signature="&gt;(Date, Date)"/>
      <method name="&gt;=" signature="&gt;=(Date, Date)">
        <return type="Bool"/>
      </method>
      <field name="description" type="String"/>
      <method name="description" signature="description(with: Locale?)">
        <return type="String"/>
      </method>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <field name="customPlaygroundQuickLook" type="PlaygroundQuickLook"/>
      <constructor name="Date" signature="Date(from: Decoder)"/>
      <method name="addTimeInterval" signature="addTimeInterval(TimeInterval)"/>
      <method name="addingTimeInterval" signature="addingTimeInterval(TimeInterval)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <method name="..." signature="...(Date)"/>
      <method name="..." signature="...(Date)"/>
      <method name="..&lt;" signature="..&lt;(Date)"/>
    </class>


    <class kind="struct" name="DateComponents">
      <constructor name="DateComponents" signature="DateComponents(calendar: Calendar?, timeZone: TimeZone?, era: Int?, year: Int?, month: Int?, day: Int?, hour: Int?, minute: Int?, second: Int?, nanosecond: Int?, weekday: Int?, weekdayOrdinal: Int?, quarter: Int?, weekOfMonth: Int?, weekOfYear: Int?, yearForWeekOfYear: Int?)"/>
      <field name="calendar" type="Calendar?"/>
      <field name="timeZone" type="TimeZone?"/>
      <field name="isValidDate" type="Bool"/>
      <method name="isValidDate" signature="isValidDate(in: Calendar)"/>
      <field name="date" type="Date?"/>
      <field name="era" type="Int?"/>
      <field name="year" type="Int?"/>
      <field name="yearForWeekOfYear" type="Int?"/>
      <field name="quarter" type="Int?"/>
      <field name="month" type="Int?"/>
      <field name="isLeapMonth" type="Bool?"/>
      <field name="weekOfMonth" type="Int?"/>
      <field name="weekOfYear" type="Int?"/>
      <field name="weekday" type="Int?"/>
      <field name="weekdayOrdinal" type="Int?"/>
      <field name="day" type="Int?"/>
      <field name="hour" type="Int?"/>
      <field name="minute" type="Int?"/>
      <field name="second" type="Int?"/>
      <field name="nanosecond" type="Int?"/>
      <method name="value" signature="value(for: Calendar.Component)"/>
      <method name="setValue" signature="setValue(Int?, for: Calendar.Component)"/>
      <method name="!=" signature="!=(DateComponents, DateComponents)"/>
      <method name="==" signature="==(DateComponents, DateComponents)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <constructor name="DateComponents" signature="DateComponents(from: Decoder)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
    </class>


    <class name="DateComponentsFormatter" supertypes="NSFormatter">
      <method name="string" signature="string(from: DateComponents)">
        <return type="String?"/>
      </method>
      <method name="string" signature="string(for: Any?)">
        <return type="String?"/>
      </method>
      <method name="string" signature="string(from: Date, to: Date)">
        <return type="String?"/>
      </method>
      <method name="string" signature="string(from: TimeInterval)">
        <return type="String?"/>
      </method>
      <field name="allowedUnits" type="NSCalendar.Unit"/>
      <field name="allowsFractionalUnits" type="Bool"/>
      <field name="calendar" type="Calendar?"/>
      <field name="collapsesLargestUnit" type="Bool"/>
      <field name="includesApproximationPhrase" type="Bool"/>
      <field name="includesTimeRemainingPhrase" type="Bool"/>
      <field name="maximumUnitCount" type="Int"/>
      <field name="unitsStyle" type="DateComponentsFormatter.UnitsStyle"/>
      <field name="zeroFormattingBehavior" type="DateComponentsFormatter.ZeroFormattingBehavior"/>
      <field name="formattingContext" type="Formatter.Context"/>
      <field name="referenceDate" type="Date?"/>
      <method name="getObjectValue" signature="getObjectValue(AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;?, for: String, errorDescription: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?)"/>
    </class>


    <class name="DateFormatter" supertypes="NSFormatter">
      <method name="date" signature="date(from: String)">
        <return type="Date?"/>
      </method>
      <method name="string" signature="string(from: Date)">
        <return type="String"/>
      </method>
      <method name="getObjectValue" signature="getObjectValue(AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;?, for: String, range: UnsafeMutablePointer&lt;NSRange&gt;?)">
        <return type="Bool"/>
      </method>
      <field name="generatesCalendarDates" type="Bool"/>
      <field name="dateStyle" type="DateFormatter.Style"/>
      <field name="timeStyle" type="DateFormatter.Style"/>
      <field name="dateFormat" type="String!"/>
      <method name="setLocalizedDateFormatFromTemplate" signature="setLocalizedDateFormatFromTemplate(String)"/>
      <field name="calendar" type="Calendar!"/>
      <field name="defaultDate" type="Date?"/>
      <field name="locale" type="Locale!"/>
      <field name="timeZone" type="TimeZone!"/>
      <field name="twoDigitStartDate" type="Date?"/>
      <field name="gregorianStartDate" type="Date?"/>
      <field name="formatterBehavior" type="DateFormatter.Behavior"/>
      <field name="isLenient" type="Bool"/>
      <field name="doesRelativeDateFormatting" type="Bool"/>
      <field name="amSymbol" type="String!"/>
      <field name="pmSymbol" type="String!"/>
      <field name="weekdaySymbols" type="[String]!"/>
      <field name="shortWeekdaySymbols" type="[String]!"/>
      <field name="veryShortWeekdaySymbols" type="[String]!"/>
      <field name="standaloneWeekdaySymbols" type="[String]!"/>
      <field name="shortStandaloneWeekdaySymbols" type="[String]!"/>
      <field name="veryShortStandaloneWeekdaySymbols" type="[String]!"/>
      <field name="monthSymbols" type="[String]!"/>
      <field name="shortMonthSymbols" type="[String]!"/>
      <field name="veryShortMonthSymbols" type="[String]!"/>
      <field name="standaloneMonthSymbols" type="[String]!"/>
      <field name="shortStandaloneMonthSymbols" type="[String]!"/>
      <field name="veryShortStandaloneMonthSymbols" type="[String]!"/>
      <field name="quarterSymbols" type="[String]!"/>
      <field name="shortQuarterSymbols" type="[String]!"/>
      <field name="standaloneQuarterSymbols" type="[String]!"/>
      <field name="shortStandaloneQuarterSymbols" type="[String]!"/>
      <field name="eraSymbols" type="[String]!"/>
      <field name="longEraSymbols" type="[String]!"/>
      <field name="formattingContext" type="Formatter.Context"/>
    </class>


    <class kind="struct" name="DateInterval">
      <constructor name="DateInterval" signature="DateInterval()"/>
      <constructor name="DateInterval" signature="DateInterval(start: Date, duration: TimeInterval)"/>
      <constructor name="DateInterval" signature="DateInterval(start: Date, end: Date)"/>
      <field name="start" type="Date"/>
      <field name="end" type="Date"/>
      <field name="duration" type="TimeInterval"/>
      <method name="!=" signature="!=(DateInterval, DateInterval)"/>
      <method name="&lt;" signature="&lt;(DateInterval, DateInterval)"/>
      <method name="&lt;=" signature="&lt;=(DateInterval, DateInterval)"/>
      <method name="==" signature="==(DateInterval, DateInterval)"/>
      <method name="&gt;" signature="&gt;(DateInterval, DateInterval)"/>
      <method name="&gt;=" signature="&gt;=(DateInterval, DateInterval)">
        <return type="Bool"/>
      </method>
      <method name="intersection" signature="intersection(with: DateInterval)"/>
      <method name="intersects" signature="intersects(DateInterval)"/>
      <method name="contains" signature="contains(Date)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <method name="compare" signature="compare(DateInterval)"/>
      <method name="..." signature="...(DateInterval)"/>
      <method name="..." signature="...(DateInterval)"/>
      <method name="..&lt;" signature="..&lt;(DateInterval)"/>
    </class>


    <class name="DateIntervalFormatter" supertypes="NSFormatter">
      <method name="string" signature="string(from: Date, to: Date)">
        <return type="String"/>
      </method>
      <field name="dateStyle" type="DateIntervalFormatter.Style"/>
      <field name="timeStyle" type="DateIntervalFormatter.Style"/>
      <field name="dateTemplate" type="String!"/>
      <field name="calendar" type="Calendar!"/>
      <field name="locale" type="Locale!"/>
      <field name="timeZone" type="TimeZone!"/>
      <method name="string" signature="string(from: DateInterval)"/>
    </class>


    <class kind="struct" name="Decimal">
      <constructor name="Decimal" signature="Decimal()"/>
      <constructor name="Decimal" signature="Decimal(Int32)"/>
      <constructor name="Decimal" signature="Decimal(UInt64)"/>
      <constructor name="Decimal" signature="Decimal(Int)"/>
      <constructor name="Decimal" signature="Decimal(UInt32)"/>
      <constructor name="Decimal" signature="Decimal(UInt16)"/>
      <constructor name="Decimal" signature="Decimal(UInt)"/>
      <constructor name="Decimal" signature="Decimal(Double)"/>
      <constructor name="Decimal" signature="Decimal(Int8)"/>
      <constructor name="Decimal" signature="Decimal(UInt8)"/>
      <constructor name="Decimal" signature="Decimal(Int64)"/>
      <constructor name="Decimal" signature="Decimal(Int16)"/>
      <constructor name="Decimal" signature="Decimal(_exponent: Int32, _length: UInt32, _isNegative: UInt32, _isCompact: UInt32, _reserved: UInt32, _mantissa: (UInt16, UInt16, UInt16, UInt16, UInt16, UInt16, UInt16, UInt16))"/>
      <constructor name="Decimal" signature="Decimal?&lt;T&gt;(exactly: T)"/>
      <constructor name="Decimal" signature="Decimal(floatLiteral: Double)"/>
      <constructor name="Decimal" signature="Decimal(integerLiteral: Int)"/>
      <constructor name="Decimal" signature="Decimal(sign: FloatingPointSign, exponent: Int, significand: Decimal)"/>
      <constructor name="Decimal" signature="Decimal(signOf: Decimal, magnitudeOf: Decimal)"/>
      <constructor name="Decimal" signature="Decimal?(string: String, locale: Locale?)"/>
      <constructor name="Decimal" signature="Decimal(_exponent: Int32, _length: UInt32, _isNegative: UInt32, _isCompact: UInt32, _reserved: UInt32, _mantissa: (UInt16, UInt16, UInt16, UInt16, UInt16, UInt16, UInt16, UInt16))"/>
      <constructor name="Decimal" signature="Decimal(sign: FloatingPointSign, exponent: Int, significand: Decimal)"/>
      <field name="sign" type="FloatingPointSign"/>
      <field name="exponent" type="Int"/>
      <field name="significand" type="Decimal"/>
      <constructor name="Decimal" signature="Decimal(Double)"/>
      <constructor name="Decimal" signature="Decimal(floatLiteral: Double)"/>
      <constructor name="Decimal" signature="Decimal(Int)"/>
      <constructor name="Decimal" signature="Decimal(Int8)"/>
      <constructor name="Decimal" signature="Decimal(Int16)"/>
      <constructor name="Decimal" signature="Decimal(Int32)"/>
      <constructor name="Decimal" signature="Decimal(Int64)"/>
      <constructor name="Decimal" signature="Decimal(integerLiteral: Int)"/>
      <constructor name="Decimal" signature="Decimal(UInt)"/>
      <constructor name="Decimal" signature="Decimal(UInt8)"/>
      <constructor name="Decimal" signature="Decimal(UInt16)"/>
      <constructor name="Decimal" signature="Decimal(UInt32)"/>
      <constructor name="Decimal" signature="Decimal(UInt64)"/>
      <constructor name="Decimal" signature="Decimal(signOf: Decimal, magnitudeOf: Decimal)"/>
      <method name="NSDecimalCopy" signature="NSDecimalCopy(UnsafeMutablePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;)"/>
      <constructor name="Decimal" signature="Decimal?(string: String, locale: Locale?)"/>
      <method name="NSDecimalString" signature="NSDecimalString(UnsafePointer&lt;Decimal&gt;, Any?)"/>
      <field name="description" type="String"/>
      <field name="exponent" type="Int"/>
      <field name="floatingPointClass" type="FloatingPointClassification"/>
      <field name="hashValue" type="Int"/>
      <field name="isCanonical" type="Bool"/>
      <field name="isFinite" type="Bool"/>
      <field name="isInfinite" type="Bool"/>
      <field name="isNaN" type="Bool"/>
      <field name="isNormal" type="Bool"/>
      <field name="isSignMinus" type="Bool"/>
      <field name="isSignaling" type="Bool"/>
      <field name="isSignalingNaN" type="Bool"/>
      <field name="isSubnormal" type="Bool"/>
      <field name="isZero" type="Bool"/>
      <field name="magnitude" type="Decimal"/>
      <field name="nextDown" type="Decimal"/>
      <field name="nextUp" type="Decimal"/>
      <field name="sign" type="FloatingPointSign"/>
      <field name="significand" type="Decimal"/>
      <field name="ulp" type="Decimal"/>
      <field name="nan" type="Decimal"/>
      <field name="quietNaN" type="Decimal"/>
      <field name="radix" type="Int"/>
      <field name="NSDecimalMaxSize" type="Int32"/>
      <field name="NSDecimalNoScale" type="Int32"/>
      <method name="*" signature="*(Decimal, Decimal)"/>
      <method name="*=" signature="*=(inout Decimal, Decimal)"/>
      <method name="+" signature="+(Decimal, Decimal)"/>
      <method name="+=" signature="+=(inout Decimal, Decimal)"/>
      <method name="-" signature="-(Decimal, Decimal)"/>
      <method name="-=" signature="-=(inout Decimal, Decimal)"/>
      <method name="/" signature="/(Decimal, Decimal)"/>
      <method name="/=" signature="/=(inout Decimal, Decimal)"/>
      <method name="&lt;" signature="&lt;(Decimal, Decimal)"/>
      <method name="==" signature="==(Decimal, Decimal)"/>
      <method name="pow" signature="pow(Decimal, Int)"/>
      <method name="negate" signature="negate()"/>
      <method name="NSDecimalCompact" signature="NSDecimalCompact(UnsafeMutablePointer&lt;Decimal&gt;)"/>
      <method name="NSDecimalAdd" signature="NSDecimalAdd(UnsafeMutablePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, NSDecimalNumber.RoundingMode)"/>
      <method name="NSDecimalSubtract" signature="NSDecimalSubtract(UnsafeMutablePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, NSDecimalNumber.RoundingMode)"/>
      <method name="NSDecimalDivide" signature="NSDecimalDivide(UnsafeMutablePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, NSDecimalNumber.RoundingMode)"/>
      <method name="NSDecimalMultiply" signature="NSDecimalMultiply(UnsafeMutablePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, NSDecimalNumber.RoundingMode)"/>
      <method name="NSDecimalMultiplyByPowerOf10" signature="NSDecimalMultiplyByPowerOf10(UnsafeMutablePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, Int16, NSDecimalNumber.RoundingMode)"/>
      <method name="NSDecimalRound" signature="NSDecimalRound(UnsafeMutablePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, Int, NSDecimalNumber.RoundingMode)"/>
      <method name="NSDecimalPower" signature="NSDecimalPower(UnsafeMutablePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;, Int, NSDecimalNumber.RoundingMode)"/>
      <method name="NSDecimalNormalize" signature="NSDecimalNormalize(UnsafeMutablePointer&lt;Decimal&gt;, UnsafeMutablePointer&lt;Decimal&gt;, NSDecimalNumber.RoundingMode)"/>
      <method name="&lt;" signature="&lt;(Decimal, Decimal)"/>
      <method name="==" signature="==(Decimal, Decimal)"/>
      <method name="isEqual" signature="isEqual(to: Decimal)"/>
      <method name="isLess" signature="isLess(than: Decimal)"/>
      <method name="isLessThanOrEqualTo" signature="isLessThanOrEqualTo(Decimal)"/>
      <method name="isTotallyOrdered" signature="isTotallyOrdered(belowOrEqualTo: Decimal)"/>
      <method name="distance" signature="distance(to: Decimal)"/>
      <method name="advanced" signature="advanced(by: Decimal)"/>
      <method name="NSDecimalCompare" signature="NSDecimalCompare(UnsafePointer&lt;Decimal&gt;, UnsafePointer&lt;Decimal&gt;)">
        <return type="ComparisonResult"/>
      </method>
      <field name="description" type="String"/>
      <field name="hashValue" type="Int"/>
      <constructor name="Decimal" signature="Decimal(from: Decoder)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
    </class>


    <class kind="struct" name="IndexPath">
      <constructor name="IndexPath" signature="IndexPath()"/>
      <constructor name="IndexPath" signature="IndexPath(index: IndexPath.Element)"/>
      <constructor name="IndexPath" signature="IndexPath(arrayLiteral: IndexPath.Element...)"/>
      <constructor name="IndexPath" signature="IndexPath(indexes: Array&lt;IndexPath.Element&gt;)"/>
      <constructor name="IndexPath" signature="IndexPath&lt;ElementSequence&gt;(indexes: ElementSequence)"/>
      <field name="count" type="Int"/>
      <field name="count" type="Int"/>
      <field name="customMirror" type="Mirror"/>
      <field name="debugDescription" type="String"/>
      <field name="description" type="String"/>
      <field name="endIndex" type="IndexPath.Index"/>
      <field name="hashValue" type="Int"/>
      <field name="indices" type="DefaultRandomAccessIndices&lt;IndexPath&gt;"/>
      <field name="isEmpty" type="Bool"/>
      <field name="item" type="Int"/>
      <field name="item" type="Int"/>
      <field name="lazy" type="LazyCollection&lt;IndexPath&gt;"/>
      <field name="lazy" type="LazySequence&lt;IndexPath&gt;"/>
      <field name="lazy" type="LazyBidirectionalCollection&lt;IndexPath&gt;"/>
      <field name="lazy" type="LazyRandomAccessCollection&lt;IndexPath&gt;"/>
      <field name="row" type="Int"/>
      <field name="section" type="Int"/>
      <field name="section" type="Int"/>
      <field name="startIndex" type="IndexPath.Index"/>
      <field name="underestimatedCount" type="Int"/>
      <field name="underestimatedCount" type="Int"/>
      <field name="isEmpty" type="Bool"/>
      <method name="!=" signature="!=(IndexPath, IndexPath)"/>
      <method name="+" signature="+(IndexPath, IndexPath)"/>
      <method name="+=" signature="+=(inout IndexPath, IndexPath)"/>
      <method name="&lt;" signature="&lt;(IndexPath, IndexPath)"/>
      <method name="&lt;=" signature="&lt;=(IndexPath, IndexPath)"/>
      <method name="&lt;=" signature="&lt;=(IndexPath, IndexPath)"/>
      <method name="==" signature="==(IndexPath, IndexPath)"/>
      <method name="&gt;" signature="&gt;(IndexPath, IndexPath)"/>
      <method name="&gt;" signature="&gt;(IndexPath, IndexPath)"/>
      <method name="&gt;=" signature="&gt;=(IndexPath, IndexPath)">
        <return type="Bool"/>
      </method>
      <method name="&gt;=" signature="&gt;=(IndexPath, IndexPath)"/>
      <method name="removeFirst" signature="removeFirst()">
        <return type="Int"/>
      </method>
      <method name="removeFirst" signature="removeFirst(Int)"/>
      <method name="removeLast" signature="removeLast()">
        <return type="Int"/>
      </method>
      <method name="removeLast" signature="removeLast(Int)"/>
      <method name="popFirst" signature="popFirst()">
        <return type="Int?"/>
      </method>
      <method name="popLast" signature="popLast()">
        <return type="Int?"/>
      </method>
      <method name="max" signature="max()">
        <return type="Int?"/>
      </method>
      <method name="min" signature="min()">
        <return type="Int?"/>
      </method>
      <method name="append" signature="append(IndexPath)"/>
      <method name="append" signature="append(Array&lt;IndexPath.Element&gt;)"/>
      <method name="append" signature="append(IndexPath.Element)"/>
      <method name="appending" signature="appending(IndexPath.Element)"/>
      <method name="appending" signature="appending(IndexPath)"/>
      <method name="appending" signature="appending(Array&lt;IndexPath.Element&gt;)"/>
      <method name="compare" signature="compare(IndexPath)"/>
      <method name="dropFirst" signature="dropFirst()">
        <return type="IndexPath"/>
      </method>
      <method name="dropFirst" signature="dropFirst(Int)">
        <return type="IndexPath"/>
      </method>
      <method name="dropLast" signature="dropLast()"/>
      <method name="dropLast" signature="dropLast(Int)">
        <return type="IndexPath"/>
      </method>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, IndexPath.Element == OtherSequence.Element"/>
      </method>
      <method name="enumerated" signature="enumerated()">
        <return type="EnumeratedSequence&lt;IndexPath&gt;"/>
      </method>
      <method name="index" signature="index(after: IndexPath.Index)"/>
      <method name="index" signature="index(before: IndexPath.Index)"/>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, IndexPath.Element == OtherSequence.Element"/>
      </method>
      <method name="makeIterator" signature="makeIterator()"/>
      <method name="max" signature="max()">
        <return type="Int?"/>
      </method>
      <method name="min" signature="min()">
        <return type="Int?"/>
      </method>
      <method name="popFirst" signature="popFirst()">
        <return type="Int?"/>
      </method>
      <method name="popLast" signature="popLast()">
        <return type="Int?"/>
      </method>
      <method name="prefix" signature="prefix(Int)">
        <return type="IndexPath"/>
      </method>
      <method name="prefix" signature="prefix(through: Array.Index)">
        <return type="IndexPath"/>
      </method>
      <method name="prefix" signature="prefix(upTo: Array.Index)">
        <return type="IndexPath"/>
      </method>
      <method name="removeFirst" signature="removeFirst()">
        <return type="Int"/>
      </method>
      <method name="removeFirst" signature="removeFirst(Int)"/>
      <method name="removeLast" signature="removeLast()">
        <return type="Int"/>
      </method>
      <method name="removeLast" signature="removeLast(Int)"/>
      <method name="reversed" signature="reversed()"/>
      <method name="sorted" signature="sorted()">
        <return type="[Int]"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix)">
        <return type="Bool where PossiblePrefix : Sequence, IndexPath.Element == PossiblePrefix.Element"/>
      </method>
      <method name="suffix" signature="suffix(Int)">
        <return type="IndexPath"/>
      </method>
      <method name="suffix" signature="suffix(from: Array.Index)">
        <return type="IndexPath"/>
      </method>
      <method name="dropFirst" signature="dropFirst()">
        <return type="IndexPath"/>
      </method>
      <method name="dropFirst" signature="dropFirst(Int)">
        <return type="IndexPath"/>
      </method>
      <method name="dropLast" signature="dropLast()"/>
      <method name="dropLast" signature="dropLast(Int)">
        <return type="IndexPath"/>
      </method>
      <field name="lazy" type="LazyCollection&lt;IndexPath&gt;"/>
      <field name="lazy" type="LazySequence&lt;IndexPath&gt;"/>
      <field name="lazy" type="LazyBidirectionalCollection&lt;IndexPath&gt;"/>
      <field name="lazy" type="LazyRandomAccessCollection&lt;IndexPath&gt;"/>
      <method name="enumerated" signature="enumerated()">
        <return type="EnumeratedSequence&lt;IndexPath&gt;"/>
      </method>
      <method name="makeIterator" signature="makeIterator()"/>
      <method name="sorted" signature="sorted()">
        <return type="[Int]"/>
      </method>
      <method name="reversed" signature="reversed()"/>
      <method name="compare" signature="compare(IndexPath)"/>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, IndexPath.Element == OtherSequence.Element"/>
      </method>
      <method name="&lt;" signature="&lt;(IndexPath, IndexPath)"/>
      <method name="&lt;=" signature="&lt;=(IndexPath, IndexPath)"/>
      <method name="==" signature="==(IndexPath, IndexPath)"/>
      <method name="&gt;" signature="&gt;(IndexPath, IndexPath)"/>
      <method name="&gt;=" signature="&gt;=(IndexPath, IndexPath)">
        <return type="Bool"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix)">
        <return type="Bool where PossiblePrefix : Sequence, IndexPath.Element == PossiblePrefix.Element"/>
      </method>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, IndexPath.Element == OtherSequence.Element"/>
      </method>
      <field name="startIndex" type="IndexPath.Index"/>
      <field name="endIndex" type="IndexPath.Index"/>
      <method name="index" signature="index(after: IndexPath.Index)"/>
      <method name="index" signature="index(before: IndexPath.Index)"/>
      <field name="indices" type="DefaultRandomAccessIndices&lt;IndexPath&gt;"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <constructor name="IndexPath" signature="IndexPath(from: Decoder)"/>
      <constructor name="IndexPath" signature="IndexPath(item: Int, section: Int)"/>
      <constructor name="IndexPath" signature="IndexPath(item: Int, section: Int)"/>
      <constructor name="IndexPath" signature="IndexPath(row: Int, section: Int)"/>
      <field name="first" type="Int?"/>
      <field name="last" type="Int?"/>
      <method name="contains" signature="contains(Int)">
        <return type="Bool"/>
      </method>
      <method name="contains" signature="contains(where: (Int) -&gt; Bool)">
        <return type="Bool"/>
      </method>
      <method name="drop" signature="drop(while: (Int) -&gt; Bool)"/>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence, by: (Int, Int) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, IndexPath.Element == OtherSequence.Element"/>
      </method>
      <method name="encode" signature="encode(to: Encoder)"/>
      <method name="filter" signature="filter((Int) -&gt; Bool)">
        <return type="[Int]"/>
      </method>
      <method name="first" signature="first(where: (Int) -&gt; Bool)">
        <return type="Int?"/>
      </method>
      <method name="flatMap" signature="flatMap((Int) -&gt; String?)"/>
      <method name="forEach" signature="forEach((Int) -&gt; Void)"/>
      <method name="index" signature="index(of: Int)">
        <return type="Array.Index?"/>
      </method>
      <method name="index" signature="index(where: (Int) -&gt; Bool)">
        <return type="Array.Index?"/>
      </method>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence, by: (Int, Int) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, IndexPath.Element == OtherSequence.Element"/>
      </method>
      <method name="map" signature="map&lt;T&gt;((Int) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="map" signature="map&lt;T&gt;((Int) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="max" signature="max(by: (Int, Int) -&gt; Bool)">
        <return type="Int?"/>
      </method>
      <method name="min" signature="min(by: (Int, Int) -&gt; Bool)">
        <return type="Int?"/>
      </method>
      <method name="partition" signature="partition(by: (Int) -&gt; Bool)"/>
      <method name="partition" signature="partition(by: (Int) -&gt; Bool)"/>
      <method name="prefix" signature="prefix(while: (Int) -&gt; Bool)"/>
      <method name="reduce" signature="reduce&lt;Result&gt;(Result, (Result, Int) -&gt; Result)">
        <return type="Result"/>
      </method>
      <method name="reduce" signature="reduce&lt;Result&gt;(into: Result, (inout Result, Int) -&gt; ())">
        <return type="Result"/>
      </method>
      <method name="sort" signature="sort(by: (Int, Int) -&gt; Bool)"/>
      <method name="sorted" signature="sorted(by: (Int, Int) -&gt; Bool)">
        <return type="[Int]"/>
      </method>
      <method name="split" signature="split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (Int) -&gt; Bool)">
        <return type="[IndexPath]"/>
      </method>
      <method name="split" signature="split(separator: Int, maxSplits: Int, omittingEmptySubsequences: Bool)">
        <return type="[IndexPath]"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix, by: (Int, Int) -&gt; Bool)">
        <return type="Bool where PossiblePrefix : Sequence, IndexPath.Element == PossiblePrefix.Element"/>
      </method>
      <method name="swapAt" signature="swapAt(Array.Index, Array.Index)"/>
      <method name="..." signature="...(IndexPath)"/>
      <method name="..." signature="...(IndexPath)"/>
      <method name="..&lt;" signature="..&lt;(IndexPath)"/>
    </class>


    <class kind="struct" name="IndexSet">
      <constructor name="IndexSet" signature="IndexSet()"/>
      <constructor name="IndexSet" signature="IndexSet&lt;S&gt;(S)"/>
      <constructor name="IndexSet" signature="IndexSet(arrayLiteral: Int...)"/>
      <constructor name="IndexSet" signature="IndexSet(integer: IndexSet.Element)"/>
      <constructor name="IndexSet" signature="IndexSet(integersIn: Range&lt;IndexSet.Element&gt;)"/>
      <constructor name="IndexSet" signature="IndexSet(integersIn: CountableClosedRange&lt;IndexSet.Element&gt;)"/>
      <constructor name="IndexSet" signature="IndexSet(integersIn: CountableRange&lt;IndexSet.Element&gt;)"/>
      <constructor name="IndexSet" signature="IndexSet(integersIn: ClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="count" signature="count(in: Range&lt;IndexSet.Element&gt;)"/>
      <method name="count" signature="count(in: CountableClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="count" signature="count(in: CountableRange&lt;IndexSet.Element&gt;)"/>
      <method name="count" signature="count(in: ClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="formIntersection" signature="formIntersection(IndexSet)"/>
      <method name="formSymmetricDifference" signature="formSymmetricDifference(IndexSet)"/>
      <method name="formUnion" signature="formUnion(IndexSet)"/>
      <method name="intersection" signature="intersection(IndexSet)"/>
      <method name="symmetricDifference" signature="symmetricDifference(IndexSet)"/>
      <method name="union" signature="union(IndexSet)"/>
      <method name="insert" signature="insert(IndexSet.Element)"/>
      <method name="insert" signature="insert(integersIn: Range&lt;IndexSet.Element&gt;)"/>
      <method name="insert" signature="insert(integersIn: ClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="insert" signature="insert(integersIn: CountableClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="insert" signature="insert(integersIn: CountableRange&lt;IndexSet.Element&gt;)"/>
      <method name="update" signature="update(with: IndexSet.Element)"/>
      <method name="remove" signature="remove(IndexSet.Element)"/>
      <method name="remove" signature="remove(integersIn: Range&lt;IndexSet.Element&gt;)"/>
      <method name="remove" signature="remove(integersIn: ClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="remove" signature="remove(integersIn: CountableRange&lt;IndexSet.Element&gt;)"/>
      <method name="remove" signature="remove(integersIn: CountableClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="removeAll" signature="removeAll()"/>
      <method name="subtract" signature="subtract(IndexSet)"/>
      <method name="subtracting" signature="subtracting(IndexSet)">
        <return type="IndexSet"/>
      </method>
      <method name="contains" signature="contains(IndexSet.Element)"/>
      <method name="contains" signature="contains(integersIn: IndexSet)"/>
      <method name="contains" signature="contains(integersIn: Range&lt;IndexSet.Element&gt;)"/>
      <method name="contains" signature="contains(integersIn: CountableRange&lt;IndexSet.Element&gt;)"/>
      <method name="contains" signature="contains(integersIn: ClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="contains" signature="contains(integersIn: CountableClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="contains" signature="contains(where: (Int) -&gt; Bool)">
        <return type="Bool"/>
      </method>
      <method name="intersects" signature="intersects(integersIn: Range&lt;IndexSet.Element&gt;)"/>
      <method name="intersects" signature="intersects(integersIn: CountableRange&lt;IndexSet.Element&gt;)"/>
      <method name="intersects" signature="intersects(integersIn: ClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="intersects" signature="intersects(integersIn: CountableClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix)">
        <return type="Bool where PossiblePrefix : Sequence, IndexSet.Element == PossiblePrefix.Element"/>
      </method>
      <method name="starts" signature="starts&lt;PossiblePrefix&gt;(with: PossiblePrefix, by: (Int, Int) -&gt; Bool)">
        <return type="Bool where PossiblePrefix : Sequence, IndexSet.Element == PossiblePrefix.Element"/>
      </method>
      <method name="isDisjoint" signature="isDisjoint(with: IndexSet)">
        <return type="Bool"/>
      </method>
      <method name="isStrictSubset" signature="isStrictSubset(of: IndexSet)">
        <return type="Bool"/>
      </method>
      <method name="isStrictSuperset" signature="isStrictSuperset(of: IndexSet)">
        <return type="Bool"/>
      </method>
      <method name="isSubset" signature="isSubset(of: IndexSet)">
        <return type="Bool"/>
      </method>
      <method name="isSuperset" signature="isSuperset(of: IndexSet)">
        <return type="Bool"/>
      </method>
      <field name="startIndex" type="IndexSet.Index"/>
      <field name="endIndex" type="IndexSet.Index"/>
      <method name="index" signature="index(after: IndexSet.Index)"/>
      <method name="index" signature="index(before: IndexSet.Index)"/>
      <method name="formIndex" signature="formIndex(after: inout IndexSet.Index)"/>
      <method name="formIndex" signature="formIndex(before: inout IndexSet.Index)"/>
      <method name="indexRange" signature="indexRange(in: Range&lt;IndexSet.Element&gt;)"/>
      <method name="indexRange" signature="indexRange(in: CountableRange&lt;IndexSet.Element&gt;)"/>
      <method name="indexRange" signature="indexRange(in: ClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="indexRange" signature="indexRange(in: CountableClosedRange&lt;IndexSet.Element&gt;)"/>
      <field name="indices" type="DefaultBidirectionalIndices&lt;IndexSet&gt;"/>
      <method name="first" signature="first(where: (Int) -&gt; Bool)">
        <return type="Int?"/>
      </method>
      <method name="max" signature="max()">
        <return type="Int?"/>
      </method>
      <method name="max" signature="max(by: (Int, Int) -&gt; Bool)">
        <return type="Int?"/>
      </method>
      <method name="min" signature="min()">
        <return type="Int?"/>
      </method>
      <method name="min" signature="min(by: (Int, Int) -&gt; Bool)">
        <return type="Int?"/>
      </method>
      <method name="integerLessThanOrEqualTo" signature="integerLessThanOrEqualTo(IndexSet.Element)"/>
      <method name="integerGreaterThan" signature="integerGreaterThan(IndexSet.Element)"/>
      <method name="integerGreaterThanOrEqualTo" signature="integerGreaterThanOrEqualTo(IndexSet.Element)"/>
      <method name="integerLessThan" signature="integerLessThan(IndexSet.Element)"/>
      <method name="index" signature="index(of: Int)">
        <return type="IndexSet.Index?"/>
      </method>
      <method name="index" signature="index(where: (Int) -&gt; Bool)">
        <return type="IndexSet.Index?"/>
      </method>
      <method name="filter" signature="filter((Int) -&gt; Bool)">
        <return type="[Int]"/>
      </method>
      <method name="filteredIndexSet" signature="filteredIndexSet(in: Range&lt;IndexSet.Element&gt;, includeInteger: (IndexSet.Element) -&gt; Bool)"/>
      <method name="filteredIndexSet" signature="filteredIndexSet(in: CountableRange&lt;IndexSet.Element&gt;, includeInteger: (IndexSet.Element) -&gt; Bool)"/>
      <method name="filteredIndexSet" signature="filteredIndexSet(in: ClosedRange&lt;IndexSet.Element&gt;, includeInteger: (IndexSet.Element) -&gt; Bool)"/>
      <method name="filteredIndexSet" signature="filteredIndexSet(in: CountableClosedRange&lt;IndexSet.Element&gt;, includeInteger: (IndexSet.Element) -&gt; Bool)"/>
      <method name="filteredIndexSet" signature="filteredIndexSet(includeInteger: (IndexSet.Element) -&gt; Bool)"/>
      <method name="prefix" signature="prefix(Int)">
        <return type="BidirectionalSlice&lt;IndexSet&gt;"/>
      </method>
      <method name="prefix" signature="prefix(through: IndexSet.Index)">
        <return type="BidirectionalSlice&lt;IndexSet&gt;"/>
      </method>
      <method name="prefix" signature="prefix(upTo: IndexSet.Index)">
        <return type="BidirectionalSlice&lt;IndexSet&gt;"/>
      </method>
      <method name="prefix" signature="prefix(while: (Int) -&gt; Bool)"/>
      <method name="suffix" signature="suffix(Int)">
        <return type="BidirectionalSlice&lt;IndexSet&gt;"/>
      </method>
      <method name="suffix" signature="suffix(from: IndexSet.Index)">
        <return type="BidirectionalSlice&lt;IndexSet&gt;"/>
      </method>
      <method name="dropLast" signature="dropLast()">
        <return type="BidirectionalSlice&lt;IndexSet&gt;"/>
      </method>
      <method name="dropLast" signature="dropLast(Int)">
        <return type="BidirectionalSlice&lt;IndexSet&gt;"/>
      </method>
      <method name="dropFirst" signature="dropFirst()">
        <return type="BidirectionalSlice&lt;IndexSet&gt;"/>
      </method>
      <method name="dropFirst" signature="dropFirst(Int)">
        <return type="BidirectionalSlice&lt;IndexSet&gt;"/>
      </method>
      <method name="drop" signature="drop(while: (Int) -&gt; Bool)"/>
      <method name="reduce" signature="reduce&lt;Result&gt;(Result, (Result, Int) -&gt; Result)">
        <return type="Result"/>
      </method>
      <field name="lazy" type="LazyBidirectionalCollection&lt;IndexSet&gt;"/>
      <field name="lazy" type="LazyCollection&lt;IndexSet&gt;"/>
      <field name="lazy" type="LazySequence&lt;IndexSet&gt;"/>
      <method name="forEach" signature="forEach((Int) -&gt; Void)"/>
      <method name="enumerated" signature="enumerated()">
        <return type="EnumeratedSequence&lt;IndexSet&gt;"/>
      </method>
      <method name="makeIterator" signature="makeIterator()"/>
      <method name="sorted" signature="sorted()">
        <return type="[Int]"/>
      </method>
      <method name="sorted" signature="sorted(by: (Int, Int) -&gt; Bool)">
        <return type="[Int]"/>
      </method>
      <method name="reversed" signature="reversed()"/>
      <method name="shift" signature="shift(startingAt: IndexSet.Element, by: Int)"/>
      <method name="split" signature="split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (Int) -&gt; Bool)">
        <return type="[BidirectionalSlice&lt;IndexSet&gt;]"/>
      </method>
      <method name="split" signature="split(separator: Int, maxSplits: Int, omittingEmptySubsequences: Bool)">
        <return type="[BidirectionalSlice&lt;IndexSet&gt;]"/>
      </method>
      <method name="!=" signature="!=(IndexSet, IndexSet)"/>
      <method name="==" signature="==(IndexSet, IndexSet)"/>
      <method name="rangeView" signature="rangeView(of: Range&lt;IndexSet.Element&gt;)"/>
      <method name="rangeView" signature="rangeView(of: CountableRange&lt;IndexSet.Element&gt;)"/>
      <method name="rangeView" signature="rangeView(of: CountableClosedRange&lt;IndexSet.Element&gt;)"/>
      <method name="rangeView" signature="rangeView(of: ClosedRange&lt;IndexSet.Element&gt;)"/>
      <field name="rangeView" type="IndexSet.RangeView"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <constructor name="IndexSet" signature="IndexSet(from: Decoder)"/>
      <field name="count" type="Int"/>
      <field name="count" type="Int"/>
      <field name="first" type="IndexSet.Element?"/>
      <field name="first" type="Int?"/>
      <field name="isEmpty" type="Bool"/>
      <field name="isEmpty" type="Bool"/>
      <field name="isEmpty" type="Bool"/>
      <field name="last" type="IndexSet.Element?"/>
      <field name="last" type="Int?"/>
      <field name="underestimatedCount" type="Int"/>
      <field name="underestimatedCount" type="Int"/>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, IndexSet.Element == OtherSequence.Element"/>
      </method>
      <method name="elementsEqual" signature="elementsEqual&lt;OtherSequence&gt;(OtherSequence, by: (Int, Int) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, IndexSet.Element == OtherSequence.Element"/>
      </method>
      <method name="encode" signature="encode(to: Encoder)"/>
      <method name="flatMap" signature="flatMap((Int) -&gt; String?)"/>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence)">
        <return type="Bool where OtherSequence : Sequence, IndexSet.Element == OtherSequence.Element"/>
      </method>
      <method name="lexicographicallyPrecedes" signature="lexicographicallyPrecedes&lt;OtherSequence&gt;(OtherSequence, by: (Int, Int) -&gt; Bool)">
        <return type="Bool where OtherSequence : Sequence, IndexSet.Element == OtherSequence.Element"/>
      </method>
      <method name="map" signature="map&lt;T&gt;((Int) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="map" signature="map&lt;T&gt;((Int) -&gt; T)">
        <return type="[T]"/>
      </method>
      <method name="reduce" signature="reduce&lt;Result&gt;(into: Result, (inout Result, Int) -&gt; ())">
        <return type="Result"/>
      </method>
    </class>


    <class name="ISO8601DateFormatter" supertypes="NSFormatter">
      <field name="formatOptions" type="ISO8601DateFormatter.Options"/>
      <field name="timeZone" type="TimeZone!"/>
      <constructor name="ISO8601DateFormatter" signature="ISO8601DateFormatter()"/>
      <method name="string" signature="string(from: Date)">
        <return type="String"/>
      </method>
      <method name="date" signature="date(from: String)">
        <return type="Date?"/>
      </method>
    </class>


    <class kind="struct" name="Locale">
      <constructor name="Locale" signature="Locale(identifier: String)"/>
      <field name="autoupdatingCurrent" type="Locale"/>
      <field name="current" type="Locale"/>
      <field name="availableIdentifiers" type="[String]"/>
      <field name="isoRegionCodes" type="[String]"/>
      <field name="isoLanguageCodes" type="[String]"/>
      <field name="isoCurrencyCodes" type="[String]"/>
      <field name="commonISOCurrencyCodes" type="[String]"/>
      <method name="canonicalIdentifier" signature="canonicalIdentifier(from: String)"/>
      <method name="components" signature="components(fromIdentifier: String)"/>
      <method name="identifier" signature="identifier(fromComponents: [String : String])"/>
      <method name="canonicalLanguageIdentifier" signature="canonicalLanguageIdentifier(from: String)"/>
      <method name="identifier" signature="identifier(fromWindowsLocaleCode: Int)"/>
      <method name="windowsLocaleCode" signature="windowsLocaleCode(fromIdentifier: String)"/>
      <field name="identifier" type="String"/>
      <field name="calendar" type="Calendar"/>
      <field name="regionCode" type="String?"/>
      <field name="languageCode" type="String?"/>
      <field name="scriptCode" type="String?"/>
      <field name="variantCode" type="String?"/>
      <field name="exemplarCharacterSet" type="CharacterSet?"/>
      <field name="collationIdentifier" type="String?"/>
      <field name="collatorIdentifier" type="String?"/>
      <field name="usesMetricSystem" type="Bool"/>
      <field name="decimalSeparator" type="String?"/>
      <field name="groupingSeparator" type="String?"/>
      <field name="currencyCode" type="String?"/>
      <field name="currencySymbol" type="String?"/>
      <field name="quotationBeginDelimiter" type="String?"/>
      <field name="quotationEndDelimiter" type="String?"/>
      <field name="alternateQuotationBeginDelimiter" type="String?"/>
      <field name="alternateQuotationEndDelimiter" type="String?"/>
      <method name="localizedString" signature="localizedString(for: Calendar.Identifier)"/>
      <method name="localizedString" signature="localizedString(forCollationIdentifier: String)"/>
      <method name="localizedString" signature="localizedString(forCollatorIdentifier: String)"/>
      <method name="localizedString" signature="localizedString(forCurrencyCode: String)"/>
      <method name="localizedString" signature="localizedString(forIdentifier: String)"/>
      <method name="localizedString" signature="localizedString(forLanguageCode: String)"/>
      <method name="localizedString" signature="localizedString(forRegionCode: String)"/>
      <method name="localizedString" signature="localizedString(forScriptCode: String)"/>
      <method name="localizedString" signature="localizedString(forVariantCode: String)"/>
      <field name="preferredLanguages" type="[String]"/>
      <method name="characterDirection" signature="characterDirection(forLanguage: String)"/>
      <method name="lineDirection" signature="lineDirection(forLanguage: String)"/>
      <method name="!=" signature="!=(Locale, Locale)"/>
      <method name="==" signature="==(Locale, Locale)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <constructor name="Locale" signature="Locale(from: Decoder)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
    </class>


    <class name="NSAttributedString" supertypes="NSObject">
      <constructor name="NSAttributedString" signature="NSAttributedString(string: String)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString(string: String, attributes: [NSAttributedStringKey : Any]? = nil)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString(attributedString: NSAttributedString)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString(data: Data, options: [NSAttributedString.DocumentReadingOptionKey : Any] = [:], documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString?(docFormat: Data, documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString?(html: Data, documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString?(html: Data, baseURL: URL, documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString?(html: Data, options: [NSAttributedString.DocumentReadingOptionKey : Any] = [:], documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString?(rtf: Data, documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString?(rtfd: Data, documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString?(rtfdFileWrapper: FileWrapper, documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString(url: URL, options: [NSAttributedString.DocumentReadingOptionKey : Any] = [:], documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString(attachment: NSTextAttachment)"/>
      <field name="string" type="String"/>
      <field name="length" type="Int"/>
      <method name="attributes" signature="attributes(at: Int, effectiveRange: NSRangePointer?)">
        <return type="[NSAttributedStringKey : Any]"/>
      </method>
      <method name="attributes" signature="attributes(at: Int, longestEffectiveRange: NSRangePointer?, in: NSRange)"/>
      <method name="attribute" signature="attribute(NSAttributedStringKey, at: Int, effectiveRange: NSRangePointer?)">
        <return type="Any?"/>
      </method>
      <method name="attribute" signature="attribute(NSAttributedStringKey, at: Int, longestEffectiveRange: NSRangePointer?, in: NSRange)">
        <return type="Any?"/>
      </method>
      <method name="isEqual" signature="isEqual(to: NSAttributedString)">
        <return type="Bool"/>
      </method>
      <method name="attributedSubstring" signature="attributedSubstring(from: NSRange)">
        <return type="NSAttributedString"/>
      </method>
      <method name="enumerateAttribute" signature="enumerateAttribute(NSAttributedStringKey, in: NSRange, options: NSAttributedString.EnumerationOptions = [], using: (Any?, NSRange, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)"/>
      <method name="enumerateAttributes" signature="enumerateAttributes(in: NSRange, options: NSAttributedString.EnumerationOptions = [], using: ([NSAttributedStringKey : Any], NSRange, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)"/>
      <method name="fontAttributes" signature="fontAttributes(in: NSRange)">
        <return type="[NSAttributedStringKey : Any]"/>
      </method>
      <method name="rulerAttributes" signature="rulerAttributes(in: NSRange)">
        <return type="[NSAttributedStringKey : Any]"/>
      </method>
      <method name="doubleClick" signature="doubleClick(at: Int)">
        <return type="NSRange"/>
      </method>
      <method name="lineBreak" signature="lineBreak(before: Int, within: NSRange)">
        <return type="Int"/>
      </method>
      <method name="lineBreakByHyphenating" signature="lineBreakByHyphenating(before: Int, within: NSRange)">
        <return type="Int"/>
      </method>
      <method name="nextWord" signature="nextWord(from: Int, forward: Bool)">
        <return type="Int"/>
      </method>
      <method name="itemNumber" signature="itemNumber(in: NSTextList, at: Int)">
        <return type="Int"/>
      </method>
      <method name="range" signature="range(of: NSTextBlock, at: Int)">
        <return type="NSRange"/>
      </method>
      <method name="range" signature="range(of: NSTextList, at: Int)">
        <return type="NSRange"/>
      </method>
      <method name="range" signature="range(of: NSTextTable, at: Int)">
        <return type="NSRange"/>
      </method>
      <method name="data" signature="data(from: NSRange, documentAttributes: [NSAttributedString.DocumentAttributeKey : Any] = [:])">
        <return type="Data"/>
      </method>
      <method name="fileWrapper" signature="fileWrapper(from: NSRange, documentAttributes: [NSAttributedString.DocumentAttributeKey : Any] = [:])">
        <return type="FileWrapper"/>
      </method>
      <method name="docFormat" signature="docFormat(from: NSRange, documentAttributes: [NSAttributedString.DocumentAttributeKey : Any] = [:])">
        <return type="Data?"/>
      </method>
      <method name="rtf" signature="rtf(from: NSRange, documentAttributes: [NSAttributedString.DocumentAttributeKey : Any] = [:])">
        <return type="Data?"/>
      </method>
      <method name="rtfd" signature="rtfd(from: NSRange, documentAttributes: [NSAttributedString.DocumentAttributeKey : Any] = [:])">
        <return type="Data?"/>
      </method>
      <method name="rtfdFileWrapper" signature="rtfdFileWrapper(from: NSRange, documentAttributes: [NSAttributedString.DocumentAttributeKey : Any] = [:])">
        <return type="FileWrapper?"/>
      </method>
      <method name="draw" signature="draw(at: CGPoint)"/>
      <method name="draw" signature="draw(in: CGRect)"/>
      <method name="draw" signature="draw(with: CGRect, options: NSStringDrawingOptions = [], context: NSStringDrawingContext?)"/>
      <method name="size" signature="size()">
        <return type="CGSize"/>
      </method>
      <method name="boundingRect" signature="boundingRect(with: CGSize, options: NSStringDrawingOptions = [], context: NSStringDrawingContext?)">
        <return type="CGRect"/>
      </method>
      <method name="containsAttachments" signature="containsAttachments(in: NSRange)">
        <return type="Bool"/>
      </method>
      <constructor name="NSAttributedString" signature="NSAttributedString?(path: String, documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString?(url: URL, documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <constructor name="NSAttributedString" signature="NSAttributedString(fileURL: URL, options: [AnyHashable : Any] = [:], documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)"/>
      <field name="containsAttachments" type="Bool"/>
      <method name="url" signature="url(at: Int, effectiveRange: NSRangePointer)">
        <return type="URL?"/>
      </method>
      <method name="draw" signature="draw(with: NSRect, options: NSString.DrawingOptions = [])"/>
      <method name="boundingRect" signature="boundingRect(with: NSSize, options: NSString.DrawingOptions = [])">
        <return type="NSRect"/>
      </method>
    </class>


    <class name="NSCache" supertypes="NSObject">
      <field name="name" type="String"/>
      <field name="countLimit" type="Int"/>
      <field name="totalCostLimit" type="Int"/>
      <field name="evictsObjectsWithDiscardedContent" type="Bool"/>
      <field name="delegate" type="NSCacheDelegate?"/>
      <method name="object" signature="object(forKey: KeyType)">
        <return type="ObjectType?"/>
      </method>
      <method name="setObject" signature="setObject(ObjectType, forKey: KeyType)"/>
      <method name="setObject" signature="setObject(ObjectType, forKey: KeyType, cost: Int)"/>
      <method name="removeObject" signature="removeObject(forKey: KeyType)"/>
      <method name="removeAllObjects" signature="removeAllObjects()"/>
    </class>


    <class name="NSCountedSet" supertypes="NSMutableSet">
      <constructor name="NSCountedSet" signature="NSCountedSet(array: [Any])"/>
      <constructor name="NSCountedSet" signature="NSCountedSet(set: Set&lt;AnyHashable&gt;)"/>
      <constructor name="NSCountedSet" signature="NSCountedSet(capacity: Int)"/>
      <method name="add" signature="add(Any)"/>
      <method name="remove" signature="remove(Any)"/>
      <method name="count" signature="count(for: Any)">
        <return type="Int"/>
      </method>
      <method name="objectEnumerator" signature="objectEnumerator()">
        <return type="NSEnumerator"/>
      </method>
    </class>


    <class name="NSDataDetector" supertypes="NSRegularExpression">
      <constructor name="NSDataDetector" signature="NSDataDetector(types: NSTextCheckingTypes)"/>
      <field name="checkingTypes" type="NSTextCheckingTypes"/>
    </class>

    <class kind="struct" name="NSEdgeInsets">
      <field name="bottom" type="CGFloat"/>
      <field name="left" type="CGFloat"/>
      <field name="right" type="CGFloat"/>
      <field name="top" type="CGFloat"/>
      <method name="NSEdgeInsetsEqual" signature="NSEdgeInsetsEqual(NSEdgeInsets, NSEdgeInsets)"/>
      <method name="NSEdgeInsetsMake" signature="NSEdgeInsetsMake(CGFloat, CGFloat, CGFloat, CGFloat)"/>
      <constructor name="NSEdgeInsets" signature="NSEdgeInsets()"/>
      <constructor name="NSEdgeInsets" signature="NSEdgeInsets(top: CGFloat, left: CGFloat, bottom: CGFloat, right: CGFloat)"/>
    </class>


    <class name="NSEnumerator" supertypes="NSObject">
      <field name="allObjects" type="[Any]"/>
      <method name="nextObject" signature="nextObject()">
        <return type="Any?"/>
      </method>
      <method name="makeIterator" signature="makeIterator()"/>
    </class>


    <class kind="protocol" name="NSFastEnumeration">
      <method name="countByEnumerating" signature="countByEnumerating(with: UnsafeMutablePointer&lt;NSFastEnumerationState&gt;, objects: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, count: Int)">
        <return type="Int"/>
      </method>
    </class>


    <class kind="struct" name="NSFastEnumerationIterator">
      <constructor name="NSFastEnumerationIterator" signature="NSFastEnumerationIterator(NSFastEnumeration)"/>
      <method name="next" signature="next()"/>
    </class>


    <class name="NSHashTable" supertypes="NSObject">
      <constructor name="NSHashTable" signature="NSHashTable(options: NSPointerFunctions.Options = [], capacity: Int)"/>
      <constructor name="NSHashTable" signature="NSHashTable(pointerFunctions: NSPointerFunctions, capacity: Int)"/>
      <constructor name="NSHashTable" signature="NSHashTable(options: NSPointerFunctions.Options = [])"/>
      <field name="anyObject" type="ObjectType?"/>
      <field name="allObjects" type="[ObjectType]"/>
      <field name="setRepresentation" type="Set&lt;AnyHashable&gt;"/>
      <field name="count" type="Int"/>
      <method name="contains" signature="contains(ObjectType?)">
        <return type="Bool"/>
      </method>
      <method name="member" signature="member(ObjectType?)">
        <return type="ObjectType?"/>
      </method>
      <method name="objectEnumerator" signature="objectEnumerator()">
        <return type="NSEnumerator"/>
      </method>
      <method name="add" signature="add(ObjectType?)"/>
      <method name="remove" signature="remove(ObjectType?)"/>
      <method name="removeAllObjects" signature="removeAllObjects()"/>
      <method name="intersect" signature="intersect(NSHashTable&lt;ObjectType&gt;)"/>
      <method name="intersects" signature="intersects(NSHashTable&lt;ObjectType&gt;)">
        <return type="Bool"/>
      </method>
      <method name="isSubset" signature="isSubset(of: NSHashTable&lt;ObjectType&gt;)">
        <return type="Bool"/>
      </method>
      <method name="isEqual" signature="isEqual(to: NSHashTable&lt;ObjectType&gt;)">
        <return type="Bool"/>
      </method>
      <method name="minus" signature="minus(NSHashTable&lt;ObjectType&gt;)"/>
      <method name="union" signature="union(NSHashTable&lt;ObjectType&gt;)"/>
      <field name="pointerFunctions" type="NSPointerFunctions"/>
    </class>


    <class name="NSLinguisticTagger" supertypes="NSObject">
      <constructor name="NSLinguisticTagger" signature="NSLinguisticTagger(tagSchemes: [NSLinguisticTagScheme], options: Int)"/>
      <field name="string" type="String?"/>
      <field name="tagSchemes" type="[NSLinguisticTagScheme]"/>
      <field name="dominantLanguage" type="String?"/>
      <method name="orthography" signature="orthography(at: Int, effectiveRange: NSRangePointer?)">
        <return type="NSOrthography?"/>
      </method>
      <method name="setOrthography" signature="setOrthography(NSOrthography?, range: NSRange)"/>
      <method name="enumerateTags" signature="enumerateTags(in: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTagger.Options = [], using: (NSLinguisticTag?, NSRange, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)"/>
      <method name="enumerateTags" signature="enumerateTags(in: NSRange, scheme: NSLinguisticTagScheme, options: NSLinguisticTagger.Options = [], using: (NSLinguisticTag?, NSRange, NSRange, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)"/>
      <method name="tag" signature="tag(at: Int, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, tokenRange: NSRangePointer?)">
        <return type="NSLinguisticTag?"/>
      </method>
      <method name="tag" signature="tag(at: Int, scheme: NSLinguisticTagScheme, tokenRange: NSRangePointer?, sentenceRange: NSRangePointer?)">
        <return type="NSLinguisticTag?"/>
      </method>
      <method name="tags" signature="tags(in: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTagger.Options = [], tokenRanges: AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?)">
        <return type="[NSLinguisticTag]"/>
      </method>
      <method name="tags" signature="tags(in: NSRange, scheme: String, options: NSLinguisticTagger.Options = [], tokenRanges: AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?)">
        <return type="[String]"/>
      </method>
      <method name="tokenRange" signature="tokenRange(at: Int, unit: NSLinguisticTaggerUnit)">
        <return type="NSRange"/>
      </method>
      <method name="sentenceRange" signature="sentenceRange(for: NSRange)">
        <return type="NSRange"/>
      </method>
      <method name="possibleTags" signature="possibleTags(at: Int, scheme: String, tokenRange: NSRangePointer?, sentenceRange: NSRangePointer?, scores: AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?)">
        <return type="[String]?"/>
      </method>
      <method name="stringEdited" signature="stringEdited(in: NSRange, changeInLength: Int)"/>
    </class>


    <class name="NSMapTable" supertypes="NSObject">
      <constructor name="NSMapTable" signature="NSMapTable(keyOptions: NSPointerFunctions.Options = [], valueOptions: NSPointerFunctions.Options = [], capacity: Int)"/>
      <constructor name="NSMapTable" signature="NSMapTable(keyOptions: NSPointerFunctions.Options = [], valueOptions: NSPointerFunctions.Options = [])"/>
      <constructor name="NSMapTable" signature="NSMapTable(keyPointerFunctions: NSPointerFunctions, valuePointerFunctions: NSPointerFunctions, capacity: Int)"/>
      <method name="object" signature="object(forKey: KeyType?)">
        <return type="ObjectType?"/>
      </method>
      <method name="keyEnumerator" signature="keyEnumerator()">
        <return type="NSEnumerator"/>
      </method>
      <method name="objectEnumerator" signature="objectEnumerator()">
        <return type="NSEnumerator?"/>
      </method>
      <field name="count" type="Int"/>
      <method name="setObject" signature="setObject(ObjectType?, forKey: KeyType?)"/>
      <method name="removeObject" signature="removeObject(forKey: KeyType?)"/>
      <method name="removeAllObjects" signature="removeAllObjects()"/>
      <method name="dictionaryRepresentation" signature="dictionaryRepresentation()">
        <return type="[AnyHashable : ObjectType]"/>
      </method>
      <field name="keyPointerFunctions" type="NSPointerFunctions"/>
      <field name="valuePointerFunctions" type="NSPointerFunctions"/>
    </class>


    <class name="NSMutableAttributedString" supertypes="NSAttributedString">
      <field name="mutableString" type="NSMutableString"/>
      <method name="replaceCharacters" signature="replaceCharacters(in: NSRange, with: String)"/>
      <method name="deleteCharacters" signature="deleteCharacters(in: NSRange)"/>
      <method name="setAttributes" signature="setAttributes([NSAttributedStringKey : Any]?, range: NSRange)"/>
      <method name="addAttribute" signature="addAttribute(NSAttributedStringKey, value: Any, range: NSRange)"/>
      <method name="addAttributes" signature="addAttributes([NSAttributedStringKey : Any] = [:], range: NSRange)"/>
      <method name="removeAttribute" signature="removeAttribute(NSAttributedStringKey, range: NSRange)"/>
      <method name="applyFontTraits" signature="applyFontTraits(NSFontTraitMask, range: NSRange)"/>
      <method name="setAlignment" signature="setAlignment(NSTextAlignment, range: NSRange)"/>
      <method name="setBaseWritingDirection" signature="setBaseWritingDirection(NSWritingDirection, range: NSRange)"/>
      <method name="subscriptRange" signature="subscriptRange(NSRange)"/>
      <method name="superscriptRange" signature="superscriptRange(NSRange)"/>
      <method name="unscriptRange" signature="unscriptRange(NSRange)"/>
      <method name="append" signature="append(NSAttributedString)"/>
      <method name="insert" signature="insert(NSAttributedString, at: Int)"/>
      <method name="replaceCharacters" signature="replaceCharacters(in: NSRange, with: NSAttributedString)"/>
      <method name="setAttributedString" signature="setAttributedString(NSAttributedString)"/>
      <method name="beginEditing" signature="beginEditing()"/>
      <method name="endEditing" signature="endEditing()"/>
      <method name="updateAttachments" signature="updateAttachments(fromPath: String)"/>
      <method name="fixAttributes" signature="fixAttributes(in: NSRange)"/>
      <method name="fixAttachmentAttribute" signature="fixAttachmentAttribute(in: NSRange)"/>
      <method name="fixFontAttribute" signature="fixFontAttribute(in: NSRange)"/>
      <method name="fixParagraphStyleAttribute" signature="fixParagraphStyleAttribute(in: NSRange)"/>
      <method name="read" signature="read(from: Data, options: [NSAttributedString.DocumentReadingOptionKey : Any] = [:], documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="read" signature="read(from: URL, options: [NSAttributedString.DocumentReadingOptionKey : Any] = [:], documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="read" signature="read(from: Data, options: [AnyHashable : Any] = [:], documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="read" signature="read(from: URL, options: [AnyHashable : Any] = [:], documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="read" signature="read(fromFileURL: URL, options: [AnyHashable : Any] = [:], documentAttributes: AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;?)">
        <return type="Bool"/>
      </method>
    </class>


    <class name="NSMutableOrderedSet" supertypes="NSOrderedSet">
      <constructor name="NSMutableOrderedSet" signature="NSMutableOrderedSet(capacity: Int)"/>
      <constructor name="NSMutableOrderedSet" signature="NSMutableOrderedSet()"/>
      <method name="add" signature="add(Any)"/>
      <method name="add" signature="add(UnsafePointer&lt;AnyObject&gt;?, count: Int)"/>
      <method name="addObjects" signature="addObjects(from: [Any])"/>
      <method name="insert" signature="insert(Any, at: Int)"/>
      <method name="insert" signature="insert([Any], at: IndexSet)"/>
      <method name="remove" signature="remove(Any)"/>
      <method name="removeObject" signature="removeObject(at: Int)"/>
      <method name="removeObjects" signature="removeObjects(at: IndexSet)"/>
      <method name="removeObjects" signature="removeObjects(in: [Any])"/>
      <method name="removeObjects" signature="removeObjects(in: NSRange)"/>
      <method name="removeAllObjects" signature="removeAllObjects()"/>
      <method name="replaceObject" signature="replaceObject(at: Int, with: Any)"/>
      <method name="replaceObjects" signature="replaceObjects(at: IndexSet, with: [Any])"/>
      <method name="replaceObjects" signature="replaceObjects(in: NSRange, with: UnsafePointer&lt;AnyObject&gt;?, count: Int)"/>
      <method name="setObject" signature="setObject(Any, at: Int)"/>
      <method name="moveObjects" signature="moveObjects(at: IndexSet, to: Int)"/>
      <method name="exchangeObject" signature="exchangeObject(at: Int, withObjectAt: Int)"/>
      <method name="filter" signature="filter(using: NSPredicate)"/>
      <method name="sort" signature="sort(using: [NSSortDescriptor])"/>
      <method name="sort" signature="sort(comparator: (Any, Any) -&gt; ComparisonResult)"/>
      <method name="sort" signature="sort(options: NSSortOptions = [], usingComparator: (Any, Any) -&gt; ComparisonResult)"/>
      <method name="sortRange" signature="sortRange(NSRange, options: NSSortOptions = [], usingComparator: (Any, Any) -&gt; ComparisonResult)"/>
      <method name="intersect" signature="intersect(NSOrderedSet)"/>
      <method name="intersectSet" signature="intersectSet(Set&lt;AnyHashable&gt;)"/>
      <method name="minus" signature="minus(NSOrderedSet)"/>
      <method name="minusSet" signature="minusSet(Set&lt;AnyHashable&gt;)"/>
      <method name="union" signature="union(NSOrderedSet)"/>
      <method name="unionSet" signature="unionSet(Set&lt;AnyHashable&gt;)"/>
      <constructor name="NSMutableOrderedSet" signature="NSMutableOrderedSet?(coder: NSCoder)"/>
    </class>


    <class name="NSNull" supertypes="NSObject"/>


    <class name="NSOrderedSet" supertypes="NSObject">
      <constructor name="NSOrderedSet" signature="NSOrderedSet(array: [Any])"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(array: [Any], copyItems: Bool)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(array: [Any], range: NSRange, copyItems: Bool)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(object: Any)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(objects: UnsafePointer&lt;AnyObject&gt;?, count: Int)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(orderedSet: NSOrderedSet)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(orderedSet: NSOrderedSet, copyItems: Bool)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(orderedSet: NSOrderedSet, range: NSRange, copyItems: Bool)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(set: Set&lt;AnyHashable&gt;)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(set: Set&lt;AnyHashable&gt;, copyItems: Bool)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet()"/>
      <field name="count" type="Int"/>
      <method name="contains" signature="contains(Any)">
        <return type="Bool"/>
      </method>
      <method name="enumerateObjects" signature="enumerateObjects(at: IndexSet, options: NSEnumerationOptions = [], using: (Any, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)"/>
      <method name="enumerateObjects" signature="enumerateObjects((Any, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)"/>
      <method name="enumerateObjects" signature="enumerateObjects(options: NSEnumerationOptions = [], using: (Any, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)"/>
      <field name="firstObject" type="Any?"/>
      <field name="lastObject" type="Any?"/>
      <method name="object" signature="object(at: Int)">
        <return type="Any"/>
      </method>
      <method name="objects" signature="objects(at: IndexSet)">
        <return type="[Any]"/>
      </method>
      <method name="index" signature="index(of: Any)">
        <return type="Int"/>
      </method>
      <method name="index" signature="index(of: Any, inSortedRange: NSRange, options: NSBinarySearchingOptions = [], usingComparator: (Any, Any) -&gt; ComparisonResult)">
        <return type="Int"/>
      </method>
      <method name="index" signature="index(ofObjectAt: IndexSet, options: NSEnumerationOptions = [], passingTest: (Any, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Bool)">
        <return type="Int"/>
      </method>
      <method name="index" signature="index(ofObjectPassingTest: (Any, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Bool)">
        <return type="Int"/>
      </method>
      <method name="index" signature="index(NSEnumerationOptions = [], ofObjectPassingTest: (Any, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Bool)">
        <return type="Int"/>
      </method>
      <method name="indexes" signature="indexes(ofObjectsAt: IndexSet, options: NSEnumerationOptions = [], passingTest: (Any, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Bool)">
        <return type="IndexSet"/>
      </method>
      <method name="indexes" signature="indexes(ofObjectsPassingTest: (Any, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Bool)">
        <return type="IndexSet"/>
      </method>
      <method name="indexes" signature="indexes(options: NSEnumerationOptions = [], ofObjectsPassingTest: (Any, Int, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Bool)">
        <return type="IndexSet"/>
      </method>
      <method name="objectEnumerator" signature="objectEnumerator()">
        <return type="NSEnumerator"/>
      </method>
      <method name="reverseObjectEnumerator" signature="reverseObjectEnumerator()">
        <return type="NSEnumerator"/>
      </method>
      <field name="reversed" type="NSOrderedSet"/>
      <method name="setValue" signature="setValue(Any?, forKey: String)"/>
      <method name="value" signature="value(forKey: String)">
        <return type="Any"/>
      </method>
      <method name="addObserver" signature="addObserver(NSObject, forKeyPath: String, options: NSKeyValueObservingOptions = [], context: UnsafeMutableRawPointer?)"/>
      <method name="removeObserver" signature="removeObserver(NSObject, forKeyPath: String)"/>
      <method name="removeObserver" signature="removeObserver(NSObject, forKeyPath: String, context: UnsafeMutableRawPointer?)"/>
      <method name="isEqual" signature="isEqual(to: NSOrderedSet)">
        <return type="Bool"/>
      </method>
      <method name="intersects" signature="intersects(NSOrderedSet)">
        <return type="Bool"/>
      </method>
      <method name="intersectsSet" signature="intersectsSet(Set&lt;AnyHashable&gt;)">
        <return type="Bool"/>
      </method>
      <method name="isSubset" signature="isSubset(of: NSOrderedSet)">
        <return type="Bool"/>
      </method>
      <method name="isSubset" signature="isSubset(of: Set&lt;AnyHashable&gt;)">
        <return type="Bool"/>
      </method>
      <method name="sortedArray" signature="sortedArray(using: [NSSortDescriptor])">
        <return type="[Any]"/>
      </method>
      <method name="sortedArray" signature="sortedArray(comparator: (Any, Any) -&gt; ComparisonResult)">
        <return type="[Any]"/>
      </method>
      <method name="sortedArray" signature="sortedArray(options: NSSortOptions = [], usingComparator: (Any, Any) -&gt; ComparisonResult)">
        <return type="[Any]"/>
      </method>
      <method name="filtered" signature="filtered(using: NSPredicate)">
        <return type="NSOrderedSet"/>
      </method>
      <field name="description" type="String"/>
      <method name="description" signature="description(withLocale: Any?)">
        <return type="String"/>
      </method>
      <method name="description" signature="description(withLocale: Any?, indent: Int)">
        <return type="String"/>
      </method>
      <field name="array" type="[Any]"/>
      <field name="set" type="Set&lt;AnyHashable&gt;"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(arrayLiteral: Any...)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet?(coder: NSCoder)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(objects: Any...)"/>
      <constructor name="NSOrderedSet" signature="NSOrderedSet(objects: UnsafePointer&lt;AnyObject&gt;, count: Int)"/>
      <method name="makeIterator" signature="makeIterator()"/>
    </class>


    <class name="NSOrthography" supertypes="NSObject">
      <constructor name="NSOrthography" signature="NSOrthography(dominantScript: String, languageMap: [String : [String]])"/>
      <field name="dominantScript" type="String"/>
      <field name="languageMap" type="[String]]"/>
      <method name="languages" signature="languages(forScript: String)">
        <return type="[String]?"/>
      </method>
      <method name="dominantLanguage" signature="dominantLanguage(forScript: String)">
        <return type="String?"/>
      </method>
      <field name="allLanguages" type="[String]"/>
      <field name="allScripts" type="[String]"/>
      <field name="dominantLanguage" type="String"/>
      <constructor name="NSOrthography" signature="NSOrthography?(coder: NSCoder)"/>
    </class>


    <class name="NSPointerArray" supertypes="NSObject">
      <constructor name="NSPointerArray" signature="NSPointerArray(options: NSPointerFunctions.Options = [])"/>
      <constructor name="NSPointerArray" signature="NSPointerArray(pointerFunctions: NSPointerFunctions)"/>
      <field name="count" type="Int"/>
      <field name="allObjects" type="[Any]"/>
      <method name="pointer" signature="pointer(at: Int)">
        <return type="UnsafeMutableRawPointer?"/>
      </method>
      <method name="addPointer" signature="addPointer(UnsafeMutableRawPointer?)"/>
      <method name="removePointer" signature="removePointer(at: Int)"/>
      <method name="insertPointer" signature="insertPointer(UnsafeMutableRawPointer?, at: Int)"/>
      <method name="replacePointer" signature="replacePointer(at: Int, withPointer: UnsafeMutableRawPointer?)"/>
      <method name="compact" signature="compact()"/>
      <field name="pointerFunctions" type="NSPointerFunctions"/>
    </class>


    <class name="NSPurgeableData" supertypes="NSMutableData"/>


    <class name="NSRegularExpression" supertypes="NSObject">
      <constructor name="NSRegularExpression" signature="NSRegularExpression(pattern: String, options: NSRegularExpression.Options = [])"/>
      <field name="pattern" type="String"/>
      <field name="options" type="NSRegularExpression.Options"/>
      <field name="numberOfCaptureGroups" type="Int"/>
      <method name="numberOfMatches" signature="numberOfMatches(in: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange)">
        <return type="Int"/>
      </method>
      <method name="enumerateMatches" signature="enumerateMatches(in: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange, using: (NSTextCheckingResult?, NSRegularExpression.MatchingFlags, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)"/>
      <method name="matches" signature="matches(in: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange)">
        <return type="[NSTextCheckingResult]"/>
      </method>
      <method name="firstMatch" signature="firstMatch(in: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange)">
        <return type="NSTextCheckingResult?"/>
      </method>
      <method name="rangeOfFirstMatch" signature="rangeOfFirstMatch(in: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange)">
        <return type="NSRange"/>
      </method>
      <method name="replaceMatches" signature="replaceMatches(in: NSMutableString, options: NSRegularExpression.MatchingOptions = [], range: NSRange, withTemplate: String)">
        <return type="Int"/>
      </method>
      <method name="stringByReplacingMatches" signature="stringByReplacingMatches(in: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange, withTemplate: String)">
        <return type="String"/>
      </method>
      <method name="replacementString" signature="replacementString(for: NSTextCheckingResult, in: String, offset: Int, template: String)">
        <return type="String"/>
      </method>
    </class>


    <class kind="struct" name="NSSortOptions">
      <field name="concurrent" type="NSSortOptions"/>
      <field name="stable" type="NSSortOptions"/>
      <constructor name="NSSortOptions" signature="NSSortOptions(rawValue: UInt)"/>
    </class>


    <class name="NSSpellServer" supertypes="NSObject">
      <field name="delegate" type="NSSpellServerDelegate?"/>
      <method name="registerLanguage" signature="registerLanguage(String?, byVendor: String?)">
        <return type="Bool"/>
      </method>
      <method name="run" signature="run()"/>
      <method name="isWord" signature="isWord(inUserDictionaries: String, caseSensitive: Bool)">
        <return type="Bool"/>
      </method>
    </class>


    <class kind="protocol" name="NSSpellServerDelegate" supertypes="NSObjectProtocol">
      <method name="spellServer" signature="spellServer(NSSpellServer, check: String, offset: Int, types: NSTextCheckingTypes, options: [String : Any]? = nil, orthography: NSOrthography?, wordCount: UnsafeMutablePointer&lt;Int&gt;)">
        <return type="[NSTextCheckingResult]?"/>
      </method>
      <method name="spellServer" signature="spellServer(NSSpellServer, suggestGuessesForWord: String, inLanguage: String)">
        <return type="[String]?"/>
      </method>
      <method name="spellServer" signature="spellServer(NSSpellServer, checkGrammarIn: String, language: String?, details: AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?)">
        <return type="NSRange"/>
      </method>
      <method name="spellServer" signature="spellServer(NSSpellServer, findMisspelledWordIn: String, language: String, wordCount: UnsafeMutablePointer&lt;Int&gt;, countOnly: Bool)">
        <return type="NSRange"/>
      </method>
      <method name="spellServer" signature="spellServer(NSSpellServer, didForgetWord: String, inLanguage: String)"/>
      <method name="spellServer" signature="spellServer(NSSpellServer, didLearnWord: String, inLanguage: String)"/>
      <method name="spellServer" signature="spellServer(NSSpellServer, suggestCompletionsForPartialWordRange: NSRange, in: String, language: String)">
        <return type="[String]?"/>
      </method>
      <method name="spellServer" signature="spellServer(NSSpellServer, recordResponse: Int, toCorrection: String, forWord: String, language: String)"/>
    </class>


    <class name="NSTextCheckingResult" supertypes="NSObject">
      <field name="range" type="NSRange"/>
      <field name="resultType" type="NSTextCheckingResult.CheckingType"/>
      <field name="numberOfRanges" type="Int"/>
      <method name="range" signature="range(at: Int)">
        <return type="NSRange"/>
      </method>
      <field name="replacementString" type="String?"/>
      <field name="regularExpression" type="NSRegularExpression?"/>
      <field name="components" type="String]?"/>
      <field name="url" type="URL?"/>
      <field name="addressComponents" type="String]?"/>
      <field name="phoneNumber" type="String?"/>
      <field name="date" type="Date?"/>
      <field name="duration" type="TimeInterval"/>
      <field name="timeZone" type="TimeZone?"/>
      <field name="orthography" type="NSOrthography?"/>
      <field name="grammarDetails" type="Any]]?"/>
      <method name="adjustingRanges" signature="adjustingRanges(offset: Int)">
        <return type="NSTextCheckingResult"/>
      </method>
      <field name="alternativeStrings" type="[String]?"/>
      <method name="range" signature="range(withName: String)"/>
    </class>


    <class name="NumberFormatter" supertypes="NSFormatter">
      <field name="formatterBehavior" type="NumberFormatter.Behavior"/>
      <field name="numberStyle" type="NumberFormatter.Style"/>
      <field name="generatesDecimalNumbers" type="Bool"/>
      <method name="getObjectValue" signature="getObjectValue(AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;?, for: String, range: UnsafeMutablePointer&lt;NSRange&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="number" signature="number(from: String)">
        <return type="NSNumber?"/>
      </method>
      <method name="string" signature="string(from: NSNumber)">
        <return type="String?"/>
      </method>
      <field name="localizesFormat" type="Bool"/>
      <field name="locale" type="Locale!"/>
      <field name="roundingBehavior" type="NSDecimalNumberHandler"/>
      <field name="roundingIncrement" type="NSNumber!"/>
      <field name="roundingMode" type="NumberFormatter.RoundingMode"/>
      <field name="format" type="String"/>
      <field name="formattingContext" type="Formatter.Context"/>
      <field name="formatWidth" type="Int"/>
      <field name="negativeFormat" type="String!"/>
      <field name="positiveFormat" type="String!"/>
      <field name="multiplier" type="NSNumber?"/>
      <field name="percentSymbol" type="String!"/>
      <field name="perMillSymbol" type="String!"/>
      <field name="minusSign" type="String!"/>
      <field name="plusSign" type="String!"/>
      <field name="exponentSymbol" type="String!"/>
      <field name="zeroSymbol" type="String?"/>
      <field name="nilSymbol" type="String"/>
      <field name="notANumberSymbol" type="String!"/>
      <field name="negativeInfinitySymbol" type="String"/>
      <field name="positiveInfinitySymbol" type="String"/>
      <field name="currencySymbol" type="String!"/>
      <field name="currencyCode" type="String!"/>
      <field name="internationalCurrencySymbol" type="String!"/>
      <field name="currencyGroupingSeparator" type="String!"/>
      <field name="positivePrefix" type="String!"/>
      <field name="positiveSuffix" type="String!"/>
      <field name="negativePrefix" type="String!"/>
      <field name="negativeSuffix" type="String!"/>
      <field name="textAttributesForNegativeValues" type="Any]?"/>
      <field name="textAttributesForPositiveValues" type="Any]?"/>
      <field name="attributedStringForZero" type="NSAttributedString"/>
      <field name="textAttributesForZero" type="Any]?"/>
      <field name="attributedStringForNil" type="NSAttributedString"/>
      <field name="textAttributesForNil" type="Any]?"/>
      <field name="attributedStringForNotANumber" type="NSAttributedString"/>
      <field name="textAttributesForNotANumber" type="Any]?"/>
      <field name="textAttributesForPositiveInfinity" type="Any]?"/>
      <field name="textAttributesForNegativeInfinity" type="Any]?"/>
      <field name="groupingSeparator" type="String!"/>
      <field name="usesGroupingSeparator" type="Bool"/>
      <field name="thousandSeparator" type="String!"/>
      <field name="hasThousandSeparators" type="Bool"/>
      <field name="decimalSeparator" type="String!"/>
      <field name="alwaysShowsDecimalSeparator" type="Bool"/>
      <field name="currencyDecimalSeparator" type="String!"/>
      <field name="groupingSize" type="Int"/>
      <field name="secondaryGroupingSize" type="Int"/>
      <field name="paddingCharacter" type="String!"/>
      <field name="paddingPosition" type="NumberFormatter.PadPosition"/>
      <field name="allowsFloats" type="Bool"/>
      <field name="minimum" type="NSNumber?"/>
      <field name="maximum" type="NSNumber?"/>
      <field name="minimumIntegerDigits" type="Int"/>
      <field name="maximumIntegerDigits" type="Int"/>
      <field name="minimumFractionDigits" type="Int"/>
      <field name="maximumFractionDigits" type="Int"/>
      <field name="usesSignificantDigits" type="Bool"/>
      <field name="minimumSignificantDigits" type="Int"/>
      <field name="maximumSignificantDigits" type="Int"/>
      <field name="isLenient" type="Bool"/>
      <field name="isPartialStringValidationEnabled" type="Bool"/>
    </class>


    <class name="Scanner" supertypes="NSObject">
      <constructor name="Scanner" signature="Scanner(string: String)"/>
      <field name="string" type="String"/>
      <field name="scanLocation" type="Int"/>
      <field name="caseSensitive" type="Bool"/>
      <field name="charactersToBeSkipped" type="CharacterSet?"/>
      <field name="locale" type="Any?"/>
      <method name="scanCharacters" signature="scanCharacters(from: CharacterSet, into: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanUpToCharacters" signature="scanUpToCharacters(from: CharacterSet, into: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanDecimal" signature="scanDecimal(UnsafeMutablePointer&lt;Decimal&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanDouble" signature="scanDouble(UnsafeMutablePointer&lt;Double&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanFloat" signature="scanFloat(UnsafeMutablePointer&lt;Float&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanHexDouble" signature="scanHexDouble(UnsafeMutablePointer&lt;Double&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanHexFloat" signature="scanHexFloat(UnsafeMutablePointer&lt;Float&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanHexInt32" signature="scanHexInt32(UnsafeMutablePointer&lt;UInt32&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanHexInt64" signature="scanHexInt64(UnsafeMutablePointer&lt;UInt64&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanInt" signature="scanInt(UnsafeMutablePointer&lt;Int&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanInt32" signature="scanInt32(UnsafeMutablePointer&lt;Int32&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanInt64" signature="scanInt64(UnsafeMutablePointer&lt;Int64&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanString" signature="scanString(String, into: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanUnsignedLongLong" signature="scanUnsignedLongLong(UnsafeMutablePointer&lt;UInt64&gt;?)">
        <return type="Bool"/>
      </method>
      <method name="scanUpTo" signature="scanUpTo(String, into: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?)">
        <return type="Bool"/>
      </method>
      <field name="isAtEnd" type="Bool"/>
    </class>


    <class kind="struct" name="TimeZone">
      <field name="autoupdatingCurrent" type="TimeZone"/>
      <field name="current" type="TimeZone"/>
      <constructor name="TimeZone" signature="TimeZone?(identifier: String)"/>
      <constructor name="TimeZone" signature="TimeZone?(abbreviation: String)"/>
      <constructor name="TimeZone" signature="TimeZone?(secondsFromGMT: Int)"/>
      <field name="knownTimeZoneIdentifiers" type="[String]"/>
      <field name="abbreviationDictionary" type="String]"/>
      <field name="identifier" type="String"/>
      <method name="abbreviation" signature="abbreviation(for: Date)"/>
      <method name="secondsFromGMT" signature="secondsFromGMT(for: Date)"/>
      <field name="timeZoneDataVersion" type="String"/>
      <method name="isDaylightSavingTime" signature="isDaylightSavingTime(for: Date)"/>
      <method name="daylightSavingTimeOffset" signature="daylightSavingTimeOffset(for: Date)"/>
      <field name="nextDaylightSavingTimeTransition" type="Date?"/>
      <method name="nextDaylightSavingTimeTransition" signature="nextDaylightSavingTimeTransition(after: Date)">
        <return type="Date?"/>
      </method>
      <method name="!=" signature="!=(TimeZone, TimeZone)"/>
      <method name="==" signature="==(TimeZone, TimeZone)"/>
      <method name="localizedName" signature="localizedName(for: NSTimeZone.NameStyle, locale: Locale?)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <constructor name="TimeZone" signature="TimeZone(from: Decoder)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
    </class>


    <class kind="struct" name="URL">
      <property name="bridgeTypes" value="Foundation.NSURL"/>
      <constructor name="URL" signature="URL?(string: String)"/>
      <constructor name="URL" signature="URL?(string: String, relativeTo: URL?)"/>
      <constructor name="URL" signature="URL(fileURLWithPath: String)">
        <tags>hardcoded_path:fileURLWithPath</tags>
        <parameters>
          <param name="fileURLWithPath" type="String"/>
        </parameters>
        <sink paramNames="fileURLWithPath" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="URL" signature="URL(fileURLWithPath: String, isDirectory: Bool)">
        <tags>hardcoded_path:fileURLWithPath</tags>
        <parameters>
          <param name="fileURLWithPath" type="String"/>
          <param name="isDirectory" type="Bool"/>
        </parameters>
        <sink paramNames="fileURLWithPath" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="URL" signature="URL(fileURLWithPath: String, isDirectory: Bool, relativeTo: URL?)">
        <tags>hardcoded_path:fileURLWithPath</tags>
        <parameters>
          <param name="fileURLWithPath" type="String"/>
          <param name="isDirectory" type="Bool"/>
          <param name="relativeTo" type="URL?"/>
        </parameters>
        <sink paramNames="fileURLWithPath" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="URL" signature="URL(fileURLWithPath: String, relativeTo: URL?)">
        <tags>hardcoded_path:fileURLWithPath</tags>
        <parameters>
          <param name="fileURLWithPath" type="String"/>
          <param name="relativeTo" type="URL?"/>
        </parameters>
        <sink paramNames="fileURLWithPath" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="URL" signature="URL(fileURLWithFileSystemRepresentation: UnsafePointer&lt;Int8&gt;, isDirectory: Bool, relativeTo: URL?)">
        <tags>hardcoded_path:fileURLWithFileSystemRepresentation</tags>
        <parameters>
          <param name="fileURLWithFileSystemRepresentation" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="isDirectory" type="Bool"/>
          <param name="relativeTo" type="URL?"/>
        </parameters>
        <sink paramNames="fileURLWithFileSystemRepresentation" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="URL" signature="URL(fileReferenceLiteralResourceName: String)"/>
      <constructor name="URL" signature="URL?(resolvingBookmarkData: Data, options: URL.BookmarkResolutionOptions, relativeTo: URL?, bookmarkDataIsStale: inout Bool)"/>
      <constructor name="URL" signature="URL(resolvingAliasFileAt: URL, options: URL.BookmarkResolutionOptions)"/>
      <constructor name="URL" signature="URL(from: Decoder)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
      <constructor name="URL" signature="URL?(dataRepresentation: Data, relativeTo: URL?, isAbsolute: Bool)"/>
      <field name="dataRepresentation" type="Data"/>
      <field name="absoluteString" type="String"/>
      <field name="absoluteURL" type="URL"/>
      <field name="baseURL" type="URL?"/>
      <field name="fragment" type="String?"/>
      <field name="host" type="String?">
        <sink argpos="-1" kind="resource_injection" resource="database" />
      </field>
      <field name="lastPathComponent" type="String"/>
      <field name="path" type="String"/>
      <field name="pathComponents" type="[String]"/>
      <field name="pathExtension" type="String"/>
      <field name="port" type="Int?"/>
      <field name="query" type="String?"/>
      <field name="relativePath" type="String"/>
      <field name="relativeString" type="String"/>
      <field name="scheme" type="String?"/>
      <field name="standardized" type="URL"/>
      <field name="standardizedFileURL" type="URL"/>
      <field name="user" type="String?"/>
      <field name="password" type="String?"/>
      <method name="resourceValues" signature="resourceValues(forKeys: Set&lt;URLResourceKey&gt;)"/>
      <method name="setResourceValues" signature="setResourceValues(URLResourceValues)"/>
      <method name="removeCachedResourceValue" signature="removeCachedResourceValue(forKey: URLResourceKey)"/>
      <method name="removeAllCachedResourceValues" signature="removeAllCachedResourceValues()"/>
      <method name="setTemporaryResourceValue" signature="setTemporaryResourceValue(Any, forKey: URLResourceKey)"/>
      <field name="isFileURL" type="Bool"/>
      <field name="hasDirectoryPath" type="Bool"/>
      <method name="withUnsafeFileSystemRepresentation" signature="withUnsafeFileSystemRepresentation&lt;ResultType&gt;((UnsafePointer&lt;Int8&gt;?) -&gt; ResultType)"/>
      <method name="resolveSymlinksInPath" signature="resolveSymlinksInPath()"/>
      <method name="resolvingSymlinksInPath" signature="resolvingSymlinksInPath()"/>
      <method name="standardize" signature="standardize()"/>
      <method name="appendPathComponent" signature="appendPathComponent(String)"/>
      <method name="appendPathComponent" signature="appendPathComponent(String, isDirectory: Bool)"/>
      <method name="appendingPathComponent" signature="appendingPathComponent(String)"/>
      <method name="appendingPathComponent" signature="appendingPathComponent(String, isDirectory: Bool)"/>
      <method name="appendPathExtension" signature="appendPathExtension(String)"/>
      <method name="appendingPathExtension" signature="appendingPathExtension(String)"/>
      <method name="deleteLastPathComponent" signature="deleteLastPathComponent()"/>
      <method name="deletingLastPathComponent" signature="deletingLastPathComponent()"/>
      <method name="deletePathExtension" signature="deletePathExtension()"/>
      <method name="deletingPathExtension" signature="deletingPathExtension()"/>
      <method name="bookmarkData" signature="bookmarkData(options: URL.BookmarkCreationOptions, includingResourceValuesForKeys: Set&lt;URLResourceKey&gt;?, relativeTo: URL?)"/>
      <method name="bookmarkData" signature="bookmarkData(withContentsOf: URL)">
        <tags>hardcoded_path:withContentsOf</tags>
        <parameters>
          <param type="String" name="withContentsOf"/>
        </parameters>
        <source paramNames="withContentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="withContentsOf" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="writeBookmarkData" signature="writeBookmarkData(Data, to: URL)"/>
      <method name="resourceValues" signature="resourceValues(forKeys: Set&lt;URLResourceKey&gt;, fromBookmarkData: Data)"/>
      <method name="checkResourceIsReachable" signature="checkResourceIsReachable()"/>
      <method name="checkPromisedItemIsReachable" signature="checkPromisedItemIsReachable()"/>
      <method name="promisedItemResourceValues" signature="promisedItemResourceValues(forKeys: Set&lt;URLResourceKey&gt;)"/>
      <method name="startAccessingSecurityScopedResource" signature="startAccessingSecurityScopedResource()"/>
      <method name="stopAccessingSecurityScopedResource" signature="stopAccessingSecurityScopedResource()"/>
      <method name="!=" signature="!=(URL, URL)"/>
      <method name="==" signature="==(URL, URL)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customPlaygroundQuickLook" type="PlaygroundQuickLook"/>
      <field name="hashValue" type="Int"/>
    </class>


    <class kind="struct" name="URLComponents">
      <constructor name="URLComponents" signature="URLComponents()"/>
      <constructor name="URLComponents" signature="URLComponents?(string: String)"/>
      <constructor name="URLComponents" signature="URLComponents?(url: URL, resolvingAgainstBaseURL: Bool)"/>
      <field name="url" type="URL?"/>
      <method name="url" signature="url(relativeTo: URL?)"/>
      <field name="string" type="String?"/>
      <field name="fragment" type="String?"/>
      <field name="host" type="String?">
        <sink argpos="-1" kind="resource_injection" resource="database" />
      </field>
      <field name="password" type="String?"/>
      <field name="path" type="String"/>
      <field name="port" type="Int?"/>
      <field name="query" type="String?"/>
      <field name="queryItems" type="[URLQueryItem]?"/>
      <field name="scheme" type="String?"/>
      <field name="user" type="String?"/>
      <field name="percentEncodedFragment" type="String?"/>
      <field name="percentEncodedHost" type="String?"/>
      <field name="percentEncodedPassword" type="String?"/>
      <field name="percentEncodedPath" type="String"/>
      <field name="percentEncodedQuery" type="String?"/>
      <field name="percentEncodedUser" type="String?"/>
      <field name="rangeOfFragment" type="Range&lt;String.Index&gt;?"/>
      <field name="rangeOfHost" type="Range&lt;String.Index&gt;?"/>
      <field name="rangeOfPassword" type="Range&lt;String.Index&gt;?"/>
      <field name="rangeOfPath" type="Range&lt;String.Index&gt;?"/>
      <field name="rangeOfPort" type="Range&lt;String.Index&gt;?"/>
      <field name="rangeOfQuery" type="Range&lt;String.Index&gt;?"/>
      <field name="rangeOfScheme" type="Range&lt;String.Index&gt;?"/>
      <field name="rangeOfUser" type="Range&lt;String.Index&gt;?"/>
      <method name="!=" signature="!=(URLComponents, URLComponents)"/>
      <method name="==" signature="==(URLComponents, URLComponents)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
    </class>


    <class kind="struct" name="URLQueryItem">
      <constructor name="URLQueryItem" signature="URLQueryItem(name: String, value: String?)"/>
      <field name="name" type="String"/>
      <field name="value" type="String?"/>
      <method name="!=" signature="!=(URLQueryItem, URLQueryItem)"/>
      <method name="==" signature="==(URLQueryItem, URLQueryItem)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
    </class>


    <class kind="struct" name="UUID">
      <constructor name="UUID" signature="UUID()"/>
      <constructor name="UUID" signature="UUID(uuid: uuid_t)"/>
      <constructor name="UUID" signature="UUID?(uuidString: String)"/>
      <field name="uuid" type="uuid_t"/>
      <field name="uuidString" type="String"/>
      <method name="!=" signature="!=(UUID, UUID)"/>
      <method name="==" signature="==(UUID, UUID)"/>
      <field name="description" type="String"/>
      <field name="debugDescription" type="String"/>
      <field name="customMirror" type="Mirror"/>
      <field name="hashValue" type="Int"/>
      <constructor name="UUID" signature="UUID(from: Decoder)"/>
      <method name="encode" signature="encode(to: Encoder)"/>
    </class>


    <class name="HTTPCookie">
      <constructor name="HTTPCookie" signature="HTTPCookie(properties: [HTTPCookiePropertyKey : Any])">
        <parameters>
          <param type="Dictionary" name="properties"/>
        </parameters>
        <sink paramNames="properties" kind="cookie_plaintext_storage" resource="network" />
      </constructor>
      <constructor name="cookies" signature="cookies(withResponseHeaderFields: [String : String], for: URL) -> [HTTPCookie]" >
        <parameters>
          <param type="Dictionary" name="withResponseHeaderFields"/>
        </parameters>
        <sink paramNames="withResponseHeaderFields" kind="cookie_plaintext_storage" resource="network" />
      </constructor>
    </class>

    <class name="HTTPCookiePropertyKey" kind="struct">
      <field name="discard" type="NSString"/>
      <field name="domain" type="NSString"/>
      <field name="path" type="NSString"/>
      <field name="value" type="NSString"/>
      <field name="name" type="NSString"/>
      <field name="secure" type="NSString"/>
      <field name="maximumAge" type="NSString"/>
    </class>

    <class name="HTTPCookieStorage">
      <field name="shared" type="Foundation.HTTPCookieStorage"/>

      <method name="setCookie" signature="setCookie(HTTPCookie)" >
        <parameters>
          <param type="HTTPCookie" />
        </parameters>
        <return type="Void" />
        <propagate from="0" to="-1"/>
      </method>
    </class>

    <class name="NSPredicate">
      <constructor name="NSPredicate" signature="NSPredicate(format: String, argumentArray: Array)">
        <parameters>
          <param type="String" name="format"/>
          <param type="Array" name="argumentArray"/>
        </parameters>
        <sink paramNames="format" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="NSPredicate" signature="NSPredicate?(format: String, arguments: CVaListPointer)">
        <parameters>
          <param type="String" name="format"/>
          <param type="CVaListPointer" name="arguments"/>
        </parameters>
        <sink paramNames="format" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="NSPredicate" signature="NSPredicate(format: String, CVarArg)">
        <parameters>
          <param type="String" name="format"/>
          <param type="CVarArg"/>
        </parameters>
        <sink paramNames="format" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="NSPredicate" signature="NSPredicate(value: Bool)" match="fullsignature">
        <parameters>
          <param type="Bool" name="value"/>
        </parameters>
      </constructor>
      <constructor name="NSPredicate" signature="NSPredicate?(block: (Any?, [String : Any]?) -> Bool))" match="fullsignature">
        <parameters>
          <param type="(Any?, [String : Any]?) -> Bool)" name="block"/>
        </parameters>
      </constructor>
      <constructor name="NSPredicate" signature="NSPredicate?(fromMetadataQueryString: String)">
        <parameters>
          <param type="String" name="fromMetadataQueryString"/>
        </parameters>
        <sink paramNames="format" kind="format_injection" resource="other" />
      </constructor>
    </class>

    <class name="NSRegularExpression">
      <constructor name="NSRegularExpression" signature="NSRegularExpression(pattern: String, options: NSRegularExpression.options)">
        <parameters>
          <param type="String" name="pattern"/>
          <param type="NSRegularExpression.options" name="options"/>
        </parameters>
        <sink paramNames="pattern" kind="regex_dos" resource="other" />
      </constructor>

      <method name="matches" signature="matches(in: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange)" >
        <parameters>
          <param type="String" name="in"/>
          <param type="NSRegularExpression.MatchingOptions" name="options"/>
          <param type="NSRange" name="range"/>
        </parameters>
        <return type="Array"/>
        <neutralization paramNames="in" kind="string" resource="other"/>
        <propagate from="0" to="-2"/>
      </method>
    </class>

    <class name="NSString" supertypes="NSObject">
      <constructor name="NSString" signature="NSString()"/>
      <constructor name="NSString" signature="NSString?(bytes: UnsafeRawPointer, length: Int, encoding: UInt)">
        <parameters>
          <param name="bytes" type="UnsafeRawPointer"/>
          <param name="length" type="Int"/>
          <param name="encoding" type="UInt"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString?(bytesNoCopy: UnsafeMutableRawPointer, length: Int, encoding: UInt, freeWhenDone: Bool)">
        <parameters>
          <param name="bytesNoCopy" type="UnsafeMutableRawPointer"/>
          <param name="length" type="Int"/>
          <param name="encoding" type="UInt"/>
          <param name="freeWhenDone" type="Bool"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString(characters: UnsafePointer&lt;unichar&gt;, length: Int)">
        <parameters>
          <param name="characters" type="UnsafePointer&lt;unichar&gt;"/>
          <param name="length" type="Int"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString(charactersNoCopy: UnsafeMutablePointer&lt;unichar&gt;, length: Int, freeWhenDone: Bool)">
        <parameters>
          <param name="charactersNoCopy" type="UnsafeMutablePointer&lt;unichar&gt;"/>
          <param name="length" type="Int"/>
          <param name="freeWhenDone" type="Bool"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString(string: String)">
        <parameters>
          <param name="string" type="String"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString?(cString: UnsafePointer&lt;Int8&gt;, encoding: UInt)">
        <parameters>
          <param name="cString" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="encoding" type="UInt"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString?(utf8String: UnsafePointer&lt;Int8&gt;)">
        <parameters>
          <param name="utf8String" type="UnsafePointer&lt;Int8&gt;"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString(format: String, arguments: CVaListPointer)">
        <parameters>
          <param name="format" type="String"/>
          <param name="arguments" type="CVaListPointer"/>
        </parameters>
        <sink argpos="2" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="NSString" signature="NSString(format: String, locale: Any?, arguments: CVaListPointer)">
        <parameters>
          <param name="format" type="String"/>
          <param name="locale" type="Any?"/>
          <param name="arguments" type="CVaListPointer"/>
        </parameters>
        <sink argpos="2" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="NSString" signature="NSString(data: Data, encoding: UInt))">
        <parameters>
          <param type="Data" name="data"/>
          <param type="UInt" name="encoding"/>
        </parameters>
        <sink argpos="0" kind="encoding_buffer_overflow" />
      </constructor>
      <constructor name="NSString" signature="NSString(contentsOfFile: String, encoding: UInt)">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param type="String" name="contentsOfFile"/>
          <param type="UInt" name="encoding"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink argpos="0" paramNames="contentsOfFile" kind="encoding_buffer_overflow" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSString" signature="NSString(contentsOfFile: String, usedEncoding: UnsafeMutablePointer&lt;UInt&gt;?))">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param type="String" name="contentsOfFile"/>
          <param type="UnsafeMutablePointer" name="usedEncoding"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOfFile" kind="encoding_buffer_overflow" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSString" signature="NSString(contentsOf: URL, encoding: UInt)">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param name="contentsOf" type="URL"/>
          <param name="encoding" type="UInt"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="encoding_buffer_overflow" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSString" signature="NSString(contentsOf: URL, usedEncoding: UnsafeMutablePointer&lt;UInt&gt;?)">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param name="contentsOf" type="URL"/>
          <param name="usedEncoding" type="UnsafeMutablePointer&lt;UInt&gt;?"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="encoding_buffer_overflow" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSString" signature="NSString?(cString: UnsafePointer&lt;Int8&gt;)">
        <parameters>
          <param name="cString" type="UnsafePointer&lt;Int8&gt;"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString?(cString: UnsafePointer&lt;Int8&gt;, length: Int)">
        <parameters>
          <param name="cString" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="length" type="Int"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString?(cStringNoCopy: UnsafeMutablePointer&lt;Int8&gt;, length: Int, freeWhenDone: Bool)">
        <parameters>
          <param name="cStringNoCopy" type="UnsafeMutablePointer&lt;Int8&gt;"/>
          <param name="length" type="Int"/>
          <param name="freeWhenDone" type="Bool"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString?(contentsOfFile: String)">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param name="contentsOfFile" type="String"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOfFile" kind="encoding_buffer_overflow" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSString" signature="NSString?(contentsOf: URL)">
        <tags>hardcoded_path:contentsOf</tags>
        <parameters>
          <param name="contentsOf" type="URL"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="encoding_buffer_overflow" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSString" signature="NSString?(coder: NSCoder)">
        <parameters>
          <param name="coder" type="NSCoder"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString(format: NSString, CVarArg...)">
        <parameters>
          <param name="format" type="NSString"/>
          <param name="" type="CVarArg..."/>
        </parameters>
        <sink paramNames="format" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="NSString" signature="NSString(format: NSString, locale: Locale?, CVarArg...)">
        <parameters>
          <param name="format" type="NSString"/>
          <param name="locale" type="Locale?"/>
          <param name="" type="CVarArg..."/>
        </parameters>
        <sink paramNames="format" kind="format_injection" resource="other" />
      </constructor>
      <constructor name="NSString" signature="NSString(string: NSString)">
        <parameters>
          <param name="string" type="NSString"/>
        </parameters>
      </constructor>
      <constructor name="NSString" signature="NSString(stringLiteral: StaticString)">
        <parameters>
          <param name="stringLiteral" type="StaticString"/>
        </parameters>
      </constructor>
      <field name="abbreviatingWithTildeInPath" type="String"/>
      <method name="addingPercentEncoding" signature="addingPercentEncoding(withAllowedCharacters: CharacterSet)">
        <parameters>
          <param name="withAllowedCharacters" type="CharacterSet"/>
        </parameters>
        <return type="String?"/>
      </method>
      <method name="addingPercentEscapes" signature="addingPercentEscapes(using: UInt)">
        <parameters>
          <param name="using" type="UInt"/>
        </parameters>
        <return type="String?"/>
      </method>
      <field name="allowLossyKey" type="StringEncodingDetectionOptionsKey"/>
      <method name="appending" signature="appending(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="appendingFormat" signature="appendingFormat(NSString, CVarArg...)">
        <parameters>
          <param name="" type="NSString"/>
          <param name="" type="CVarArg..."/>
        </parameters>
        <sink argpos="0" paramNames="format" kind="format_injection" resource="other" />
      </method>
      <method name="appendingPathComponent" signature="appendingPathComponent(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="appendingPathExtension" signature="appendingPathExtension(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="String?"/>
      </method>
      <method name="applyingTransform" signature="applyingTransform(StringTransform, reverse: Bool)">
        <parameters>
          <param name="" type="StringTransform"/>
          <param name="reverse" type="Bool"/>
        </parameters>
      </method>
      <field name="availableStringEncodings" type="UnsafePointer&lt;UInt&gt;"/>
      <field name="boolValue" type="Bool"/>
      <method name="boundingRect" signature="boundingRect(with: CGSize, options: NSStringDrawingOptions = [], attributes: [NSAttributedStringKey : Any]? = nil, context: NSStringDrawingContext?)">
        <parameters>
          <param name="with" type="CGSize"/>
          <param name="options" type="NSStringDrawingOptions = []"/>
          <param name="" type="attributes"/>
          <param name="context" type="NSStringDrawingContext?"/>
        </parameters>
        <return type="CGRect"/>
      </method>
      <method name="boundingRect" signature="boundingRect(with: NSSize, options: NSString.DrawingOptions = [], attributes: [NSAttributedStringKey : Any]? = nil)">
        <parameters>
          <param name="with" type="NSSize"/>
          <param name="options" type="NSString.DrawingOptions = []"/>
          <param name="" type="attributes"/>
        </parameters>
        <return type="NSRect"/>
      </method>
      <method name="cString" signature="cString(using: UInt)">
        <parameters>
          <param name="using" type="UInt"/>
        </parameters>
        <return type="UnsafePointer&lt;Int8&gt;?"/>
      </method>
      <method name="cString" signature="cString()"/>
      <method name="cStringLength" signature="cStringLength()"/>
      <method name="canBeConverted" signature="canBeConverted(to: UInt)">
        <parameters>
          <param name="to" type="UInt"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="capitalized" type="String"/>
      <method name="capitalized" signature="capitalized(with: Locale?)">
        <parameters>
          <param name="with" type="Locale?"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="caseInsensitiveCompare" signature="caseInsensitiveCompare(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="ComparisonResult"/>
      </method>
      <method name="character" signature="character(at: Int)">
        <parameters>
          <param name="at" type="Int"/>
        </parameters>
        <return type="unichar"/>
      </method>
      <field name="characterConversionException" type="NSExceptionName"/>
      <method name="commonPrefix" signature="commonPrefix(with: String, options: NSString.CompareOptions = [])">
        <parameters>
          <param name="with" type="String"/>
          <param name="options" type="NSString.CompareOptions = []"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="compare" signature="compare(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="ComparisonResult"/>
      </method>
      <method name="compare" signature="compare(String, options: NSString.CompareOptions = [])">
        <parameters>
          <param name="" type="String"/>
          <param name="options" type="NSString.CompareOptions = []"/>
        </parameters>
        <return type="ComparisonResult"/>
      </method>
      <method name="compare" signature="compare(String, options: NSString.CompareOptions = [], range: NSRange)">
        <parameters>
          <param name="" type="String"/>
          <param name="options" type="NSString.CompareOptions = []"/>
          <param name="range" type="NSRange"/>
        </parameters>
        <return type="ComparisonResult"/>
      </method>
      <method name="compare" signature="compare(String, options: NSString.CompareOptions = [], range: NSRange, locale: Any?)">
        <parameters>
          <param name="" type="String"/>
          <param name="options" type="NSString.CompareOptions = []"/>
          <param name="range" type="NSRange"/>
          <param name="locale" type="Any?"/>
        </parameters>
        <return type="ComparisonResult"/>
      </method>
      <method name="completePath" signature="completePath(into: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?, caseSensitive: Bool, matchesInto: AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?, filterTypes: [String]?)">
        <parameters>
          <param name="into" type="AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?"/>
          <param name="caseSensitive" type="Bool"/>
          <param name="matchesInto" type="AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?"/>
          <param name="filterTypes" type="[String]?"/>
        </parameters>
        <return type="Int"/>
      </method>
      <method name="components" signature="components(separatedBy: String)">
        <parameters>
          <param name="separatedBy" type="String"/>
        </parameters>
        <return type="[String]"/>
      </method>
      <method name="components" signature="components(separatedBy: CharacterSet)">
        <parameters>
          <param name="separatedBy" type="CharacterSet"/>
        </parameters>
        <return type="[String]"/>
      </method>
      <method name="contains" signature="contains(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="customPlaygroundQuickLook" type="PlaygroundQuickLook"/>
      <method name="data" signature="data(using: UInt)">
        <parameters>
          <param name="using" type="UInt"/>
        </parameters>
        <return type="Data?"/>
      </method>
      <method name="data" signature="data(using: UInt)" >
        <parameters>
          <param type="UInt" name="using" />
        </parameters>
        <return type="Foundation.NSData" />
        <sink argpos="-1" kind="encoding_buffer_overflow" />
      </method>
      <method name="data" signature="data(using: UInt, allowLossyConversion: Bool)" >
        <parameters>
          <param type="UInt" name="using" />
          <param type="Bool" name="allowLossyConversion" />
        </parameters>
        <return type="Foundation.NSData" />
      </method>
      <field name="decomposedStringWithCanonicalMapping" type="String"/>
      <field name="decomposedStringWithCompatibilityMapping" type="String"/>
      <field name="defaultCStringEncoding" type="UInt"/>
      <field name="deletingLastPathComponent" type="String"/>
      <field name="deletingPathExtension" type="String"/>
      <field name="description" type="String"/>
      <field name="disallowedEncodingsKey" type="StringEncodingDetectionOptionsKey"/>
      <field name="doubleValue" type="Double"/>
      <method name="draw" signature="draw(at: CGPoint, withAttributes: [NSAttributedStringKey : Any]? = nil)">
        <parameters>
          <param name="at" type="CGPoint"/>
          <param name="" type="withAttributes"/>
        </parameters>
      </method>
      <method name="draw" signature="draw(in: CGRect, withAttributes: [NSAttributedStringKey : Any]? = nil)">
        <parameters>
          <param name="in" type="CGRect"/>
          <param name="" type="withAttributes"/>
        </parameters>
      </method>
      <method name="draw" signature="draw(with: CGRect, options: NSStringDrawingOptions = [], attributes: [NSAttributedStringKey : Any]? = nil, context: NSStringDrawingContext?)">
        <parameters>
          <param name="with" type="CGRect"/>
          <param name="options" type="NSStringDrawingOptions = []"/>
          <param name="" type="attributes"/>
          <param name="context" type="NSStringDrawingContext?"/>
        </parameters>
      </method>
      <method name="draw" signature="draw(with: NSRect, options: NSString.DrawingOptions = [], attributes: [NSAttributedStringKey : Any]? = nil)">
        <parameters>
          <param name="with" type="NSRect"/>
          <param name="options" type="NSString.DrawingOptions = []"/>
          <param name="" type="attributes"/>
        </parameters>
      </method>
      <method name="enumerateLines" signature="enumerateLines((String, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)">
        <parameters>
          <param name="" type="(String"/>
          <param name="" type="UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void"/>
        </parameters>
      </method>
      <method name="enumerateLinguisticTags" signature="enumerateLinguisticTags(in: NSRange, scheme: NSLinguisticTagScheme, options: NSLinguisticTagger.Options = [], orthography: NSOrthography?, using: (NSLinguisticTag?, NSRange, NSRange, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)">
        <parameters>
          <param name="in" type="NSRange"/>
          <param name="scheme" type="NSLinguisticTagScheme"/>
          <param name="options" type="NSLinguisticTagger.Options = []"/>
          <param name="orthography" type="NSOrthography?"/>
          <param name="using" type="(NSLinguisticTag?"/>
          <param name="" type="NSRange"/>
          <param name="" type="NSRange"/>
          <param name="" type="UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void"/>
        </parameters>
      </method>
      <method name="enumerateSubstrings" signature="enumerateSubstrings(in: NSRange, options: NSString.EnumerationOptions = [], using: (String?, NSRange, NSRange, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)">
        <parameters>
          <param name="in" type="NSRange"/>
          <param name="options" type="NSString.EnumerationOptions = []"/>
          <param name="using" type="(String?"/>
          <param name="" type="NSRange"/>
          <param name="" type="NSRange"/>
          <param name="" type="UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void"/>
        </parameters>
      </method>
      <field name="expandingTildeInPath" type="String"/>
      <field name="fastestEncoding" type="UInt"/>
      <field name="fileSystemRepresentation" type="UnsafePointer&lt;Int8&gt;"/>
      <field name="floatValue" type="Float"/>
      <method name="folding" signature="folding(options: NSString.CompareOptions = [], locale: Locale?)">
        <parameters>
          <param name="options" type="NSString.CompareOptions = []"/>
          <param name="locale" type="Locale?"/>
        </parameters>
        <return type="String"/>
      </method>
      <field name="fromWindowsKey" type="StringEncodingDetectionOptionsKey"/>
      <method name="getBytes" signature="getBytes(UnsafeMutableRawPointer?, maxLength: Int, usedLength: UnsafeMutablePointer&lt;Int&gt;?, encoding: UInt, options: NSString.EncodingConversionOptions = [], range: NSRange, remaining: NSRangePointer?)">
        <parameters>
          <param name="" type="UnsafeMutableRawPointer?"/>
          <param name="maxLength" type="Int"/>
          <param name="usedLength" type="UnsafeMutablePointer&lt;Int&gt;?"/>
          <param name="encoding" type="UInt"/>
          <param name="options" type="NSString.EncodingConversionOptions = []"/>
          <param name="range" type="NSRange"/>
          <param name="remaining" type="NSRangePointer?"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="getCString" signature="getCString(UnsafeMutablePointer&lt;Int8&gt;, maxLength: Int, encoding: UInt)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;Int8&gt;"/>
          <param name="maxLength" type="Int"/>
          <param name="encoding" type="UInt"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="getCString" signature="getCString(UnsafeMutablePointer&lt;Int8&gt;)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;Int8&gt;"/>
        </parameters>
      </method>
      <method name="getCString" signature="getCString(UnsafeMutablePointer&lt;Int8&gt;, maxLength: Int)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;Int8&gt;"/>
          <param name="maxLength" type="Int"/>
        </parameters>
      </method>
      <method name="getCString" signature="getCString(UnsafeMutablePointer&lt;Int8&gt;, maxLength: Int, range: NSRange, remaining: NSRangePointer?)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;Int8&gt;"/>
          <param name="maxLength" type="Int"/>
          <param name="range" type="NSRange"/>
          <param name="remaining" type="NSRangePointer?"/>
        </parameters>
      </method>
      <method name="getCharacters" signature="getCharacters(UnsafeMutablePointer&lt;unichar&gt;, range: NSRange)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;unichar&gt;"/>
          <param name="range" type="NSRange"/>
        </parameters>
      </method>
      <method name="getCharacters" signature="getCharacters(UnsafeMutablePointer&lt;unichar&gt;)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;unichar&gt;"/>
        </parameters>
      </method>
      <method name="getFileSystemRepresentation" signature="getFileSystemRepresentation(UnsafeMutablePointer&lt;Int8&gt;, maxLength: Int)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;Int8&gt;"/>
          <param name="maxLength" type="Int"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="getLineStart" signature="getLineStart(UnsafeMutablePointer&lt;Int&gt;?, end: UnsafeMutablePointer&lt;Int&gt;?, contentsEnd: UnsafeMutablePointer&lt;Int&gt;?, for: NSRange)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;Int&gt;?"/>
          <param name="end" type="UnsafeMutablePointer&lt;Int&gt;?"/>
          <param name="contentsEnd" type="UnsafeMutablePointer&lt;Int&gt;?"/>
          <param name="for" type="NSRange"/>
        </parameters>
      </method>
      <method name="getParagraphStart" signature="getParagraphStart(UnsafeMutablePointer&lt;Int&gt;?, end: UnsafeMutablePointer&lt;Int&gt;?, contentsEnd: UnsafeMutablePointer&lt;Int&gt;?, for: NSRange)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;Int&gt;?"/>
          <param name="end" type="UnsafeMutablePointer&lt;Int&gt;?"/>
          <param name="contentsEnd" type="UnsafeMutablePointer&lt;Int&gt;?"/>
          <param name="for" type="NSRange"/>
        </parameters>
      </method>
      <method name="hasPrefix" signature="hasPrefix(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="hasSuffix" signature="hasSuffix(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="hash" type="Int"/>
      <field name="intValue" type="Int32"/>
      <field name="integerValue" type="Int"/>
      <field name="isAbsolutePath" type="Bool"/>
      <method name="isEqual" signature="isEqual(to: String)">
        <parameters>
          <param name="to" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="lastPathComponent" type="String"/>
      <field name="latinToGreek" type="StringTransform"/>
      <field name="length" type="Int"/>
      <method name="lengthOfBytes" signature="lengthOfBytes(using: UInt)">
        <parameters>
          <param name="using" type="UInt"/>
        </parameters>
        <return type="Int"/>
      </method>
      <field name="likelyLanguageKey" type="StringEncodingDetectionOptionsKey"/>
      <method name="lineRange" signature="lineRange(for: NSRange)">
        <parameters>
          <param name="for" type="NSRange"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="linguisticTags" signature="linguisticTags(in: NSRange, scheme: NSLinguisticTagScheme, options: NSLinguisticTagger.Options = [], orthography: NSOrthography?, tokenRanges: AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?)">
        <parameters>
          <param name="in" type="NSRange"/>
          <param name="scheme" type="NSLinguisticTagScheme"/>
          <param name="options" type="NSLinguisticTagger.Options = []"/>
          <param name="orthography" type="NSOrthography?"/>
          <param name="tokenRanges" type="AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?"/>
        </parameters>
        <return type="[NSLinguisticTag]"/>
      </method>
      <field name="localizedCapitalized" type="String"/>
      <method name="localizedCaseInsensitiveCompare" signature="localizedCaseInsensitiveCompare(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="ComparisonResult"/>
      </method>
      <method name="localizedCaseInsensitiveContains" signature="localizedCaseInsensitiveContains(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="localizedCompare" signature="localizedCompare(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="ComparisonResult"/>
      </method>
      <field name="localizedLowercase" type="String"/>
      <method name="localizedName" signature="localizedName(of: UInt)">
        <parameters>
          <param name="of" type="UInt"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="localizedStandardCompare" signature="localizedStandardCompare(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="ComparisonResult"/>
      </method>
      <method name="localizedStandardContains" signature="localizedStandardContains(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="localizedStandardRange" signature="localizedStandardRange(of: String)">
        <parameters>
          <param name="of" type="String"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="localizedStringWithFormat" signature="localizedStringWithFormat(NSString, CVarArg...)">
        <parameters>
          <param name="" type="NSString"/>
          <param name="" type="CVarArg..."/>
        </parameters>
      </method>
      <field name="localizedUppercase" type="String"/>
      <method name="localizedUserNotificationString" signature="localizedUserNotificationString(forKey: String, arguments: [Any]?)">
        <parameters>
          <param name="forKey" type="String"/>
          <param name="arguments" type="[Any]?"/>
        </parameters>
        <return type="String"/>
      </method>
      <field name="longLongValue" type="Int64"/>
      <method name="lossyCString" signature="lossyCString()"/>
      <field name="lossySubstitutionKey" type="StringEncodingDetectionOptionsKey"/>
      <field name="lowercased" type="String"/>
      <method name="lowercased" signature="lowercased(with: Locale?)">
        <parameters>
          <param name="with" type="Locale?"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="maximumLengthOfBytes" signature="maximumLengthOfBytes(using: UInt)">
        <parameters>
          <param name="using" type="UInt"/>
        </parameters>
        <return type="Int"/>
      </method>
      <method name="padding" signature="padding(toLength: Int, withPad: String, startingAt: Int)">
        <parameters>
          <param name="toLength" type="Int"/>
          <param name="withPad" type="String"/>
          <param name="startingAt" type="Int"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="paragraphRange" signature="paragraphRange(for: NSRange)">
        <parameters>
          <param name="for" type="NSRange"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <field name="parseErrorException" type="NSExceptionName"/>
      <method name="path" signature="path(withComponents: [String])">
        <parameters>
          <param name="withComponents" type="[String]"/>
        </parameters>
        <return type="String"/>
      </method>
      <field name="pathComponents" type="[String]"/>
      <field name="pathExtension" type="String"/>
      <field name="precomposedStringWithCanonicalMapping" type="String"/>
      <field name="precomposedStringWithCompatibilityMapping" type="String"/>
      <method name="propertyList" signature="propertyList()">
        <return type="Any"/>
      </method>
      <method name="propertyListFromStringsFileFormat" signature="propertyListFromStringsFileFormat()">
        <return type="[AnyHashable : Any]?"/>
      </method>
      <method name="range" signature="range(of: String)">
        <parameters>
          <param name="of" type="String"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="range" signature="range(of: String, options: NSString.CompareOptions = [])">
        <parameters>
          <param name="of" type="String"/>
          <param name="options" type="NSString.CompareOptions = []"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="range" signature="range(of: String, options: NSString.CompareOptions = [], range: NSRange)">
        <parameters>
          <param name="of" type="String"/>
          <param name="options" type="NSString.CompareOptions = []"/>
          <param name="range" type="NSRange"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="range" signature="range(of: String, options: NSString.CompareOptions = [], range: NSRange, locale: Locale?)">
        <parameters>
          <param name="of" type="String"/>
          <param name="options" type="NSString.CompareOptions = []"/>
          <param name="range" type="NSRange"/>
          <param name="locale" type="Locale?"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="rangeOfCharacter" signature="rangeOfCharacter(from: CharacterSet)">
        <parameters>
          <param name="from" type="CharacterSet"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="rangeOfCharacter" signature="rangeOfCharacter(from: CharacterSet, options: NSString.CompareOptions = [])">
        <parameters>
          <param name="from" type="CharacterSet"/>
          <param name="options" type="NSString.CompareOptions = []"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="rangeOfCharacter" signature="rangeOfCharacter(from: CharacterSet, options: NSString.CompareOptions = [], range: NSRange)">
        <parameters>
          <param name="from" type="CharacterSet"/>
          <param name="options" type="NSString.CompareOptions = []"/>
          <param name="range" type="NSRange"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="rangeOfComposedCharacterSequence" signature="rangeOfComposedCharacterSequence(at: Int)">
        <parameters>
          <param name="at" type="Int"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="rangeOfComposedCharacterSequences" signature="rangeOfComposedCharacterSequences(for: NSRange)">
        <parameters>
          <param name="for" type="NSRange"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <field name="removingPercentEncoding" type="String?"/>
      <method name="replacingCharacters" signature="replacingCharacters(in: NSRange, with: String)">
        <parameters>
          <param name="in" type="NSRange"/>
          <param name="with" type="String"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="replacingOccurrences" signature="replacingOccurrences(of: String, with: String)">
        <parameters>
          <param name="of" type="String"/>
          <param name="with" type="String"/>
        </parameters>
        <return type="String"/>
        <neutralization argpos="-1" kind="string" resource="other"/>
      </method>
      <method name="replacingOccurrences" signature="replacingOccurrences(of: String, with: String, options: NSString.CompareOptions = [], range: NSRange)">
        <parameters>
          <param name="of" type="String"/>
          <param name="with" type="String"/>
          <param name="options" type="NSString.CompareOptions = []"/>
          <param name="range" type="NSRange"/>
        </parameters>
        <return type="String"/>
        <neutralization argpos="-1" kind="string" resource="other"/>
      </method>
      <method name="replacingPercentEscapes" signature="replacingPercentEscapes(using: UInt)">
        <parameters>
          <param name="using" type="UInt"/>
        </parameters>
        <return type="String?"/>
      </method>
      <field name="resolvingSymlinksInPath" type="String"/>
      <method name="size" signature="size(withAttributes: [NSAttributedStringKey : Any]? = nil)">
        <parameters>
          <param name="" type="withAttributes"/>
        </parameters>
        <return type="CGSize"/>
      </method>
      <field name="smallestEncoding" type="UInt"/>
      <field name="standardizingPath" type="String"/>
      <method name="string" signature="string(withCString: UnsafePointer&lt;Int8&gt;)">
        <parameters>
          <param name="withCString" type="UnsafePointer&lt;Int8&gt;"/>
        </parameters>
      </method>
      <method name="string" signature="string(withCString: UnsafePointer&lt;Int8&gt;, length: Int)">
        <parameters>
          <param name="withCString" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="length" type="Int"/>
        </parameters>
      </method>
      <method name="string" signature="string(withContentsOfFile: String)">
        <tags>hardcoded_path:withContentsOfFile</tags>
        <parameters>
          <param name="withContentsOfFile" type="String"/>
        </parameters>
        <source paramNames="withContentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="withContentsOfFile" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="string" signature="string(withContentsOf: URL)">
        <tags>hardcoded_path:withContentsOfFile</tags>
        <parameters>
          <param name="withContentsOf" type="URL"/>
        </parameters>
        <source paramNames="withContentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="withContentsOfFile" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="stringEncoding" signature="stringEncoding(for: Data, encodingOptions: [StringEncodingDetectionOptionsKey : Any]? = nil, convertedString: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?, usedLossyConversion: UnsafeMutablePointer&lt;ObjCBool&gt;?)">
        <parameters>
          <param name="for" type="Data"/>
          <param name="" type="encodingOptions"/>
          <param name="convertedString" type="AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?"/>
          <param name="usedLossyConversion" type="UnsafeMutablePointer&lt;ObjCBool&gt;?"/>
        </parameters>
        <return type="UInt"/>
      </method>
      <method name="strings" signature="strings(byAppendingPaths: [String])">
        <parameters>
          <param name="byAppendingPaths" type="[String]"/>
        </parameters>
        <return type="[String]"/>
      </method>
      <method name="substring" signature="substring(from: Int)">
        <parameters>
          <param name="from" type="Int"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="substring" signature="substring(with: NSRange)">
        <parameters>
          <param name="with" type="NSRange"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="substring" signature="substring(to: Int)">
        <parameters>
          <param name="to" type="Int"/>
        </parameters>
        <return type="String"/>
      </method>
      <field name="suggestedEncodingsKey" type="StringEncodingDetectionOptionsKey"/>
      <method name="trimmingCharacters" signature="trimmingCharacters(in: CharacterSet)">
        <parameters>
          <param name="in" type="CharacterSet"/>
        </parameters>
        <return type="String"/>
      </method>
      <field name="uppercased" type="String"/>
      <method name="uppercased" signature="uppercased(with: Locale?)">
        <parameters>
          <param name="with" type="Locale?"/>
        </parameters>
        <return type="String"/>
      </method>
      <field name="useOnlySuggestedEncodingsKey" type="StringEncodingDetectionOptionsKey"/>
      <field name="utf8String" type="UnsafePointer&lt;Int8&gt;?"/>
      <method name="variantFittingPresentationWidth" signature="variantFittingPresentationWidth(Int)">
        <parameters>
          <param name="" type="Int"/>
        </parameters>
      </method>
      <method name="write" signature="write(toFile: String, atomically: Bool, encoding: UInt)">
        <parameters>
          <param name="toFile" type="String"/>
          <param name="atomically" type="Bool"/>
          <param name="encoding" type="UInt"/>
        </parameters>
        <return type="func write(toFile path: String, atomically useAuxiliaryFile: Bool, encoding enc: UInt) throws"/>
      </method>
      <method name="write" signature="write(to: URL, atomically: Bool, encoding: UInt)">
        <parameters>
          <param name="to" type="URL"/>
          <param name="atomically" type="Bool"/>
          <param name="encoding" type="UInt"/>
        </parameters>
        <return type="func write(to url: URL, atomically useAuxiliaryFile: Bool, encoding enc: UInt) throws"/>
      </method>
      <method name="write" signature="write(toFile: String, atomically: Bool)">
        <parameters>
          <param name="toFile" type="String"/>
          <param name="atomically" type="Bool"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="write" signature="write(to: URL, atomically: Bool)">
        <parameters>
          <param name="to" type="URL"/>
          <param name="atomically" type="Bool"/>
        </parameters>
        <return type="Bool"/>
      </method>
    </class>

    <class name="NSMutableString" supertypes="Foundation.NSString" />

    <class name="Data">
      <property name="bridgeTypes" value="Foundation.NSData"/>
    </class>

    <class name="NSData" supertypes="AESAdditions.NSData" >
      <method name="base64EncodedData" signature="base64EncodedData(options: NSData.Base64EncodingOptions = [])" >
        <tags>algo:base64</tags>
        <parameters>
          <param type="NSData.Base64EncodingOptions" />
        </parameters>
        <return type="Foundation.NSData" />
      </method>
      <method name="base64EncodedString" signature="base64EncodedString(options: NSData.Base64EncodingOptions = [])" >
        <tags>algo:base64</tags>
        <parameters>
          <param type="NSData.Base64EncodingOptions" />
        </parameters>
        <return type="Foundation.NSData" />
        <sink argpos="-1" kind="weak_hash_algorithm" resource="crypto" />
      </method>
      <constructor name="NSData" signature="NSData(bytes: UnsafeRawPointer?, length: Int)">
        <parameters>
          <param name="bytes" type="UnsafeRawPointer?"/>
          <param name="length" type="Int"/>
        </parameters>
      </constructor>
      <constructor name="NSData" signature="NSData(bytesNoCopy: UnsafeMutableRawPointer, length: Int)">
        <parameters>
          <param name="bytesNoCopy" type="UnsafeMutableRawPointer"/>
          <param name="length" type="Int"/>
        </parameters>
      </constructor>
      <constructor name="NSData" signature="NSData(bytesNoCopy: UnsafeMutableRawPointer, length: Int, deallocator: ((UnsafeMutableRawPointer, Int) -&gt; Void)? = nil)">
        <parameters>
          <param name="bytesNoCopy" type="UnsafeMutableRawPointer"/>
          <param name="length" type="Int"/>
          <param name="deallocator" type="((UnsafeMutableRawPointer"/>
          <param name="" type="Int) -&gt; Void)? = nil"/>
        </parameters>
      </constructor>
      <constructor name="NSData" signature="NSData(bytesNoCopy: UnsafeMutableRawPointer, length: Int, freeWhenDone: Bool)">
        <parameters>
          <param name="bytesNoCopy" type="UnsafeMutableRawPointer"/>
          <param name="length" type="Int"/>
          <param name="freeWhenDone" type="Bool"/>
        </parameters>
      </constructor>
      <constructor name="NSData" signature="NSData(data: Data)">
        <parameters>
          <param name="data" type="Data"/>
        </parameters>
      </constructor>
      <constructor name="NSData" signature="NSData?(contentsOfFile: String)">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param name="contentsOfFile" type="String"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSData" signature="NSData(contentsOfFile: String, options: NSData.ReadingOptions = [])">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param name="contentsOfFile" type="String"/>
          <param name="options" type="NSData.ReadingOptions = []"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSData" signature="NSData?(contentsOf: URL)">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param name="contentsOf" type="URL"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSData" signature="NSData(contentsOf: URL, options: NSData.ReadingOptions = [])">
        <tags>hardcoded_path:contentsOfFile</tags>
        <parameters>
          <param name="contentsOf" type="URL"/>
          <param name="options" type="NSData.ReadingOptions = []"/>
        </parameters>
        <source paramNames="contentsOf" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSData" signature="NSData?(contentsOfMappedFile: String)">
        <tags>hardcoded_path:contentsOfMappedFile</tags>
        <parameters>
          <param name="contentsOfMappedFile" type="String"/>
        </parameters>
        <source paramNames="contentsOfFile" kind="file_input" resource="filesystem" />
        <sink paramNames="contentsOfFile" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="NSData" signature="NSData?(base64Encoded: Data, options: NSData.Base64DecodingOptions = [])">
        <parameters>
          <param name="base64Encoded" type="Data"/>
          <param name="options" type="NSData.Base64DecodingOptions = []"/>
        </parameters>
      </constructor>
      <constructor name="NSData" signature="NSData?(base64Encoding: String)">
        <parameters>
          <param name="base64Encoding" type="String"/>
        </parameters>
      </constructor>
      <constructor name="NSData" signature="NSData?(base64Encoded: String, options: NSData.Base64DecodingOptions = [])">
        <parameters>
          <param name="base64Encoded" type="String"/>
          <param name="options" type="NSData.Base64DecodingOptions = []"/>
        </parameters>
      </constructor>
      <method name="base64EncodedData" signature="base64EncodedData(options: NSData.Base64EncodingOptions = [])">
        <parameters>
          <param name="options" type="NSData.Base64EncodingOptions = []"/>
        </parameters>
        <return type="Data"/>
      </method>
      <method name="base64EncodedString" signature="base64EncodedString(options: NSData.Base64EncodingOptions = [])">
        <parameters>
          <param name="options" type="NSData.Base64EncodingOptions = []"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="base64Encoding" signature="base64Encoding()">
        <return type="String"/>
      </method>
      <field name="bytes" type="UnsafeRawPointer"/>
      <method name="contains" signature="contains(UInt8)">
        <parameters>
          <param name="" type="UInt8"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="contains" signature="contains(where: (UInt8) -&gt; Bool)">
        <parameters>
          <param name="where" type="(UInt8) -&gt; Bool"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="dataWithContentsOfMappedFile" signature="dataWithContentsOfMappedFile(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="Any?"/>
      </method>
      <field name="description" type="String"/>
      <method name="enumerateBytes" signature="enumerateBytes((UnsafeRawPointer, NSRange, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void)">
        <parameters>
          <param name="" type="(UnsafeRawPointer"/>
          <param name="" type="NSRange"/>
          <param name="" type="UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void"/>
        </parameters>
      </method>
      <method name="getBytes" signature="getBytes(UnsafeMutableRawPointer)">
        <parameters>
          <param name="" type="UnsafeMutableRawPointer"/>
        </parameters>
      </method>
      <method name="getBytes" signature="getBytes(UnsafeMutableRawPointer, length: Int)">
        <parameters>
          <param name="" type="UnsafeMutableRawPointer"/>
          <param name="length" type="Int"/>
        </parameters>
      </method>
      <method name="getBytes" signature="getBytes(UnsafeMutableRawPointer, range: NSRange)">
        <parameters>
          <param name="" type="UnsafeMutableRawPointer"/>
          <param name="range" type="NSRange"/>
        </parameters>
      </method>
      <method name="isEqual" signature="isEqual(to: Data)">
        <parameters>
          <param name="to" type="Data"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="length" type="Int"/>
      <method name="range" signature="range(of: Data, options: NSData.SearchOptions = [], in: NSRange)">
        <parameters>
          <param name="of" type="Data"/>
          <param name="options" type="NSData.SearchOptions = []"/>
          <param name="in" type="NSRange"/>
        </parameters>
        <return type="NSRange"/>
      </method>
      <method name="subdata" signature="subdata(with: NSRange)">
        <parameters>
          <param name="with" type="NSRange"/>
        </parameters>
        <return type="Data"/>
      </method>
      <method name="write" signature="write(toFile: String, atomically: Bool)">
        <parameters>
          <param name="toFile" type="String"/>
          <param name="atomically" type="Bool"/>
        </parameters>
        <return type="Bool"/>
        <sink paramNames="toFile" kind="sensitive_output" resource="filesystem" />
        <sink paramNames="toFile" kind="path_traversal" resource="filesystem" />
        <sink argpos="-2" kind="insecure_temporary_file" resource="filesystem">
          <checker id="foundation.atomicallyChecker" />
        </sink>
      </method>
      <method name="write" signature="write(toFile: String, options: NSData.WritingOptions = [])">
        <parameters>
          <param name="toFile" type="String"/>
          <param name="options" type="NSData.WritingOptions = []"/>
        </parameters>
        <sink paramNames="toFile" kind="sensitive_output" resource="filesystem" />
        <sink paramNames="toFile" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="write" signature="write(to: URL, atomically: Bool)">
        <parameters>
          <param name="to" type="URL"/>
          <param name="atomically" type="Bool"/>
        </parameters>
        <return type="Bool"/>
        <sink paramNames="to" kind="sensitive_output" resource="filesystem" />
        <sink paramNames="to" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="write" signature="write(to: URL, options: NSData.WritingOptions = [])">
        <parameters>
          <param name="to" type="URL"/>
          <param name="options" type="NSData.WritingOptions = []"/>
        </parameters>
        <sink paramNames="to" kind="sensitive_output" resource="filesystem" />
        <sink paramNames="to" kind="path_traversal" resource="filesystem" />
      </method>
    </class>

    <class name="URLSessionConfiguration">
      <method name="background" signature="background(withIdentifier: String)">
        <parameters>
          <param type="String" name="withIdentifier"/>
        </parameters>
        <return type="Foundation.URLSessionConfiguration"/>
      </method>

      <field name="`default`" type="Foundation.URLSessionConfiguration" />
      <field name="ephemeral" type="Foundation.URLSessionConfiguration" />
      <field name="httpAdditionalHeaders" type="Dictionary">
        <tags>open_redirect:headers</tags>
        <sink argpos="-1" kind="header_manipulation" resource="web"/>
      </field>
      <field name="httpCookieStorage" type="Foundation.HTTPCookieStorage">
        <sink argpos="-1" kind="header_manipulation" resource="web"/>
      </field>
      <field name="tlsMinimumSupportedProtocol" type="Foundation.SSLProtocol" />
      <field name="requestCachePolicy" type="Foundation.NSURLRequest.CachePolicy" />
    </class>

    <class name="NSBundle">
      <property name="bridgeTypes" value="Foundation.Bundle"/>
      <field name="main" type="Foundation.Bundle" />

      <method name="loadNibNamed" signature="loadNibNamed(_ nibName: NSNib.Name, owner: Any?, topLevelObjects: AutoreleasingUnsafeMutablePointer?) -> Bool" >
        <parameters>
          <param type="String" />
          <param type="Any" name="owner" />
          <param type="AutoreleasingUnsafeMutablePointer" name="topLevelObjects" />
        </parameters>
        <sink argpos="0" paramNames="nibName" kind="resource_injection" resource="other" />
      </method>
    </class>

    <class name="NSURLComponents">
      <property name="bridgeTypes" value="Foundation.URLComponents"/>
      <constructor name="NSURLComponents" signature="NSURLComponents()" />
      <constructor name="NSURLComponents" signature="NSURLComponents(string: String)" >
        <parameters>
          <param type="String" name="string" />
        </parameters>
      </constructor>
      <constructor name="NSURLComponents" signature="NSURLComponents(url : URL, resolvingAgainstBaseURL : Bool)" >
        <parameters>
          <param type="URL" name="url" />
          <param type="Bool" name="resolvingAgainstBaseURL" />
        </parameters>
      </constructor>

      <field name="queryItems" type="Dictionary" />
    </class>

    <class name="URLComponents">
      <property name="bridgeTypes" value="Foundation.NSURLComponents"/>
    </class>

    <class name="NSURL">
      <field name="absoluteString" type="String" />
      <field name="absoluteURL" type="URL" />
      <field name="baseURL" type="URL" />
      <field name="fragment" type="String" />
      <field name="host" type="String" >
        <sink argpos="-1" kind="resource_injection" resource="database" />
      </field>
      <field name="path" type="String" />
      <field name="port" type="Int" />
      <field name="user" type="String" />
      <field name="password" type="String" />

      <constructor name="NSURL" signature="NSURL(string : String)" >
        <parameters>
          <param type="String" name="string" />
        </parameters>
      </constructor>
      <constructor name="NSURL" signature="NSURL(string : String, relativeTo : NSURL)" >
        <parameters>
          <param type="String" name="string" />
          <param type="NSURL" name="relativeTo" />
        </parameters>
      </constructor>

    </class>

    <class name="URLSession">
      <field name="shared" type="Foundation.URLSession">
        <source argpos="-1,-2" kind="other_input" resource="network">
          <tags>insecure_transport:SSL 3.0</tags>
        </source>
      </field>

      <constructor name="URLSession" signature="URLSession(configuration: URLSessionConfiguration)">
        <parameters>
          <param type="Foundation.URLSessionConfiguration" name="configuration" />
        </parameters>
        <sink paramNames="configuration" kind="insecure_transport" resource="network" />
      </constructor>
      <constructor name="URLSession" signature="URLSession(configuration: Foundation.URLSessionConfiguration, delegate: URLSessionDelegate, delegateQueue: OperationQueue)">
        <parameters>
          <param type="URLSessionConfiguration" name="configuration" />
          <param type="URLSessionDelegate" name="delegate" />
          <param type="OperationQueue" name="delegateQueue" />
        </parameters>
        <sink paramNames="configuration" kind="insecure_transport" resource="network" />
      </constructor>

      <method name="dataTask" signature="dataTask(with: URL)" >
        <parameters>
          <param type="URL" name="with" />
        </parameters>
        <closures>
          <closure>
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink paramNames="with" kind="privacy_violation" resource="network" />
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="dataTask" signature="dataTask(with: URL, completionHandler: block)" >
        <parameters>
          <param type="URL" name="with" />
          <param type="block" name="completionHandler" />
        </parameters>
        <closures>
          <closure argpos="1" >
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink paramNames="with" kind="privacy_violation" resource="network" />
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="dataTask" signature="dataTask(with: URLRequest)" >
        <parameters>
          <param type="URLRequest" name="with" />
        </parameters>
        <closures>
          <closure>
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="dataTask" signature="dataTask(with: URLRequest, completionHandler: block)" >
        <parameters>
          <param type="URLRequest" name="with" />
          <param type="block" name="completionHandler" />
        </parameters>
        <closures>
          <closure argpos="1" >
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="downloadTask" signature="downloadTask(with: URL)" >
        <parameters>
          <param type="URL" name="with" />
        </parameters>
        <closures>
          <closure>
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink paramNames="with" kind="privacy_violation" resource="network" />
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="downloadTask" signature="downloadTask(with: URL, completionHandler: block)" >
        <parameters>
          <param type="URL" name="with" />
          <param type="block" name="completionHandler" />
        </parameters>
        <closures>
          <closure argpos="1" >
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink paramNames="with" kind="privacy_violation" resource="network" />
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="downloadTask" signature="downloadTask(with: URLRequest)" >
        <parameters>
          <param type="URLRequest" name="with" />
        </parameters>
        <closures>
          <closure>
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="downloadTask" signature="downloadTask(with: URLRequest, completionHandler: block)" >
        <parameters>
          <param type="URLRequest" name="with" />
          <param type="block" name="completionHandler" />
        </parameters>
        <closures>
          <closure argpos="1">
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="uploadTask" signature="uploadTask(with: URL)" >
        <parameters>
          <param type="URL" name="with" />
        </parameters>
        <closures>
          <closure>
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" />
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="uploadTask" signature="uploadTask(with: URL, completionHandler: block)" >
        <parameters>
          <param type="URL" name="with" />
          <param type="block" name="completionHandler" />
        </parameters>
        <closures>
          <closure argpos="1">
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" />
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="uploadTask" signature="uploadTask(with: URLRequest)" >
        <parameters>
          <param type="URLRequest" name="with" />
        </parameters>
        <closures>
          <closure>
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="uploadTask" signature="uploadTask(with: URLRequest, completionHandler: block)" >
        <parameters>
          <param type="URLRequest" name="with" />
          <param type="block" name="completionHandler" />
        </parameters>
        <closures>
          <closure argpos="1">
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="streamTask" signature="streamTask(with: URL)" >
        <parameters>
          <param type="URL" name="with" />
        </parameters>
        <closures>
          <closure>
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" />
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="streamTask" signature="streamTask(with: URL, completionHandler: block)" >
        <parameters>
          <param type="URL" name="with" />
          <param type="block" name="completionHandler" />
        </parameters>
        <closures>
          <closure argpos="1">
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" />
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="streamTask" signature="streamTask(with: URLRequest)" >
        <parameters>
          <param type="URLRequest" name="with" />
        </parameters>
        <closures>
          <closure>
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="streamTask" signature="streamTask(with: URLRequest, completionHandler: block)" >
        <parameters>
          <param type="URLRequest" name="with" />
          <param type="block" name="completionHandler" />
        </parameters>
        <closures>
          <closure argpos="1">
            <source argpos="0,1" kind="user_input" resource="other" />
          </closure>
        </closures>
        <sink paramNames="with" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="with" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
    </class>

    <class name="NSURLConnection">
      <constructor name="NSURLConnection" signature="NSURLConnection(request: URLRequest, delegate: Any)">
        <parameters>
          <param type="URLRequest" name="request" />
          <param type="Any" name="delegate" />
        </parameters>
        <sink paramNames="request" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="request" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </constructor>
      <constructor name="NSURLConnection" signature="NSURLConnection(request: URLRequest, delegate: Any, startImmediately: Bool)">
        <parameters>
          <param type="URLRequest" name="request" />
          <param type="Any" name="delegate" />
          <param type="Bool" name="startImmediately" />
        </parameters>
        <sink paramNames="request" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink paramNames="request" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </constructor>

      <method name="sendSynchronousRequest" signature="sendSynchronousRequest(NSURLRequest, returningResponse: NSURLResponse, error: NSError)" >
        <parameters>
          <param type="NSURLRequest" />
          <param type="NSURLResponse" name="returningResponse" />
          <param type="NSError" name="error" />
        </parameters>
        <sink argpos="0" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink argpos="0" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="sendAsynchronousRequest" signature="sendAsynchronousRequest(NSURLRequest, queue: NSOperationQueue, completionHandler: block)" >
        <parameters>
          <param type="NSURLRequest" />
          <param type="queue" name="NSOperationQueue" />
          <param type="block" name="completionHandler" />
        </parameters>
        <sink argpos="0" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink argpos="0" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="connectionWithRequest" signature="connectionWithRequest(NSURLRequest, delegate: NSDelegate)" >
        <parameters>
          <param type="NSURLRequest" />
          <param type="NSDelegate" name="delegate" />
        </parameters>
        <sink argpos="0" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink argpos="0" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="connectionWithRequest" signature="connectionWithRequest(NSURLRequest, delegate: NSDelegate)" >
        <parameters>
          <param type="NSURLRequest" />
          <param type="NSDelegate" name="delegate" />
        </parameters>
        <sink argpos="0" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink argpos="0" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>
      <method name="connectionWithRequest" signature="connectionWithRequest(NSURLRequest, delegate: NSDelegate)" >
        <parameters>
          <param type="NSURLRequest" />
          <param type="NSDelegate" name="delegate" />
        </parameters>
        <sink argpos="0" kind="insecure_transport" resource="network" />
        <sink argpos="0" kind="privacy_violation" resource="network" >
          <checker id="foundation.httpGetChecker"/>
        </sink>
        <sink argpos="0" kind="open_redirect" resource="network" />
        <sink paramNames="with" kind="http_caching" resource="network" />
      </method>

    </class>

    <class name="URLCache">
      <field name="shared" type="Foundation.URLCache" />
      
      <method name="removeCachedResponse" signature="removeCachedResponse(for: URLRequest)" >
        <tags>cache_cleared</tags>
        <parameters>
          <param type="Foundation.URLRequest" name="for" />
        </parameters>
      </method>
      <method name="removeCachedResponse" signature="removeCachedResponse(for: URLSessionDataTaks)" >
        <tags>cache_cleared</tags>
        <parameters>
          <param type="Foundation.URLSessionDataTaks" name="for" />
        </parameters>
      </method>
      <method name="removeCachedResponses" signature="removeCachedResponses(since: Date)" >
        <tags>cache_cleared</tags>
        <parameters>
          <param type="Date" name="since" />
        </parameters>
      </method>
      <method name="removeAllCachedResponses" signature="removeAllCachedResponses()" >
        <tags>cache_cleared</tags>
      </method>
    </class>

    <class name="UserDefaults">
      <property name="bridgeTypes" value="NSUserDefaults"/>
      <method name="standardUserDefaults" signature="standardUserDefaults()" >
        <return type="Foundation.UserDefaults" />
      </method>

      <method name="object" signature="object(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="url" signature="url(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="array" signature="array(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="dictionary" signature="dictionary(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="string" signature="string(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="stringArray" signature="stringArray(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="data" signature="data(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="bool" signature="bool(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="integer" signature="integer(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="float" signature="float(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="double" signature="double(forkey : String)" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="dictionaryRepresentation" signature="dictionaryRepresentation()" >
        <return type="Dictionary" />
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>

      <method name="set" signature="set(Any, forkey : String)" >
        <parameters>
          <param type="Any" />
          <param type="String" name="forKey" />
        </parameters>
        <sink paramNames="forKey" kind="privacy_violation" resource="filesystem" />
        <sink argpos="0" paramNames="forKey" kind="sensitive_file_disclosure" resource="filesystem" />
      </method>
    </class>

    <class name="NSUserDefaults">
      <property name="bridgeTypes" value="UserDefaults"/>
      <method name="standardUserDefaults" signature="standardUserDefaults()" >
        <return type="Foundation.NSUserDefaults" />
      </method>

      <method name="objectForKey" signature="objectForKey(String)" >
        <parameters>
          <param type="String"/>
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="URLForKey" signature="URLForKey(String)" >
        <parameters>
          <param type="String"/>
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="URLForKey" signature="URLForKey(String)" >
        <parameters>
          <param type="String"/>
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="arrayForKey" signature="arrayForKey(String)" >
        <parameters>
          <param type="String"/>
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="dictionaryForKey" signature="dictionaryForKey(String)" >
        <parameters>
          <param type="String"/>
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="stringForKey" signature="stringForKey(String)" >
        <parameters>
          <param type="String"/>
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="stringArrayForKey" signature="stringArrayForKey()" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="dataForKey" signature="dataForKey()" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="integerForKey" signature="integerForKey()" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="floatForKey" signature="floatForKey()" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="doubleForKey" signature="doubleForKey()" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="doubleForKey" signature="doubleForKey()" >
        <parameters>
          <param type="String" name="forKey" />
        </parameters>
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>
      <method name="dictionaryRepresentation" signature="dictionaryRepresentation()" >
        <return type="Dictionary" />
        <source argpos="-1" kind="sensitive_info" resource="other" />
      </method>

      <method name="setObject" signature="setObject(Any, forkey : String)" >
        <parameters>
          <param type="Any" />
          <param type="String" name="forKey" />
        </parameters>
        <sink paramNames="forKey" kind="privacy_violation" resource="filesystem" />
      </method>
    </class>

    <class name="NSURLRequest">
      <field name="httpMethod" type="String" />

      <constructor name="NSURLRequest" signature="NSURLRequest(url : URL)">
        <parameters>
          <param type="URL" name="url"/>
        </parameters>
        <sink paramNames="url" kind="http_parameter_pollution" />
      </constructor>
      <constructor name="NSURLRequest" signature="NSURLRequest(url: URL, cachePolicy: NSURLRequest.CachePolicy, timeoutInterval: TimeInterval)">
        <parameters>
          <param type="URL" name="url"/>
          <param type="Foundation.NSURLRequest.CachePolicy," name="cachePolicy"/>
          <param type="TimeInterval" name="timeoutInterval"/>
        </parameters>
        <sink paramNames="url" kind="http_parameter_pollution" />
      </constructor>
    </class>

    <class name="NSMutableURLRequest" supertypes="Foundation.NSURLRequest" >
      <constructor name="NSMutableURLRequest" signature="NSMutableURLRequest(url : URL)">
        <parameters>
          <param type="URL" name="url"/>
        </parameters>
        <sink paramNames="url" kind="http_parameter_pollution" />
      </constructor>
      <constructor name="NSMutableURLRequest" signature="NSMutableURLRequest(url: URL, cachePolicy: NSURLRequest.CachePolicy, timeoutInterval: TimeInterval)">
        <parameters>
          <param type="URL" name="url"/>
          <param type="Foundation.NSURLRequest.CachePolicy," name="cachePolicy"/>
          <param type="TimeInterval" name="timeoutInterval"/>
        </parameters>
        <sink paramNames="url" kind="http_parameter_pollution" />
      </constructor>
    </class>

    <class name="JSONSerialization">
      <method name="jsonObject" signature="jsonObject(with: Data, options: JSONSerialization.ReadingOptions = [])">
        <parameters>
          <param type="Data" name="with" />
          <param type="Foundation.JSONSerialization.ReadingOptions" name="options" />
        </parameters>
      </method>
      <method name="jsonObject" signature="jsonObject(with: Data, options: JSONSerialization.ReadingOptions = [])">
        <parameters>
          <param type="InputStream" name="with" />
          <param type="Foundation.JSONSerialization.ReadingOptions" name="options" />
        </parameters>
      </method>
      <method name="data" signature="data(withJSONObject: Any, options: JSONSerialization.WritingOptions = [])">
        <parameters>
          <param type="Any" />
          <param type="Foundation.JSONSerialization.WritingOptions" name="options" />
        </parameters>
        <source argpos="-1" kind="file_input" resource="other" />
      </method>
      <method name="writeJSONObject" signature="writeJSONObject(Any, to: OutputStream, options: JSONSerialization.WritingOptions = [], error: NSErrorPointer)">
        <parameters>
          <param type="Any" />
          <param type="OutputStream" name="to" />
          <param type="Foundation.JSONSerialization.WritingOptions" name="options" />
          <param type="NSErrorPointer" name="error" />
        </parameters>
        <sink argpos="0" kind="json_injection" resource="other" />
      </method>
    </class>

    <class name="NSJSONSerialization">
      <method name="JSONObjectWithData" signature="JSONObjectWithData(Data, options: JSONSerialization.ReadingOptions = [])">
        <parameters>
          <param type="Data" />
          <param type="Foundation.JSONSerialization.ReadingOptions" name="options" />
        </parameters>
        <sink argpos="0" kind="json_injection" resource="other" />
      </method>
      <method name="JSONObjectWithStream" signature="JSONObjectWithStream(Data, options: JSONSerialization.ReadingOptions = [])">
        <parameters>
          <param type="InputStream" />
          <param type="Foundation.JSONSerialization.ReadingOptions" name="options" />
        </parameters>
        <sink argpos="0" kind="json_injection" resource="other" />
      </method>
      <method name="dataWithJSONObject" signature="dataWithJSONObject(Any, options: JSONSerialization.WritingOptions = [])">
        <parameters>
          <param type="Any" />
          <param type="Foundation.JSONSerialization.WritingOptions" name="options" />
        </parameters>
        <sink argpos="0" kind="json_injection" resource="other" />
      </method>
      <method name="writeJSONObject" signature="writeJSONObject(Any, toSteam: OutputStream, options: JSONSerialization.WritingOptions = [], error: NSErrorPointer)">
        <parameters>
          <param type="Any" />
          <param type="OutputStream" name="toSteam" />
          <param type="Foundation.JSONSerialization.WritingOptions" name="options" />
          <param type="NSErrorPointer" name="error" />
        </parameters>
        <sink argpos="0" kind="json_injection" resource="other" />
      </method>
    </class>

    <class name="Process">
      <field name="arguments" type="String" />
      <field name="launchPath" type="String" />
      <field name="standardOutput" type="Any">
        <source argpos="-1" kind="system_input" resource="os" />
      </field>

      <method name="launch" signature="launch()" >
        <sink argpos="-2" kind="command_injection" resource="os" />
      </method>
    </class>

    <class name="NSTask">
      <field name="arguments" type="String" />
      <field name="launchPath" type="String" />

      <method name="launch" signature="launch()" >
        <sink argpos="-2" kind="command_injection" resource="os" />
      </method>
    </class>

    <class name="XMLParser" supertypes="NSObject">
      <method name="abortParsing" signature="abortParsing()"/>
      <field name="allowedExternalEntityURLs" type="Set&lt;URL&gt;?"/>
      <field name="columnNumber" type="Int"/>
      <field name="delegate" type="XMLParserDelegate?"/>
      <field name="errorDomain" type="String"/>
      <field name="externalEntityResolvingPolicy" type="XMLParser.ExternalEntityResolvingPolicy"/>
      <field name="lineNumber" type="Int"/>
      <field name="parserError" type="Error?"/>
      <field name="publicID" type="String?"/>
      <field name="shouldProcessNamespaces" type="Bool"/>
      <field name="shouldReportNamespacePrefixes" type="Bool"/>
      <field name="shouldResolveExternalEntities" type="Bool"/>
      <field name="systemID" type="String?"/>

      <constructor name="XMLParser" signature="XMLParser?(contentsOf: URL)">
        <tags>hardcoded_path:withContentsOf</tags>
        <parameters>
          <param name="contentsOf" type="URL"/>
        </parameters>
        <sink paramNames="contentsOf" kind="path_traversal" resource="filesystem" />
      </constructor>
      <constructor name="XMLParser" signature="XMLParser(data: Data)">
        <parameters>
          <param name="data" type="Data"/>
        </parameters>
      </constructor>
      <constructor name="XMLParser" signature="XMLParser(stream: InputStream)">
        <parameters>
          <param name="stream" type="InputStream"/>
        </parameters>
      </constructor>

      <method name="parse" signature="parse()">
        <return type="Bool"/>
        <sink argpos="-2" kind="xml_entity_injection" resource="other" />
      </method>
    </class>

    <class name="XMLDocument" supertypes="NSXMLNode">
      <constructor name="XMLDocument" signature="XMLDocument(contentsOf: URL, options: XMLNode.Options = [])">
        <tags>hardcoded_path:withContentsOf</tags>
        <parameters>
          <param name="contentsOf" type="URL"/>
          <param name="options" type="XMLNode.Options = []"/>
        </parameters>
      </constructor>
      <constructor name="XMLDocument" signature="XMLDocument(data: Data, options: XMLNode.Options = [])">
        <parameters>
          <param name="data" type="Data"/>
          <param name="options" type="XMLNode.Options = []"/>
        </parameters>
      </constructor>
      <constructor name="XMLDocument" signature="XMLDocument(rootElement: XMLElement?)">
        <parameters>
          <param name="rootElement" type="XMLElement?"/>
        </parameters>
      </constructor>
      <constructor name="XMLDocument" signature="XMLDocument(xmlString: String, options: XMLNode.Options = [])">
        <parameters>
          <param name="xmlString" type="String"/>
          <param name="options" type="XMLNode.Options = []"/>
        </parameters>
      </constructor>
      <constructor name="XMLDocument" signature="XMLDocument()"/>
      <method name="addChild" signature="addChild(XMLNode)">
        <parameters>
          <param name="" type="XMLNode"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <field name="characterEncoding" type="String?"/>
      <field name="documentContentKind" type="XMLDocument.ContentKind"/>
      <field name="documentIncludeContentTypeDeclaration" type="XMLNode.Options"/>
      <field name="documentTidyHTML" type="XMLNode.Options"/>
      <field name="documentTidyXML" type="XMLNode.Options"/>
      <field name="documentValidate" type="XMLNode.Options"/>
      <field name="documentXInclude" type="XMLNode.Options"/>
      <field name="dtd" type="XMLDTD?"/>
      <method name="insertChild" signature="insertChild(XMLNode, at: Int)">
        <parameters>
          <param name="" type="XMLNode"/>
          <param name="at" type="Int"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="insertChildren" signature="insertChildren([XMLNode], at: Int)">
        <parameters>
          <param name="" type="[XMLNode]"/>
          <param name="at" type="Int"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <field name="isStandalone" type="Bool"/>
      <field name="mimeType" type="String?"/>
      <method name="object" signature="object(byApplyingXSLT: Data, arguments: [String : String]?)">
        <parameters>
          <param name="byApplyingXSLT" type="Data"/>
          <param name="" type="arguments"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="object" signature="object(byApplyingXSLTString: String, arguments: [String : String]?)">
        <parameters>
          <param name="byApplyingXSLTString" type="String"/>
          <param name="" type="arguments"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="objectByApplyingXSLT" signature="objectByApplyingXSLT(at: URL, arguments: [String : String]?)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="" type="arguments"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="removeChild" signature="removeChild(at: Int)">
        <parameters>
          <param name="at" type="Int"/>
        </parameters>
      </method>
      <method name="replaceChild" signature="replaceChild(at: Int, with: XMLNode)">
        <parameters>
          <param name="at" type="Int"/>
          <param name="with" type="XMLNode"/>
        </parameters>
        <sink paramNames="with" kind="xml_injection" resource="other" />
      </method>
      <method name="replacementClass" signature="replacementClass(for: AnyClass)">
        <parameters>
          <param name="for" type="AnyClass"/>
        </parameters>
        <return type="AnyClass"/>
      </method>
      <method name="rootElement" signature="rootElement()">
        <return type="XMLElement?"/>
      </method>
      <method name="setChildren" signature="setChildren([XMLNode]?)">
        <parameters>
          <param name="" type="[XMLNode]?"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="setRootElement" signature="setRootElement(XMLElement)">
        <parameters>
          <param name="" type="XMLElement"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="validate" signature="validate()">
        <return type="func validate() throws"/>
      </method>
      <field name="version" type="String?"/>
      <field name="xmlData" type="Data"/>
      <method name="xmlData" signature="xmlData(options: XMLNode.Options = [])">
        <parameters>
          <param name="options" type="XMLNode.Options = []"/>
        </parameters>
      </method>
    </class>

    <class name="XMLElement" supertypes="NSXMLNode">
      <constructor name="XMLElement" signature="XMLElement(name: String)">
        <parameters>
          <param name="name" type="String"/>
        </parameters>
      </constructor>
      <constructor name="XMLElement" signature="XMLElement(name: String, stringValue: String?)">
        <parameters>
          <param name="name" type="String"/>
          <param name="stringValue" type="String?"/>
        </parameters>
      </constructor>
      <constructor name="XMLElement" signature="XMLElement(xmlString: String)">
        <parameters>
          <param name="xmlString" type="String"/>
        </parameters>
      </constructor>
      <constructor name="XMLElement" signature="XMLElement(name: String, uri: String?)">
        <parameters>
          <param name="name" type="String"/>
          <param name="uri" type="String?"/>
        </parameters>
      </constructor>
      <constructor name="XMLElement" signature="XMLElement(kind: XMLNode.Kind, options: XMLNode.Options = [])">
        <parameters>
          <param name="kind" type="XMLNode.Kind"/>
          <param name="options" type="XMLNode.Options = []"/>
        </parameters>
      </constructor>
      <method name="addAttribute" signature="addAttribute(XMLNode)">
        <parameters>
          <param name="" type="XMLNode"/>
        </parameters>
      </method>
      <method name="addChild" signature="addChild(XMLNode)">
        <parameters>
          <param name="" type="XMLNode"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="addNamespace" signature="addNamespace(XMLNode)">
        <parameters>
          <param name="" type="XMLNode"/>
        </parameters>
      </method>
      <method name="attribute" signature="attribute(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
        <return type="XMLNode?"/>
      </method>
      <method name="attribute" signature="attribute(forLocalName: String, uri: String?)">
        <parameters>
          <param name="forLocalName" type="String"/>
          <param name="uri" type="String?"/>
        </parameters>
        <return type="XMLNode?"/>
      </method>
      <field name="attributes" type="[XMLNode]?"/>
      <method name="elements" signature="elements(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
        <return type="[XMLElement]"/>
      </method>
      <method name="elements" signature="elements(forLocalName: String, uri: String?)">
        <parameters>
          <param name="forLocalName" type="String"/>
          <param name="uri" type="String?"/>
        </parameters>
        <return type="[XMLElement]"/>
      </method>
      <method name="insertChild" signature="insertChild(XMLNode, at: Int)">
        <parameters>
          <param name="" type="XMLNode"/>
          <param name="at" type="Int"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="insertChildren" signature="insertChildren([XMLNode], at: Int)">
        <parameters>
          <param name="" type="[XMLNode]"/>
          <param name="at" type="Int"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="namespace" signature="namespace(forPrefix: String)">
        <parameters>
          <param name="forPrefix" type="String"/>
        </parameters>
        <return type="XMLNode?"/>
      </method>
      <field name="namespaces" type="[XMLNode]?"/>
      <method name="normalizeAdjacentTextNodesPreservingCDATA" signature="normalizeAdjacentTextNodesPreservingCDATA(Bool)">
        <parameters>
          <param name="" type="Bool"/>
        </parameters>
      </method>
      <method name="removeAttribute" signature="removeAttribute(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
      </method>
      <method name="removeChild" signature="removeChild(at: Int)">
        <parameters>
          <param name="at" type="Int"/>
        </parameters>
      </method>
      <method name="removeNamespace" signature="removeNamespace(forPrefix: String)">
        <parameters>
          <param name="forPrefix" type="String"/>
        </parameters>
      </method>
      <method name="replaceChild" signature="replaceChild(at: Int, with: XMLNode)">
        <parameters>
          <param name="at" type="Int"/>
          <param name="with" type="XMLNode"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="resolveNamespace" signature="resolveNamespace(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
        <return type="XMLNode?"/>
      </method>
      <method name="resolvePrefix" signature="resolvePrefix(forNamespaceURI: String)">
        <parameters>
          <param name="forNamespaceURI" type="String"/>
        </parameters>
        <return type="String?"/>
      </method>
      <method name="setAttributesAs" signature="setAttributesAs([AnyHashable : Any])">
        <parameters>
          <param name="[AnyHashable" type="Any]"/>
        </parameters>
      </method>
      <method name="setAttributesWith" signature="setAttributesWith([String : String])">
        <parameters>
          <param name="[String" type="String]"/>
        </parameters>
      </method>
      <method name="setChildren" signature="setChildren([XMLNode]?)">
        <parameters>
          <param name="" type="[XMLNode]?"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
    </class>

    <class name="NSXMLDocument" supertypes="NSXMLNode">
      <constructor name="NSXMLDocument" signature="NSXMLDocument(contentsOf: URL, options: NSXMLNode.Options = [])">
        <parameters>
          <param name="contentsOf" type="URL"/>
          <param name="options" type="XMLNode.Options = []"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLDocument" signature="NSXMLDocument(data: Data, options: NSXMLNode.Options = [])">
        <parameters>
          <param name="data" type="Data"/>
          <param name="options" type="NSXMLNode.Options = []"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLDocument" signature="NSXMLDocument(rootElement: NSXMLElement?)">
        <parameters>
          <param name="rootElement" type="NSXMLElement?"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLDocument" signature="NSXMLDocument(xmlString: String, options: NSXMLNode.Options = [])">
        <parameters>
          <param name="xmlString" type="String"/>
          <param name="options" type="XMLNode.Options = []"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLDocument" signature="NSXMLDocument()"/>
      <method name="addChild" signature="addChild(XMLNode)">
        <parameters>
          <param name="" type="XMLNode"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <field name="characterEncoding" type="String?"/>
      <field name="documentContentKind" type="XMLDocument.ContentKind"/>
      <field name="documentIncludeContentTypeDeclaration" type="XMLNode.Options"/>
      <field name="documentTidyHTML" type="NSXMLNode.Options"/>
      <field name="documentTidyXML" type="NSXMLNode.Options"/>
      <field name="documentValidate" type="NSXMLNode.Options"/>
      <field name="documentXInclude" type="NSXMLNode.Options"/>
      <field name="dtd" type="XMLDTD?"/>
      <method name="insertChild" signature="insertChild(XMLNode, at: Int)">
        <parameters>
          <param name="" type="XMLNode"/>
          <param name="at" type="Int"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="insertChildren" signature="insertChildren([XMLNode], at: Int)">
        <parameters>
          <param name="" type="[XMLNode]"/>
          <param name="at" type="Int"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <field name="isStandalone" type="Bool"/>
      <field name="mimeType" type="String?"/>
      <method name="object" signature="object(byApplyingXSLT: Data, arguments: [String : String]?)">
        <parameters>
          <param name="byApplyingXSLT" type="Data"/>
          <param name="" type="arguments"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="object" signature="object(byApplyingXSLTString: String, arguments: [String : String]?)">
        <parameters>
          <param name="byApplyingXSLTString" type="String"/>
          <param name="" type="arguments"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="objectByApplyingXSLT" signature="objectByApplyingXSLT(at: NSURL, arguments: [String : String]?)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="" type="arguments"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="removeChild" signature="removeChild(at: Int)">
        <parameters>
          <param name="at" type="Int"/>
        </parameters>
      </method>
      <method name="replaceChild" signature="replaceChild(at: Int, with: NSXMLNode)">
        <parameters>
          <param name="at" type="Int"/>
          <param name="with" type="NSXMLNode"/>
        </parameters>
        <sink paramNames="with" kind="xml_injection" resource="other" />
      </method>
      <method name="replacementClass" signature="replacementClass(for: AnyClass)">
        <parameters>
          <param name="for" type="AnyClass"/>
        </parameters>
        <return type="AnyClass"/>
      </method>
      <method name="rootElement" signature="rootElement()">
        <return type="XMLElement?"/>
      </method>
      <method name="setChildren" signature="setChildren([NSXMLNode]?)">
        <parameters>
          <param name="" type="[XMLNode]?"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="setRootElement" signature="setRootElement(NSXMLElement)">
        <parameters>
          <param name="" type="NSXMLElement"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="validate" signature="validate()">
        <return type="func validate() throws"/>
      </method>
      <field name="version" type="String?"/>
      <field name="xmlData" type="Data"/>
      <method name="xmlData" signature="xmlData(options: NSXMLNode.Options = [])">
        <parameters>
          <param name="options" type="NSXMLNode.Options = []"/>
        </parameters>
      </method>
    </class>

    <class name="NSXMLParser" supertypes="NSObject">
      <method name="abortParsing" signature="abortParsing()"/>
      <field name="allowedExternalEntityURLs" type="Set&lt;URL&gt;?"/>
      <field name="columnNumber" type="Int"/>
      <field name="delegate" type="XMLParserDelegate?"/>
      <field name="errorDomain" type="String"/>
      <field name="externalEntityResolvingPolicy" type="XMLParser.ExternalEntityResolvingPolicy"/>
      <field name="lineNumber" type="Int"/>
      <field name="parserError" type="Error?"/>
      <field name="publicID" type="String?"/>
      <field name="shouldProcessNamespaces" type="Bool"/>
      <field name="shouldReportNamespacePrefixes" type="Bool"/>
      <field name="shouldResolveExternalEntities" type="Bool"/>
      <field name="systemID" type="String?"/>

      <constructor name="NSXMLParser" signature="XMLParser?(contentsOf: URL)">
        <parameters>
          <param name="contentsOf" type="URL"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLParser" signature="XMLParser(data: Data)">
        <parameters>
          <param name="data" type="Data"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLParser" signature="XMLParser(stream: InputStream)">
        <parameters>
          <param name="stream" type="InputStream"/>
        </parameters>
      </constructor>

      <method name="parse" signature="parse()">
        <return type="Bool"/>
        <sink argpos="-2" kind="xml_entity_injection" resource="other" />
      </method>
    </class>

    <class name="NSXMLElement" supertypes="NSXMLNode">
      <constructor name="NSXMLElement" signature="NSXMLElement(name: String)">
        <parameters>
          <param name="name" type="String"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLElement" signature="NSXMLElement(name: String, stringValue: String?)">
        <parameters>
          <param name="name" type="String"/>
          <param name="stringValue" type="String?"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLElement" signature="NSXMLElement(xmlString: String)">
        <parameters>
          <param name="xmlString" type="String"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLElement" signature="NSXMLElement(name: String, uri: String?)">
        <parameters>
          <param name="name" type="String"/>
          <param name="uri" type="String?"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLElement" signature="NSXMLElement(kind: NSXMLNode.Kind, options: NSXMLNode.Options = [])">
        <parameters>
          <param name="kind" type="NSXMLNode.Kind"/>
          <param name="options" type="NSXMLNode.Options = []"/>
        </parameters>
      </constructor>
      <method name="addAttribute" signature="addAttribute(NSXMLNode)">
        <parameters>
          <param name="" type="NSXMLNode"/>
        </parameters>
      </method>
      <method name="addChild" signature="addChild(NSXMLNode)">
        <parameters>
          <param name="" type="NSXMLNode"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="addNamespace" signature="addNamespace(NSXMLNode)">
        <parameters>
          <param name="" type="NSXMLNode"/>
        </parameters>
      </method>
      <method name="attribute" signature="attribute(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
        <return type="NSXMLNode?"/>
      </method>
      <method name="attribute" signature="attribute(forLocalName: String, uri: String?)">
        <parameters>
          <param name="forLocalName" type="String"/>
          <param name="uri" type="String?"/>
        </parameters>
        <return type="NSXMLNode?"/>
      </method>
      <field name="attributes" type="[NSXMLNode]?"/>
      <method name="elements" signature="elements(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
        <return type="[XMLElement]"/>
      </method>
      <method name="elements" signature="elements(forLocalName: String, uri: String?)">
        <parameters>
          <param name="forLocalName" type="String"/>
          <param name="uri" type="String?"/>
        </parameters>
        <return type="[NSXMLElement]"/>
      </method>
      <method name="insertChild" signature="insertChild(XMLNode, at: Int)">
        <parameters>
          <param name="" type="NSXMLNode"/>
          <param name="at" type="Int"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="insertChildren" signature="insertChildren([NSXMLNode], at: Int)">
        <parameters>
          <param name="" type="[NSXMLNode]"/>
          <param name="at" type="Int"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="namespace" signature="namespace(forPrefix: String)">
        <parameters>
          <param name="forPrefix" type="String"/>
        </parameters>
        <return type="NSXMLNode?"/>
      </method>
      <field name="namespaces" type="[NSXMLNode]?"/>
      <method name="normalizeAdjacentTextNodesPreservingCDATA" signature="normalizeAdjacentTextNodesPreservingCDATA(Bool)">
        <parameters>
          <param name="" type="Bool"/>
        </parameters>
      </method>
      <method name="removeAttribute" signature="removeAttribute(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
      </method>
      <method name="removeChild" signature="removeChild(at: Int)">
        <parameters>
          <param name="at" type="Int"/>
        </parameters>
      </method>
      <method name="removeNamespace" signature="removeNamespace(forPrefix: String)">
        <parameters>
          <param name="forPrefix" type="String"/>
        </parameters>
      </method>
      <method name="replaceChild" signature="replaceChild(at: Int, with: NSXMLNode)">
        <parameters>
          <param name="at" type="Int"/>
          <param name="with" type="NSXMLNode"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
      <method name="resolveNamespace" signature="resolveNamespace(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
        <return type="NSXMLNode?"/>
      </method>
      <method name="resolvePrefix" signature="resolvePrefix(forNamespaceURI: String)">
        <parameters>
          <param name="forNamespaceURI" type="String"/>
        </parameters>
        <return type="String?"/>
      </method>
      <method name="setAttributesAs" signature="setAttributesAs([AnyHashable : Any])">
        <parameters>
          <param name="[AnyHashable" type="Any]"/>
        </parameters>
      </method>
      <method name="setAttributesWith" signature="setAttributesWith([String : String])">
        <parameters>
          <param name="[String" type="String]"/>
        </parameters>
      </method>
      <method name="setChildren" signature="setChildren([NSXMLNode]?)">
        <parameters>
          <param name="" type="[NSXMLNode]?"/>
        </parameters>
        <sink argpos="0" kind="xml_injection" resource="other" />
      </method>
    </class>

    <class name="XMLNode" supertypes="NSObject">
      <constructor name="XMLNode" signature="XMLNode(kind: XMLNode.Kind)">
        <parameters>
          <param name="kind" type="XMLNode.Kind"/>
        </parameters>
      </constructor>
      <constructor name="XMLNode" signature="XMLNode(kind: XMLNode.Kind, options: XMLNode.Options = [])">
        <parameters>
          <param name="kind" type="XMLNode.Kind"/>
          <param name="options" type="XMLNode.Options = []"/>
        </parameters>
      </constructor>
      <constructor name="XMLNode" signature="XMLNode()"/>
      <method name="attribute" signature="attribute(withName: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="attribute" signature="attribute(withName: String, uri: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="uri" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="canonicalXMLStringPreservingComments" signature="canonicalXMLStringPreservingComments(Bool)">
        <parameters>
          <param name="" type="Bool"/>
        </parameters>
      </method>
      <method name="child" signature="child(at: Int)">
        <parameters>
          <param name="at" type="Int"/>
        </parameters>
        <return type="XMLNode?"/>
      </method>
      <field name="childCount" type="Int"/>
      <field name="children" type="[XMLNode]?"/>
      <method name="comment" signature="comment(withStringValue: String)">
        <parameters>
          <param name="withStringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="description" type="String"/>
      <method name="detach" signature="detach()"/>
      <method name="document" signature="document()">
        <return type="Any"/>
      </method>
      <method name="document" signature="document(withRootElement: XMLElement)">
        <parameters>
          <param name="withRootElement" type="XMLElement"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="dtdNode" signature="dtdNode(withXMLString: String)">
        <parameters>
          <param name="withXMLString" type="String"/>
        </parameters>
        <return type="Any?"/>
      </method>
      <method name="element" signature="element(withName: String)">
        <parameters>
          <param name="withName" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="element" signature="element(withName: String, children: [XMLNode]?, attributes: [XMLNode]?)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="children" type="[XMLNode]?"/>
          <param name="attributes" type="[XMLNode]?"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="element" signature="element(withName: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="element" signature="element(withName: String, uri: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="uri" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="index" type="Int"/>
      <field name="kind" type="XMLNode.Kind"/>
      <field name="level" type="Int"/>
      <field name="localName" type="String?"/>
      <method name="localName" signature="localName(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
      </method>
      <field name="name" type="String?"/>
      <method name="namespace" signature="namespace(withName: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="next" type="XMLNode?"/>
      <field name="nextSibling" type="XMLNode?"/>
      <method name="nodes" signature="nodes(forXPath: String)">
        <parameters>
          <param name="forXPath" type="String"/>
        </parameters>
        <return type="[XMLNode]"/>
        <sink paramNames="forXPath" kind="xpath_injection" resource="other" />
      </method>
      <field name="objectValue" type="Any?"/>
      <method name="objects" signature="objects(forXQuery: String)">
        <parameters>
          <param name="forXQuery" type="String"/>
        </parameters>
        <sink paramNames="forXQuery" kind="xpath_injection" resource="other" />
      </method>
      <method name="objects" signature="objects(forXQuery: String, constants: [String : Any]?)">
        <parameters>
          <param name="forXQuery" type="String"/>
          <param name="" type="constants"/>
        </parameters>
        <sink paramNames="forXQuery" kind="xpath_injection" resource="other" />
      </method>
      <field name="parent" type="XMLNode?"/>
      <method name="predefinedNamespace" signature="predefinedNamespace(forPrefix: String)">
        <parameters>
          <param name="forPrefix" type="String"/>
        </parameters>
        <return type="XMLNode?"/>
      </method>
      <field name="prefix" type="String?"/>
      <method name="prefix" signature="prefix(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
      </method>
      <field name="previous" type="XMLNode?"/>
      <field name="previousSibling" type="XMLNode?"/>
      <method name="processingInstruction" signature="processingInstruction(withName: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="rootDocument" type="XMLDocument?"/>
      <method name="setStringValue" signature="setStringValue(String, resolvingEntities: Bool)">
        <parameters>
          <param name="" type="String"/>
          <param name="resolvingEntities" type="Bool"/>
        </parameters>
      </method>
      <field name="stringValue" type="String?"/>
      <method name="text" signature="text(withStringValue: String)">
        <parameters>
          <param name="withStringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="uri" type="String?"/>
      <field name="xPath" type="String?"/>
      <field name="xmlString" type="String"/>
      <method name="xmlString" signature="xmlString(options: XMLNode.Options = [])">
        <parameters>
          <param name="options" type="XMLNode.Options = []"/>
        </parameters>
      </method>
    </class>

    <class name="NSXMLNode" supertypes="NSObject">
      <constructor name="NSXMLNode" signature="NSXMLNode(kind: NSXMLNode.Kind)">
        <parameters>
          <param name="kind" type="NSXMLNode.Kind"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLNode" signature="NSXMLNode(kind: NSXMLNode.Kind, options: NSXMLNode.Options = [])">
        <parameters>
          <param name="kind" type="NSXMLNode.Kind"/>
          <param name="options" type="NSXMLNode.Options = []"/>
        </parameters>
      </constructor>
      <constructor name="NSXMLNode" signature="NSXMLNode()"/>
      <method name="attribute" signature="attribute(withName: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="attribute" signature="attribute(withName: String, uri: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="uri" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="canonicalXMLStringPreservingComments" signature="canonicalXMLStringPreservingComments(Bool)">
        <parameters>
          <param name="" type="Bool"/>
        </parameters>
      </method>
      <method name="child" signature="child(at: Int)">
        <parameters>
          <param name="at" type="Int"/>
        </parameters>
        <return type="XMLNode?"/>
      </method>
      <field name="childCount" type="Int"/>
      <field name="children" type="[NSXMLNode]?"/>
      <method name="comment" signature="comment(withStringValue: String)">
        <parameters>
          <param name="withStringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="description" type="String"/>
      <method name="detach" signature="detach()"/>
      <method name="document" signature="document()">
        <return type="Any"/>
      </method>
      <method name="document" signature="document(withRootElement: NSXMLElement)">
        <parameters>
          <param name="withRootElement" type="NSXMLElement"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="dtdNode" signature="dtdNode(withXMLString: String)">
        <parameters>
          <param name="withXMLString" type="String"/>
        </parameters>
        <return type="Any?"/>
      </method>
      <method name="element" signature="element(withName: String)">
        <parameters>
          <param name="withName" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="element" signature="element(withName: String, children: [NSXMLNode]?, attributes: [NSXMLNode]?)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="children" type="[NSXMLNode]?"/>
          <param name="attributes" type="[XMLNode]?"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="element" signature="element(withName: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <method name="element" signature="element(withName: String, uri: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="uri" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="index" type="Int"/>
      <field name="kind" type="NSXMLNode.Kind"/>
      <field name="level" type="Int"/>
      <field name="localName" type="String?"/>
      <method name="localName" signature="localName(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
      </method>
      <field name="name" type="String?"/>
      <method name="namespace" signature="namespace(withName: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="next" type="NSXMLNode?"/>
      <field name="nextSibling" type="NSXMLNode?"/>
      <method name="nodes" signature="nodes(forXPath: String)">
        <parameters>
          <param name="forXPath" type="String"/>
        </parameters>
        <return type="[NSXMLNode]"/>
        <sink paramNames="forXPath" kind="xpath_injection" resource="other" />
      </method>
      <field name="objectValue" type="Any?"/>
      <method name="objects" signature="objects(forXQuery: String)">
        <parameters>
          <param name="forXQuery" type="String"/>
        </parameters>
        <sink paramNames="forXQuery" kind="xpath_injection" resource="other" />
      </method>
      <method name="objects" signature="objects(forXQuery: String, constants: [String : Any]?)">
        <parameters>
          <param name="forXQuery" type="String"/>
          <param name="" type="constants"/>
        </parameters>
        <sink paramNames="forXQuery" kind="xpath_injection" resource="other" />
      </method>
      <field name="parent" type="NSXMLNode?"/>
      <method name="predefinedNamespace" signature="predefinedNamespace(forPrefix: String)">
        <parameters>
          <param name="forPrefix" type="String"/>
        </parameters>
        <return type="NSXMLNode?"/>
      </method>
      <field name="prefix" type="String?"/>
      <method name="prefix" signature="prefix(forName: String)">
        <parameters>
          <param name="forName" type="String"/>
        </parameters>
      </method>
      <field name="previous" type="NSXMLNode?"/>
      <field name="previousSibling" type="NSXMLNode?"/>
      <method name="processingInstruction" signature="processingInstruction(withName: String, stringValue: String)">
        <parameters>
          <param name="withName" type="String"/>
          <param name="stringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="rootDocument" type="NSXMLDocument?"/>
      <method name="setStringValue" signature="setStringValue(String, resolvingEntities: Bool)">
        <parameters>
          <param name="" type="String"/>
          <param name="resolvingEntities" type="Bool"/>
        </parameters>
      </method>
      <field name="stringValue" type="String?"/>
      <method name="text" signature="text(withStringValue: String)">
        <parameters>
          <param name="withStringValue" type="String"/>
        </parameters>
        <return type="Any"/>
      </method>
      <field name="uri" type="String?"/>
      <field name="xPath" type="String?"/>
      <field name="xmlString" type="String"/>
      <method name="xmlString" signature="xmlString(options: NSXMLNode.Options = [])">
        <parameters>
          <param name="options" type="NSXMLNode.Options = []"/>
        </parameters>
      </method>
    </class>

    <class kind="protocol" name="NSURLConnectionDelegate" supertypes="NSObjectProtocol">
      <method name="connection" signature="connection(NSURLConnection, willSendRequestFor: URLAuthenticationChallenge)">
        <parameters>
          <param name="" type="NSURLConnection"/>
          <param name="willSendRequestFor" type="URLAuthenticationChallenge"/>
        </parameters>
      </method>
      <method name="connection" signature="connection(NSURLConnection, canAuthenticateAgainstProtectionSpace: URLProtectionSpace)">
        <parameters>
          <param name="" type="NSURLConnection"/>
          <param name="canAuthenticateAgainstProtectionSpace" type="URLProtectionSpace"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="connection" signature="connection(NSURLConnection, didCancel: URLAuthenticationChallenge)">
        <parameters>
          <param name="" type="NSURLConnection"/>
          <param name="didCancel" type="URLAuthenticationChallenge"/>
        </parameters>
      </method>
      <method name="connection" signature="connection(NSURLConnection, didReceive: URLAuthenticationChallenge)">
        <parameters>
          <param name="" type="NSURLConnection"/>
          <param name="didReceive" type="URLAuthenticationChallenge"/>
        </parameters>
      </method>
      <method name="connection" signature="connection(NSURLConnection, didFailWithError: Error)">
        <parameters>
          <param name="" type="NSURLConnection"/>
          <param name="didFailWithError" type="Error"/>
        </parameters>
      </method>
      <method name="connectionShouldUseCredentialStorage" signature="connectionShouldUseCredentialStorage(NSURLConnection)">
        <parameters>
          <param name="" type="NSURLConnection"/>
        </parameters>
      </method>
    </class>


    <class name="FileManager" supertypes="NSObject">
      <field name="NSUbiquityIdentityDidChange" type="NSNotification.Name"/>
      <field name="default" type="FileManager"/>

      <method name="attributesOfFileSystem" signature="attributesOfFileSystem(forPath: String)">
        <tags>hardcoded_path:forPath</tags>
        <parameters>
          <param name="forPath" type="String"/>
        </parameters>
        <return type="[FileAttributeKey : Any]"/>
      </method>
      <method name="attributesOfItem" signature="attributesOfItem(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="[FileAttributeKey : Any]"/>
      </method>
      <method name="changeCurrentDirectoryPath" signature="changeCurrentDirectoryPath(String)">
        <tags>hardcoded_path:0</tags>
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="changeFileAttributes" signature="changeFileAttributes([AnyHashable : Any] = [:], atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="" type="[AnyHashable"/>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="componentsToDisplay" signature="componentsToDisplay(forPath: String)">
        <tags>hardcoded_path:forPath</tags>
        <parameters>
          <param name="forPath" type="String"/>
        </parameters>
        <return type="[String]?"/>
      </method>
      <method name="containerURL" signature="containerURL(forSecurityApplicationGroupIdentifier: String)">
        <tags>hardcoded_path:0</tags>
        <parameters>
          <param name="forSecurityApplicationGroupIdentifier" type="String"/>
        </parameters>
        <return type="URL?"/>
      </method>
      <method name="contents" signature="contents(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="Data?"/>
        <sink paramNames="atPath" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="contentsEqual" signature="contentsEqual(atPath: String, andPath: String)">
        <tags>hardcoded_path:atPath|andPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="andPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="contentsOfDirectory" signature="contentsOfDirectory(at: URL, includingPropertiesForKeys: [URLResourceKey]?, options: FileManager.DirectoryEnumerationOptions = [])">
        <parameters>
          <param name="at" type="URL"/>
          <param name="includingPropertiesForKeys" type="[URLResourceKey]?"/>
          <param name="options" type="FileManager.DirectoryEnumerationOptions = []"/>
        </parameters>
        <return type="[URL]"/>
      </method>
      <method name="contentsOfDirectory" signature="contentsOfDirectory(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="[String]"/>
        <sink paramNames="atPath" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="copyItem" signature="copyItem(at: URL, to: URL)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="to" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="copyItem" signature="copyItem(atPath: String, toPath: String)">
        <tags>hardcoded_path:atPath|toPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="toPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="createDirectory" signature="createDirectory(at: URL, withIntermediateDirectories: Bool, attributes: [FileAttributeKey : Any]? = nil)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="withIntermediateDirectories" type="Bool"/>
          <param name="" type="attributes"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="createDirectory" signature="createDirectory(atPath: String, withIntermediateDirectories: Bool, attributes: [FileAttributeKey : Any]? = nil)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="withIntermediateDirectories" type="Bool"/>
          <param name="" type="attributes"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="createDirectory" signature="createDirectory(atPath: String, attributes: [AnyHashable : Any] = [:])">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="" type="attributes"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="createFile" signature="createFile(atPath: String, contents: Data?, attributes: [FileAttributeKey : Any]? = nil)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="contents" type="Data?"/>
          <param name="" type="attributes"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="createSymbolicLink" signature="createSymbolicLink(at: URL, withDestinationURL: URL)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="withDestinationURL" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="createSymbolicLink" signature="createSymbolicLink(atPath: String, withDestinationPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="withDestinationPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="createSymbolicLink" signature="createSymbolicLink(atPath: String, pathContent: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="pathContent" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="currentDirectoryPath" type="String"/>
      <field name="delegate" type="FileManagerDelegate?"/>
      <method name="destinationOfSymbolicLink" signature="destinationOfSymbolicLink(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="directoryContents" signature="directoryContents(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="[Any]?"/>
      </method>
      <method name="displayName" signature="displayName(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="enumerator" signature="enumerator(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="FileManager.DirectoryEnumerator?"/>
        <sink paramNames="atPath" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="enumerator" signature="enumerator(at: URL, includingPropertiesForKeys: [URLResourceKey]?, options: FileManager.DirectoryEnumerationOptions, errorHandler: ((URL, Error) -&gt; Bool)?)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="includingPropertiesForKeys" type="[URLResourceKey]?"/>
          <param name="options" type="FileManager.DirectoryEnumerationOptions"/>
          <param name="errorHandler" type="((URL"/>
          <param name="" type="Error) -&gt; Bool)?"/>
        </parameters>
      </method>
      <method name="evictUbiquitousItem" signature="evictUbiquitousItem(at: URL)">
        <parameters>
          <param name="at" type="URL"/>
        </parameters>
        <return type="true"/>
      </method>
      <method name="fileAttributes" signature="fileAttributes(atPath: String, traverseLink: Bool)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="traverseLink" type="Bool"/>
        </parameters>
        <return type="[AnyHashable : Any]?"/>
      </method>
      <method name="fileExists" signature="fileExists(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="fileExists" signature="fileExists(atPath: String, isDirectory: UnsafeMutablePointer&lt;ObjCBool&gt;?)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="isDirectory" type="UnsafeMutablePointer&lt;ObjCBool&gt;?"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="fileManager" signature="fileManager(FileManager, shouldProceedAfterError: [AnyHashable : Any])">
        <parameters>
          <param name="" type="FileManager"/>
          <param name="" type="shouldProceedAfterError"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="fileManager" signature="fileManager(FileManager, willProcessPath: String)">
        <parameters>
          <param name="" type="FileManager"/>
          <param name="willProcessPath" type="String"/>
        </parameters>
      </method>
      <method name="fileSystemAttributes" signature="fileSystemAttributes(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="[AnyHashable : Any]?"/>
      </method>
      <method name="fileSystemRepresentation" signature="fileSystemRepresentation(withPath: String)">
        <tags>hardcoded_path:withPath</tags>
        <parameters>
          <param name="withPath" type="String"/>
        </parameters>
        <return type="UnsafePointer&lt;Int8&gt;"/>
      </method>
      <method name="getFileProviderServicesForItem" signature="getFileProviderServicesForItem(at: URL, completionHandler: ([NSFileProviderServiceName : NSFileProviderService]?, Error?) -&gt; Void)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="" type="completionHandler"/>
          <param name="" type="Error?) -&gt; Void"/>
        </parameters>
      </method>
      <method name="getRelationship" signature="getRelationship(UnsafeMutablePointer&lt;FileManager.URLRelationship&gt;, ofDirectoryAt: URL, toItemAt: URL)">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;FileManager.URLRelationship&gt;"/>
          <param name="ofDirectoryAt" type="URL"/>
          <param name="toItemAt" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="getRelationship" signature="Bool">
        <parameters>
          <param name="" type="UnsafeMutablePointer&lt;FileManager.URLRelationship&gt;"/>
          <param name="of" type="FileManager.SearchPathDirectory"/>
          <param name="in" type="FileManager.SearchPathDomainMask"/>
          <param name="toItemAt" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="homeDirectory" signature="homeDirectory(forUser: String)">
        <parameters>
          <param name="forUser" type="String"/>
        </parameters>
        <return type="URL?"/>
      </method>
      <field name="homeDirectoryForCurrentUser" type="URL"/>
      <method name="isDeletableFile" signature="isDeletableFile(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="isExecutableFile" signature="isExecutableFile(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="isReadableFile" signature="isReadableFile(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="isUbiquitousItem" signature="isUbiquitousItem(at: URL)">
        <parameters>
          <param name="at" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="isWritableFile" signature="isWritableFile(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="linkItem" signature="linkItem(at: URL, to: URL)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="to" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="linkItem" signature="linkItem(atPath: String, toPath: String)">
        <tags>hardcoded_path:atPath|toPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="toPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="mountedVolumeURLs" signature="mountedVolumeURLs(includingResourceValuesForKeys: [URLResourceKey]?, options: FileManager.VolumeEnumerationOptions = [])">
        <parameters>
          <param name="includingResourceValuesForKeys" type="[URLResourceKey]?"/>
          <param name="options" type="FileManager.VolumeEnumerationOptions = []"/>
        </parameters>
        <return type="[URL]?"/>
      </method>
      <method name="moveItem" signature="moveItem(at: URL, to: URL)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="to" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="moveItem" signature="moveItem(atPath: String, toPath: String)">
        <tags>hardcoded_path:atPath|toPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
          <param name="toPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="pathContentOfSymbolicLink" signature="pathContentOfSymbolicLink(atPath: String)">
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="String?"/>
      </method>
      <method name="removeItem" signature="removeItem(at: URL)">
        <parameters>
          <param name="at" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="removeItem" signature="removeItem(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="Bool"/>
        <sink paramNames="atPath" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="replaceItem" signature="replaceItem(at: URL, withItemAt: URL, backupItemName: String?, options: FileManager.ItemReplacementOptions = [], resultingItemURL: AutoreleasingUnsafeMutablePointer&lt;NSURL?&gt;?)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="withItemAt" type="URL"/>
          <param name="backupItemName" type="String?"/>
          <param name="options" type="FileManager.ItemReplacementOptions = []"/>
          <param name="resultingItemURL" type="AutoreleasingUnsafeMutablePointer&lt;NSURL?&gt;?"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="replaceItemAt" signature="replaceItemAt(URL, withItemAt: URL, backupItemName: String?, options: FileManager.ItemReplacementOptions)">
        <parameters>
          <param name="" type="URL"/>
          <param name="withItemAt" type="URL"/>
          <param name="backupItemName" type="String?"/>
          <param name="options" type="FileManager.ItemReplacementOptions"/>
        </parameters>
      </method>
      <method name="replaceItemAtURL" signature="replaceItemAtURL(originalItemURL: NSURL, withItemAtURL: NSURL, backupItemName: String?, options: FileManager.ItemReplacementOptions)">
        <parameters>
          <param name="originalItemURL" type="NSURL"/>
          <param name="withItemAtURL" type="NSURL"/>
          <param name="backupItemName" type="String?"/>
          <param name="options" type="FileManager.ItemReplacementOptions"/>
        </parameters>
      </method>
      <method name="setAttributes" signature="setAttributes([FileAttributeKey : Any], ofItemAtPath: String)">
        <tags>hardcoded_path:ofItemaAtPath</tags>
        <parameters>
          <param name="[FileAttributeKey" type="Any]"/>
          <param name="ofItemAtPath" type="String"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="setUbiquitous" signature="setUbiquitous(Bool, itemAt: URL, destinationURL: URL)">
        <parameters>
          <param name="" type="Bool"/>
          <param name="itemAt" type="URL"/>
          <param name="destinationURL" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="startDownloadingUbiquitousItem" signature="startDownloadingUbiquitousItem(at: URL)">
        <parameters>
          <param name="at" type="URL"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="string" signature="string(withFileSystemRepresentation: UnsafePointer&lt;Int8&gt;, length: Int)">
        <parameters>
          <param name="withFileSystemRepresentation" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="length" type="Int"/>
        </parameters>
        <return type="String"/>
      </method>
      <method name="subpaths" signature="subpaths(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="[String]?"/>
        <sink paramNames="atPath" kind="path_traversal" resource="filesystem" />
      </method>
      <method name="subpathsOfDirectory" signature="subpathsOfDirectory(atPath: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="atPath" type="String"/>
        </parameters>
        <return type="[String]"/>
        <sink paramNames="atPath" kind="path_traversal" resource="filesystem" />
      </method>
      <field name="temporaryDirectory" type="URL"/>
      <method name="trashItem" signature="trashItem(at: URL, resultingItemURL: AutoreleasingUnsafeMutablePointer&lt;NSURL?&gt;?)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="resultingItemURL" type="AutoreleasingUnsafeMutablePointer&lt;NSURL?&gt;?"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="ubiquityIdentityToken" type="NSObjectProtocol)?"/>
      <method name="unmountVolume" signature="unmountVolume(at: URL, options: FileManager.UnmountOptions = [], completionHandler: (Error?) -&gt; Void)">
        <parameters>
          <param name="at" type="URL"/>
          <param name="options" type="FileManager.UnmountOptions = []"/>
          <param name="completionHandler" type="(Error?) -&gt; Void"/>
        </parameters>
      </method>
      <method name="url" signature="url(for: FileManager.SearchPathDirectory, in: FileManager.SearchPathDomainMask, appropriateFor: URL?, create: Bool)">
        <parameters>
          <param name="for" type="FileManager.SearchPathDirectory"/>
          <param name="in" type="FileManager.SearchPathDomainMask"/>
          <param name="appropriateFor" type="URL?"/>
          <param name="create" type="Bool"/>
        </parameters>
        <return type="URL"/>
      </method>
      <method name="url" signature="url(forUbiquityContainerIdentifier: String?)">
        <parameters>
          <param name="forUbiquityContainerIdentifier" type="String?"/>
        </parameters>
        <return type="URL?"/>
      </method>
      <method name="url" signature="url(forPublishingUbiquitousItemAt: URL, expiration: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;?)">
        <parameters>
          <param name="forPublishingUbiquitousItemAt" type="URL"/>
          <param name="expiration" type="AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;?"/>
        </parameters>
        <return type="URL"/>
      </method>
      <method name="urls" signature="urls(for: FileManager.SearchPathDirectory, in: FileManager.SearchPathDomainMask)">
        <parameters>
          <param name="for" type="FileManager.SearchPathDirectory"/>
          <param name="in" type="FileManager.SearchPathDomainMask"/>
        </parameters>
        <return type="[URL]"/>
      </method>
    </class>

    <class name="Bundle" supertypes="NSObject">
      <constructor name="Bundle" signature="Bundle(for: AnyClass)">
        <parameters>
          <param name="for" type="AnyClass"/>
        </parameters>
      </constructor>
      <constructor name="Bundle" signature="Bundle?(identifier: String)">
        <parameters>
          <param name="identifier" type="String"/>
        </parameters>
      </constructor>
      <constructor name="Bundle" signature="Bundle?(url: URL)">
        <parameters>
          <param name="url" type="URL"/>
        </parameters>
      </constructor>
      <constructor name="Bundle" signature="Bundle?(path: String)">
        <tags>hardcoded_path:atPath</tags>
        <parameters>
          <param name="path" type="String"/>
        </parameters>
      </constructor>
      <field name="allBundles" type="[Bundle]"/>
      <field name="allFrameworks" type="[Bundle]"/>
      <field name="appStoreReceiptURL" type="URL?"/>
      <field name="builtInPlugInsPath" type="String?"/>
      <field name="builtInPlugInsURL" type="URL?"/>
      <field name="bundleIdentifier" type="String?"/>
      <field name="bundlePath" type="String"/>
      <field name="bundleURL" type="URL"/>
      <method name="classNamed" signature="classNamed(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
        <return type="AnyClass?"/>
      </method>
      <method name="contextHelp" signature="contextHelp(forKey: NSHelpManager.ContextHelpKey)">
        <parameters>
          <param name="forKey" type="NSHelpManager.ContextHelpKey"/>
        </parameters>
        <return type="NSAttributedString?"/>
      </method>
      <field name="developmentLocalization" type="String?"/>
      <field name="didLoadNotification" type="NSNotification.Name"/>
      <field name="executableArchitectures" type="[NSNumber]?"/>
      <field name="executablePath" type="String?"/>
      <field name="executableURL" type="URL?"/>
      <method name="image" signature="image(forResource: NSImage.Name)">
        <parameters>
          <param name="forResource" type="NSImage.Name"/>
        </parameters>
        <return type="NSImage?"/>
      </method>
      <field name="infoDictionary" type="Any]?"/>
      <field name="isLoaded" type="Bool"/>
      <method name="load" signature="load()">
        <return type="Bool"/>
      </method>
      <method name="loadAndReturnError" signature="loadAndReturnError()">
        <return type="func loadAndReturnError() throws"/>
      </method>
      <method name="loadNibNamed" signature="loadNibNamed(String, owner: Any?, options: [AnyHashable : Any]? = nil)">
        <parameters>
          <param name="" type="String"/>
          <param name="owner" type="Any?"/>
          <param name="" type="options"/>
        </parameters>
        <return type="[Any]?"/>
      </method>
      <method name="loadNibNamed" signature="loadNibNamed(NSNib.Name, owner: Any?, topLevelObjects: AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?)">
        <parameters>
          <param name="" type="NSNib.Name"/>
          <param name="owner" type="Any?"/>
          <param name="topLevelObjects" type="AutoreleasingUnsafeMutablePointer&lt;NSArray?&gt;?"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="localizations" type="[String]"/>
      <field name="localizedInfoDictionary" type="Any]?"/>
      <method name="localizedString" signature="localizedString(forKey: String, value: String?, table: String?)">
        <parameters>
          <param name="forKey" type="String"/>
          <param name="value" type="String?"/>
          <param name="table" type="String?"/>
        </parameters>
        <return type="String"/>
      </method>
      <field name="main" type="Foundation.Bundle"/>
      <method name="object" signature="object(forInfoDictionaryKey: String)">
        <parameters>
          <param name="forInfoDictionaryKey" type="String"/>
        </parameters>
        <return type="Any?"/>
      </method>
      <method name="path" signature="path(forResource: String?, ofType: String?)">
        <parameters>
          <param name="forResource" type="String?"/>
          <param name="ofType" type="String?"/>
        </parameters>
        <return type="String?"/>
        <source argpos="-1" kind="file_input" resource="environment" />
      </method>
      <method name="path" signature="path(forResource: String?, ofType: String?, inDirectory: String?)">
        <parameters>
          <param name="forResource" type="String?"/>
          <param name="ofType" type="String?"/>
          <param name="inDirectory" type="String?"/>
        </parameters>
        <return type="String?"/>
        <source argpos="-1" kind="file_input" resource="environment" />
      </method>
      <method name="path" signature="path(forResource: String?, ofType: String?, inDirectory: String?, forLocalization: String?)">
        <parameters>
          <param name="forResource" type="String?"/>
          <param name="ofType" type="String?"/>
          <param name="inDirectory" type="String?"/>
          <param name="forLocalization" type="String?"/>
        </parameters>
        <return type="String?"/>
        <source argpos="-1" kind="file_input" resource="environment" />
      </method>
      <method name="path" signature="path(forResource: String?, ofType: String?, inDirectory: String)">
        <parameters>
          <param name="forResource" type="String?"/>
          <param name="ofType" type="String?"/>
          <param name="inDirectory" type="String"/>
        </parameters>
        <return type="String?"/>
        <source argpos="-1" kind="file_input" resource="environment" />
      </method>
      <method name="path" signature="path(forSoundResource: NSSound.Name)">
        <parameters>
          <param name="forSoundResource" type="NSSound.Name"/>
        </parameters>
        <return type="String?"/>
        <source argpos="-1" kind="file_input" resource="environment" />
      </method>
      <method name="path" signature="path(forAuxiliaryExecutable: String)">
        <parameters>
          <param name="forAuxiliaryExecutable" type="String"/>
        </parameters>
        <return type="String?"/>
        <source argpos="-1" kind="file_input" resource="environment" />
      </method>
      <method name="pathForImageResource" signature="pathForImageResource(NSImage.Name)">
        <parameters>
          <param name="" type="NSImage.Name"/>
        </parameters>
        <return type="String?"/>
      </method>
      <method name="paths" signature="paths(forResourcesOfType: String?, inDirectory: String?)">
        <parameters>
          <param name="forResourcesOfType" type="String?"/>
          <param name="inDirectory" type="String?"/>
        </parameters>
        <return type="[String]"/>
        <source argpos="-1" kind="file_input" resource="environment" />
      </method>
      <method name="paths" signature="paths(forResourcesOfType: String?, inDirectory: String?, forLocalization: String?)">
        <parameters>
          <param name="forResourcesOfType" type="String?"/>
          <param name="inDirectory" type="String?"/>
          <param name="forLocalization" type="String?"/>
        </parameters>
        <return type="[String]"/>
        <source argpos="-1" kind="file_input" resource="environment" />
      </method>
      <method name="paths" signature="paths(forResourcesOfType: String?, inDirectory: String)">
        <parameters>
          <param name="forResourcesOfType" type="String?"/>
          <param name="inDirectory" type="String"/>
        </parameters>
        <return type="[String]"/>
        <source argpos="-1" kind="file_input" resource="environment" />
      </method>
      <field name="preferredLocalizations" type="[String]"/>
      <method name="preferredLocalizations" signature="preferredLocalizations(from: [String])">
        <parameters>
          <param name="from" type="[String]"/>
        </parameters>
        <return type="[String]"/>
      </method>
      <method name="preferredLocalizations" signature="preferredLocalizations(from: [String], forPreferences: [String]?)">
        <parameters>
          <param name="from" type="[String]"/>
          <param name="forPreferences" type="[String]?"/>
        </parameters>
        <return type="[String]"/>
      </method>
      <method name="preflight" signature="preflight()">
        <return type="func preflight() throws"/>
      </method>
      <method name="preservationPriority" signature="preservationPriority(forTag: String)">
        <parameters>
          <param name="forTag" type="String"/>
        </parameters>
        <return type="Double"/>
      </method>
      <field name="principalClass" type="AnyClass?"/>
      <field name="privateFrameworksPath" type="String?"/>
      <field name="privateFrameworksURL" type="URL?"/>
      <field name="resourcePath" type="String?"/>
      <field name="resourceURL" type="URL?"/>
      <method name="setPreservationPriority" signature="setPreservationPriority(Double, forTags: Set&lt;String&gt;)">
        <parameters>
          <param name="" type="Double"/>
          <param name="forTags" type="Set&lt;String&gt;"/>
        </parameters>
      </method>
      <field name="sharedFrameworksPath" type="String?"/>
      <field name="sharedFrameworksURL" type="URL?"/>
      <field name="sharedSupportPath" type="String?"/>
      <field name="sharedSupportURL" type="URL?"/>
      <method name="unload" signature="unload()">
        <return type="Bool"/>
      </method>
      <method name="url" signature="url(forResource: String?, withExtension: String?, subdirectory: String?)">
        <parameters>
          <param name="forResource" type="String?"/>
          <param name="withExtension" type="String?"/>
          <param name="subdirectory" type="String?"/>
        </parameters>
        <return type="URL?"/>
      </method>
      <method name="url" signature="url(forResource: String?, withExtension: String?)">
        <parameters>
          <param name="forResource" type="String?"/>
          <param name="withExtension" type="String?"/>
        </parameters>
        <return type="URL?"/>
      </method>
      <method name="url" signature="url(forResource: String?, withExtension: String?, subdirectory: String?, localization: String?)">
        <parameters>
          <param name="forResource" type="String?"/>
          <param name="withExtension" type="String?"/>
          <param name="subdirectory" type="String?"/>
          <param name="localization" type="String?"/>
        </parameters>
        <return type="URL?"/>
      </method>
      <method name="url" signature="url(forResource: String?, withExtension: String?, subdirectory: String?, in: URL)">
        <parameters>
          <param name="forResource" type="String?"/>
          <param name="withExtension" type="String?"/>
          <param name="subdirectory" type="String?"/>
          <param name="in" type="URL"/>
        </parameters>
        <return type="URL?"/>
      </method>
      <method name="url" signature="url(forAuxiliaryExecutable: String)">
        <parameters>
          <param name="forAuxiliaryExecutable" type="String"/>
        </parameters>
        <return type="URL?"/>
      </method>
      <method name="urlForImageResource" signature="urlForImageResource(NSImage.Name)">
        <parameters>
          <param name="" type="NSImage.Name"/>
        </parameters>
        <return type="URL?"/>
      </method>
      <method name="urls" signature="urls(forResourcesWithExtension: String?, subdirectory: String?)">
        <parameters>
          <param name="forResourcesWithExtension" type="String?"/>
          <param name="subdirectory" type="String?"/>
        </parameters>
        <return type="[URL]?"/>
      </method>
      <method name="urls" signature="urls(forResourcesWithExtension: String?, subdirectory: String?, localization: String?)">
        <parameters>
          <param name="forResourcesWithExtension" type="String?"/>
          <param name="subdirectory" type="String?"/>
          <param name="localization" type="String?"/>
        </parameters>
        <return type="[URL]?"/>
      </method>
      <method name="urls" signature="urls(forResourcesWithExtension: String?, subdirectory: String?, in: URL)">
        <parameters>
          <param name="forResourcesWithExtension" type="String?"/>
          <param name="subdirectory" type="String?"/>
          <param name="in" type="URL"/>
        </parameters>
        <return type="[URL]?"/>
      </method>
    </class>

    <class name="NSCondition" supertypes="NSObject">
      <method name="broadcast" signature="broadcast()"/>
      <field name="name" type="String?"/>
      <method name="signal" signature="signal()"/>
      <method name="wait" signature="wait()">
        <tags>lock</tags>
      </method>
      <method name="wait" signature="wait(until: Date)">
        <tags>lock</tags>
        <parameters>
          <param name="until" type="Date"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="lock" signature="lock()">
        <tags>lock</tags>
        <return type="Bool"/>
      </method>
    </class>

    <class name="NSDistributedLock" supertypes="NSObject">
      <constructor name="NSDistributedLock" signature="NSDistributedLock?(path: String)">
        <tags>lock</tags>
        <parameters>
          <param name="path" type="String"/>
        </parameters>
      </constructor>
      <method name="`break`" signature="`break`()"/>
      <method name="`try`" signature="`try`()">
        <tags>lock</tags>
        <return type="Bool"/>
      </method>
      <field name="lockDate" type="Date"/>
      <method name="unlock" signature="unlock()"/>
    </class>

    <class name="NSRecursiveLock" supertypes="NSObject">
      <method name="`try`" signature="`try`()">
        <tags>lock</tags>
        <return type="Bool"/>
      </method>
      <method name="lock" signature="lock(before: Date)">
        <tags>lock</tags>
        <parameters>
          <param name="before" type="Date"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="name" type="String?"/>
    </class>

    <class name="NSConditionLock" supertypes="NSObject">
      <constructor name="NSConditionLock" signature="NSConditionLock(condition: Int)">
        <tags>lock</tags>
        <parameters>
          <param name="condition" type="Int"/>
        </parameters>
      </constructor>
      <method name="`try`" signature="`try`()">
        <tags>lock</tags>
        <return type="Bool"/>
      </method>
      <field name="condition" type="Int"/>
      <method name="lock" signature="lock(before: Date)">
        <tags>lock</tags>
        <parameters>
          <param name="before" type="Date"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="lock" signature="lock(whenCondition: Int)">
        <tags>lock</tags>
        <parameters>
          <param name="whenCondition" type="Int"/>
        </parameters>
      </method>
      <method name="lock" signature="lock(whenCondition: Int, before: Date)">
        <tags>lock</tags>
        <parameters>
          <param name="whenCondition" type="Int"/>
          <param name="before" type="Date"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="name" type="String?"/>
      <method name="tryLock" signature="tryLock(whenCondition: Int)">
        <tags>lock</tags>
        <parameters>
          <param name="whenCondition" type="Int"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <method name="unlock" signature="unlock(withCondition: Int)">
        <parameters>
          <param name="withCondition" type="Int"/>
        </parameters>
      </method>
    </class>

    <class name="NSLock" supertypes="NSObject">
      <method name="`try`" signature="`try`()">
        <tags>lock</tags>
        <return type="Bool"/>
      </method>
      <method name="lock" signature="lock(before: Date)">
        <tags>lock</tags>
        <parameters>
          <param name="before" type="Date"/>
        </parameters>
        <return type="Bool"/>
      </method>
      <field name="name" type="String?"/>
    </class>

    <class name="NSDateFormatter" supertypes="NSFormatter">
      <property name="bridgeTypes" value="Foundation.DateFormatter"/>
      <constructor name="NSDateFormatter" signature="NSDateFormatter()" >
        <tags>cache_formatter</tags>
      </constructor>
    </class>

    <class name="DateFormatter" supertypes="NSFormatter">
      <property name="bridgeTypes" value="Foundation.NSDateFormatter"/>
      <constructor name="DateFormatter" signature="DateFormatter()" >
        <tags>cache_formatter</tags>
      </constructor>

      <field name="amSymbol" type="String!"/>
      <field name="calendar" type="Calendar!"/>
      <method name="date" signature="date(from: String)">
        <parameters>
          <param name="from" type="String"/>
        </parameters>
        <return type="Date?"/>
      </method>
      <field name="dateFormat" type="String!"/>
      <method name="dateFormat" signature="dateFormat(fromTemplate: String, options: Int, locale: Locale?)">
        <parameters>
          <param name="fromTemplate" type="String"/>
          <param name="options" type="Int"/>
          <param name="locale" type="Locale?"/>
        </parameters>
        <return type="String?"/>
      </method>
      <field name="dateStyle" type="DateFormatter.Style"/>
      <field name="defaultDate" type="Date?"/>
      <field name="defaultFormatterBehavior" type="DateFormatter.Behavior"/>
      <field name="doesRelativeDateFormatting" type="Bool"/>
      <field name="eraSymbols" type="[String]!"/>
      <field name="formatterBehavior" type="DateFormatter.Behavior"/>
      <field name="formattingContext" type="Formatter.Context"/>
      <field name="generatesCalendarDates" type="Bool"/>
      <method name="getObjectValue" signature="getObjectValue(AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;?, for: String, range: UnsafeMutablePointer&lt;NSRange&gt;?)">
        <parameters>
          <param name="" type="AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;?"/>
          <param name="for" type="String"/>
          <param name="range" type="UnsafeMutablePointer&lt;NSRange&gt;?"/>
        </parameters>
        <return type="func getObjectValue(_ obj: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;?, for string: String, range rangep: UnsafeMutablePointer&lt;NSRange&gt;?) throws"/>
      </method>
      <field name="gregorianStartDate" type="Date?"/>
      <field name="isLenient" type="Bool"/>
      <field name="locale" type="Locale!"/>
      <method name="localizedString" signature="localizedString(from: Date, dateStyle: DateFormatter.Style, timeStyle: DateFormatter.Style)">
        <parameters>
          <param name="from" type="Date"/>
          <param name="dateStyle" type="DateFormatter.Style"/>
          <param name="timeStyle" type="DateFormatter.Style"/>
        </parameters>
        <return type="String"/>
      </method>
      <field name="longEraSymbols" type="[String]!"/>
      <field name="monthSymbols" type="[String]!"/>
      <field name="pmSymbol" type="String!"/>
      <field name="quarterSymbols" type="[String]!"/>
      <method name="setLocalizedDateFormatFromTemplate" signature="setLocalizedDateFormatFromTemplate(String)">
        <parameters>
          <param name="" type="String"/>
        </parameters>
      </method>
      <field name="shortMonthSymbols" type="[String]!"/>
      <field name="shortQuarterSymbols" type="[String]!"/>
      <field name="shortStandaloneMonthSymbols" type="[String]!"/>
      <field name="shortStandaloneQuarterSymbols" type="[String]!"/>
      <field name="shortStandaloneWeekdaySymbols" type="[String]!"/>
      <field name="shortWeekdaySymbols" type="[String]!"/>
      <field name="standaloneMonthSymbols" type="[String]!"/>
      <field name="standaloneQuarterSymbols" type="[String]!"/>
      <field name="standaloneWeekdaySymbols" type="[String]!"/>
      <method name="string" signature="string(from: Date)">
        <parameters>
          <param name="from" type="Date"/>
        </parameters>
        <return type="String"/>
      </method>
      <field name="timeStyle" type="DateFormatter.Style"/>
      <field name="timeZone" type="TimeZone!"/>
      <field name="twoDigitStartDate" type="Date?"/>
      <field name="veryShortMonthSymbols" type="[String]!"/>
      <field name="veryShortStandaloneMonthSymbols" type="[String]!"/>
      <field name="veryShortStandaloneWeekdaySymbols" type="[String]!"/>
      <field name="veryShortWeekdaySymbols" type="[String]!"/>
      <field name="weekdaySymbols" type="[String]!"/>
    </class>

    <class name="NSObject">
      <method name="perform" signature="perform(_: Selector, with : Any?, afterDelay: TimeInterval)" >
        <parameters>
          <param type="Selector" />
          <param type="Any" name="with" />
          <param type="TimeInterval" name="afterDelay" />
        </parameters>

        <sink argpos="0" kind="unsafe_reflection" resource="other" />
      </method>
      <method name="perform" signature="perform(_ : Selector, with : Any?, afterDelay: TimeInterval, inModes : [RunLoopMode])" >
        <parameters>
          <param type="Selector" />
          <param type="Any" name="with" />
          <param type="TimeInterval" name="afterDelay" />
          <param type="Array" name="inModes" />
        </parameters>

        <sink argpos="0" kind="unsafe_reflection" resource="other" />
      </method>
      <method name="performSelector" signature="performSelector(onMainThread: Selector, with : Any?, waitUntilDone: Bool)" >
        <parameters>
          <param type="Selector" name="onMainThread" />
          <param type="Any" name="with" />
          <param type="Bool" name="waitUntilDone" />
        </parameters>

        <sink argpos="0" kind="unsafe_reflection" resource="other" />
      </method>
      <method name="performSelector" signature="performSelector(onMainThread: Selector, with : Any?, waitUntilDone: Bool, modes : [String]?)" >
        <parameters>
          <param type="Selector" name="onMainThread" />
          <param type="Any" name="with" />
          <param type="Bool" name="waitUntilDone" />
          <param type="Array" name="modes" />
        </parameters>

        <sink argpos="0" kind="unsafe_reflection" resource="other" />
      </method>
      <method name="perform" signature="perform(_ : Selector, on : Thread, with : Any?, waitUntilDone: Bool)" match="name">
        <parameters>
          <param type="Selector" />
          <param type="Thread" name="on" />
          <param type="Any" name="with" />
          <param type="Bool" name="waitUntilDone" />
        </parameters>

        <sink argpos="0" kind="unsafe_reflection" resource="other" />
      </method>
      <method name="perform" signature="perform(_ : Selector, on : Thread, with : Any?, waitUntilDone: Bool, modes : [String]?)" >
        <parameters>
          <param type="Selector" />
          <param type="Thread" name="on" />
          <param type="Any" name="with" />
          <param type="Bool" name="waitUntilDone" />
          <param type="Array" name="modes" />
        </parameters>

        <sink argpos="0" kind="unsafe_reflection" resource="other" />
      </method>
      <method name="performSelector" signature="performSelector(inBackground: Selector, with : Any?)" >
        <parameters>
          <param type="Selector" name="inBackground" />
          <param type="Any" name="with" />
        </parameters>

        <sink argpos="0" kind="unsafe_reflection" resource="other" />
      </method>
    </class>

    <class name="URLAuthenticationChallenge">
      <field name="protectionSpace" type="Foundation.URLProtectionSpace" />
    </class>

    <class name="URLProtectionSpace">
      <field name="serverTrust" type="Security.Trust.SecTrust" />
    </class>

    <class name="NSCoder" supertypes="NSObject">
      <field name="allowedClasses" type="Set&lt;AnyHashable&gt;?"/>
      <field name="allowsKeyedCoding" type="Bool"/>
      <method name="containsValue" signature="containsValue(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeArray" signature="decodeArray(ofObjCType: UnsafePointer&lt;Int8&gt;, count: Int, at: UnsafeMutableRawPointer)">
        <parameters>
          <param name="ofObjCType" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="count" type="Int"/>
          <param name="at" type="UnsafeMutableRawPointer"/>
        </parameters>
      </method>
      <method name="decodeBool" signature="decodeBool(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeBytes" signature="decodeBytes(forKey: String, returnedLength: UnsafeMutablePointer&lt;Int&gt;?)">
        <parameters>
          <param name="forKey" type="String"/>
          <param name="returnedLength" type="UnsafeMutablePointer&lt;Int&gt;?"/>
        </parameters>
      </method>
      <method name="decodeBytes" signature="decodeBytes(withReturnedLength: UnsafeMutablePointer&lt;Int&gt;)">
        <parameters>
          <param name="withReturnedLength" type="UnsafeMutablePointer&lt;Int&gt;"/>
        </parameters>
      </method>
      <method name="decodeCGAffineTransform" signature="decodeCGAffineTransform(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="CGAffineTransform"/>
      </method>
      <method name="decodeCGPoint" signature="decodeCGPoint(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="CGPoint"/>
      </method>
      <method name="decodeCGRect" signature="decodeCGRect(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="CGRect"/>
      </method>
      <method name="decodeCGSize" signature="decodeCGSize(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="CGSize"/>
      </method>
      <method name="decodeCGVector" signature="decodeCGVector(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="CGVector"/>
      </method>
      <method name="decodeCInt" signature="decodeCInt(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeData" signature="decodeData()"/>
      <method name="decodeDirectionalEdgeInsets" signature="decodeDirectionalEdgeInsets(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeDouble" signature="decodeDouble(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeFloat" signature="decodeFloat(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeInt32" signature="decodeInt32(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeInt64" signature="decodeInt64(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeInteger" signature="decodeInteger(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeObject" signature="decodeObject()"/>
      <method name="decodeObject" signature="decodeObject(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeObject" signature="decodeObject&lt;DecodedObjectType&gt;(of: DecodedObjectType.Type, forKey: String)">
        <parameters>
          <param name="of" type="DecodedObjectType.Type"/>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeObject" signature="decodeObject(of: [AnyClass]?, forKey: String)">
        <parameters>
          <param name="of" type="[AnyClass]?"/>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodePoint" signature="decodePoint()"/>
      <method name="decodePoint" signature="decodePoint(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodePropertyList" signature="decodePropertyList()"/>
      <method name="decodePropertyList" signature="decodePropertyList(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="Any?"/>
      </method>
      <method name="decodeRect" signature="decodeRect()"/>
      <method name="decodeRect" signature="decodeRect(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeSize" signature="decodeSize()"/>
      <method name="decodeSize" signature="decodeSize(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeTime" signature="decodeTime(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="CMTime"/>
      </method>
      <method name="decodeTimeMapping" signature="decodeTimeMapping(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="CMTimeMapping"/>
      </method>
      <method name="decodeTimeRange" signature="decodeTimeRange(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="CMTimeRange"/>
      </method>
      <method name="decodeTopLevelObject" signature="decodeTopLevelObject()"/>
      <method name="decodeTopLevelObject" signature="decodeTopLevelObject(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeTopLevelObject" signature="decodeTopLevelObject&lt;DecodedObjectType&gt;(of: DecodedObjectType.Type, forKey: String)">
        <parameters>
          <param name="of" type="DecodedObjectType.Type"/>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeTopLevelObject" signature="decodeTopLevelObject(of: [AnyClass]?, forKey: String)">
        <parameters>
          <param name="of" type="[AnyClass]?"/>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="decodeUIEdgeInsets" signature="decodeUIEdgeInsets(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="UIEdgeInsets"/>
      </method>
      <method name="decodeUIOffset" signature="decodeUIOffset(forKey: String)">
        <parameters>
          <param name="forKey" type="String"/>
        </parameters>
        <return type="UIOffset"/>
      </method>
      <method name="decodeValue" signature="decodeValue(ofObjCType: UnsafePointer&lt;Int8&gt;, at: UnsafeMutableRawPointer)">
        <parameters>
          <param name="ofObjCType" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="at" type="UnsafeMutableRawPointer"/>
        </parameters>
      </method>
      <method name="decodeValue" signature="decodeValue(ofObjCType: UnsafePointer&lt;Int8&gt;, at: UnsafeMutableRawPointer, size: Int)">
        <parameters>
          <param name="ofObjCType" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="at" type="UnsafeMutableRawPointer"/>
          <param name="size" type="Int"/>
        </parameters>
      </method>
      <field name="decodingFailurePolicy" type="NSCoder.DecodingFailurePolicy"/>
      <method name="encode" signature="encode(Bool, forKey: String)">
        <parameters>
          <param name="" type="Bool"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(Data)">
        <parameters>
          <param name="" type="Data"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(Double, forKey: String)">
        <parameters>
          <param name="" type="Double"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(Float, forKey: String)">
        <parameters>
          <param name="" type="Float"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(Int, forKey: String)">
        <parameters>
          <param name="" type="Int"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(Int32, forKey: String)">
        <parameters>
          <param name="" type="Int32"/>
          <param name="forKey" type="String"/>
        </parameters>
      </method>
      <method name="encode" signature="encode(Int64, forKey: String)">
        <parameters>
          <param name="" type="Int64"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(Any?)">
        <parameters>
          <param name="" type="Any?"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(Any?, forKey: String)">
        <parameters>
          <param name="" type="Any?"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(NSPoint)">
        <parameters>
          <param name="" type="NSPoint"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(NSPoint, forKey: String)">
        <parameters>
          <param name="" type="NSPoint"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(NSRect)">
        <parameters>
          <param name="" type="NSRect"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(NSRect, forKey: String)">
        <parameters>
          <param name="" type="NSRect"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(NSSize)">
        <parameters>
          <param name="" type="NSSize"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(NSSize, forKey: String)">
        <parameters>
          <param name="" type="NSSize"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(CGPoint, forKey: String)">
        <parameters>
          <param name="" type="CGPoint"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(CGRect, forKey: String)">
        <parameters>
          <param name="" type="CGRect"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(CGSize, forKey: String)">
        <parameters>
          <param name="" type="CGSize"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(CGAffineTransform, forKey: String)">
        <parameters>
          <param name="" type="CGAffineTransform"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(UIEdgeInsets, forKey: String)">
        <parameters>
          <param name="" type="UIEdgeInsets"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(UIOffset, forKey: String)">
        <parameters>
          <param name="" type="UIOffset"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(CGVector, forKey: String)">
        <parameters>
          <param name="" type="CGVector"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(CMTime, forKey: String)">
        <parameters>
          <param name="" type="CMTime"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(CMTimeRange, forKey: String)">
        <parameters>
          <param name="" type="CMTimeRange"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(CMTimeMapping, forKey: String)">
        <parameters>
          <param name="" type="CMTimeMapping"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encode" signature="encode(NSDirectionalEdgeInsets, forKey: String)">
        <parameters>
          <param name="" type="NSDirectionalEdgeInsets"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeArray" signature="encodeArray(ofObjCType: UnsafePointer&lt;Int8&gt;, count: Int, at: UnsafeRawPointer)">
        <parameters>
          <param name="ofObjCType" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="count" type="Int"/>
          <param name="at" type="UnsafeRawPointer"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeBycopyObject" signature="encodeBycopyObject(Any?)">
        <parameters>
          <param name="" type="Any?"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeByrefObject" signature="encodeByrefObject(Any?)">
        <parameters>
          <param name="" type="Any?"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeBytes" signature="encodeBytes(UnsafeRawPointer?, length: Int)">
        <parameters>
          <param name="" type="UnsafeRawPointer?"/>
          <param name="length" type="Int"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeBytes" signature="encodeBytes(UnsafePointer&lt;UInt8&gt;?, length: Int, forKey: String)">
        <parameters>
          <param name="" type="UnsafePointer&lt;UInt8&gt;?"/>
          <param name="length" type="Int"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeCInt" signature="encodeCInt(Int32, forKey: String)">
        <parameters>
          <param name="" type="Int32"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeConditionalObject" signature="encodeConditionalObject(Any?)">
        <parameters>
          <param name="" type="Any?"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeConditionalObject" signature="encodeConditionalObject(Any?, forKey: String)">
        <parameters>
          <param name="" type="Any?"/>
          <param name="forKey" type="String"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodePropertyList" signature="encodePropertyList(Any)">
        <parameters>
          <param name="" type="Any"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeRootObject" signature="encodeRootObject(Any)">
        <parameters>
          <param name="" type="Any"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <method name="encodeValue" signature="encodeValue(ofObjCType: UnsafePointer&lt;Int8&gt;, at: UnsafeRawPointer)">
        <parameters>
          <param name="ofObjCType" type="UnsafePointer&lt;Int8&gt;"/>
          <param name="at" type="UnsafeRawPointer"/>
        </parameters>
        <sink argpos="0" kind="serialization_injection" resource="other" />
      </method>
      <field name="error" type="Error?"/>
      <method name="failWithError" signature="failWithError(Error)">
        <parameters>
          <param name="" type="Error"/>
        </parameters>
      </method>
      <field name="requiresSecureCoding" type="Bool"/>
      <field name="systemVersion" type="UInt32"/>
      <method name="version" signature="version(forClassName: String)">
        <parameters>
          <param name="forClassName" type="String"/>
        </parameters>
        <return type="Int"/>
      </method>
    </class>

    <class name="NSKeyedArchiver" supertypes="Foundation.NSCoder" />

    <!-- global objects -->
    <member name="FileManager.SearchPathDirectory.documentDirectory" type="int" alias="documentDirectory" >
      <source argpos="-1" kind="other_input" resource="filesystem"><tags>document_dir</tags></source>
    </member>

    <member name="FileManager.NSSearchPathDirectory.NSDocumentDirectory" type="int" alias="NSDocumentDirectory" >
      <source argpos="-1" kind="other_input" resource="filesystem"><tags>document_dir</tags></source>
    </member>

    <class kind="protocol" name="NSCoding">
      <constructor name="NSCoding" signature="NSCoding?(coder: NSCoder)">
        <parameters>
          <param name="coder" type="NSCoder"/>
        </parameters>
      </constructor>
      <method name="encode" signature="encode(with: NSCoder)">
        <parameters>
          <param name="with" type="NSCoder"/>
        </parameters>
      </method>
    </class>


  </module>
</library>