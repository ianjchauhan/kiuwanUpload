<?xml version="1.0" encoding="UTF-8"?>
<library xmlns="http://www.optimyth.com/schema/definitions/library_metadata"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         name="dotnet" standard="dotnet" technology="csharp">

  <description url="https://docs.microsoft.com/dotnet/api/?view=netframework-4.8">.NET Framework</description>
  
  <!--  Builtin value types -->
  <class name="System.Object">
    <method name="Equals" signature="Equals(System.Object)">
      <return type="bool"/>
    </method>
    <method name="Equals_2" signature="Equals(System.Object,System.Object)" instance="false" alias="ReferenceEquals">
      <return type="bool"/>
    </method>
    <method name="GetHashCode" signature="GetHashCode()">
      <return type="System.Int32"/>
    </method>
    <method name="GetType" signature="GetType()">
      <return type="System.Type"/>
    </method>
    <method name="ToString" signature="ToString()">
      <return type="System.String"/>
    </method>
  </class>
  <class name="System.ValueType" supertypes="System.Object">
  </class>
  <class name="System.Boolean" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <method name="TryParse" signature="TryParse(string,System.Boolean)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
  </class>
  <class name="System.Byte" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <method name="TryParse" signature="TryParse(string,System.Byte)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
  </class>
  <class name="System.Char" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <method name="TryParse" signature="TryParse(string,System.Char)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
  </class>
  <class name="System.Decimal" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <method name="TryParse" signature="TryParse(string,System.Decimal)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
  </class>
  <class name="System.Double" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <method name="TryParse" signature="TryParse(string,System.Double)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
  </class>
  <class name="System.Int16" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <method name="TryParse" signature="TryParse(string,System.Int16)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
  </class>
  <class name="System.Int32" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <field name="MaxValue" type="System.Int32" />
    <method name="TryParse" signature="TryParse(string,System.Int32)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
    <method name="Parse" signature="Parse(string)" match="name">
      <return type="System.Int32"/>
      <propagate from="0" to="-1"/>
    </method>
  </class>
  <class name="System.Int64" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <method name="TryParse" signature="TryParse(string,System.Int64)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
    <method name="Parse" signature="Parse(string)" match="name">
      <return type="System.Int32"/>
      <propagate from="0" to="-1"/>
    </method>
  </class>
  <class name="System.SByte" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <method name="TryParse" signature="TryParse(string,System.SByte)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
  </class>
  <class name="System.Single" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
    <method name="TryParse" signature="TryParse(string,System.SByte)">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
  </class>
  <class name="System.UInt16" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
  </class>
  <class name="System.UInt32" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
  </class>
  <class name="System.UInt64" kind="struct" supertypes="System.ValueType">
    <tags>valuetype</tags>
  </class>
  <class name="System.Array" kind="struct" supertypes="System.ValueType">
    <field name="Length" type="int">
      <tags>potential_infinite_loop_neutralizer</tags>
    </field>
    <method name="Contains" signature="Contains(System.Array, item)">
      <return type="bool"/>
      <neutralization argpos="-2" kind="string"/>
    </method>
  </class>

  <!-- Primitive types for C# and VB.Net, aliases of standard .Net type -->
  <class name="bool" kind="struct" supertypes="System.Boolean">
    <tags>valuetype</tags>
  </class>
  <class name="Boolean" kind="struct" supertypes="System.Boolean">
    <tags>valuetype</tags>
  </class>
  <class name="byte" kind="struct" supertypes="System.Byte">
    <tags>valuetype</tags>
  </class>
  <class name="Byte" kind="struct" supertypes="System.Byte">
    <tags>valuetype</tags>
  </class>
  <class name="char" kind="struct" supertypes="System.Char">
    <tags>valuetype</tags>
  </class>
  <class name="Char" kind="struct" supertypes="System.Char">
    <tags>valuetype</tags>
  </class>
  <class name="decimal" kind="struct" supertypes="System.Decimal">
    <tags>valuetype</tags>
  </class>
  <class name="Decimal" kind="struct" supertypes="System.Decimal">
    <tags>valuetype</tags>
  </class>
  <class name="double" kind="struct" supertypes="System.Double">
    <tags>valuetype</tags>
  </class>
  <class name="Double" kind="struct" supertypes="System.Double">
    <tags>valuetype</tags>
  </class>
  <class name="float" kind="struct" supertypes="System.Single">
    <tags>valuetype</tags>
  </class>
  <class name="Single" kind="struct" supertypes="System.Single">
    <tags>valuetype</tags>
  </class>
  <class name="int" kind="struct" supertypes="System.Int32">
    <tags>valuetype</tags>
  </class>
  <class name="Integer" kind="struct" supertypes="System.Int32">
    <tags>valuetype</tags>
  </class>
  <class name="long" kind="struct" supertypes="System.Int64">
    <tags>valuetype</tags>
  </class>
  <class name="Long" kind="struct" supertypes="System.Int64">
    <tags>valuetype</tags>
  </class>
  <class name="sbyte" kind="struct" supertypes="System.SByte">
    <tags>valuetype</tags>
  </class>
  <class name="SByte" kind="struct" supertypes="System.SByte">
    <tags>valuetype</tags>
  </class>
  <class name="short" kind="struct" supertypes="System.Int16">
    <tags>valuetype</tags>
  </class>
  <class name="Short" kind="struct" supertypes="System.Int16">
    <tags>valuetype</tags>
  </class>
  <class name="uint" kind="struct" supertypes="System.UInt32">
    <tags>valuetype</tags>
  </class>
  <class name="UInteger" kind="struct" supertypes="System.UInt32">
    <tags>valuetype</tags>
  </class>
  <class name="ulong" kind="struct" supertypes="System.UInt64">
    <tags>valuetype</tags>
  </class>
  <class name="ULong" kind="struct" supertypes="System.UInt64">
    <tags>valuetype</tags>
  </class>
  <class name="ushort" kind="struct" supertypes="System.UInt16">
    <tags>valuetype</tags>
  </class>
  <class name="UShort" kind="struct" supertypes="System.UInt16">
    <tags>valuetype</tags>
  </class>
  <class name="array" kind="struct" supertypes="System.Array" >
    <method name="Contains" signature="Contains(item)">
      <return type="bool"/>
      <neutralization argpos="0,-2" kind="string"/>
    </method>
  </class>

  <!-- Propagations and neutralizations via common objects -->
  <class name="System.String" supertypes="System.Object">
    <description>String</description>
    <!-- String constructors, propagate tainting from first arg to the returned string -->
    <constructor name="String" signature="String(Char[])">
      <propagate from="0" to="-1"/>
    </constructor>
    <constructor name="String" signature="String(Char[],Int32,Int32)">
      <propagate from="0" to="-1"/>
    </constructor>
    <field name="Length" type="int">
      <tags>potential_infinite_loop</tags>
    </field>
    <field name="Chars" type="array" elementType="char"/>
    <method name="Concat" signature="Concat(string,string)">
      <return type="string"/>
      <propagate from="0,1" to="-1"/>
    </method>
    <method name="Concat" signature="Concat(string,string,string)">
      <return type="string"/>
      <propagate from="0,1,2" to="-1"/>
    </method>
    <method name="Concat" signature="Concat(string,string,string,string)">
      <return type="string"/>
      <propagate from="0,1,2,3" to="-1"/>
    </method>
    <method name="EndsWith" signature="EndsWith(string)">
      <neutralization argpos="-2" kind="string"/>
    </method>
    <method name="EndsWith" signature="EndsWith(string,stringComparison)">
      <neutralization argpos="-2" kind="string"/>
    </method>
    <method name="EndsWith" signature="EndsWith(string,Boolean,CultureInfo)">
      <neutralization argpos="-2" kind="string"/>
    </method>
    <method name="Format" signature="Format(string,Object...)" match="name">
      <return type="string"/>
      <propagate from="0,1" to="-1"/>
    </method>
    <method name="Format" signature="Format(IFormatProvider,string,Object)">
      <return type="string"/>
      <propagate from="1,2" to="-1"/>
    </method>
    <method name="Insert" signature="Insert(Int,string)">
      <return type="string"/>
      <propagate from="1" to="-1"/>
    </method>
    <method name="IsNullOrEmpty" signature="IsNullOrEmpty(string)" alias="IsNullOrWhiteSpace">
      <return type="bool"/>
      <neutralization argpos="0" kind="nullable" resource="memory"/>
    </method>
    <method name="Join" signature="Join(string,System.Collections.IEnumerable)">
      <return type="string"/>
      <propagate from="0,1" to="-1"/>
    </method>
    <method name="Join" signature="Join(string,System.Collections.IEnumerable)">
      <return type="string"/>
      <propagate from="0,1" to="-1"/>
    </method>
    <!--  Replacement methods propagate tainting to the returned string and neutralize tainting for receiver object-->
    <method name="Replace" signature="Replace(string,string)">
      <return type="string"/>
      <neutralization argpos="-2" kind="string"/>
    </method>
    <method name="StartsWith" signature="StartsWith(string)">
      <return type="bool"/>
      <neutralization argpos="-2" kind="string"/>
    </method>
    <method name="StartsWith" signature="StartsWith(string,stringComparison)">
      <return type="bool"/>
      <neutralization argpos="-2" kind="string"/>
    </method>
    <method name="StartsWith" signature="StartsWith(string,Boolean,CultureInfo)">
      <return type="bool"/>
      <neutralization argpos="-2" kind="string"/>
    </method>
    <method name="Substring" signature="Substring(Int32)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="Substring" signature="Substring(Int32,Int32)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToCharArray" signature="ToCharArray(void)">
      <return type="array"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToCharArray" signature="ToCharArray(Int32,Int32)">
      <return type="array"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToLower" signature="ToLower(void)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToLower" signature="ToLower(System.Globalization.CultureInfo)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToLowerInvariant" signature="ToLowerInvariant(void)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToString" signature="ToString(void)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToString" signature="ToString(IFormatProvider)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToUpper" signature="ToUpper(void)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToUpper" signature="ToUpper(System.Globalization.CultureInfo)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="ToUpperInvariant" signature="ToUpperInvariant(void)">
      <return type="string"/>
      <propagate from="-2" to="-1"/>
    </method>
    <method name="IndexOfAny" signature="IndexOfAny(array)" match="name" >
      <return type="int"/>
      <neutralization argpos="-2" kind="path_traversal"/>
    </method>
  </class>

  <!-- C# primitive String type -->
  <class name="string" supertypes="System.String"/>
  <!-- VB.Net primitive String type -->
  <class name="String" supertypes="System.String"/>

  <class name="System.Text.StringBuilder">
    <description>String builder</description>
    <constructor name="StringBuilder" signature="StringBuilder(string)">
      <propagate from="0" to="-1"/>
    </constructor>
    <constructor name="StringBuilder" signature="StringBuilder(string,Int32)">
      <propagate from="0" to="-1"/>
    </constructor>
    <constructor name="StringBuilder" signature="StringBuilder(string,Int32,Int32,Int32)">
      <propagate from="0" to="-1"/>
    </constructor>
    <method name="Append" signature="Append(string)">
      <return type="System.Text.StringBuilder"/>
      <propagate from="0" to="-1,-2"/>
    </method>
    <method name="Append" signature="Append(string,Int32,Int32)">
      <return type="System.Text.StringBuilder"/>
      <propagate from="0" to="-1,-2"/>
    </method>
    <method name="AppendFormat" signature="AppendFormat(string,Object[])">
      <return type="System.Text.StringBuilder"/>
      <propagate from="1" to="-1,-2"/>
    </method>
    <method name="AppendLine" signature="AppendLine(string)">
      <return type="System.Text.StringBuilder"/>
      <propagate from="0" to="-1,-2"/>
    </method>
    <method name="Clear" signature="Clear(void)">
      <return type="System.Text.StringBuilder"/>
      <neutralization argpos="-1,-2" kind="string"/>
    </method>
    <method name="Insert" signature="Insert(Int32,string)">
      <return type="System.Text.StringBuilder"/>
      <propagate from="1" to="-1,-2"/>
    </method>
    <method name="Remove" signature="Remove(Int,Int)">
      <return type="System.Text.StringBuilder"/>
      <neutralization argpos="-1" kind="string"/>
    </method>
    <method name="Replace" signature="Replace(string,string)">
      <return type="System.Text.StringBuilder"/>
      <propagate from="-2,1" to="-1"/>
      <neutralization argpos="-1" kind="string"/>
    </method>
    <method name="Replace" signature="Replace(string,string,Int32,Int32)">
      <return type="System.Text.StringBuilder"/>
      <propagate from="-2,1" to="-1"/>
      <neutralization argpos="-1" kind="string"/>
    </method>
    <method name="ToString" signature="ToString()">
      <return type="string"/>
      <propagate from="-2,1" to="-1"/>
    </method>
  </class>

  <class name="System.IDisposable" kind="interface">
    <method name="Dispose" signature="Dispose()"/>
  </class>
  
  <class name="System.Nullable" kind="struct">
    <field name="HasValue" type="bool">
      <tags>kills_nullable</tags>
    </field>
    <field name="Value" type="object">
      <tags>nullable</tags>
    </field>
    <method name="GetValueOrDefault" signature="GetValueOrDefault()">
      <neutralization argpos="-1" kind="nullable" resource="memory"/>
    </method>
    <method name="GetValueOrDefault" signature="GetValueOrDefault(object)">
      <propagate from="-2,0" to="-1"/>
    </method>
  </class>

  <class name="System.Convert">
    <method name="ToBoolean" signature="ToBoolean(string)" instance="false">
      <return type="bool"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToChar" signature="ToChar(string)" instance="false" match="name">
      <return type="char"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToDateTime" signature="ToDateTime(string)" instance="false" match="name">
      <return type="System.DateTime"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToDecimal" signature="ToDecimal(string)" instance="false" match="name">
      <return type="System.Decimal"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToDouble" signature="ToDouble(string)" instance="false" match="name">
      <return type="double"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToInt16" signature="ToInt16(string)" instance="false" match="name">
      <return type="short"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToInt32" signature="ToInt32(string)" instance="false" match="name">
      <return type="int"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToInt64" signature="ToInt64(string)" instance="false" match="name">
      <return type="long"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToSByte" signature="ToSByte(string)" instance="false" match="name">
      <return type="sbyte"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToSingle" signature="ToSingle(string)" instance="false" match="name">
      <return type="float"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToUInt16" signature="ToUInt16(string)" instance="false" match="name">
      <return type="ushort"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToInt32" signature="ToInt32(string)" instance="false" match="name">
      <return type="uint"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="ToUInt64" signature="ToUInt64(string)" instance="false" match="name">
      <return type="ulong"/>
      <neutralization argpos="0" kind="string"/>
    </method>
  </class>

  <class name="Microsoft.VisualBasic.Information">
    <method name="IsArray" signature="IsArray(object)" instance="false" alias="IsDate,IsError,IsNumeric">
      <return type="bool"/>
      <neutralization argpos="0" kind="nullable" resource="memory"/>
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="IsReference" signature="IsReference(object)" instance="false"
            alias="IsDBNull,IsNothing">
      <return type="bool"/>
      <neutralization argpos="0" kind="nullable" resource="memory"/>
    </method>
  </class>

  <class name="System.Uri">
    <description>Provides an object representation of a uniform resource identifier (URI).</description>
    <constructor name="Uri" signature="Uri(string)">
      <propagate from="0" to="-1"/>
    </constructor>
    <method name="IsWellFormedUriString(string,Int32)" signature="IsWellFormedUriString(string,Int32)">
      <neutralization argpos="0" kind="string"/>
    </method>
  </class>

  <!-- COLLECTIONS -->
  <!-- NON GENERIC  -->
  <class name="System.Collections.IEnumerable" kind="interface">
    <method name="GetEnumerator" signature="GetEnumerator(void)">
      <return type="System.Collections.IEnumerator"/>
      <propagate from="-2" to="-1"/>
    </method>
  </class>

  <class name="System.Collections.IEnumerator" kind="interface">
    <field name="Current" type="object">
      <propagate from="-2" to="-1"/>
    </field>
  </class>

  <class name="System.Collections.Generic.IReadOnlyCollection" supertypes="System.Collections.IEnumerable">
  </class>

  <class name="System.Collections.ReadOnlyCollectionBase" supertypes="System.Collections.ICollection"></class>

  <class name="System.Collections.Generic.IReadOnlyList" supertypes="System.Collections.Generic.IReadOnlyCollection">
  </class>

  <class name="System.Collections.ICollection" kind="interface" supertypes="System.Collections.IEnumerable">
    <method name="Add" signature="Add(T)" match="name">
      <propagate from="0" to="-2"/>
    </method>
    <method name="Clear" signature="Clear()">
      <neutralization argpos="-2" kind="*"/>
    </method>
    <method name="CopyTo" signature="CopyTo(T[],Int32)" match="name">
      <propagate from="-2" to="0"/>
    </method>
    <method name="Remove" signature="Remove(T)" match="name">
      <neutralization argpos="-2" kind="*"/>
    </method>
  </class>

  <class name="System.Collections.IList" kind="interface" supertypes="System.Collections.ICollection">
    <method name="Insert" signature="Insert(Int32,T)" match="name">
      <propagate from="1" to="-2"/>
    </method>
    <method name="RemoveAt" signature="RemoveAt(Int32)" match="name">
      <neutralization argpos="-1"  kind="*"/>
    </method>
  </class>

  <class name="System.Collections.ArrayList" kind="interface" supertypes="System.Collections.IList">
    <tags>mutable</tags>
  </class>

  <class name="System.Collections.IDictionary" kind="interface" supertypes="System.Collections.ICollection">
    <field name="Item" type="array">
      <propagate from="-2" to="-1"/>
    </field>
    <field name="Keys" type="array">
      <propagate from="-2" to="-1"/>
    </field>
    <field name="Values" type="array">
      <propagate from="-2" to="-1"/>
    </field>
    <method name="Add" signature="Add(T,T)" match="name">
      <propagate from="0,1" to="-1, -2"/>
    </method>
    <method name="TryGetValue" signature="TryGetValue(T,T)" match="name">
      <tags>retval-needs-check</tags>
      <propagate from="-2" to="1"/>
    </method>
  </class>

  <class name="System.Collections.DictionaryBase" kind="interface" supertypes="System.Collections.IDictionary"/>
  <class name="System.Collections.Hashtable" supertypes="System.Collections.IDictionary">
    <tags>mutable</tags>
  </class>

  <!-- GENERIC  -->
  <class name="System.Collections.Generic.IEnumerable" kind="interface">
    <method name="GetEnumerator" signature="GetEnumerator(void)">
      <return type="System.Collections.Generic.IEnumerator"/>
      <propagate from="-2" to="-1"/>
    </method>
  </class>

  <class name="System.Collections.Generic.IEnumerator" kind="interface">
    <field name="Current" type="T">
      <propagate from="-2" to="-1"/>
    </field>
  </class>

  <class name="System.Collections.Generic.ICollection" kind="interface" supertypes="System.Collections.Generic.IEnumerable">
    <method name="Add" signature="Add(T)" match="name">
      <propagate from="0" to="-2"/>
    </method>
    <method name="Clear" signature="Clear()">
      <neutralization argpos="-2"  kind="*"/>
    </method>
    <method name="CopyTo" signature="CopyTo(T[],Int32)" match="name">
      <propagate from="-2" to="0"/>
    </method>
    <method name="Remove" signature="Remove(T)" match="name">
      <neutralization argpos="-1"  kind="*"/>
    </method>
  </class>

  <class name="System.Collections.Generic.IList" kind="interface" supertypes="System.Collections.Generic.ICollection">
    <field name="Item" type="array">
      <propagate from="-2" to="-1"/>
    </field>
    <method name="Insert" signature="Insert(Int32,T)" match="name">
      <propagate from="1" to="-2"/>
    </method>
    <method name="RemoveAt" signature="RemoveAt(Int32)" match="name">
      <neutralization argpos="-1"  kind="*"/>
    </method>
  </class>

  <class name="System.Collections.Generic.List" supertypes="System.Collections.Generic.IList">
    <tags>mutable</tags>
    <method name="AddRange" signature="AddRange(System.Collections.IEnumerable)" match="name">
      <propagate from="0" to="-2"/>
    </method>
    <method name="InsertRange" signature="InsertRange(int,System.Collections.IEnumerable)" match="name">
      <propagate from="1" to="-2"/>
    </method>
    <method name="RemoveRange" signature="RemoveRange(int,int)" match="name">
      <neutralization argpos="-1" kind="*"/>
    </method>
    <method name="ToArray" signature="ToArray()" match="name">
      <return type="array"/>
      <propagate from="-2" to="-1"/>
    </method>
  </class>

  <class name="System.Collections.Generic.IDictionary" kind="interface" supertypes="System.Collections.Generic.ICollection">
    <field name="Item" type="array">
      <propagate from="-2" to="-1"/>
    </field>
    <field name="Keys" type="array">
      <propagate from="-2" to="-1"/>
    </field>
    <field name="Values" type="array">
      <propagate from="-2" to="-1"/>
    </field>
    <method name="Add" signature="Add(T,T)" match="name">
      <propagate from="0,1" to="-1"/>
    </method>
    <method name="TryGetValue" signature="TryGetValue(T,T)" match="name">
      <tags>retval-needs-check</tags>
      <propagate from="-2" to="1"/>
    </method>
  </class>

  <class name="System.Collections.Generic.Dictionary" kind="interface" supertypes="System.Collections.Generic.IDictionary">
    <tags>mutable</tags>
    <constructor name="Dictionary" signature="Dictionary(IDictionary)">
      <propagate from="0" to="-2"/>
    </constructor>
  </class>

  <class name="System.Collections.Specialized.NameObjectCollectionBase" supertypes="System.Collections.Generic.ICollection">
  </class>

  <!-- EXCEPTIONS -->
  <class name="System.Exception">
    <description>Base class for exceptions.</description>
    <constructor name="Exception" signature="Exception(string)">
      <!-- LR - Creating an exception does not leak anything ... Unless exception is dumped to end-users later -->
      <!--sink argpos="0" kind="information_leak" resource="other"/-->
    </constructor>
    <field name="Data" type="string">
      <source kind="system_information" resource="other" argpos="-1"/>
    </field>
    <field name="Message" type="string">
      <source kind="system_information" resource="other" argpos="-1"/>
    </field>
    <field name="Source" type="string">
      <source kind="system_information" resource="other" argpos="-1"/>
    </field>
    <field name="StackTrace" type="string">
      <source kind="system_information" resource="other" argpos="-1"/>
    </field>
    <field name="TargetSite" type="string">
      <source kind="system_information" resource="other" argpos="-1"/>
    </field>
    <method name="ToString" signature="ToString(void)">
      <return type="string"/>
      <source kind="system_information" resource="other" argpos="-1"/>
    </method>
  </class>

  <class name="System.DateTime" kind="struct">
    <method name="TryParse" signature="TryParse(string,System.DateTime)" match="name" alias="TryParseExact">
      <tags>retval-needs-check</tags>
      <return type="bool"/>
    </method>
  </class>

  <!-- VB.Net primitive Date type -->
  <class name="Date" kind="struct" supertypes="System.DateTime"/>

  <class name="System.Random">
    <tags>insecure_random</tags>
    <method name="Next" signature="Next()" alias="name">
      <tags>random, data:-1</tags>
      <return type="int"/>
      <sink argpos="-1" kind="insecure_random" resource="crypto"/>
    </method>
    <method name="NextBytes" signature="NextBytes(byte[])">
      <tags>random, data:0</tags>
      <sink argpos="0" kind="insecure_random" resource="crypto"/>
    </method>
    <method name="NextDouble" signature="NextDouble()" alias="Sample">
      <tags>random, data:-1</tags>
      <return type="double"/>
      <sink argpos="-1" kind="insecure_random" resource="crypto"/>
    </method>
  </class>

  <class name="Microsoft.Build.BuildEngine.InternalLoggerException" supertypes="System.Exception"/>
  <class name="Microsoft.Build.BuildEngine.InvalidProjectFileException" supertypes="System.Exception"/>
  <class name="Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException" supertypes="System.Exception"/>
  <class name="Microsoft.Build.BuildEngine.RemoteErrorException" supertypes="System.Exception"/>
  <class name="Microsoft.Build.Exceptions.BuildAbortedException" supertypes="System.Exception"/>
  <class name="Microsoft.Build.Exceptions.InternalLoggerException" supertypes="System.Exception"/>
  <class name="Microsoft.Build.Exceptions.InvalidProjectFileException" supertypes="System.Exception"/>
  <class name="Microsoft.Build.Exceptions.InvalidToolsetDefinitionException" supertypes="System.Exception"/>
  <class name="Microsoft.Build.Framework.LoggerException" supertypes="System.Exception"/>
  <class name="Microsoft.CSharp.RuntimeBinder.RuntimeBinderException" supertypes="System.Exception"/>
  <class name="Microsoft.CSharp.RuntimeBinder.RuntimeBinderInternalCompilerException" supertypes="System.Exception"/>
  <class name="Microsoft.JScript.CmdLineException" supertypes="System.Exception"/>
  <class name="Microsoft.JScript.ParserException" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.ApplicationServices.CantStartSingleInstanceException" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.ApplicationServices.NoStartupFormException" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebClassContainingClassNotOptional" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebClassCouldNotFindEvent" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebClassNextItemCannotBeCurrentWebItem" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebClassNextItemRespondNotFound" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebClassUserWebClassNameNotOptional" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebClassWebClassFileNameNotOptional" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebClassWebItemNotValid" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebItemAssociatedWebClassNotOptional" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebItemClosingTagNotFound" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebItemCouldNotLoadEmbeddedResource" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebItemCouldNotLoadTemplateFile" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebItemNameNotOptional" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebItemNoTemplateSpecified" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebItemTooManyNestedTags" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.Compatibility.VB6.WebItemUnexpectedErrorReadingTemplateFile" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.CompilerServices.IncompleteInitialization" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.CompilerServices.InternalErrorException" supertypes="System.Exception"/>
  <class name="Microsoft.VisualBasic.FileIO.MalformedLineException" supertypes="System.Exception"/>
  <class name="System.Activities.DynamicUpdate.InstanceUpdateException" supertypes="System.Exception"/>
  <class name="System.Activities.ExpressionParser.SourceExpressionException" supertypes="System.Exception"/>
  <class name="System.Activities.Expressions.LambdaSerializationException" supertypes="System.Exception"/>
  <class name="System.Activities.InvalidWorkflowException" supertypes="System.Exception"/>
  <class name="System.Activities.Presentation.Metadata.AttributeTableValidationException" supertypes="System.Exception"/>
  <class name="System.Activities.Statements.WorkflowTerminatedException" supertypes="System.Exception"/>
  <class name="System.Activities.VersionMismatchException" supertypes="System.Exception"/>
  <class name="System.Activities.WorkflowApplicationException" supertypes="System.Exception"/>
  <class name="System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException" supertypes="System.Exception"/>
  <class name="System.AddIn.Hosting.InvalidPipelineStoreException" supertypes="System.Exception"/>
  <class name="System.AggregateException" supertypes="System.Exception"/>
  <class name="System.ApplicationException" supertypes="System.Exception"/>
  <class name="System.ComponentModel.Composition.CompositionContractMismatchException" supertypes="System.Exception"/>
  <class name="System.ComponentModel.Composition.CompositionException" supertypes="System.Exception"/>
  <class name="System.ComponentModel.Composition.ImportCardinalityMismatchException" supertypes="System.Exception"/>
  <class name="System.ComponentModel.Composition.Primitives.ComposablePartException" supertypes="System.Exception"/>
  <class name="System.ComponentModel.DataAnnotations.ValidationException" supertypes="System.Exception"/>
  <class name="System.ComponentModel.Design.ExceptionCollection" supertypes="System.Exception"/>
  <class name="System.Configuration.Provider.ProviderException" supertypes="System.Exception"/>
  <class name="System.Configuration.SettingsPropertyIsReadOnlyException" supertypes="System.Exception"/>
  <class name="System.Configuration.SettingsPropertyNotFoundException" supertypes="System.Exception"/>
  <class name="System.Configuration.SettingsPropertyWrongTypeException" supertypes="System.Exception"/>
  <class name="System.Data.Linq.ChangeConflictException" supertypes="System.Exception"/>
  <class name="System.Diagnostics.Eventing.Reader.EventLogException" supertypes="System.Exception"/>
  <class name="System.Diagnostics.Tracing.EventSourceException" supertypes="System.Exception"/>
  <class name="System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectExistsException" supertypes="System.Exception"/>
  <class name="System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException" supertypes="System.Exception"/>
  <class name="System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException" supertypes="System.Exception"/>
  <class name="System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException" supertypes="System.Exception"/>
  <class name="System.DirectoryServices.Protocols.DirectoryException" supertypes="System.Exception"/>
  <class name="System.DivideByZeroException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.AsynchronousOperationException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Metadata.MetadataSerializationException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Protocols.WSTrust.WSTrustSerializationException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.RequestException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Selectors.CardSpaceException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Selectors.IdentityValidationException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Selectors.PolicyValidationException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Selectors.ServiceBusyException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Selectors.ServiceNotStartedException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Selectors.StsCommunicationException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Selectors.UnsupportedPolicyOptionsException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Selectors.UntrustedRecipientException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Selectors.UserCancellationException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Services.AsynchronousOperationException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Services.FederatedAuthenticationSessionEndingException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Services.FederationException" supertypes="System.Exception"/>
  <class name="System.IdentityModel.Services.WSFederationMessageException" supertypes="System.Exception"/>
  <class name="System.InvalidTimeZoneException" supertypes="System.Exception"/>
  <class name="System.Management.Instrumentation.InstrumentationBaseException" supertypes="System.Exception"/>
  <class name="System.Management.Instrumentation.WmiProviderInstallationException" supertypes="System.Exception"/>
  <class name="System.Runtime.CompilerServices.RuntimeWrappedException" supertypes="System.Exception"/>
  <class name="System.Runtime.DurableInstancing.InstancePersistenceException" supertypes="System.Exception"/>
  <class name="System.Runtime.Remoting.MetadataServices.SUDSGeneratorException" supertypes="System.Exception"/>
  <class name="System.Runtime.Remoting.MetadataServices.SUDSParserException" supertypes="System.Exception"/>
  <class name="System.Runtime.Serialization.InvalidDataContractException" supertypes="System.Exception"/>
  <class name="System.Security.RightsManagement.RightsManagementException" supertypes="System.Exception"/>
  <class name="System.ServiceModel.Channels.InvalidChannelBindingException" supertypes="System.Exception"/>
  <class name="System.SystemException" supertypes="System.Exception"/>
  <class name="System.Threading.BarrierPostPhaseException" supertypes="System.Exception"/>
  <class name="System.Threading.LockRecursionException" supertypes="System.Exception"/>
  <class name="System.Threading.Tasks.TaskSchedulerException" supertypes="System.Exception"/>
  <class name="System.TimeZoneNotFoundException" supertypes="System.Exception"/>
  <class name="System.Windows.Automation.NoClickablePointException" supertypes="System.Exception"/>
  <class name="System.Windows.Automation.ProxyAssemblyNotLoadedException" supertypes="System.Exception"/>
  <class name="System.Windows.Controls.PrintDialogException" supertypes="System.Exception"/>
  <class name="System.Windows.Xps.XpsException" supertypes="System.Exception"/>
  <class name="System.Windows.Xps.XpsWriterException" supertypes="System.Exception"/>
  <class name="System.Workflow.Activities.Rules.RuleException" supertypes="System.Exception"/>
  <class name="System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException" supertypes="System.Exception"/>
  <class name="System.Workflow.ComponentModel.Serialization.WorkflowMarkupSerializationException" supertypes="System.Exception"/>
  <class name="System.Workflow.ComponentModel.WorkflowTerminatedException" supertypes="System.Exception"/>
  <class name="System.Workflow.Runtime.WorkflowOwnershipException" supertypes="System.Exception"/>
  <class name="System.Xaml.XamlException" supertypes="System.Exception"/>

  <!-- Threads and synchronization -->

  <class name="System.Threading.Thread">
    <constructor name="Thread" signature="Thread(System.Threading.ParameterizedThreadStart,int)" match="name"/>
    <field name="CurrentContext" type="System.Runtime.Remoting.Contexts.Context" instance="false"/>
    <field name="CurrentPrincipal" type="System.Security.Principal.IPrincipal" instance="false"/>
    <field name="CurrentThread" type="System.Threading.Thread" instance="false"/>
    <field name="ExecutionContext" type="System.Threading.ExecutionContext"/>
    <field name="IsAlive" type="bool"/>
    <field name="IsBackground" type="bool"/>
    <field name="IsThreadPoolThread" type="bool"/>
    <field name="ManagedThreadId" type="int"/>
    <field name="Name" type="string"/>
    <field name="Priority" type="System.Threading.ThreadPriority"/>
    <field name="ThreadState" type="System.Threading.ThreadState"/>
    <method name="Abort" signature="Abort(object)" match="name"/>
    <method name="BeginCriticalRegion" signature="BeginCriticalRegion()" instance="false"/>
    <method name="EndCriticalRegion" signature="EndCriticalRegion()" instance="false"/>
    <method name="GetDomain" signature="GetDomain()" instance="false">
      <return type="System.AppDomain"/>
    </method>
    <method name="Interrupt" signature="Interrupt()"/>
    <method name="Join" signature="Join()"/>
    <method name="Join" signature="Join(System.TimeSpan)">
      <return type="bool"/>
    </method>
    <method name="MemoryBarrier" signature="MemoryBarrier()" instance="false"/>
    <method name="ResetAbort" signature="ResetAbort()" instance="false"/>
    <method name="Resume" signature="Resume()">
      <tags>obsolete,dangerous</tags>
    </method>
    <method name="Sleep" signature="Sleep(System.TimeSpan)" instance="false"/>
    <method name="SpinWait" signature="SpinWait(int)" instance="false"/>
    <method name="Start" signature="Start()"/>
    <method name="Start" signature="Start(object)"/>
    <method name="Suspend" signature="Suspend()">
      <tags>obsolete,dangerous</tags>
    </method>
    <method name="Yield" signature="Yield()" instance="false">
      <return type="bool"/>
    </method>
  </class>

  <class name="System.Threading.ThreadPool">
    <method name="BindHandle" signature="BindHandle(System.IntPtr)" instance="false">
      <tags>obsolete</tags><return type="bool"/>
    </method>
    <method name="BindHandle" signature="BindHandle(System.Runtime.InteropServices.SafeHandle)" instance="false">
      <return type="bool"/>
    </method>
    <method name="QueueUserWorkItem" signature="QueueUserWorkItem(System.Threading.WaitCallback,object)"
            instance="false" match="name" alias="UnsafeQueueUserWorkItem">
      <return type="bool"/>
    </method>
    <method name="RegisterWaitForSingleObject"
            signature="RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,object,System.TimeSpan,bool)"
            instance="false" alias="UnsafeRegisterWaitForSingleObject">
      <return type="System.Threading.RegisteredWaitHandle"/>
    </method>
    <method name="UnsafeQueueNativeOverlapped" signature="UnsafeQueueNativeOverlapped(NativeOverlapped*)" instance="false"/>
    <method name="GetAvailableThreads" signature="GetAvailableThreads(int,int)"/>
    <method name="GetMaxThreads" signature="GetMaxThreads(int,int)"/>
    <method name="SetMaxThreads" signature="SetMaxThreads(int,int)"/>
    <method name="GetMinThreads" signature="GetMinThreads(int,int)"/>
    <method name="SetMinThreads" signature="SetMinThreads(int,int)"/>
  </class>

  <class name="System.Threading.Monitor">
    <method name="Enter" signature="Enter(object)" instance="false">
      <tags>lock</tags>
    </method>
    <method name="Enter" signature="Enter(object,bool)" instance="false">
      <tags>lock</tags>
    </method>
    <method name="Exit" signature="Exit(object)" instance="false">
      <tags>unlock</tags>
    </method>
    <method name="IsEntered" signature="IsEntered(object)" instance="false">
      <return type="bool"/>
    </method>
    <method name="Pulse" signature="Pulse(object)" instance="false">
      <tags>notify</tags>
    </method>
    <method name="PulseAll" signature="PulseAll(object)" instance="false">
      <tags>notify</tags>
    </method>
    <method name="TryEnter" signature="TryEnter(object)" instance="false">
      <tags>lock</tags>
      <return type="bool"/>
    </method>
    <method name="TryEnter" signature="TryEnter(object,System.TimeSpan)" instance="false">
      <tags>lock</tags>
      <return type="bool"/>
    </method>
    <method name="TryEnter" signature="TryEnter(object,System.TimeSpan,bool)" instance="false">
      <tags>lock</tags>
    </method>
    <method name="Wait" signature="Wait(object)" instance="false">
      <tags>wait</tags>
      <return type="bool"/><!-- always true, or does not return -->
    </method>
    <method name="Wait" signature="Wait(object,System.TimeSpan)" instance="false">
      <tags>wait</tags>
      <return type="bool"/><!-- does not return until the lock is reacquired -->
    </method>
    <method name="Wait" signature="Wait(object,System.TimeSpan,bool)" instance="false">
      <tags>wait</tags>
      <return type="bool"/><!-- does not return until the lock is reacquired -->
    </method>
  </class>

  <class name="System.Threading.Mutex">
    <tags>sync_leak,disposable</tags>
    <method name="Close" signature="Close()">
      <neutralization argpos="-2" kind="sync_leak"/>
    </method>
    <method name="OpenExisting" signature="OpenExisting(string)" match="name">
      <return type="System.Threading.Mutex"/>
    </method>
    <method name="ReleaseMutex" signature="ReleaseMutex()">
      <tags>unlock</tags>
    </method>
    <method name="WaitOne" signature="WaitOne()" match="name">
      <tags>lock</tags>
    </method>
  </class>

  <class name="System.Threading.TimerCallback" kind="interface"/>

  <class name="System.Threading.Timer">
    <tags>timer</tags>
    <constructor name="Timer" signature="Timer(System.Threading.TimerCallback)" match="numargs">
      <tags>callback:0</tags>
    </constructor>
    <constructor name="Timer_1" signature="Timer(System.Threading.TimerCallback,object,int,int)" match="numargs">
      <tags>callback:0,dueTime:2,period:3</tags>
    </constructor>
    <method name="Change" signature="Change(int,int)" match="numargs">
      <tags>dueTime:0,period:1</tags>
    </method>
  </class>

  <class name="System.Threading.Tasks.Task"/>

  <!-- Information leakage -->

  <class name="System.Console">
    <field name="Error" type="System.IO.TextWriter" instance="false"/>
    <field name="In" type="System.IO.TextReader" instance="false"/>
    <field name="Out" type="System.IO.TextWriter" instance="false"/>
    <method name="OpenStandardError" signature="OpenStandardError()" instance="false" match="name">
      <return type="System.IO.Stream"/>
    </method>
    <method name="OpenStandardInput" signature="OpenStandardInput()" instance="false" match="name">
      <return type="System.IO.Stream"/>
      <source argpos="-1" kind="user_input" resource="gui"/>
    </method>
    <method name="OpenStandardOutput" signature="OpenStandardOutput()" instance="false" match="name">
      <return type="System.IO.Stream"/>
    </method>
    <method name="Read" signature="Read()" instance="false">
      <return type="int"/>
      <source argpos="-1" kind="user_input" resource="gui"/>
    </method>
    <method name="ReadLine" signature="ReadLine()" instance="false">
      <return type="string"/>
      <source argpos="-1" kind="user_input" resource="gui"/>
    </method>
    <method name="SetError" signature="SetError(System.IO.TextWriter)" instance="false"/>
    <method name="SetIn" signature="SetIn(System.IO.TextReader)" instance="false"/>
    <method name="SetOut" signature="SetOut(System.IO.TextWriter)" instance="false"/>
    <method name="Write" signature="Write(string)" instance="false" match="name">
      <tags>PlaintextStoragePassword:256</tags>
      <sink argpos="0" kind="information_leak" resource="gui"/>
    </method>
    <method name="WriteLine" signature="WriteLine(string)" instance="false" match="name">
      <tags>PlaintextStoragePassword:256,Exceptions:209</tags>
      <sink argpos="0" kind="information_leak" resource="gui"/>
    </method>
  </class>

  <class name="System.Management.ManagementObjectSearcher">
    <description>Retrieves a collection of management objects based on a specified query.</description>
    <method name="Get" signature="Get(void)">
      <return type="System.Management.ManagementObjectCollection"/>
      <source kind="system_information" resource="os" argpos="-1"/>
    </method>
    <method name="Get" signature="Get(System.Management.ManagementOperationObserver)">
      <source kind="system_information" resource="os" argpos="-1"/>
    </method>
  </class>

  <class name="System.Management.ManagementObjectCollection" supertypes="System.Collections.ICollection"/>

  <class name="System.Management.ManagementClass">
    <description>Represents a Common Information Model (CIM) management class.</description>
    <field name="Properties" type="array">
      <source kind="system_information" resource="os" argpos="-1"/>
    </field>
  </class>

  <class name="System.Environment">
    <description>Provides information about the current environment and platform.</description>
    <field name="CommandLine" type="string">
      <source argpos="-1" kind="system_information" resource="os"/>
      <source argpos="-1" kind="user_input" resource="os"/>
    </field>
    <field name="CurrentDirectory" type="string">
      <source kind="system_information" resource="filesystem" argpos="-1"/>
    </field>
    <field name="MachineName" type="string">
      <source kind="system_information" resource="os" argpos="-1"/>
    </field>
    <field name="OSVersion" type="string">
      <source kind="system_information" resource="os" argpos="-1"/>
    </field>
    <field name="StackTrace" type="string">
      <source kind="system_information" resource="other" argpos="-1"/>
    </field>
    <field name="SystemDirectory" type="string">
      <source kind="system_information" resource="os" argpos="-1"/>
    </field>
    <field name="UserDomainName" type="string">
      <source kind="system_information" resource="os" argpos="-1"/>
    </field>
    <field name="UserName" type="string">
      <source kind="system_information" resource="os" argpos="-1"/>
    </field>
    <field name="Version" type="string">
      <source kind="system_information" resource="os" argpos="-1"/>
    </field>

    <method name="Exit" signature="Exit(int)" instance="false">
      <tags>process-termination</tags>
    </method>
    <method name="ExpandEnvironmentVariables" signature="ExpandEnvironmentVariables(string)" instance="false">
      <return type="string"/>
      <source kind="system_information" resource="environment" argpos="-1"/>
    </method>
    <method name="FailFast" signature="FaiFast(string,System.Exception)" instance="false" match="name">
      <tags>process-termination</tags>
    </method>
    <method name="GetEnvironmentVariable" signature="GetEnvironmentVariable(string)" instance="false" match="name">
      <tags>nullable</tags>
      <return type="string"/>
      <source kind="system_information" resource="environment" argpos="-1"/>
    </method>
    <method name="GetEnvironmentVariables" signature="GetEnvironmentVariables()" instance="false" match="name">
      <return type="System.Collections.IDictionary"/>
      <source kind="system_information" resource="environment" argpos="-1"/>
    </method>
    <method name="GetFolderPath" signature="GetFolderPath(System.Environment.SpecialFolder)" instance="false" match="name">
      <return type="string"/>
      <source kind="system_information" resource="filesystem" argpos="-1"/>
    </method>
    <method name="GetLogicalDrives" signature="GetLogicalDrives()" instance="false">
      <return type="array"/>
      <source kind="system_information" resource="filesystem" argpos="-1"/>
    </method>
    <method name="GetCommandLineArgs" signature="GetCommandLineArgs()" instance="false">
      <return type="string[]"/>
      <source kind="user_input" resource="os" argpos="-1"/>
    </method>
    <method name="SetEnvironmentVariable" signature="SetEnvironmentVariable(string,string)" instance="false" match="name">
      <sink argpos="0,1" kind="setting_manipulation" resource="environment"/>
    </method>
  </class>

  <!-- Security types -->

  <class name="System.Security.Principal.IPrincipal" kind="interface">
    <field name="Identity" type="System.Security.Principal.IIdentity"/>
    <method name="IsInRole" signature="IsInRole(string)">
      <tags>security_check,security_decision</tags>
      <sink argpos="0" kind="security_decision" resource="web"/>
    </method>
  </class>

  <class name="System.Security.Principal.GenericPrincipal" supertypes="System.Security.Claims.ClaimsPrincipal"/>
  <class name="System.Security.Principal.WindowsPrincipal" supertypes="System.Security.Claims.ClaimsPrincipal"/>

  <class name="System.Security.Principal.IIdentity" kind="interface">
    <field name="Name" type="string">
      <!-- <source argpos="0" kind="system_information" resource="other">CWE:497</source> -->
    </field>
    <field name="IsAuthenticated" type="bool">
      <tags>security_check</tags>
    </field>
  </class>

  <class name="System.Security.Claims.ClaimsPrincipal" supertypes="System.Security.Principal.IPrincipal">
    <field name="Identity" type="System.Security.Principal.IIdentity"/>
    <field name="Identities" type="System.Collections.Generic.IEnumerable"/>
    <field name="Current" type="System.Security.Claims.ClaimsPrincipal" instance="false"/>
  </class>

  <class name="System.Security.CryptoConfig"/>

  <!-- LDAP injection -->

  <class name="System.DirectoryServices.DirectoryEntry">
    <description>Encapsulates a node or object in the Active Directory Domain Services hierarchy.</description>
    <tags>ldap_leak,disposable</tags>
    <constructor name="DirectoryEntry" signature="DirectoryEntry(string)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="DirectoryEntry" signature="DirectoryEntry(string,string,string)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="DirectoryEntry" signature="DirectoryEntry(string,string,string,System.DirectoryServices.AuthenticationTypes)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <method name="Close" signature="Close()">
      <neutralization argpos="-2" kind="ldap_leak"/>
    </method>
  </class>

  <class name="System.DirectoryServices.DirectorySearcher">
    <description>Performs queries against Active Directory Domain Services.</description>
    <tags>ldap_leak,disposable</tags>
    <constructor name="DirectorySearcher" signature="DirectorySearcher(string)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="DirectorySearcher" signature="DirectorySearcher(System.DirectoryServices.DirectoryEntry,string)">
      <propagate from="0" to="-1"/>
      <sink argpos="1" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="DirectorySearcher" signature="DirectorySearcher(System.DirectoryServices.DirectoryEntry,string,string[])">
      <propagate from="0" to="-1"/>
      <sink argpos="1" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="DirectorySearcher" signature="DirectorySearcher(string,string[],SearchScope)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="DirectorySearcher" signature="DirectorySearcher(System.DirectoryServices.DirectoryEntry,string,string[],System.DirectoryServices.SearchScope)">
      <propagate from="0" to="-1"/>
      <sink argpos="1" kind="ldap_injection" resource="other"/>
    </constructor>
    <field name="Filter" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
    <method name="FindAll" signature="FindAll()">
      <return type="System.DirectoryServices.SearchResultCollection"/>
    </method>
  </class>

  <class name="System.DirectoryServices.SearchResultCollection">
    <tags>ldap_leak,disposable</tags>
  </class>

  <class name="System.DirectoryServices.Protocols.LdapConnection">
    <description>The LdapConnection class creates a TCP/IP or UDP LDAP connection to Microsoft Active Directory Domain Services or an LDAP server.</description>
    <tags>ldap_leak,disposable</tags>
    <constructor name="LdapConnection" signature="LdapConnection(string)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="LdapConnection" signature="LdapConnection(System.DirectoryServices.Protocols.LdapDirectoryIdentifier,System.Net.NetworkCredential)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="LdapConnection" signature="LdapConnection(System.DirectoryServices.Protocols.LdapDirectoryIdentifier,System.Net.NetworkCredential,System.DirectoryServices.Protocols.AuthType)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <field name="Directory" type="System.DirectoryServices.Protocols.DirectoryIdentifier">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
  </class>

  <class name="System.DirectoryServices.Protocols.LdapDirectoryIdentifier">
    <description>The LdapDirectoryIdentifier class creates a directory identifier for one or more LDAP servers.</description>
    <constructor name="LdapDirectoryIdentifier" signature="LdapDirectoryIdentifier(string)" match="name">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
  </class>

  <class name="System.DirectoryServices.Protocols.AddRequest">
    <constructor name="AddRequest" signature="AddRequest(string)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="AddRequest" signature="AddRequest(string,string)">
      <sink argpos="0,1" kind="ldap_injection" resource="other"/>
    </constructor>
    <field name="DistinguishedName" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
  </class>

  <class name="System.DirectoryServices.Protocols.CompareRequest">
    <constructor name="CompareRequest" signature="CompareRequest(string,System.DirectoryServices.Protocols.DirectoryAttribute)">
      <sink argpos="0,1" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="CompareRequest" signature="CompareRequest(string,string,string)">
      <sink argpos="0,1,2" kind="ldap_injection" resource="other"/>
    </constructor>
    <field name="DistinguishedName" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
  </class>

  <class name="System.DirectoryServices.Protocols.DeleteRequest">
    <constructor name="DeleteRequest" signature="DeleteRequest(string)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <field name="DistinguishedName" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
  </class>

  <class name="System.DirectoryServices.Protocols.DsmlAuthRequest">
    <constructor name="DsmlAuthRequest" signature="DsmlAuthRequest(string)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <field name="Principal" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
  </class>

  <class name="System.DirectoryServices.Protocols.ExtendedRequest">
    <constructor name="ExtendedRequest" signature="ExtendedRequest(string)">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="ExtendedRequest" signature="ExtendedRequest(string,string)">
      <sink argpos="0,1" kind="ldap_injection" resource="other"/>
    </constructor>
  </class>

  <class name="System.DirectoryServices.Protocols.ModifyDNRequest">
    <constructor name="ModifyDNRequest" signature="ModifyDNRequest(string,string,string)">
      <sink argpos="0,1,2" kind="ldap_injection" resource="other"/>
    </constructor>
    <field name="DeleteOldRdn" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
    <field name="DistinguishedName" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
    <field name="NewName" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
    <field name="NewParentDistinguishedName" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
  </class>

  <class name="System.DirectoryServices.Protocols.ModifyRequest">
    <constructor name="ModifyRequest" signature="ModifyRequest(string,System.DirectoryServices.Protocols.DirectoryAttributeModification[])">
      <sink argpos="0,1" kind="ldap_injection" resource="other"/>
    </constructor>
    <constructor name="ModifyRequest" signature="ModifyRequest(string,System.DirectoryServices.Protocols.DirectoryAttributeOperation,string,Object[])">
      <sink argpos="0,1,2,3" kind="ldap_injection" resource="other"/>
    </constructor>
    <field name="DistinguishedName" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
  </class>

  <class name="System.DirectoryServices.Protocols.SearchRequest">
    <constructor name="SearchRequest" signature="SearchRequest(string,string,System.DirectoryServices.Protocols.SearchScope,string[])">
      <sink argpos="0,1" kind="ldap_injection" resource="other"/>
    </constructor>
    <field name="DistinguishedName" type="string">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
    <field name="Filter" type="object">
      <sink argpos="0" kind="ldap_injection" resource="other"/>
    </field>
  </class>

  <!-- Runtime and command execution -->
  <class name="System.Diagnostics.Process">
    <description>Provides access to local and remote processes and enables you to start and stop local system processes.</description>
    <field name="StartInfo" type="System.Diagnostics.ProcessStartInfo"/>
    <field name="StandardOutput" alias="StandardError" type="System.IO.StreamReader">
      <source argpos="-1" kind="other_input" resource="os"/>
    </field>
    <method name="GetCurrentProcess" signature="GetCurrentProcess()" instance="false">
      <return type="System.Diagnostics.Process"/>
    </method>
    <method name="GetProcesses" signature="GetProcesses(string)" instance="false" match="name">
      <return type="System.Diagnostics.Process[]"/>
      <sink argpos="0" kind="resource_injection" resource="os"/>
    </method>
    <method name="GetProcessById" signature="GetProcessById(int,string)" instance="false" match="name">
      <return type="System.Diagnostics.Process"/>
      <sink argpos="0,1" kind="resource_injection" resource="os"/>
    </method>
    <method name="GetProcessesByName" signature="GetProcessesByName(string,string)" instance="false" match="name">
      <return type="System.Diagnostics.Process"/>
      <sink argpos="0,1" kind="resource_injection" resource="os"/>
    </method>

    <method name="Start" signature="Start(string)" instance="false" match="fullsignature">
      <return type="System.Diagnostics.Process"/>
      <sink argpos="0" kind="command_injection" resource="os"/>
    </method>
    <method name="Start" signature="Start(System.Diagnostics.ProcessStartInfo)" instance="false" match="fullsignature">
      <return type="System.Diagnostics.Process"/>
    </method>
    <method name="Start" signature="Start(string,string)" instance="false">
      <return type="System.Diagnostics.Process"/>
      <sink argpos="0,1" kind="command_injection" resource="os"/>
    </method>
    <method name="Start" signature="Start(string,string,System.Security.SecureString,string)" instance="false">
      <return type="System.Diagnostics.Process"/>
      <sink argpos="0" kind="command_injection" resource="os"/>
      <sink argpos="1,2" kind="hardcoded_credentials" resource="os"/>
    </method>
    <method name="Start" signature="Start(string,string,string,System.Security.SecureString,string)" instance="false">
      <return type="System.Diagnostics.Process"/>
      <sink argpos="0,1" kind="command_injection" resource="os"/>
      <sink argpos="2,3" kind="hardcoded_credentials" resource="os"/>
    </method>
  </class>

  <class name="System.Diagnostics.ProcessStartInfo">
    <description>Specifies a set of values that are used when you start a process.</description>
    <constructor name="ProcessStartInfo" signature="ProcessStartInfo(string)">
      <sink argpos="0" kind="command_injection" resource="os"/>
    </constructor>
    <constructor name="ProcessStartInfo" signature="ProcessStartInfo(string,string)">
      <sink argpos="0,1" kind="command_injection" resource="os"/>
    </constructor>
    <field name="FileName" type="string">
      <sink argpos="0" kind="command_injection" resource="os"/>
    </field>
    <field name="Arguments" type="string">
      <tags>other_input:true</tags>
      <sink argpos="0" kind="command_injection" resource="os"/>
    </field>
    <field name="Verb" type="string">
      <sink argpos="0" kind="command_injection" resource="os"/>
    </field>
  </class>

  <!-- RegExp -->
  <class name="System.Text.RegularExpressions.Regex">
    <description>Represents an immutable regular expression.</description>
    <constructor name="Regex" signature="Regex(string)">
      <sink argpos="0" kind="regex_dos" resource="other"/>
    </constructor>
    <constructor name="Regex" signature="Regex(string,System.Text.RegularExpressions.RegexOptions)">
      <sink argpos="0" kind="regex_dos" resource="other"/>
    </constructor>
    <constructor name="Regex" signature="Regex(string,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
      <!-- Note: TimeSpan arg "neutralizes" DosRegex and exponential backtracking issues -->
      <!--<sink argpos="0" kind="regex_dos" resource="other"/>-->
    </constructor>
    <method name="IsMatch" signature="IsMatch(string)">
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="IsMatch" signature="IsMatch(string,string)" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
    <method name="IsMatch" signature="IsMatch(string,string,System.Text.RegularExpressions.RegexOptions)" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
    <method name="Match" signature="Match(string)">
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="Match" signature="Match(string,string)" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
    <method name="Match" signature="Match(string,string,System.Text.RegularExpressions.RegexOptions)" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
    <method name="Matches" signature="Matches(string)">
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="Matches" signature="Matches(string,string)" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
    <method name="Matches" signature="Matches(string,string,System.Text.RegularExpressions.RegexOptions)" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
    <method name="Replace" signature="Replace(string,System.Text.RegularExpressions.MatchEvaluator)">
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="Replace" signature="Replace(string,string,System.Text.RegularExpressions.MatchEvaluator)" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
    <method name="Replace" signature="Replace(string,string,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
    <method name="Split" signature="Split(string)">
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="Split" signature="Split(string,string)" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
    <method name="Split" signature="Split(string,string,System.Text.RegularExpressions.RegexOptions)" instance="false">
      <neutralization argpos="0" kind="string"/>
      <sink argpos="1" kind="regex_dos" resource="other"/>
    </method>
  </class>

  <!-- Code injection -->
  <class name="System.CodeDom.Compiler.CodeDomProvider">
    <description>Provides a base class for CodeDomProvider implementations.</description>
    <method name="CompileAssemblyFromSource" signature="CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,string[])">
      <sink argpos="1" kind="code_injection" resource="other"/>
    </method>
  </class>

  <!--  Code DOM -->
  <class name="System.CodeDom.CodeExpression"/>

  <class name="System.CodeDom.CodeArgumentReferenceExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeArgumentReferenceExpression" signature="CodeArgumentReferenceExpression(string)">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </constructor>
    <field name="ParameterName" type="string">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeCastExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeCastExpression" signature="CodeCastExpression(string,System.CodeDom.CodeExpression)">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </constructor>
    <field name="TargetType" type="System.CodeDom.CodeTypeReference">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeDelegateCreateExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeDelegateCreateExpression" signature="CodeDelegateCreateExpression(System.CodeDom.CodeTypeReference,System.CodeDom.CodeExpression,string)">
      <sink argpos="1,2" kind="code_injection" resource="other"/>
    </constructor>
    <field name="MethodName" type="string">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
    <field name="TargetObject" type="System.CodeDom.CodeExpression">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeDelegateInvokeExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeDelegateInvokeExpression" signature="CodeDelegateInvokeExpression(System.CodeDom.CodeExpression,System.CodeDom.CodeExpression[])">
      <sink argpos="0,1" kind="code_injection" resource="other"/>
    </constructor>
    <field name="Parameters" type="System.CodeDom.CodeExpressionCollection">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
    <field name="TargetObject" type="System.CodeDom.CodeExpression">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeEventReferenceExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeEventReferenceExpression" signature="CodeEventReferenceExpression(System.CodeDom.CodeExpression,string)">
      <sink argpos="0,1" kind="code_injection" resource="other"/>
    </constructor>
    <field name="EventName" type="string">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
    <field name="TargetObject" type="System.CodeDom.CodeExpression">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeFieldReferenceExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeFieldReferenceExpression" signature="CodeFieldReferenceExpression(System.CodeDom.CodeExpression,string)">
      <sink argpos="0,1" kind="code_injection" resource="other"/>
    </constructor>
    <field name="FieldName" type="string">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
    <field name="TargetObject" type="System.CodeDom.CodeExpression">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeIndexerExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeIndexerExpression" signature="CodeIndexerExpression(System.CodeDom.CodeExpression,System.CodeDom.CodeExpression[])">
      <sink argpos="0,1" kind="code_injection" resource="other"/>
    </constructor>
    <field name="Indices" type="System.CodeDom.CodeExpressionCollection">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
    <field name="TargetObject" type="System.CodeDom.CodeExpression">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeMethodInvokeExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeMethodInvokeExpression" signature="CodeMethodInvokeExpression(System.CodeDom.CodeExpression,string,System.CodeDom.CodeExpression[])">
      <sink argpos="0,1,2" kind="code_injection" resource="other"/>
    </constructor>
    <constructor name="CodeMethodInvokeExpression" signature="CodeMethodInvokeExpression(System.CodeDom.CodeMethodReferenceExpression,System.CodeDom.CodeExpression[])">
      <sink argpos="0,1" kind="code_injection" resource="other"/>
    </constructor>
    <field name="Parameters" type="System.CodeDom.CodeExpressionCollection">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
    <field name="Method" type="System.CodeDom.CodeMethodReferenceExpression">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeMethodReferenceExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeMethodReferenceExpression" signature="CodeMethodReferenceExpression(System.CodeDom.CodeExpression,string)">
      <sink argpos="0,1" kind="code_injection" resource="other"/>
    </constructor>
    <constructor name="CodeMethodReferenceExpression" signature="CodeMethodReferenceExpression(System.CodeDom.CodeExpression,string,System.CodeDom.CodeTypeReference[])">
      <sink argpos="0,1" kind="code_injection" resource="other"/>
    </constructor>
    <field name="MethodName" type="string">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
    <field name="TargetObject" type="System.CodeDom.CodeExpression">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeObjectCreateExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeObjectCreateExpression" signature="CodeObjectCreateExpression(string,System.CodeDom.CodeExpression)">
      <sink argpos="0,1" kind="code_injection" resource="other"/>
    </constructor>
    <field name="CreateType" type="System.CodeDom.CodeTypeReference">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodePrimitiveExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodePrimitiveExpression" signature="CodePrimitiveExpression(Object)">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </constructor>
    <field name="Value" type="Object">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodePropertyReferenceExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodePropertyReferenceExpression" signature="CodePropertyReferenceExpression(System.CodeDom.CodeExpression,string)">
      <sink argpos="0,1" kind="code_injection" resource="other"/>
    </constructor>
    <field name="PropertyName" type="string">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
    <field name="TargetObject" type="System.CodeDom.CodeExpression">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <class name="System.CodeDom.CodeSnippetExpression" supertypes="System.CodeDom.CodeExpression">
    <constructor name="CodeSnippetExpression" signature="CodeSnippetExpression(string)">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </constructor>
    <field name="Value" type="string">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </field>
  </class>

  <!-- IronPython & IronTuby scripts engine -->
  <class name="Microsoft.Scripting.Hosting.ScriptEngine">
    <method name="CreateScriptSourceFromString" signature="CreateScriptSourceFromString(string)">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
    <method name="CreateScriptSourceFromString" signature="CreateScriptSourceFromString(string,string)">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
    <method name="CreateScriptSourceFromString" signature="CreateScriptSourceFromString(string,string,Microsoft.Scripting.SourceCodeKind)">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
    <method name="Execute" signature="Execute(string)">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
    <method name="Execute" signature="Execute(string,Microsoft.Scripting.Hosting.ScriptScope)">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
    <method name="ExecuteAndWrap" signature="ExecuteAndWrap(string)" match="name">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
    <method name="ExecuteFile" signature="ExecuteFile(string)" match="name">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
  </class>

  <!-- Scripting API -->
  <class name="Microsoft.CodeAnalysis.CSharp.Scripting.CSharpScript">
    <method name="Create" signature="Create(string)" match="name">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
    <method name="Eval" signature="Eval(string)" match="name">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
    <method name="EvaluateAsync" signature="EvaluateAsync(string)" match="name">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
    <method name="Run" signature="Run(string)" match="name">
      <sink argpos="0" kind="code_injection" resource="other"/>
    </method>
  </class>

  <!-- XML injection neutralizations -->
  <class name="System.Security.SecurityElement">
    <description>Represents the XML object model for encoding security objects.This class cannot be inherited.</description>
    <method name="Escape" signature="Escape(string)">
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="IsValidAttributeName" signature="IsValidAttributeName(string)">
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="IsValidAttributeValue" signature="IsValidAttributeValue(string)">
      <neutralization argpos="0" kind="string"/>
    </method>
    <method name="IsValidText" signature="IsValidText(string)">
      <neutralization argpos="0" kind="string"/>
    </method>
  </class>

  <!-- InteropServices -->
  <class name="System.Runtime.InteropServices.Marshal">
    <tags>unsafe</tags>
  </class>

  <!-- Configuration -->
  <class name="System.Runtime.Versioning.FrameworkName">
    <field name="FullName" type="string"/>
    <field name="Identifier" type="string"/>
    <field name="Profile" type="string"/>
    <field name="Version" type="System.Version"/>
  </class>

  <class name="System.Version">
    <field name="Build" type="int"/>
    <field name="Major" type="int"/><field name="MajorRevision" type="int"/>
    <field name="Minor" type="int"/><field name="MinorRevision" type="int"/>
    <field name="Revision" type="int"/>
    <method name="Parse" signature="Parse(string)" instance="false">
      <return type="System.Version"/>
    </method>
  </class>

  <!-- System.Runtime.Serialization -->
  <class name="System.Runtime.Serialization.IFormatter" kind="interface">
    <field name="Binder" type="System.Runtime.Serialization.SerializationBinder"></field>
    <field name="Context" type="System.Runtime.Serialization.StreamingContext"></field>
    <field name="SurrogateSelector" type="System.Runtime.Serialization.SurrogateSelector"></field>
    
    <method name="Deserialize" signature="Deserialize(System.IO.Stream)" match="name">
      <return type="object"/>
    </method>
    <method name="Serialize" signature="Serialize(System.IO.Stream,object)" match="name"></method>
  </class>
  
  <class name="System.Runtime.Remoting.Messaging.IRemotingFormatter" kind="interface" supertypes="System.Runtime.Serialization.IFormatter">
    <tags>rpc</tags>
  </class>

  <class name="System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" supertypes="System.Runtime.Serialization.IFormatter,System.Runtime.Remoting.Messaging.IRemotingFormatter">
    <field name="AssemblyFormat" type="System.Runtime.Serialization.Formatters.FormatterAssemblyStyle"></field>
    <field name="FilterLevel" type="System.Runtime.Serialization.Formatters.TypeFilterLevel"/>
    <field name="TypeFormat" type="System.Runtime.Serialization.Formatters.FormatterTypeStyle"/>
    <method name="UnsafeDeserialize" signature="UnsafeDeserialize(System.IO.Stream)" match="name">
      <return type="object"/>
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:UNCONDITIONALLY_UNSAFE</tags></sink>
    </method>
    <method name="Deserialize" signature="Deserialize(System.IO.Stream)" match="name">
      <return type="object"/>
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:UNCONDITIONALLY_UNSAFE</tags></sink>
    </method>
  </class>

  <class name="Systm.Messaging.IMessageFormatter" supertypes="System.ICloneable">
    <method name="Read" signature="Read(System.Messaging.Message)">
      <return type="object"/>
    </method>
    <method name="Write" signature="Write(System.Messaging.Message,object)"/>
  </class>

  <class name="System.Messaging.BinaryMessageFormatter" supertypes="System.Messaging.IMessageFormatter, System.ICloneable">
    <!-- Uses BinaryFormatter under the hood, deserialization is considered unsafe unconditionally -->
    <method name="Read" signature="Read(System.Messaging.Message)">
      <return type="object"/>
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:UNCONDITIONALLY_UNSAFE</tags></sink>
    </method>
  </class>
  
  <class name="System.Messaging.XmlMessageFormatter" supertypes="System.Messaging.IMessageFormatter, System.ICloneable">
    <!-- unless attacker may choose the accepted types, uses XmlFormatter, which is much more limited for RCE attacks -->
    <field name="TargetTypeNames" type="string[]" elementType="string">
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:CONTROLLED_EXPECTED_TYPE</tags></sink>
    </field>
    <field name="TargetTypes" type="System.Type[]" elementType="System.Type">
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:CONTROLLED_EXPECTED_TYPE</tags></sink>
    </field>
    <constructor name="XmlMessageFormatter" signature="XmlMessageFormatter(String[])" match="numargs">
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:CONTROLLED_EXPECTED_TYPE</tags></sink>
    </constructor>
  </class>

  <class name="System.Runtime.Serialization.Formatters.Soap.SoapFormatter" supertypes="System.Runtime.Serialization.Formatters.Binary.BinaryFormatter">
    <!-- Not really extending BinaryFormatter, but works as such from a security standpoint -->
  </class>

  <class name="System.Runtime.Serialization.XmlObjectSerializer" kind="abstract_class">
    <method name="ReadObject" signature="ReadObject(System.IO.Stream)" match="name">
      <return type="object"/>
    </method>
    <method name="WriteObject" signature="WriteObject(System.IO.Stream,object)" alias="WriteObjectContent,WritStartObject,WriteEndObject"></method>
  </class>

  <class name="System.Runtime.Serialization.DataContractSerializer" supertypes="System.Runtime.Serialization.XmlObjectSerializer">
    <!--method name="ReadObject" signature="ReadObject(System.IO.Stream)" match="name">
      <return type="object"/>
    </method-->
  </class>
  
  <class name="System.Runtime.Serialization.Json.DataContractJsonSerializer" supertypes="System.Runtime.Serialization.XmlObjectSerializer">
    <constructor name="DataContractJsonSerializer" signature="DataContractJsonSerializer(System.Type)" match="name">
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:CONTROLLED_EXPECTED_TYPE</tags></sink>
    </constructor>
  </class>

  <class name="System.Runtime.Serialization.NetDataContractSerializer" supertypes="System.Runtime.Serialization.XmlObjectSerializer,System.Runtime.Serialization.IFormatter">
    <field name="AssemblyFormat" type="System.Runtime.Serialization.Formatters.FormatterAssemblyStyle"></field>
    <field name="IgnoreExtensionDataObject" type="bool"/>
    <field name="MaxItemsInObjectGraph" type="int"/>

    <method name="Deserialize" signature="Deserialize(System.IO.Stream)" match="name">
      <return type="object"/>
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:UNCONDITIONALLY_UNSAFE</tags></sink>
    </method>
    <method name="ReadObject" signature="ReadObject(System.IO.Stream)" match="name">
      <return type="object"/>
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:UNCONDITIONALLY_UNSAFE</tags></sink>
    </method>
  </class>
  
  <class name="System.Web.Script.Serialization.JavaScriptTypeResolver" kind="abstract_class">
    <method name="ResolveType" signature="ResolveType(string)"><return type="System.Type"/></method>
    <method name="ResolveTypeId" signature="ResolveType(System.Type)"><return type="string"/></method>
  </class>
  
  <class name="System.Web.Script.Serialization.SimpleTypeResolver" supertypes="System.Web.Script.Serialization.JavaScriptTypeResolver">
    <tags>WeakTypeResolver</tags>
  </class>
  
  <class name="System.Web.Script.Serialization.JavaScriptSerializer">
    <constructor name="JavaScriptSerializer" signature="JavaScriptSerializer()"/>
    <constructor name="JavaScriptSerializer_1" signature="JavaScriptSerializer(System.Web.Script.Serialization.JavaScriptTypeResolver)">
      <tags>WithTypeResolver:0</tags>
    </constructor>
    <method name="Deserialize" signature="Deserialize(string,System.Type)">
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:WEAK_TYPE_CONTROL</tags><checker id="code_injection_deserialization"/></sink>
      <sink argpos="1" kind="code_injection_deserialization"><tags>reason:CONTROLLED_EXPECTED_TYPE</tags></sink>
    </method>
    <method name="Deserialize_2" signature="Deserialize(string)">
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:WEAK_TYPE_CONTROL</tags><checker id="code_injection_deserialization"/></sink>
    </method>
    <method name="DeserializeObject" signature="DeserializeObject(string)">
      <sink argpos="0" kind="code_injection_deserialization"><tags>reason:WEAK_TYPE_CONTROL</tags><checker id="code_injection_deserialization"/></sink>
    </method>
  </class>

  <!-- System.Drawing -->
  <class name="System.Drawing.Graphics">
    <tags>image_leak,disposable</tags>
    <method name="FromHdc" signature="FromHdc(System.IntPtr,System.IntPtr)" instance="false" match="name"
            alias="FromHdcInternal,FromHwnd,FromHwndInteranl">
      <return type="System.Drawing.Graphics"/>
    </method>
    <method name="FromImage" signature="FromImage(System.Drawing.Image)" instance="false" match="name">
      <return type="System.Drawing.Graphics"/>
    </method>
  </class>

  <class name="System.Drawing.Image" kind="abstract_class" supertypes="System.IDisposable,System.ISerializable">
    <tags>image_leak,disposable</tags>
    <field name="RawFormat" type="System.Drawing.Imaging.ImageFormat">
      <tags>check.fileupload.content</tags>
    </field>
    <method name="FromFile" signature="FromFile(string,bool)" instance="false" match="name">
      <return type="System.Drawing.Image"/>
      <sink argpos="0" kind="path_traversal" resource="filesystem"/>
    </method>
    <method name="FromHbitmap" signature="FromHbitmap(System.IntPtr,System.IntPtr)" instance="false" match="name">
      <return type="System.Drawing.Image"/>
    </method>
    <method name="FromStream" signature="FromStream(System.IO.Stream, bool, bool)" instance="false" match="name">
      <tags>check.fileupload.content</tags>
      <return type="System.Drawing.Image"/>
      <neutralization argpos="0" kind="dangerous_file_upload"/>
    </method>
    <method name="Save" signature="Save(string)" match="name">
      <sink argpos="0" kind="path_traversal" resource="filesystem"/>
    </method>
  </class>

  <class name="System.Drawing.Bitmap" supertypes="System.Drawing.Image">
    <tags>image_leak,disposable</tags>
    <constructor name="Bitmap" signature="Bitmap(System.IO.Stream, bool)" match="name">
      <tags>check.fileupload.content</tags>
      <neutralization argpos="0" kind="dangerous_file_upload"/>
    </constructor>
    <constructor name="Bitmap" signature="Bitmap(string)" match="name">
      <sink argpos="0" kind="path_traversal" resource="filesystem"/>
    </constructor>
  </class>

  <class name="System.Drawing.Imaging.Metafile" supertypes="System.Drawing.Image">
    <tags>image_leak,disposable</tags>
    <constructor name="Metafile" signature="Metafile(System.IO.Stream)" match="name">
      <tags>check.fileupload.content</tags>
      <neutralization argpos="0" kind="dangerous_file_upload"/>
    </constructor>
    <constructor name="Metafile" signature="Metafile(string)" match="name">
      <sink argpos="0" kind="path_traversal" resource="filesystem"/>
    </constructor>
  </class>

  <class name="System._AppDomain" kind="interface">
    <method name="ExecuteAssembly" signature="ExecuteAssembly(string)" alias="ExecuteAssemblyByName" match="name">
      <sink argpos="0" kind="process_control" resource="os"/>
    </method>
    <method name="Load" signature="Load(string)" match="name">
      <sink argpos="0" kind="process_control" resource="os"/>
    </method>

  </class>

  <class name="System.AppDomain" supertypes="System._AppDomain">
    <field name="CurrentDomain" type="System.AppDomain"/>
    <method name="CreateDomain" signature="CreateDomain(string)" instance="false">
      <return type="System.AppDomain"/>
      <sink argpos="0" kind="process_control" resource="os"/>
    </method>
    <method name="CreateInstance" signature="CreateInstance(string,string)" match="name">
      <return type="System.Runtime.Remoting.ObjectHandle"/>
      <sink argpos="0,1" kind="process_control" resource="os"/>
    </method>
  </class>

  <!-- Registry -->

  <class name="Microsoft.Win32.Registry">
    <field name="ClassesRoot" type="Microsoft.Win32.RegistryKey"/>
    <field name="CurrentConfig" type="Microsoft.Win32.RegistryKey"/>
    <field name="CurrentUser" type="Microsoft.Win32.RegistryKey"/>
    <field name="DynData" type="Microsoft.Win32.RegistryKey"/>
    <field name="LocalMachine" type="Microsoft.Win32.RegistryKey"/>
    <field name="PerformanceData" type="Microsoft.Win32.RegistryKey"/>
    <field name="Users" type="Microsoft.Win32.RegistryKey"/>

    <method name="GetValue" signature="GetValue(string,string,object)" instance="false">
      <return type="object"/>
      <source argpos="-1" kind="system_information" resource="configuration"/>
    </method>
    <method name="SetValue" signature="SetValue(string,string,object)" instance="false" match="name">
      <sink argpos="0,1,2" kind="registry_manipulation" resource="configuration"/>
    </method>
  </class>

  <class name="Microsoft.Win32.RegistryKey">
    <tags>registry_leak,disposable</tags>
    <field name="Handle" type="Microsoft.Win32.SafeHandles.SafeRegistryHandle"/>

    <method name="Close" signature="Close()">
      <neutralization argpos="-2" kind="registry_leak"/>
    </method>
    <method name="CreateSubKey" signature="CreateSubKey(string)" match="name">
      <return type="Microsoft.Win32.RegistryKey"/>
      <sink argpos="0" kind="registry_manipulation" resource="configuration"/>
    </method>
    <method name="DeleteSubKey" signature="DeleteSubKey(string)" match="name">
      <sink argpos="0" kind="registry_manipulation" resource="configuration"/>
    </method>
    <method name="DeleteSubKeyTree" signature="DeleteSubKeyTree(string)" match="name">
      <sink argpos="0" kind="registry_manipulation" resource="configuration"/>
    </method>
    <method name="DeleteValue" signature="DeleteValue(string)" match="name">
      <sink argpos="0" kind="registry_manipulation" resource="configuration"/>
    </method>
    <method name="GetValue" signature="GetValue(string)" match="name">
      <source argpos="-1" kind="system_information" resource="configuration"/>
    </method>
    <method name="GetValueNames" signature="GetValueNames()" match="name">
      <return type="string[]"/>
      <source argpos="-1" kind="system_information" resource="configuration"/>
    </method>
    <method name="OpenSubKey" signature="OpenSubKey(string)" match="name">
      <return type="Microsoft.Win32.RegistryKey"/>
    </method>
    <method name="SetValue" signature="SetValue(string,object)" match="name">
      <sink argpos="0,1" kind="registry_manipulation" resource="configuration"/>
    </method>
  </class>
  
  <class name="System.Guid" kind="struct" supertypes="System.IComparable, System.IEquatable, System.IFormattable" />

</library>