<?xml version="1.0" encoding="UTF-8"?>
<library xmlns="http://www.optimyth.com/schema/definitions/library_metadata"
         name="kotlin.stdlib" standard="Standard_library" technology="kotlin">

  <description url="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/">Kotlin core functions and types</description>

  <module name="kotlin" >
    <class name="kotlin.Any">
      <field name="class" type="kotlin.reflect.KClass" />
    </class>
    <class name="kotlin.Number" kind="abstract_class" supertypes="kotlin.Any" >
      <method name="toByte" signature="toByte()" >
        <return type="kotlin.Byte" />
      </method>
      <method name="toChar" signature="toChar()" >
        <return type="kotlin.Char" />
      </method>
      <method name="toDouble" signature="toDouble()" >
        <return type="kotlin.Double" />
      </method>
      <method name="toFloat" signature="toFloat()" >
        <return type="kotlin.Float" />
      </method>
      <method name="toInt" signature="toInt()" >
        <return type="kotlin.Int" />
      </method>
      <method name="toLong" signature="toLong()" >
        <return type="kotlin.Long" />
      </method>
      <method name="toString" signature="toString()" >
        <return type="kotlin.String" />
      </method>
      <method name="rotateLeft" signature="rotateLeft(bitCount kotlin.Int)" alias="rotateRight">
        <return type="@self"/>
      </method>
    </class>

    <class name="kotlin.Boolean" supertypes="kotlin.Comparable" >
      <method name="and" signature="and(other kotlin.Boolean)" alias="not, or, xor" >
        <return type="kotlin.Boolean" />
      </method>
    </class>
    <class name="kotlin.Char" supertypes="kotlin.Comparable" />
    <class name="kotlin.Byte" supertypes="kotlin.Number" />
    <class name="kotlin.UByte" supertypes="kotlin.Comparable" />
    <class name="kotlin.Double" supertypes="kotlin.Number" />
    <class name="kotlin.UDouble" supertypes="kotlin.Number" />
    <class name="kotlin.Float" supertypes="kotlin.Number" />
    <class name="kotlin.UFloat" supertypes="kotlin.Number" />
    <class name="kotlin.Int" supertypes="kotlin.Number" />
    <class name="kotlin.UInt" supertypes="kotlin.Number" />
    <class name="kotlin.Long" supertypes="kotlin.Number" />
    <class name="kotlin.ULong" supertypes="kotlin.Number" />
    <class name="kotlin.Short" supertypes="kotlin.Number" />
    <class name="kotlin.UShort" supertypes="kotlin.Number" />

    <class name="kotlin.String" supertypes="kotlin.Comparable, kotlin.CharSequence" >
      <method name="capitalize" signature="capitalize()" alias="decapitalize" >
        <return type="kotlin.String" />
      </method>
      <method name="charset" signature="charset()" >
        <return type="java.nio.charset.Charset" />
      </method>
      <method name="equals" signature="equals(other kotlin.Any)" >
        <return type="kotlin.Boolean" />
        <neutralization argpos="-2,0" kind="string"/>
      </method>
      <method name="get" signature="get(index kotlin.Int)" alias="getOrNull" >
        <return type="kotlin.Char" />
      </method>
      <method name="length" signature="length()" >
        <return type="kotlin.Int" />
      </method>
      <method name="plus" signature="plus(other Any?)" >
        <return type="kotlin.String" />
      </method>
      <method name="subSequence" signature="subSequence(startIndex kotlin.Int, endIndex kotlin.Int)" >
        <return type="kotlin.CharSequence" />
      </method>

      <!-- casting -->
      <method name="encodeToByteArray" signature="encodeToByteArray" >
        <return type="kotlin.ByteArray" />
      </method>
      <method name="toBigDecimal" signature="toBigDecimal()" alias="toBigDecimalOrNull" >
        <return type="java.math.BigDecimal" />
      </method>
      <method name="toBigInteger" signature="toBigInteger()" alias="toBigIntegerOrNull" >
        <return type="java.math.BigInteger" />
      </method>
      <method name="toByte" signature="toByte()" alias="toByteOrNull" >
        <return type="kotlin.Byte" />
      </method>
      <method name="toByteArray" signature="toByteArray()" >
        <return type="kotlin.ByteArray" />
      </method>
      <method name="toCharArray" signature="toCharArray()" >
        <return type="kotlin.CharArray" />
      </method>
      <method name="toCollection" signature="toCollection()" >
        <return type="kotlin.MutableCollection" />
      </method>
      <method name="toDouble" signature="toDouble()" alias="toDoubleOrNull" >
        <return type="kotlin.Double" />
      </method>
      <method name="toFloat" signature="toFloat()" alias="toFloatOrNull" >
        <return type="kotlin.Float" />
      </method>
      <method name="toHashSet" signature="toHashSet()" >
        <return type="kotlin.collection.HashSet" />
      </method>
      <method name="toInt" signature="toInt()" alias="toIntOrNull" >
        <return type="kotlin.Int" />
      </method>
      <method name="toList" signature="toList()" >
        <return type="kotlin.collection.List" />
      </method>
      <method name="toLong" signature="toLong()" alias="toLongOrNull" >
        <return type="kotlin.Long" />
      </method>
      <method name="toSet" signature="toSet()" >
        <return type="kotlin.collection.Set" />
      </method>
      <method name="toShort" signature="toShort()" alias="toShortOrNull" >
        <return type="kotlin.Short" />
      </method>
      <method name="toUByte" signature="toUByte()" alias="toUByteOrNull" >
        <return type="kotlin.UByte" />
      </method>
      <method name="toUInt" signature="toUInt()" alias="toUIntOrNull" >
        <return type="kotlin.UInt" />
      </method>
      <method name="toULong" signature="toULong()" alias="toULongOrNull" >
        <return type="kotlin.ULong" />
      </method>
      <method name="toUShort" signature="toUShort()" alias="toUShortOrNull" >
        <return type="kotlin.UShort" />
      </method>

      <!-- regex extension -->
      <method name="toPattern" signature="toPattern()" match="name" >
        <return type="java.util.regex.Pattern" />
      </method>
      <method name="toRegex" signature="toRegex()" match="name" >
        <return type="kotlin.text.Regex" />
        <sink argpos="-2" kind="regex_dos" resource="other" />
      </method>

      <!-- fuel extensions https://github.com/kittinunf/Fuel#quick-start -->
      <method name="httpGet" signature="httpGet()" alias="httpPost, httpPut, httpDelete, httpDownload" match="name" >
        <return type="com.github.kittinunf.fuel.core.Request" />
        <sink argpos="-2" kind="http_parameter_pollution" resource="web" />
        <sink argpos="-2" kind="ssrf"/>
        <sink argpos="-2" kind="insecure_transport" resource="network" />
      </method>
    </class>

    <class name="kotlin.CharSequence" kind="interface" >
      <method name="concat" signature="concat(str kotlin.String)" >
        <return type="kotlin.String" />
      </method>
      <method name="contains" signature="contains(other kotlin.CharSequence, ignoreCase kotlin.Boolean)" match="name" >
        <return type="kotlin.Boolean" />
        <neutralization argpos="-2,0" kind="path_traversal">
          <checker id="j2se.normalizationChecker" />
        </neutralization>
      </method>
      <method name="contentEquals" signature="contentEquals(charSequence kotlin.CharSequence)" match="name" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="drop" signature="drop(n kotlin.Int)" alias="dropLast, dropLastWhile, dropWhile">
        <return type="kotlin.String" />
      </method>
      <method name="elementAtOrElse" signature="elementAtOrElse(index kotlin.Int, defaultValue (kotlin.Int)->kotlin.Char)" alias="elementAtOrNull" >
        <return type="kotlin.Char" />
      </method>
      <method name="endWith" signature="endsWith(char kotlin.Char, ignoreCase kotlin.Boolean)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="filter" signature="filter(predicate (kotlin.Char)->kotlin.Boolean)" alias="filterIndexed, filterIndexedTo, filterNot, filterNotTo, filterTo">
        <return type="kotlin.String" />
      </method>
      <method name="find" signature="find(predicate (kotlin.Char)->kotlin.Boolean)" alias="findLast" >
        <return type="kotlin.Char" />
      </method>
      <method name="findAnyOf" signature="findAnyOf()" alias="findLastAnyOf" >
        <return type="kotlin.Pair" />
      </method>
      <method name="first" signature="first()" alias="firstOrNull" match="name" >
        <return type="kotlin.Char" />
      </method>
      <method name="flatMap" signature="flatMap(transform kotlin.Char)" alias="flatMapTo" >
        <return type="kotlin.collections.List" />
      </method>
      <method name="fold" signature="fold(initial R, operation (R,kotlin.Char)->R)" alias="foldIndexed, foldRight, foldRightIndexed" >
        <return type="kotlin.collections.List" />
      </method>
      <method name="replace" signature="replace(regex kotlin.text.Regex, replacement kotlin.String)" >
        <return type="kotlin.String" />
        <propagate from="-2,1" to="-1"/>
        <sink argpos="0" kind="regex_dos" resource="other"/>
        <neutralization argpos="-1" kind="string" resource="other" />
      </method>
      <method name="matches" signature="matches(regex kotlin.text.Regex)" >
        <return type="kotlin.Boolean" />
        <propagate from="-2,1" to="-1"/>
        <sink argpos="0" kind="regex_dos" resource="other"/>
        <neutralization argpos="-1" kind="string" resource="other" />
      </method>
    </class>

    <function name="kotlin.String.format" signature="kotlin.String.format(java.util.Locale, kotlin.Any, kotlin.Any...)" kind="function" match="fullsignature">
      <return type="kotlin.String" />
      <sink argpos="1" kind="format_injection" resource="formatstr"/>
    </function>
    <function name="kotlin.String.format" signature="kotlin.String.format(kotlin.Any,kotlin.Any...)" kind="function"  match="numargs">
      <return type="kotlin.String" />
      <sink argpos="0" kind="format_injection" resource="formatstr"/>
    </function>

    <class name="kotlin.Comparable" kind="interface" />
    <class name="kotlin.Function" kind="interface" />
    <class name="kotlin.Lazy" kind="interface" />
    <class name="kotlin.Nothing"/>
    <class name="kotlin.Enum" supertypes="kotlin.Comparable" />
    <class name="kotlin.Pair" supertypes="kotlin.Serializable" />
    <class name="kotlin.Result" supertypes="kotlin.Serializable" />
    <class name="kotlin.Volatile" supertypes="kotlin.jvm.Volatile" />
    <class name="kotlin.Unit"/>

    <class name="kotlin.Array" supertypes="kotlin.Any" >
      <field name="size" type="kotlin.Int"/>
      <field name="indices" type="kotlin.ranges.IntRange"/>
      <field name="lastIndex" type="kotlin.Int"/>

      <constructor name="Array" signature="Array(size kotlin.Int, init (kotlin.Int)-> kotlin.Any)"></constructor>
      <method name="all" signature="all(predicate (kotlin.Any)->kotlin.Boolean)"><return type="kotlin.Boolean"/></method>
      <method name="any" signature="any()"><return type="kotlin.Boolean"/></method>
      <method name="any" signature="any(predicate (kotlin.Any)->kotlin.Boolean)"><return type="kotlin.Boolean"/></method>
      <method name="asIterable" signature="asIterable()"><return type="kotlin.collections.Iterable"/></method>
      <method name="asSequence" signature="asSequence()"><return type="kotlin.sequences.Sequence"/></method>
      <method name="associate" signature="associate(transform (kotlin.Any)->kotlin.Pair)"><return type="kotlin.collections.Map"/></method>
      <method name="associateBy" signature="associateBy(keySelector (kotlin.Any)->kotlin.Any)"><return type="kotlin.collections.Map"/></method>
      <method name="associateBy" signature="associateBy(keySelector (kotlin.Any)->kotlin.Any, valueTransform (kotlin.Any)->kotlin.Any)"><return type="kotlin.collections.Map"/></method>
      <method name="associateByTo"
              signature="associateByTo(destination kotlin.collections.MutableMap, keySelector (kotlin.Any)->kotlin.Any, valueTransform (T)->kotlin.Any)" match="name">
        <return type="kotlin.collections.MutableMap"/>
      </method>
      <method name="associateTo" signature="associateTo(destination kotlin.collections.MutableMap, transform (kotlin.Any)->kotlin.Pair)">
        <return type="kotlin.collections.MutableMap"/>
      </method>
      <method name="associateWith" signature="associateWith(valueSelector (kotlin.Any)->kotlin.Any)">
        <return type="kotlin.collections.Map"/>
      </method>
      <method name="associateWithTo"
              signature="associateWithTo(destination kotlin.collections.MutableMap, valueSelector (kotlin.Any)->kotlin.Any)">
        <return type="kotlin.collections.Map"/>
      </method>
      <method name="average" signature="average()"><return type="kotlin.Double"/></method>
      <method name="binarySearch" signature="binarySearch()" match="name"><return type="kotlin.Int"/></method>
      <method name="count" signature="count()" ><return type="kotlin.Int" /></method>
      <method name="count" signature="count(predicate (kotlin.Any)->kotlin.Boolean)" ><return type="kotlin.Int" /></method>
      <method name="distinct" signature="distinct()"><return type="kotlin.collections.List"/></method>
      <method name="drop" signature="drop(n kotlin.Int)" alias="dropLast"><return type="kotlin.collections.List"/></method>
      <method name="dropWhile" signature="dropWhile(predicate (kotlin.Any)->kotlin.Boolean)" alias="dropLastWhile">
        <return type="kotlin.collections.List"/>
        <propagate from="-2" to="-1"/>
        <neutralization kind="*" argpos="-1" resource="other"/>
      </method>
      <method name="elementAtOrElse" signature="elementAtOrElse(index kotlin.Int, defaultValue (kotlin.Int)->kotlin.Any)"><return type="kotlin.Any"/></method>
      <method name="elementAtOrNull" signature="elementAtOrNull(index kotlin.Int)"><return type="kotlin.Any?"/></method>
      <method name="filter" signature="filter(predicate (kotlin.Any)->kotlin.Boolean)" match="name"
              alias="filterIndexed, filterNot">
        <return type="kotlin.collections.List"/>
        <propagate from="-2" to="-1"/>
        <neutralization kind="*" argpos="-1" resource="other"/>
      </method>
      <method name="filterIsInstance" signature="filterIsInstance()" match="name" alias="filterNotNull">
        <return type="kotlin.collections.List"/>
        <propagate from="-2" to="-1"/>
      </method>
      <method name="filterTo" signature="filterTo(destination kotlin.collections.MutableCollection, predicate (kotlin.Any)->kotlin.Boolean)" match="name"
              alias="filterNotTo, filterIndexedTo">
        <return type="kotlin.collections.MutableCollection"/>
        <propagate from="0,-2" to="-1"/>
        <neutralization kind="*" argpos="-1" resource="other"/>
      </method>
      <method name="filterIsInstanceTo" signature="filterIsInstanceTo(destination kotlin.collections.MutableCollection)" match="name"
              alias="filterNotNullTo">
        <return type="kotlin.collections.MutableCollection"/>
        <propagate from="0,-2" to="-1"/>
      </method>
      <method name="find" signature="find(predicate (kotlin.Any)->kotlin.Boolean)" alias="findLast"><return type="kotlin.Any"/></method>
      <method name="first" signature="first()" alias="last, firstOrNull, lastOrNull"><return type="koltin.Any"/></method>
      <method name="flatMap" signature="flatMap(transform (kotlin.Any)->kotlin.collections.Iterable)" alias="flatMapIndexed"><return type="kotlin.collections.List"/></method>
      <method name="flatMapTo" signature="flatMap(destination kotlin.collections.MutableCollection, transform (kotlin.Any)->kotlin.collections.Iterable)" alias="flatMapIndexedTo">
        <return type="kotlin.collections.MutableCollection"/>
      </method>
      <method name="flatten" signature="flatten()"><return type="kotlin.collections.List"/></method>
      <method name="fold" signature="fold(initial kotlin.Any, operation (kotlin.Any, kotlin.Any)->kotlin.Any)" 
              alias="foldIndexed, foldRight, foldRightIndexed">
        <return type="kotlin.Any"/>
      </method>
      <method name="forEach" signature="forEach(action (kotlin.Any)->kotlin.Unit)" alias="forEachIndexed"></method>
      <method name="get" signature="get(kotlin.Int)" match="name" alias="getOrElse, getOrNull"><return type="kotlin.Any"/></method>
      <method name="groupBy" signature="groupBy(keyselector (kotlin.Any)->kotlin.Any)" match="name"><return type="kotlin.collections.Map"/></method>
      <method name="groupByTo" signature="groupByTo(destination kotlin.collections.MutableMap, keyselector (kotlin.Any)->kotlin.Any)" match="name">
        <return type="kotlin.collections.MutableMap"/>
      </method>
      <method name="groupingBy" signature="groupingBy(keyselector (kotlin.Any)->kotlin.Any)"><return type="kotlin.collections.Grouping"/></method>
      <method name="indexOf" signature="indexOf(element kotlin.Any)" alias="lastIndexOf"><return type="kotlin.Int"/></method>
      <method name="indexOfFirst" signature="indexOf(predicate (kotlin.Any)->kotlin.Any)" alias="indexOfLast"><return type="kotlin.Int"/></method>
      <method name="intersect" signature="intersect(kotlin.collections.Iterable)"><return type="kotlin.collections.Set"/></method>
      <method name="isArrayOf" signature="isArrayOf()" alias="isEmpty, isNotEmpty, isNullOrEmpty"><return type="kotlin.Boolean"/></method>
      <method name="joinTo" signature="joinTo(buffer kotlin.text.Appendable)" match="name"><return type="kotlin.text.Appendable"/></method>
      <method name="joinToString" signature="joinToString()" match="name"><return type="kotlin.String"/></method>
      <method name="map" signature="map(transform (kotlin.Any)->kotlin.Any)" alias="mapNotNull, mapIndexed, mapIndexedNotNull"><return type="kotlin.collections.List"/></method>
      <method name="mapTo" signature="flatMap(destination kotlin.collections.MutableCollection, transform (kotlin.Any)->kotlin.Any)" alias="mapNotNullTo, mapIndexedTo, mapIndexedNotNullTo">
        <return type="kotlin.collections.MutableCollection"/>
      </method>
      <method name="max" signature="max()" alias="maxOrNull, min, minOrNull"><return type="kotlin.Any?"/></method>
      <method name="maxBy" signature="maxBy(selector (kotlin.Any)->kotlin.Any)" alias="maxByOrNull, minBy, minByOrNull"><return type="kotlin.Any?"/></method>
      <method name="maxWith" signature="maxWith(comparator kotlin.Comparator)" alias="maxWithOrNull, minWith, minWithOrNull"><return type="kotlin.Any?"/></method>
      <method name="maxOf" signature="maxOf(selector (kotlin.Any)->kotlin.Double)" alias="maxOfOrNull, minOf, minOfOrNull"><return type="kotlin.Double"/></method>
      <method name="maxOfWith" signature="maxOfWith(comparator kotlin.Comparator, selector (kotlin.Any)->kotlin.Any)" alias="maxOfWithOrNull, minOfWith, minOfWithOrNull"><return type="kotlin.Any"/></method>
      <method name="none" signature="none()"><return type="kotlin.Boolean"/></method>
      <method name="none" signature="none(predicate (kotlin.Any)->kotlin.Boolean)"><return type="kotlin.Boolean"/></method>
      <method name="onEach" signature="onEach(action (kotlin.Any)->kotlin.Unit)" alias="onEachIndexed"><return type="@self"/></method>
      <method name="partition" signature="partition(predicate (kotlin.Any)->kotlin.Boolean)"><return type="kotlin.Pair" elementType="kotlin.collections.List"/></method>
      <method name="random" signature="random(kotlin.random.Random)" match="name" alias="randomOrNull"><return type="kotlin.Any"/></method>
      <method name="reduce" signature="reduce(operation (operation (kotlin.Any,kotlin.Any)->kotlin.Any)"
              alias="reduceOrNull, reduceIndexed, reduceIndexedOrNull, reduceRight, reduceRightOrNull, reduceRightIndexed, reduceRightIndexedOrNull">
        <return type="kotlin.Any"/>
      </method>
      <method name="requireNoNulls" signature="requireNoNulls()"><return type="@self"/></method>
      <method name="reverse" signature="reverse()" match="name"></method>
      <method name="reversed" signature="reversed()"><return type="kotlin.collections.List"/></method>
      <method name="reversedArray" signature="reversedArray()"><return type="@self"/></method>
      <method name="runningFold" signature="runningFold(initial kotlin.Any, operation (kotlin.Any, kotlin.Any)->kotlin.Any)"
              alias="runningFoldIndexed, scan, scanIndexed">
        <return type="kotlin.collections.List"/>
      </method>
      <method name="runningReduce" signature="runningReduce(operation (operation (kotlin.Any,kotlin.Any)->kotlin.Any)"
              alias="runningReduceIndexed, scanReduce, scanReduceIndexed">
        <return type="kotlin.collections.List"/>
      </method>
      <method name="shuffle" signature="shuffle(kotlin.random.Random)" match="name"></method>
      <method name="single" signature="single(predicate (kotlin.Any)->kotlin.Boolean)" match="name" alias="singleOrNull">
        <return type="kotlin.Any"/>
      </method>
      <method name="slice" signature="slice(kotlin.ranges.IntRange)" match="numargs"><return type="kotlin.collections.List"/></method>
      <method name="sliceArray" signature="sliceArray(kotlin.ranges.IntRange)" match="numargs"><return type="@self"/></method>
      <method name="sort" signature="sort(comparison (kotlin.Any, kotlin.Any)->kotlin.Int)" match="numargs"
              alias="sortBy, sortDescending, sortByDescending"></method>
      <method name="sorted" signature="sorted()" alias="sortedDescending"><return type="kotlin.collections.List"/></method>
      <method name="sortedArray" signature="sortedArray()" alias="sortedArrayDescending"><return type="@self"/></method>
      <method name="sortedArrayWith" signature="sortedArrayWith(comparator kotlin.Comparator)"><return type="@self"/></method>
      <method name="sortedWith" signature="sortedWith(comparator kotlin.Comparator)"><return type="kotlin.collections.List"/></method>
      <method name="sortWith" signature="sortWith(comparator kotlin.Comparator)"></method>
      <method name="subtract" signature="subtract(kotlin.collections.Iterable)" alias="union"><return type="kotlin.collections.Set"/></method>
      <method name="take" signature="take(kotlin.Int)" alias="takeLast"><return type="kotlin.collections.List"/></method>
      <method name="takeWhile" signature="takeWhile(predicate (kotlin.Any)->kotlin.Boolean)" alias="takeLastWhile"><return type="kotlin.collections.List"/></method>
      <method name="toBooleanArray" signature="toBooleanArray()"><return type="kotlin.BooleanArray"/></method>
      <method name="toByteArray" signature="toByteArray()"><return type="kotlin.ByteArray"/></method>
      <method name="toCharArray" signature="toCharArray()"><return type="kotlin.CharArray"/></method>
      <method name="toCollection" signature="toCollection(kotlin.collections.MutableCollection)"><return type="kotlin.collections.MutableCollection"/></method>
      <method name="toDoubleArray" signature="toDoubleArray()"><return type="kotlin.DoubleArray"/></method>
      <method name="toFloatArray" signature="toFloatArray()"><return type="kotlin.FloatArray"/></method>
      <method name="toHashSet" signature="toHashSet()"><return type="kotlin.collections.HashSet"/></method>
      <method name="toIntArray" signature="toIntArray()"><return type="kotlin.IntArray"/></method>
      <method name="toList" signature="toList()"><return type="kotlin.collections.List"/></method>
      <method name="toLongArray" signature="toLongArray()"><return type="kotlin.LongArray"/></method>
      <method name="toMap" signature="toMap()"><return type="kotlin.collections.Map"/></method>
      <method name="toMap" signature="toMap(kotlin.collections.MutableMap)"><return type="kotlin.collections.MutableMap"/></method>
      <method name="toMutableList" signature="toMutableList()"><return type="kotlin.collections.MutableList"/></method>
      <method name="toMutableSet" signature="toMutableSet()"><return type="kotlin.collections.MutableSet"/></method>
      <method name="toSet" signature="toSet()" alias="toSortedSet"><return type="kotlin.collections.Set"/></method>
      <method name="toShortArray" signature="toShortArray()"><return type="kotlin.ShortArray"/></method>
      <method name="toArray" signature="toArray()"><return type="kotlin.Array"/></method>
      <method name="toUByteArray" signature="toUByteArray()"><return type="kotlin.UByteArray"/></method>
      <method name="toUIntArray" signature="toUIntArray()"><return type="kotlin.UIntArray"/></method>
      <method name="toULongArray" signature="toULongArray()"><return type="kotlin.ULongArray"/></method>
      <method name="toUShortArray" signature="toUShortArray()"><return type="kotlin.UShortArray"/></method>
      <method name="withIndex" signature="withIndex()"><return type="kotlin.collections.Iterable" elementType="kotlin.collections.IndexedValue"/></method>
      <method name="unzip" signature="unzip()"><return type="kotlin.collections.Pair" elementType="kotlin.collections.List"/></method>
      <method name="zip" signature="zip()" match="name"><return type="kotlin.collections.List"/></method>
    </class>

    <!-- typed arrays do not really extend from kotlin.Array. This is to leverage inheritance and to avoid rewriting the methods -->
    <class name="kotlin.BooleanArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.ByteArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.UByteArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.IntArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.UIntArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.LongArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.UIntArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.CharArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.DoubleArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.UDoubleArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.FloatArray" supertypes="kotlin.Array" >
    </class>
    <class name="kotlin.UFloatArray" supertypes="kotlin.Array" >
    </class>

    <function name="kotlin.arrayOf" signature="kotlin.arrayOf(kotlin.Any...)">
      <tags>array-factory</tags>
      <return type="kotlin.Array"/>
    </function>
    <function name="kotlin.arrayOfNulls" signature="kotlin.arrayOfNulls(size kotlin.Int)">
      <tags>array-factory</tags>
      <return type="kotlin.Array"/>
    </function>
    <function name="kotlin.emptyArray" signature="kotlin.emptyArray()">
      <tags>array-factory</tags>
      <return type="kotlin.Array"/>
    </function>
    <function name="kotlin.booleanArrayOf" signature="kotlin.booleanArrayOf(kotlin.Boolean...)">
      <tags>array-factory</tags>
      <return type="kotlin.BooleanArray"/>
    </function>
    <function name="kotlin.byteArrayOf" signature="kotlin.byteArrayOf(kotlin.Byte...)" alias="kotlin.ubyteArrayOf">
      <tags>array-factory</tags>
      <return type="kotlin.ByteArray"/>
    </function>
    <function name="kotlin.charArrayOf" signature="kotlin.charArrayOf(kotlin.Char...)">
      <tags>array-factory</tags>
      <return type="kotlin.CharArray"/>
    </function>
    <function name="kotlin.doubleArrayOf" signature="kotlin.doubleArrayOf(kotlin.Double...)">
      <tags>array-factory</tags>
      <return type="kotlin.DoubleArray"/>
    </function>
    <function name="kotlin.enumValues" signature="kotlin.enumValues()">
      <tags>array-factory</tags>
      <return type="kotlin.Array"/>
    </function>
    <function name="kotlin.floatArrayOf" signature="kotlin.floatArrayOf(kotlin.Float...)">
      <tags>array-factory</tags>
      <return type="kotlin.FloatArray"/>
    </function>
    <function name="kotlin.intArrayOf" signature="kotlin.intArrayOf(kotlin.Int...)" alias="kotlin.uintArrayOf">
      <tags>array-factory</tags>
      <return type="kotlin.IntArray"/>
    </function>
    <function name="kotlin.longArrayOf" signature="kotlin.longArrayOf(kotlin.Long...)" alias="kotlin.ulongArrayOf">
      <tags>array-factory</tags>
      <return type="kotlin.LongArray"/>
    </function>
    <function name="kotlin.shortArrayOf" signature="kotlin.shortArrayOf(kotlin.Short...)" alias="kotlin.ushortArrayOf">
      <tags>array-factory</tags>
      <return type="kotlin.ShortArray"/>
    </function>

    <function name="kotlin.arrayListOf" signature="kotlin.arrayListOf(kotlin.Any...)">
      <tags>list-factory</tags>
      <return type="kotlin.collections.ArrayList"/>
    </function>

    <function name="kotlin.printStackTrace" signature="kotlin.printStackTrace()" match="name" >
      <sink argpos="0" kind="detail_error" resource="other"/>
    </function>

    <class name="kotlin.ConcurrentModificationException" supertypes="kotlin.RuntimeException" />
    <class name="kotlin.RuntimeException" supertypes="kotlin.Exception" />


    <!-- kotlin.io -->
    <class name="kotlin.io.FileTreeWalk" supertypes="kotlin.sequences.Sequence">

    </class>

    <function name="kotlin.createTempDir" signature="kotlin.createTempDir(prefix kotlin.String, suffix kotlin.String, directory java.io.File)" >
      <sink argpos="2" kind="path_traversal" resource="filesystem" />
      <source argpos="-1" kind="file_input" resource="filesystem" />
    </function>

    <function name="kotlin.createTempFile" signature="kotlin.createTempFile(prefix kotlin.String, suffix kotlin.String, directory java.io.File)" >
      <sink argpos="2" kind="path_traversal" resource="filesystem" />
      <source argpos="-1" kind="file_input" resource="filesystem" />
    </function>

    <function name="kotlin.print" signature="kotlin.print(message)" alias="println" />

    <function name="kotlin.readLine" signature="kotlin.readLine()" alias="readln, readlnOrNull">
      <return type="kotlin.String?" />
      <propagate from="-2" to="-1"/>
      <source argpos="-1" kind="user_input" resource="gui" />
    </function>


    <!-- kotlin.sequences -->
    <class name="kotlin.sequences.Sequence" kind="interface" >
      <method name="all" signature="all()" >
        <return type="Boolean" />
      </method>
    </class>


    <!-- kotlin.collections -->
    <class name="kotlin.collections.Iterator" kind="interface" >
      <method name="hasNext" signature="hasNext()" >
        <tags>potential_infinite_loop_neutralizer</tags>
        <return type="kotlin.Boolean" />
        <propagate from="-2" to="-1"/>
        <neutralization argpos="-2" kind="loop-condition" resource="other" />
      </method>
      <method name="next" signature="next()" >
        <tags>potential_infinite_loop_neutralizer</tags>
        <propagate from="-2" to="-1"/>
      </method>
      <method name="asSequence" signature="asSequence()" >
        <return type="kotlin.sequences.Sequence" />
      </method>
      <method name="iterator" signature="iterator()" >
        <return type="kotlin.collections.Iterator" />
      </method>
      <method name="forEach" signature="forEach"/>
      <method name="withIndex" signature="withIndex()" >
        <return type="kotlin.collections.Iterator" />
      </method>
    </class>

    <class name="kotlin.collections.AbstractIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.BooleanIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.ByteIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.CharIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.DoubleIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.FloatIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.IntIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.ListIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" >
      <method name="hasPrevious" signature="hasPrevious()" >
        <tags>potential_infinite_loop_neutralizer</tags>
        <return type="kotlin.Boolean" />
        <propagate from="-2" to="-1"/>
        <neutralization argpos="-2" kind="loop-condition" resource="other" />
      </method>
      <method name="previous" signature="previous()" >
        <tags>potential_infinite_loop_neutralizer</tags>
        <propagate from="-2" to="-1"/>
      </method>
      <method name="previousIndex" signature="previousIndex()" >
        <return type="kotlin.Int" />
      </method>
    </class>
    <class name="kotlin.collections.MutableIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.ShortIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.UByteIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.UIntIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.ULongIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />
    <class name="kotlin.collections.UShortIterator" kind="abstract_class" supertypes="kotlin.collections.Iterator" />

    <class name="kotlin.collections.Iterable" kind="interface" >
      <method name="iterator" signature="iterator()" >
        <return type="kotlin.collections.Iterator" />
      </method>
      <method name="shuffled" signature="shuffled()" match="name" >
        <return type="kotlin.collections.List" />
        <source argpos="-1" kind="insecure_random" resource="crypto"/>
      </method>
    </class>

    <class name="kotlin.collections.MutableIterable" kind="interface" supertypes="kotlin.collections.Iterable" />

    <class name="kotlin.collections.Collection" kind="interface" supertypes="kotlin.collections.Iterable" >
      <method name="contains" signature="contains(element *)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="containsAll" signature="ContainsAll(elements kotlin.collections.Collection)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="isEmpty" signature="isEmpty()" >
        <return type="kotlin.Boolean" />
      </method>
    </class>

    <class name="kotlin.collections.AbstractCollection" kind="abstract_class" supertypes="kotlin.collections.Collection" >
      <method name="toArray" signature="toArray()" match="name" >
        <return type="kotlin.Array" />
      </method>
      <method name="toString" signature="toString()" >
        <return type="kotlin.String" />
      </method>
    </class>

    <class name="kotlin.collections.List" kind="interface" supertypes="kotlin.collections.Collection" >
      <method name="get" signature="get(index kotlin.Int)" >
        <return type="E" />
      </method>
      <method name="indexOf" signature="indexOf(element *)" >
        <return type="kotlin.Int" />
      </method>
      <method name="lastIndexOf" signature="lastIndexOf(Element *)" >
        <return type="kotlin.Int" />
      </method>
      <method name="listIterator" signature="listIterator()" match="name" >
        <return type="kotlin.collections.ListIterator" />
      </method>
      <method name="subList" signature="subList(fromIndex kotlin.Int, toIndex kotlin.Int)" >
        <return type="kotlin.collections.List" />
      </method>
    </class>
    <class name="kotlin.collections.AbstractList" kind="abstract_class" supertypes="kotlin.collections.AbstractCollection, kotlin.collections.List" />
    <class name="kotlin.collections.AbstractMutableList" kind="abstract_class" supertypes="kotlin.collections.MutableList" />
    <class name="kotlin.collections.MutableList" kind="interface" supertypes="kotlin.collections.MutableCollection, kotlin.collections.List" />

    <class name="kotlin.collections.Set" kind="interface" supertypes="kotlin.collections.Collection" />
    <class name="kotlin.collections.AbstractSet" kind="abstract_class" supertypes="kotlin.collections.AbstractCollection, kotlin.collections.Set" />

    <class name="kotlin.collections.MutableCollection" kind="interface" supertypes="kotlin.collections.Collection, kotlin.collections.MutableIterable" >
      <method name="add" signature="add(element *)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="addAll" signature="addAll(Elements kotlin.collections.Collection)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="clear" signature="clear()" />
      <method name="remove" signature="remove(element *)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="removeAll" signature="elements kotlin.collections.Collection)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="retainAll" signature="retainAll(elements kotlin.collections.Collection)" >
        <return type="kotlin.Boolean" />
      </method>
    </class>
    <class name="kotlin.collections.AbstractMutableCollection" kind="abstract_class" supertypes="kotlin.collections.AbstractCollection" />

    <class name="kotlin.collections.Entry" kind="interface" >
      <field name="key" type="*" />
      <field name="value" type="*" />

      <method name="component1" signature="component1()" >
        <return type="*" />
      </method>
      <method name="component2" signature="component2()" >
        <return type="*" />
      </method>
      <method name="toPair" signature="toPair()" >
        <return type="kotlin.Pair" />
      </method>
    </class>

    <class name="kotlin.collections.Map" kind="interface" >
      <method name="entries" signature="entries()" >
        <return type="kotlin.collections.Set" />
      </method>
      <method name="keys" signature="keys()" >
        <return type="kotlin.collections.Set" />
      </method>
      <method name="values" signature="values()" >
        <return type="kotlin.collections.Set" />
      </method>
      <method name="containsKey" signature="containsKey(key *)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="containsValue" signature="containsValue(value *)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="get" signature="get(key *)" alias="getOrDefault" >
        <return type="*" />
      </method>
    </class>
    <class name="kotlin.collections.AbstractMap" kind="abstract_class" supertypes="kotlin.collections.Map" />
    <class name="kotlin.collections.AbstractMutableMap" kind="abstract_class" supertypes="kotlin.collections.MutableMap" />
    <class name="kotlin.collections.MutableMap" kind="interface" supertypes="kotlin.collections.Map" >
      <method name="put" signature="put(key *, value *)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="putAll" signature="putAll(from kotlin.collections.Map)" >
        <return type="kotlin.Boolean" />
      </method>
      <method name="clear" signature="clear()" />
      <method name="remove" signature="remove(key *)" match="name" >
        <return type="kotlin.Boolean" />
      </method>
    </class>

    <class name="kotlin.collections.RandomAccess" kind="interface" />

    <class name="kotlin.collection.ArrayList" supertypes="kotlin.collections.MutableList, kotlin.collections.RandomAccess" />
    <class name="kotlin.collection.HashMap" supertypes="kotlin.collections.MutableMap" />
    <class name="kotlin.collection.LinkedHashMap" supertypes="kotlin.collections.MutableMap" />
    <class name="kotlin.collection.HashSet" supertypes="kotlin.collections.MutableSet" />
    <class name="kotlin.collection.LinkedHashSet" supertypes="kotlin.collections.LinkedHashSet" />

    <function name="kotlin.collections.buildMap"
              signature="kotlin.collections.buildMap(capacity kotlin.Int, builderAction kotlin.collections.MutableMap.()->Unit)" match="name">
      <return type="kotlin.collections.Map"/>
    </function>

    <function name="kotlin.collections.buildList"
              signature="kotlin.collections.buildList(capacity kotlin.Int, builderAction kotlin.collections.MutableList.()->Unit)" match="name">
      <return type="kotlin.collections.List"/>
    </function>

    <function name="kotlin.collections.buildSet"
              signature="kotlin.collections.buildSet(capacity kotlin.Int, builderAction kotlin.collections.MutableSet.()->Unit)" match="name">
      <return type="kotlin.collections.Set"/>
    </function>


    <!-- kotlin.js -->
    <function name="kotlin.js.Console.error" signature="kotlin.js.Console.error(kotlin.Any,kotlin.Any...)" match="name"
              alias="kotlin.js.Console.info,kotlin.js.Console.log,kotlin.js.Console.warn,kotlin.js.Console.dir" >
      <sink argpos="0,1,2,3" kind="log_forging" />
    </function>

    <class name="kotlin.js.Date" kind="interface" />
    <class name="kotlin.js.JSON" kind="interface" >
      <method name="parse" signature="parse(text kotlin.String)" >
        <sink argpos="0" kind="json_injection" resource="other" />
      </method>
      <method name="parse" signature="parse(text kotlin.String, receiver tuple)" >
        <sink argpos="0" kind="json_injection" resource="other" />
      </method>
    </class>

    <class name="kotlin.js.Promise">
      <method name="then" signature="then(onFulfilled, onRejected)" >
        <return type="kotlin.js.Promise" />
      </method>
      <method name="catch" signature="then(onRejected)" >
        <return type="kotlin.js.Promise" />
      </method>
      <method name="all" signature="all(promise)" >
        <return type="kotlin.js.Promise" />
      </method>
      <method name="race" signature="race(promise)" >
        <return type="kotlin.js.Promise" />
      </method>
      <method name="reject" signature="reject(e)" >
        <return type="kotlin.js.Promise" />
      </method>
      <method name="resolve" signature="race(e)" >
        <return type="kotlin.js.Promise" />
      </method>
    </class>

    <class name="kotlin.js.RegExp" >
      <constructor name="RegExp" signature="RegExp(pattern kotlin.String, flags kotlin.String)" match="name" >
        <sink kind="regex_dos" argpos="0"/>
      </constructor>
      <method name="exec" signature="exec(str kotlin.String)" >
        <return type="kotlin.js.RegExpMatch"/>
      </method>
      <method name="test" signature="test(str kotlin.String)">
        <return type="kotlin.Boolean"/>
        <neutralization argpos="0"/>
      </method>
    </class>

    <function name="kotlin.js.eval" signature="eval(kotlin.String)" >
      <sink argpos="0" kind="code_injection"/>
    </function>

    <class name="kotlin.js.JsClass" kind="interface" >
      <field name="name" type="kotlin.String" />
      <field name="kotlin" type="kotlin.reflect.KClass" />
    </class>

    <function name="kotlin.js.Math.random" signature="kotlin.js.Math.random()" >
      <sink argpos="-1" kind="insecure_random" resource="other"/>
    </function>


    <!-- kotlin.reflect -->
    <class name="kotlin.reflect.KClass">
      <field name="constructors" type="kotlin.collections.Collection" elementType="kotlin.reflect.KFunction"/>
      <field name="isAbstract" alias="isCompanion, isData, isFinal, isInner, isOpen, isSealed" type="kotlin.Boolean"/>
      <field name="members" type="kotlin.collections.Collection" elementType="kotlin.reflect.KCallable"
             alias="declaredMembers"
      />
      <field name="nestedClasses" type="kotlin.collections.Collection" elementType="kotlin.reflect.KClass"
             alias="sealedSubclasses, allSuperclasses"/>
      <field name="objectInstance" type="Any?"/>
      <field name="qualifiedName" type="kotlin.String" alias="simpleName"/>
      <field name="supertypes" type="kotlin.collections.List" elementType="kotlin.reflect.KType"/>
      <field name="typeParameters" type="kotlin.collections.List" elementType="kotlin.reflect.KTypeParameter"/>
      <field name="visibility" type="kotlin.reflect.KVisibility"/>
      <method name="isInstance" signature="isInstance(value kotlin.Any?)"><return type="kotlin.Boolean"/></method>

      <field name="java" alias="javaClass, javaObjectType, javaPrimitiveType" type="java.lang.Class"/>
      <field name="js" type="kotlin.js.JsClass"/>
      <field name="typeParameters" type="kotlin.collections.List" elementType="kotlin.reflect.KTypeParameter"/>
      <field name="allSupertypes" type="kotlin.collections.Collection" elementType="kotlin.reflect.KType"/>
      <field name="companionObject" type="kotlin.reflect.KClass"/>
      <field name="companionObjectInstance" type="kotlin.Any"/>
      <field name="declaredFunctions" type="kotlin.collections.Collection" elementType="kotlin.reflect.KFunction"
             alias="declaredMemberExtensionFunctions, declaredMemberFunctions, memberExtensionFunctions, memberFunctions, staticFunctions"/>
      <field name="declaredMemberExtensionProperties" type="kotlin.collections.Collection" elementType="kotlin.reflect.KProperty2"
             alias="memberExtensionProperties"/>
      <field name="declaredMemberProperties" type="kotlin.collections.Collection" elementType="kotlin.reflect.KProperty1"
             alias="memberProperties, staticProperties"/>
      <field name="defaultType" type="kotlin.reflect.KType"/>
      <field name="primaryConstructor" type="kotlin.reflect.KFunction"/>
      <method name="cast" signature="cast(value kotlin.Any?)" alias="safeCast"><return type="kotlin.Any"/></method>
      <method name="createInstance" signature="createInstance()"><return type="kotlin.Any"/></method>
      <method name="isSubclassOf" signature="isSubclassOf(base kotlin.reflect.KClass)"><return type="kotlin.Boolean"/></method>
      <method name="isSuperclassOf" signature="isSuperclassOf(derived kotlin.reflect.KClass)"><return type="kotlin.Boolean"/></method>
    </class>

    <class name="kotlin.reflect.KFunction" kind="interface" supertypes="kotlin.reflect.KCallable, kotlin.Function" >
      <field name="isExternal" type="kotlin.Boolean" />
      <field name="isInfix" type="kotlin.Boolean" />
      <field name="isInline" type="kotlin.Boolean" />
      <field name="isOperator" type="kotlin.Boolean" />
      <field name="isSuspend" type="kotlin.Boolean" />
      <field name="extensionReceiverParameter" type="kotlin.reflect.KParameter" />
      <field name="instanceParameter" type="kotlin.reflect.KParameter" />
      <field name="isAccessible" type="kotlin.Boolean" />
      <field name="javaConstructor" type="java.lang.reflect.Constructor" />
      <field name="javaMethod" type="java.lang.reflect.Method" />
      <field name="valueParameters" type="kotlin.collections.List" elementType="kotlin.reflect.KParameter" />
    </class>

    <class name="kotlin.reflect.KProperty" kind="interface" supertypes="kotlin.reflect.KCallable, kotlin.Function" >
      <field name="getter" type="kotlin.reflect.Getter" />
      <field name="setter" type="kotlin.reflect.Setter" />
      <field name="isConst" type="kotlin.Boolean" />
      <field name="isLateinit" type="kotlin.Boolean" />
      <field name="isAccessible" type="kotlin.Boolean" />
      <field name="javaField" type="java.lang.reflect.Field" />
      <field name="javaGetter" type="java.lang.reflect.Method" />
    </class>

    <class name="kotlin.reflect.KCallable" kind="interface" supertypes="kotlin.reflect.KAnnotatedElement">
      <field name="isAbstract" type="kotlin.Boolean" />
      <field name="isFinal" type="kotlin.Boolean" />
      <field name="isOpen" type="kotlin.Boolean" />
      <field name="isSuspend" type="kotlin.Boolean" />
      <field name="name" type="kotlin.String" />
      <field name="parameters" type="kotlin.collections.List" elementType="kotlin.reflect.KParameter" />
      <field name="returnType" type="kotlin.reflect.KCallable.KType" />
      <field name="typeParameters" type="kotlin.collections.List" elementType="kotlin.reflect.KTypeParameter" />
      <field name="visibility" type="kotlin.reflect.KVisibility" />
    </class>

    <class name="kotlin.reflect.Getter" kind="interface" supertypes="kotlin.reflect.KFunction, kotlin.reflect.KProperty.Accessor" />
    <class name="kotlin.reflect.Setter" kind="interface" supertypes="kotlin.reflect.KFunction, kotlin.reflect.KProperty.Accessor" />

    <class name="kotlin.Function" kind="interface" >
      <method name="reflect" signature="reflect()" >
        <return type="kotlin.reflect.KFunction" />
      </method>
    </class>

    <class name="kotlin.reflect.KProperty.Accessor" kind="interface" >
      <field name="property" type="kotlin.reflect.KProperty" />
    </class>

    <class name="kotlin.reflect.KAnnotatedElement" kind="interface" >
      <field name="annotaitons" type="kotlin.collections.List" elementType="kotlin.reflect.Annotations" />
    </class>

    <class name="kotlin.reflect.KAnnotatedElement" kind="interface" >
      <field name="annotaitons" type="kotlin.collections.List" elementType="kotlin.reflect.Annotations" />
    </class>

    <class name="kotlin.reflect.KParameter" kind="interface" supertypes="kotlin.reflect.KAnnotatedElement" >
      <field name="isOptional" type="kotlin.Boolean" />
      <field name="isVararg" type="kotlin.Boolean" />
      <field name="name" type="kotlin.String?" />
      <field name="name" type="kotlin." />
    </class>

    <class name="kotlin.reflect.KType" kind="interface" supertypes="kotlin.reflect.KAnnotatedElement" >
      <field name="arguments" type="kotlin.collections.List" elementType="kotlin.reflect.KTypeProjection" />
      <field name="classifier" type="kotlin.reflect.KClassifier" />
      <field name="isMarkedNullable" type="kotlin.String?" />
      <field name="javaType" type="java.lang.reflect.Type" />
    </class>

    <class name="kotlin.reflect.KClassifier" kind="interface" />
    <class name="kotlin.reflect.KTypeProjection" kind="interface" >
      <field name="type" type="java.lang.reflect.Type?" />
    </class>

    <function name="kotlin.javaClass" signature="kotlin.javaClass()" >
      <return type="java.lang.Class" />
    </function>
    <function name="kotlin.class" signature="kotlin.class()" >
      <return type="kotlin.reflect.KClass" />
    </function>


    <!-- kotlin.text -->
    <class name="kotlin.text.Regex">
      <constructor name="Regex" signature="Regex(pattern kotlin.String)" >
        <sink kind="regex_dos" argpos="0"/>
      </constructor>
      <constructor name="Regex" signature="Regex(pattern kotlin.String, option kotlin.text.RegexOption)" >
        <sink kind="regex_dos" argpos="0"/>
      </constructor>
      <constructor name="Regex" signature="Regex(pattern kotlin.String, options kotlin.collections.Set)" >
        <sink kind="regex_dos" argpos="0"/>
      </constructor>

      <method name="toPattern" signature="toPattern()" >
        <return type="java.util.regex.Pattern" />
        <sink argpos="-2" kind="regex_dos" resource="other" />
      </method>
      <method name="split" signature="split(input CharSequence)" match="name">
        <return type="kotlin.collections.List"/>
        <propagate from="0" to="-1"/>
      </method>
      <method name="splitToSequence" signature="splitToSequence(input CharSequence)" match="name">
        <return type="kotlin.sequences.Sequence"/>
        <propagate from="0" to="-1"/>
      </method>
      <method name="matches" signature="matches(input CharSequence)" match="name">
        <return type="kotlin.text.MatchResult"/>
        <neutralization argpos="0" kind="string"/>
      </method>
      <method name="matchEntire" signature="matchEntire(input CharSequence)" match="name">
        <return type="kotlin.Boolean"/>
        <neutralization argpos="0" kind="string"/>
      </method>
      <method name="replace" signature="replace(input CharSequence, replacement kotlin.String)" match="name">
        <return type="kotlin.text.MatchResult"/>
        <neutralization argpos="0" kind="string"/>
      </method>
      <method name="replaceFirst" signature="replaceFirst(input CharSequence)" match="name">
        <return type="kotlin.text.MatchResult"/>
        <neutralization argpos="0" kind="string"/>
      </method>

      <method name="escape" signature="escape(literal kotlin.String)" >
        <return type="kotlin.String" />
      </method>
      <method name="escapeReplacement" signature="escapeReplacement(literal kotlin.String)" >
        <return type="kotlin.String" />
      </method>
      <method name="fromLiteral" signature="fromLiteral(literal kotlin.String)" >
        <return type="kotlin.text.Regex" />
        <sink kind="regex_dos" argpos="0"/>
      </method>
    </class>

    <class name="kotlin.text.StringBuilder" supertypes="java.lang.StringBuilder" />

    <function name="kotlin.append" signature="kotlin.append(value CharSequence)" alias="appendln" >
      <return type="java.lang.Appendable"/>
      <propagate from="0" to="-2"/>
    </function>
    <function name="kotlin.buildString" signature="kotlin.buildString(kotlin.text.StringBuilder)" >
      <return type="kotlin.String" />
    </function>

    <!-- Kotlin native -->
    <function name="platform.posix.system" signature="platform.posix.system(kotlin.String)" kind="function" match="name">
      <sink argpos="0" kind="command_injection" resource="environment"/>
    </function>

    <!-- kotlin.random -->
    <class name="kotlin.random.Random">
      <method name="nextBits" signature="nextBits()" alias="nextBoolean, nextDouble, nextFloat, nextInt, nextLong, nextUInt, nextUBytes" match="name" >
        <source argpos="-1" kind="insecure_random" resource="crypto"/>
        <propagate from="-2" to="-1"/>
      </method>
      <method name="asJavaRandom" signature="asJavaRandom()" >
        <return type="java.util.Random" />
      </method>
    </class>

    <!-- kotlin ranges -->
    <class name="kotlin.ranges.CharProgression" supertypes="kotlin.collections.Iterable" />
    <class name="kotlin.ranges.CharRange" supertypes="kotlin.ranges.CharProgression" />
    <class name="kotlin.ranges.ClosedRange" supertypes="kotlin.Comparable" />
    <class name="kotlin.ranges.ClosedFloatingPointRange" supertypes="kotlin.ranges.ClosedRange" />
    <class name="kotlin.ranges.IntProgression" supertypes="kotlin.collections.Iterable" />
    <class name="kotlin.ranges.IntRange" supertypes="kotlin.ranges.IntProgression" />
    <class name="kotlin.ranges.LongProgression" supertypes="kotlin.collections.Iterable" />
    <class name="kotlin.ranges.LongRange" supertypes="kotlin.ranges.LongProgression" />
    <class name="kotlin.ranges.UIntProgression" supertypes="kotlin.collections.Iterable" />
    <class name="kotlin.ranges.UIntRange" supertypes="kotlin.ranges.UIntProgression" />
    <class name="kotlin.ranges.ULongProgression" supertypes="kotlin.collections.Iterable" />
    <class name="kotlin.ranges.ULongRange" supertypes="kotlin.ranges.ULongProgression" />

    <class name="kotlin.Throwable">
      <field name="cause" type="kotlin.Throwable"/>
      <field name="message" type="kotlin.String"/>
      <method name="getStackTrace" signature="getStackTrace()"><return type="kotlin.Array" elementType="kotlin.String"/></method>
      <method name="getStackTraceAddresses" signature="getStackTraceAddresses()"><return type="kotlin.collections.List" elementType="kotlin.Long"/></method>
      <method name="printStackTrace" signature="printStackTrace()"></method>
      <method name="stackTrace" signature="stackTrace()"><return type="kotlin.Array" elementType="java.lang.StackTraceElement"/></method>
    </class>
    <class name="kotlin.Error" supertypes="kotlin.Throwable"></class>
    <class name="kotlin.Exception" supertypes="kotlin.Throwable"></class>
  </module>
</library>